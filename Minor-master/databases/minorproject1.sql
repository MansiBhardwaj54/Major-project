-- phpMyAdmin SQL Dump
-- version 4.9.2
-- https://www.phpmyadmin.net/
--
-- Host: 127.0.0.1
-- Generation Time: May 27, 2020 at 10:17 AM
-- Server version: 10.4.11-MariaDB
-- PHP Version: 7.2.26

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET AUTOCOMMIT = 0;
START TRANSACTION;
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- Database: `minorproject1`
--

-- --------------------------------------------------------

--
-- Table structure for table `batch`
--

CREATE TABLE `batch` (
  `ID` int(11) NOT NULL,
  `BRANCH` varchar(200) NOT NULL,
  `BATCH` varchar(200) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

--
-- Dumping data for table `batch`
--

INSERT INTO `batch` (`ID`, `BRANCH`, `BATCH`) VALUES
(1, 'CSE', 'A1'),
(2, 'CSE', 'A2'),
(3, 'CSE', 'B1'),
(4, 'CSE', 'B2'),
(5, 'IT', 'A1'),
(6, 'IT', 'B1'),
(7, 'IT', 'C1'),
(12, 'IT', 'A4');

-- --------------------------------------------------------

--
-- Table structure for table `bcs-206`
--

CREATE TABLE `bcs-206` (
  `ID` int(15) DEFAULT NULL,
  `BRANCH` varchar(5) CHARACTER SET utf8 DEFAULT NULL,
  `BATCH` varchar(5) CHARACTER SET utf8 DEFAULT NULL,
  `ROLL` bigint(20) DEFAULT NULL,
  `2020-01-16_0-2` tinyint(1) DEFAULT NULL,
  `2020-01-17_11-13` tinyint(1) DEFAULT NULL,
  `2020-01-24_13-15` tinyint(1) DEFAULT NULL,
  `2020-01-28_15-18` tinyint(1) DEFAULT NULL,
  `2020-02-04_15-18` tinyint(1) DEFAULT NULL,
  `2020-01-17_13-15` tinyint(1) DEFAULT NULL,
  `2020-02-07_13-16` tinyint(1) DEFAULT NULL,
  `2020-01-16_9-12` tinyint(1) DEFAULT NULL,
  `2020-01-22_13-16` tinyint(1) DEFAULT NULL,
  `2020-01-23_9-12` tinyint(1) DEFAULT NULL,
  `2020-02-06_9-12` tinyint(1) DEFAULT NULL,
  `2020-02-06_13-16` tinyint(1) DEFAULT NULL,
  `2020-01-23_12-16` tinyint(1) DEFAULT NULL,
  `2020-02-07_12-16` tinyint(1) DEFAULT NULL,
  `20-02-11_15-17` tinyint(1) DEFAULT NULL,
  `20-02-13_9-12` tinyint(1) DEFAULT NULL,
  `20-02-13_13-15` tinyint(1) DEFAULT NULL,
  `20-02-14_13-15` tinyint(1) DEFAULT NULL,
  `20-02-18_15-17` tinyint(1) DEFAULT NULL,
  `20-02-20_9-12` tinyint(1) DEFAULT NULL,
  `20-02-20_13-15` tinyint(1) DEFAULT NULL,
  `20-02-21_11-15` tinyint(1) DEFAULT NULL,
  `20-02-21_13-17` tinyint(1) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

--
-- Dumping data for table `bcs-206`
--

INSERT INTO `bcs-206` (`ID`, `BRANCH`, `BATCH`, `ROLL`, `2020-01-16_0-2`, `2020-01-17_11-13`, `2020-01-24_13-15`, `2020-01-28_15-18`, `2020-02-04_15-18`, `2020-01-17_13-15`, `2020-02-07_13-16`, `2020-01-16_9-12`, `2020-01-22_13-16`, `2020-01-23_9-12`, `2020-02-06_9-12`, `2020-02-06_13-16`, `2020-01-23_12-16`, `2020-02-07_12-16`, `20-02-11_15-17`, `20-02-13_9-12`, `20-02-13_13-15`, `20-02-14_13-15`, `20-02-18_15-17`, `20-02-20_9-12`, `20-02-20_13-15`, `20-02-21_11-15`, `20-02-21_13-17`) VALUES
(1, 'CSE', 'A1', 101012018, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1),
(2, 'CSE', 'A1', 3001012018, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0),
(3, 'CSE', 'A1', 1901012018, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
(4, 'CSE', 'A1', 2501012018, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
(5, 'CSE', 'A1', 1601012018, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
(6, 'CSE', 'A1', 1501012018, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0),
(7, 'CSE', 'A1', 3401012018, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
(8, 'CSE', 'A1', 201012018, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
(9, 'CSE', 'A1', 3501012018, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
(10, 'CSE', 'A1', 701012018, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1),
(11, 'CSE', 'A1', 3301012018, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0),
(12, 'CSE', 'A1', 401012018, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
(13, 'CSE', 'A1', 901012018, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0),
(14, 'CSE', 'A1', 3601012018, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
(15, 'CSE', 'A1', 1701012018, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1),
(16, 'CSE', 'A1', 2801012018, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1),
(17, 'CSE', 'A1', 1101012018, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
(18, 'CSE', 'A1', 2201012018, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1),
(19, 'CSE', 'A1', 2901012018, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0),
(20, 'CSE', 'A1', 3101012018, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1),
(21, 'CSE', 'A1', 1201012018, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1),
(22, 'CSE', 'A1', 1301012018, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0),
(23, 'CSE', 'A1', 3701012018, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0),
(24, 'CSE', 'A1', 2001012018, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1),
(25, 'CSE', 'A1', 3201012018, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
(26, 'CSE', 'A1', 2301012018, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0),
(27, 'CSE', 'A1', 601012018, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0),
(28, 'CSE', 'A1', 301012018, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0),
(29, 'CSE', 'A1', 2701012018, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0),
(30, 'CSE', 'A1', 1801012018, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
(31, 'CSE', 'A1', 3801012018, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0),
(32, 'CSE', 'A1', 1401012018, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0),
(33, 'CSE', 'A1', 501012018, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1),
(34, 'CSE', 'A1', 2101012018, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1),
(35, 'CSE', 'A1', 2401012018, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1),
(36, 'CSE', 'A1', 801012018, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
(37, 'CSE', 'A1', 2601012018, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
(38, 'CSE', 'B1', 4501012018, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0),
(39, 'CSE', 'B1', 4601012018, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0),
(40, 'CSE', 'B1', 4701012018, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0),
(41, 'CSE', 'B1', 6001012018, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0),
(42, 'CSE', 'B1', 5301012018, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0),
(43, 'CSE', 'B1', 6501012018, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0),
(44, 'CSE', 'B1', 4801012018, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0),
(45, 'CSE', 'B1', 7201012018, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0),
(46, 'CSE', 'B1', 6101012018, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0),
(47, 'CSE', 'B1', 7101012018, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0),
(48, 'CSE', 'B1', 5901012018, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0),
(49, 'CSE', 'B1', 4901012018, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0),
(50, 'CSE', 'B1', 6601012018, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0),
(51, 'CSE', 'B1', 7501012018, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0),
(52, 'CSE', 'B1', 4001012018, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0),
(53, 'CSE', 'B1', 3901012018, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
(54, 'CSE', 'B1', 5701012018, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0),
(55, 'CSE', 'B1', 6801012018, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0),
(56, 'CSE', 'B1', 5001012018, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0),
(57, 'CSE', 'B1', 4401012018, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0),
(58, 'CSE', 'B1', 5801012018, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0),
(59, 'CSE', 'B1', 6201012018, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0),
(60, 'CSE', 'B1', 5601012018, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0),
(61, 'CSE', 'B1', 6701012018, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
(62, 'CSE', 'B1', 4301012018, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0),
(63, 'CSE', 'B1', 6301012018, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0),
(64, 'CSE', 'B1', 7601012018, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0),
(65, 'CSE', 'B1', 7401012018, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0),
(66, 'CSE', 'B1', 4101012018, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0),
(67, 'CSE', 'B1', 5401012018, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0),
(68, 'CSE', 'B1', 6901012018, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0),
(69, 'CSE', 'B1', 6401012018, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0),
(70, 'CSE', 'B1', 7301012018, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0),
(71, 'CSE', 'B1', 5101012018, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0),
(72, 'CSE', 'B1', 1001012018, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0);

-- --------------------------------------------------------

--
-- Table structure for table `doubts`
--

CREATE TABLE `doubts` (
  `ID` int(11) NOT NULL,
  `Q_ID` int(11) NOT NULL,
  `Q_NAME` varchar(400) NOT NULL,
  `ROLL` bigint(20) NOT NULL,
  `DOUBT` text NOT NULL,
  `ANSWER` longtext NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

--
-- Dumping data for table `doubts`
--

INSERT INTO `doubts` (`ID`, `Q_ID`, `Q_NAME`, `ROLL`, `DOUBT`, `ANSWER`) VALUES
(1, 3, 'Quick Sort', 119, 'My code is not running even thoughI feel everything is coded fine. Can you please help me debug this?', ''),
(2, 2, 'Merge Sort', 90, 'Merge sort is used for sorting the data. But how can we optimize merge sort?', 'your doubt will be answered'),
(3, 3, 'Quick Sort', 78, 'My code is not working for edge cases like sorting 2 numbers etc. How can I improve it?', ''),
(4, 6, 'Display nodes of a tree', 12001012016, 'Which nodes are to be displayed?', ''),
(7, 5, 'Print hello world', 12001012016, 'ertyuth', ''),
(8, 2, 'Merge Sort', 119, 'yo', ''),
(9, 3, 'Quick Sort', 7601012018, 'I have a doubt', 'I am answering'),
(10, 4, 'Simultaneous MinMax', 7601012018, 'another doubt', ''),
(11, 4, 'Simultaneous MinMax', 7601012018, 'I declare a doubt\r\n', 'Why are you so curious?');

-- --------------------------------------------------------

--
-- Table structure for table `lab`
--

CREATE TABLE `lab` (
  `ID` int(11) NOT NULL,
  `LAB_ID` varchar(80) NOT NULL,
  `LAB_NAME` varchar(200) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

--
-- Dumping data for table `lab`
--

INSERT INTO `lab` (`ID`, `LAB_ID`, `LAB_NAME`) VALUES
(1, 'BCS-110', 'Programming in C Language Lab'),
(2, 'BIT-259', 'Object Oriented Programming Lab'),
(3, 'BCS-257', 'Data Structures Lab'),
(4, 'BIT-357', 'Data Communication and Computer Networks Lab'),
(5, 'BCS-354', 'Compiler Design Lab'),
(6, 'BCS-356', 'Network Programming Lab'),
(7, 'BCS-206', 'Analysis and Design of Algorithms Lab'),
(8, 'BIT-353', 'Computer Graphics and Multimedia Lab');

-- --------------------------------------------------------

--
-- Table structure for table `qtos_map`
--

CREATE TABLE `qtos_map` (
  `ID` int(11) NOT NULL,
  `Q_ID` int(11) NOT NULL,
  `ROLL` bigint(20) NOT NULL,
  `SUBMISSION` varchar(10000) NOT NULL,
  `SCORE` int(11) NOT NULL,
  `INPUT` text NOT NULL,
  `OP` text NOT NULL,
  `ALGO` text NOT NULL,
  `DATE` date NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

--
-- Dumping data for table `qtos_map`
--

INSERT INTO `qtos_map` (`ID`, `Q_ID`, `ROLL`, `SUBMISSION`, `SCORE`, `INPUT`, `OP`, `ALGO`, `DATE`) VALUES
(14, 2, 7101012018, '\r\n\r\n\r\n#include<iostream>\r\nusing namespace std;\r\n#include <iostream>\r\nusing namespace std;\r\nvoid swap(int *a, int *b)\r\n{\r\n int t = *a;\r\n *a = *b;\r\n *b = t;\r\n}\r\nint partition(int array[], int low, int high)\r\n{\r\n int pivot = array[high];\r\n int i = (low - 1);\r\n for (int j = low; j < high; j++)\r\n {\r\n if (array[j] <= pivot)\r\n {\r\n i++;\r\n swap(&array[i], &array[j]);\r\n }\r\n }\r\n swap(&array[i + 1], &array[high]);\r\n return (i + 1);\r\n}\r\nvoid qs(int array[], int low, int high)\r\n{\r\n if (low < high)\r\n {\r\n int pi = partition(array, low, high);\r\n qs(array, low, pi - 1);\r\n qs(array, pi + 1, high);\r\n }\r\n}\r\nint main(){\r\nint n;\r\ncin>>n;\r\nint arr[n];\r\nfor(int i=0;i<n;i++){\r\n cin>>arr[i];\r\n}\r\nqs(arr,0,n-1);\r\nfor(int i=0;i<n;i++){\r\n cout<<arr[i];\r\n //if(i==n-1)\r\n // break;\r\n cout<<\" \";\r\n}\r\nreturn 0;\r\n}\r\n', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', 'MergeSort(arr[], l, r)\r\nIf r > l\r\n 1. Find the middle point to divide the array into two halves:\r\n middle m = (l+r)/2\r\n 2. mergeSort for first half:\r\n 		mergeSort(arr, l, m)\r\n 3. mergeSort for second half:\r\n 		mergeSort(arr, m+1, r)\r\n 4. Merge the two halves sorted in step 2 and 3:\r\n 	merge(arr, l, m, r)', '2020-05-25'),
(15, 2, 3901012018, '﻿#include<stdlib.h>\r\n#include<stdio.h>\r\n#include<iostream>\r\n#include<conio.h>\r\nusing namespace std;\r\nvoid merge(int arr[], int l, int m, int r)\r\n{\r\n    int i, j, k;\r\n    int n1 = m - l + 1;\r\n    int n2 =  r - m;\r\n\r\n\r\n    int L[n1], R[n2];\r\n\r\n\r\n    for (i = 0; i < n1; i++)\r\n        L[i] = arr[l + i];\r\n    for (j = 0; j < n2; j++)\r\n        R[j] = arr[m + 1+ j];\r\n\r\n\r\n    i = 0;\r\n    j = 0;\r\n    k = l;\r\n    while (i < n1 && j < n2)\r\n    {\r\n        if (L[i] <= R[j])\r\n        {\r\n            arr[k] = L[i];\r\n            i++;\r\n        }\r\n        else\r\n        {\r\n            arr[k] = R[j];\r\n            j++;\r\n        }\r\n        k++;\r\n    }\r\n\r\n\r\n    while (i < n1)\r\n    {\r\n        arr[k] = L[i];\r\n        i++;\r\n        k++;\r\n    }\r\n\r\n\r\n    while (j < n2)\r\n    {\r\n        arr[k] = R[j];\r\n        j++;\r\n        k++;\r\n    }\r\n}\r\n\r\n\r\nvoid mergeSort(int arr[], int l, int r)\r\n{\r\n    if (l < r)\r\n    {\r\n\r\n\r\n        int m = l+(r-l)/2;\r\n        mergeSort(arr, l, m);\r\n        mergeSort(arr, m+1, r);\r\n\r\n\r\n        merge(arr, l, m, r);\r\n    }\r\n}\r\nvoid printArray(int A[], int size)\r\n{\r\n    int i;\r\n    for (i=0; i < size; i++)\r\n        printf(\"%d \", A[i]);\r\n}\r\n\r\n\r\n\r\n\r\nint main()\r\n{\r\n    int n; cin >> n;\r\n\r\n\r\n    int* arr = new int[n];\r\n\r\n\r\n    for(int i = 0; i < n; i++)\r\n        cin >> arr[i];\r\n\r\n\r\n    int arr_size = sizeof(arr)/sizeof(arr[0]);\r\n\r\n\r\n    mergeSort(arr, 0, n - 1);\r\n    printArray(arr, n);\r\n    return 0;\r\n}', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', 'MergeSort(arr[], l,  r)\r\nIf r > l\r\n     1. Find the middle point to divide the array into two halves:  \r\n             middle m = (l+r)/2\r\n     2. Call mergeSort for first half:   \r\n             Call mergeSort(arr, l, m)\r\n     3. Call mergeSort for second half:\r\n             Call mergeSort(arr, m+1, r)\r\n     4. Merge the two halves sorted in step 2 and 3:\r\n             Call merge(arr, l, m, r)', '2020-05-25'),
(16, 2, 4901012018, '#include<iostream>\r\nusing namespace std;\r\n\r\n\r\nvoid merge(int arr[], int sPos, int ePos)\r\n{\r\n    \r\n    int temp[1000];\r\n    int mid= (sPos+ePos)/2;\r\n    for(int i=mid+1;i<=ePos;i++)\r\n    {\r\n        temp[i]= arr[i];\r\n    }\r\n     \r\n     int i= mid, j=ePos, k=ePos;\r\n     while(i>=sPos&&j>mid)\r\n     {\r\n         if(arr[i]>temp[j])\r\n         {\r\n             arr[k--]= arr[i--];\r\n         }\r\n         else\r\n         {\r\n             arr[k--]= temp[j--];\r\n         }\r\n     }\r\n     while(j>mid)\r\n     {\r\n         arr[k--]= temp[j--];\r\n     }\r\n    \r\n}\r\n\r\nvoid mergeSort(int arr[], int sPos, int ePos)\r\n{\r\n    if(sPos>=ePos) return;\r\n    int mPos= (sPos+ePos)/2;\r\n    \r\n    mergeSort(arr, sPos, mPos);\r\n    mergeSort(arr, mPos+1, ePos);\r\n    merge(arr, sPos, ePos);\r\n    \r\n}\r\n\r\n\r\nint main()\r\n{\r\n    \r\n    int n; cin>>n;\r\n    int arr[n];\r\n    \r\n    for(int i=0;i<n;i++) cin>>arr[i];\r\n      \r\n      \r\n      mergeSort(arr,0,n-1);\r\n      \r\n      for(int i=0;i<n;i++) cout<<arr[i]<<\" \";\r\n    \r\n}\r\n                                            \r\n', 10, '7 10 -42 15 12 37 -7 -9', '-42 -9 -7 10 12 15 37 ', '', '2020-03-11'),
(17, 2, 7201012018, '#include<iostream>\r\nusing namespace  std;\r\n\r\nvoid merge(int arr[], int l, int m, int r) \r\n{ \r\n	int i, j, k; \r\n	int n1 = m - l + 1; \r\n	int n2 = r - m; \r\n\r\n	/* create temp arrays */\r\n	int L[n1], R[n2]; \r\n\r\n	/* Copy data to temp arrays L[] and R[] */\r\n	for (i = 0; i < n1; i++) \r\n		L[i] = arr[l + i]; \r\n	for (j = 0; j < n2; j++) \r\n		R[j] = arr[m + 1+ j]; \r\n\r\n\r\n	i = 0; \r\n	j = 0; \r\n	k = l;  \r\n	while (i < n1 && j < n2) \r\n	{ \r\n		if (L[i] <= R[j]) \r\n		{ \r\n			arr[k] = L[i]; \r\n			i++; \r\n		} \r\n		else\r\n		{ \r\n			arr[k] = R[j]; \r\n			j++; \r\n		} \r\n		k++; \r\n	} \r\n\r\n	/* Copy the remaining elements of L[], if there \r\n	are any */\r\n	while (i < n1) \r\n	{ \r\n		arr[k] = L[i]; \r\n		i++; \r\n		k++; \r\n	} \r\n\r\n	/* Copy the remaining elements of R[], if there \r\n	are any */\r\n	while (j < n2) \r\n	{ \r\n		arr[k] = R[j]; \r\n		j++; \r\n		k++; \r\n	} \r\n} \r\n\r\n/* l is for left index and r is right index of the \r\nsub-array of arr to be sorted */\r\nvoid mergeSort(int arr[], int l, int r) \r\n{ \r\n	if (l < r) \r\n	{ \r\n		// Same as (l+r)/2, but avoids overflow for \r\n		// large l and h \r\n		int m = l+(r-l)/2; \r\n\r\n		// Sort first and second halves \r\n		mergeSort(arr, l, m); \r\n		mergeSort(arr, m+1, r); \r\n\r\n		merge(arr, l, m, r); \r\n	} \r\n} \r\n\r\nvoid printArray(int A[], int size) \r\n{ \r\n	int i; \r\n	for (i=0; i < size; i++) \r\n		cout<<A[i]<<\" \";\r\n\r\n} \r\n\r\nint main() \r\n{ \r\n    int n;\r\nint arr[1000000];\r\ncin>>n;\r\nfor(int i=0;i<n;i++)\r\n{\r\n    cin>>arr[i];\r\n}\r\nint arr_size=n;\r\n\r\n\r\n	mergeSort(arr, 0, arr_size - 1); \r\n\r\n	printArray(arr, arr_size); \r\n	return 0; \r\n} \r\n', 0, '', '', '', '0000-00-00'),
(18, 2, 5701012018, '#include <iostream>\r\nusing namespace std;\r\nvoid merge(int *,int, int , int );\r\nvoid merge_sort(int *arr, int low, int high)\r\n{\r\n    int mid;\r\n    if (low < high)\r\n    {\r\n        mid=(low+high)/2;\r\n        merge_sort(arr,low,mid);\r\n        merge_sort(arr,mid+1,high);\r\n        merge(arr,low,high,mid);\r\n    }\r\n}\r\nvoid merge(int *arr, int low, int high, int mid)\r\n{\r\n    int i, j, k, c[50];\r\n    i = low;\r\n    k = low;\r\n    j = mid + 1;\r\n    while (i <= mid && j <= high)\r\n    {\r\n        if (arr[i] < arr[j])\r\n        {\r\n            c[k] = arr[i];\r\n            k++;\r\n            i++;\r\n        }\r\n        else\r\n        {\r\n            c[k] = arr[j];\r\n            k++;\r\n            j++;\r\n        }\r\n    }\r\n    while (i <= mid)\r\n    {\r\n        c[k] = arr[i];\r\n        k++;\r\n        i++;\r\n    }\r\n    while (j <= high)\r\n    {\r\n        c[k] = arr[j];\r\n        k++;\r\n        j++;\r\n    }\r\n    for (i = low; i < k; i++)  {\r\n        arr[i] = c[i];\r\n    }\r\n}\r\nint main()\r\n{\r\n    int myarray[30], num;\r\n    cin>>num;\r\n    for (int i = 0; i < num; i++) \r\n    { \r\n        cin>>myarray[i];\r\n    }\r\n    merge_sort(myarray, 0, num-1);\r\n    for (int i = 0; i < num; i++)\r\n    {\r\n        cout<<myarray[i]<<\" \";\r\n    }\r\n}\r\n', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', 'MergeSort(arr[], l,  r)\r\nIf r > l\r\n     1. Find the middle point to divide the array into two halves:  \r\n             middle m = (l+r)/2\r\n     2. Call mergeSort for first half:   \r\n             Call mergeSort(arr, l, m)\r\n     3. Call mergeSort for second half:\r\n             Call mergeSort(arr, m+1, r)\r\n     4. Merge the two halves sorted in step 2 and 3:\r\n             Call merge(arr, l, m, r)', '2020-05-25'),
(19, 2, 4501012018, '#include<iostream>\r\nusing namespace std;\r\nvoid swapping(int &a, int &b) {\r\n   int temp;\r\n   temp = a;\r\n   a = b;\r\n   b = temp;\r\n}\r\nvoid display(int *array, int size) {\r\n   for(int i = 0; i<size; i++)\r\n      cout << array[i] << \" \";\r\n}\r\nvoid merge(int *array, int l, int m, int r) {\r\n   int i, j, k, nl, nr;\r\n\r\n   nl = m-l+1; nr = r-m;\r\n   int larr[nl], rarr[nr];\r\n\r\n   for(i = 0; i<nl; i++)\r\n      larr[i] = array[l+i];\r\n   for(j = 0; j<nr; j++)\r\n      rarr[j] = array[m+1+j];\r\n   i = 0; j = 0; k = l;\r\n\r\n   while(i < nl && j<nr) {\r\n      if(larr[i] <= rarr[j]) {\r\n         array[k] = larr[i];\r\n         i++;\r\n      }else{\r\n         array[k] = rarr[j];\r\n         j++;\r\n      }\r\n      k++;\r\n   }\r\n   while(i<nl) {\r\n      array[k] = larr[i];\r\n      i++; k++;\r\n   }\r\n   while(j<nr) {\r\n      array[k] = rarr[j];\r\n      j++; k++;\r\n   }\r\n}\r\nvoid mergeSort(int *array, int l, int r) {\r\n   int m;\r\n   if(l < r) {\r\n      int m = l+(r-l)/2;\r\n      mergeSort(array, l, m);\r\n      mergeSort(array, m+1, r);\r\n      merge(array, l, m, r);\r\n   }\r\n}\r\nint main() {\r\n   int n;\r\n   cin >> n;\r\n   int arr[n];\r\n   for(int i = 0; i<n; i++) {\r\n      cin >> arr[i];\r\n   }\r\n   mergeSort(arr, 0, n-1);\r\n   display(arr, n);\r\n}\r\n', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', '\r\nMergeSort(arr[], l,  r)\r\nIf r > l\r\n 	1. Find the middle point to divide the array into two halves:\r\n         	middle m = (l+r)/2\r\n	 2. Call mergeSort for first half:\r\n         	Call mergeSort(arr, l, m)\r\n 	3. Call mergeSort for second half:\r\n         	Call mergeSort(arr, m+1, r)\r\n 	4. Merge the two halves sorted in step 2 and 3:\r\n         	Call merge(arr, l, m, r)\r\n', '2020-05-25'),
(20, 2, 5101012018, '#include<iostream>\r\nusing namespace std;\r\nvoid merge(int *a,int low,int high,int mid){\r\n\r\n    int i,j,k,temp[high-low+1];\r\n    i=low;\r\n    k=0;\r\n    j=mid+1;\r\n    while(i<=mid && j<=high){\r\n        if(a[i]<a[j]){\r\n            temp[k]=a[i];\r\n            k++;\r\n            i++;\r\n        }else{\r\n            temp[k]=a[j];\r\n            k++;\r\n            j++;\r\n        }\r\n    }\r\n    while(i<=mid){\r\n        temp[k]=a[i];\r\n        k++;\r\n        i++;\r\n    }\r\n    while(j<=high){\r\n        temp[k]=a[j];\r\n        k++;\r\n        j++;\r\n    }\r\n    for(int i=low;i<=high;i++){\r\n        a[i]=temp[i-low];\r\n    }\r\n\r\n}\r\nvoid ms(int *a,int low,int high){\r\n    int mid;\r\n    if(low<high){\r\n        mid=(low+high)/2;\r\n        ms(a,low,mid);\r\n        ms(a,mid+1,high);\r\n        merge(a,low,high,mid);\r\n    }\r\n}\r\nint main(){\r\n    int n;\r\n    cin>>n;\r\n    int arr[n];\r\n    for(int i=0;i<n;i++){\r\n        cin>>arr[i];\r\n    }\r\n\r\n    ms(arr,0,n-1);\r\n     for(int i=0;i<n;i++){\r\n        cout<<arr[i];\r\n        if(i!=n-1)\r\n        cout<<\" \";\r\n    }\r\n    return 0;\r\n}\r\n', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000', 'MergeSort(arr[], l,  r)\r\nIf r > l\r\n 	1. Find the middle point to divide the array into two halves: \r\n         	middle m = (l+r)/2\r\n	 2. Call mergeSort for first half:  \r\n         	Call mergeSort(arr, l, m)\r\n 	3. Call mergeSort for second half:\r\n         	Call mergeSort(arr, m+1, r)\r\n 	4. Merge the two halves sorted in step 2 and 3:\r\n         	Call merge(arr, l, m, r)\r\n', '2020-05-25'),
(21, 2, 4801012018, '﻿#include<iostream>\r\nusing namespace std;\r\nvoid merge(int arr[], int l, int m, int r)\r\n{\r\n    int i, j, k;\r\n    int n1 = m - l + 1;\r\n    int n2 =  r - m;\r\n\r\n\r\n    int L[n1], R[n2];\r\n\r\n\r\n    for (i = 0; i < n1; i++)\r\n        L[i] = arr[l + i];\r\n    for (j = 0; j < n2; j++)\r\n        R[j] = arr[m + 1+ j];\r\n\r\n\r\n    i = 0;\r\n    j = 0;\r\n    k = l;\r\n    while (i < n1 && j < n2)\r\n    {\r\n        if (L[i] <= R[j])\r\n        {\r\n            arr[k] = L[i];\r\n            i++;\r\n        }\r\n        else\r\n        {\r\n            arr[k] = R[j];\r\n            j++;\r\n        }\r\n        k++;\r\n    }\r\n\r\n\r\n    while (i < n1)\r\n    {\r\n        arr[k] = L[i];\r\n        i++;\r\n        k++;\r\n    }\r\n\r\n\r\n    while (j < n2)\r\n    {\r\n        arr[k] = R[j];\r\n        j++;\r\n        k++;\r\n    }\r\n}\r\n\r\n\r\nvoid mergeSort(int arr[], int l, int r)\r\n{\r\n    if (l < r)\r\n    {\r\n\r\n\r\n        int m = l+(r-l)/2;\r\n        mergeSort(arr, l, m);\r\n        mergeSort(arr, m+1, r);\r\n\r\n\r\n        merge(arr, l, m, r);\r\n    }\r\n}\r\nvoid printArray(int A[], int size)\r\n{\r\n    int i;\r\n    for (i=0; i < size; i++)\r\n        cout<<A[i]<<\" \";\r\n}\r\n\r\n\r\n\r\n\r\nint main()\r\n{\r\n    int n; cin >> n;\r\n\r\n\r\n    int* arr = new int[n];\r\n\r\n\r\n    for(int i = 0; i < n; i++)\r\n        cin >> arr[i];\r\n\r\n\r\n    int arr_size = sizeof(arr)/sizeof(arr[0]);\r\n\r\n\r\n    mergeSort(arr, 0, n - 1);\r\n    printArray(arr, n);\r\n    return 0;\r\n}', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', '﻿MergeSort(arr[], l,  r)\r\nIf r > l\r\n     1. Find the middle point to divide the array into two halves:  \r\n             middle m = (l+r)/2\r\n    2. Call mergeSort for first half:   \r\n             Call mergeSort(arr, l, m)\r\n     3. Call mergeSort for second half:\r\n             Call mergeSort(arr, m+1, r)\r\n     4. Merge the two halves sorted in step 2 and 3:\r\n             Call merge(arr, l, m, r)', '2020-05-25'),
(22, 2, 6201012018, '#include<iostream>\r\nusing namespace std;\r\nvoid merge(int arr[],int start1,int start2, int end){\r\n    int  temp[100000];\r\n    int s1=start1;\r\n    int e1=start2-1;\r\n    int s2=start2;\r\n    int e2=end;\r\n    int k=0;\r\n    while(s1<=e1 && s2<=e2){\r\n        if(arr[s1]<arr[s2]){\r\n            temp[k++]=arr[s1++];\r\n        }\r\n        else{\r\n            temp[k++]=arr[s2++];\r\n        }\r\n    }\r\n    while(s1<=e1){\r\n        temp[k++]=arr[s1++];\r\n    }\r\n    while(s2<=e2){\r\n        temp[k++]=arr[s2++];\r\n    }\r\n    for(long int i=start1,k=0;i<=end;i++){\r\n        arr[i]=temp[k++];\r\n    }\r\n    return;\r\n}\r\nvoid mergesort(int arr[], int start, int end){\r\n    if(start>=end){\r\n        return;\r\n    }\r\n    int mid=(start+end)/2;\r\n    mergesort(arr,start,mid);\r\n    mergesort(arr,mid+1,end);\r\n    merge(arr,start,mid+1,end);\r\n    return;\r\n}\r\nint main(){\r\n    int arr[100000],n;\r\n    cin>>n;\r\n    for(int i=0;i<n;i++){\r\n        cin>>arr[i];\r\n    }\r\n    mergesort(arr,0,n-1);\r\n    for(int i=0;i<n;i++){\r\n        cout<<arr[i]<<\" \";\r\n    }\r\n}\r\n\r\n                                            \r\n', 10, '', '', '', '0000-00-00'),
(23, 2, 6501012018, 'import java.util.*; public class Main { public static void main(String[] args) { Scanner scn = new Scanner(System.in); int n = scn.nextInt(); int[] arr = new int[n]; for(int i=0;i<n;i++) arr[i] = scn.nextInt(); int[] ans = MergeSortRecursion(arr, 0, arr.length - 1); for (int val : ans) { System.out.print(val+\" \"); } } public static int[] mergetwosortedarrays(int[] one, int[] two) { int[] ans = new int[one.length + two.length]; int i = 0; int j = 0; int k = 0; while (i < one.length && j < two.length) { if (one[i] < two[j]) { ans[k] = one[i]; i++; } else { ans[k] = two[j]; j++; } k++; } if (j == two.length) { while (i < one.length) { ans[k] = one[i]; i++; k++; } } if (i == one.length) { while (j < two.length) { ans[k] = two[j]; j++; k++; } } return ans; } public static int[] MergeSortRecursion(int[] arr, int lo, int hi) { if (lo == hi) { int[] br = new int[1]; br[0] = arr[lo]; return br; } int mid = (lo + hi) / 2; int[] fh = MergeSortRecursion(arr, lo, mid); int[] sh = MergeSortRecursion(arr, mid + 1, hi); int[] merged = mergetwosortedarrays(fh, sh); return merged; } }\r\n\r\n', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', 'Algo:\r\n\r\n\r\n\r\nMergeSort(arr[], l,  r)\r\nIf r > l\r\n     1. Find the middle point to divide the array into two halves:  \r\n             middle m = (l+r)/2\r\n     2. Call mergeSort for first half:   \r\n             Call mergeSort(arr, l, m)\r\n     3. Call mergeSort for second half:\r\n             Call mergeSort(arr, m+1, r)\r\n     4. Merge the two halves sorted in step 2 and 3:\r\n             Call merge(arr, l, m, r)', '2020-05-25'),
(24, 2, 4601012018, '#include<iostream>\nusing namespace std;\nvoid merge(int input[],int l, int m, int r)\n{\n    int i,j,k;\n    int n1=m-l+1;\n    int n2=r-m;\n    int L[n1],R[n2];\n    for(i=0;i<n1;i++)\n    L[i]=input[l+i];\n    for(j=0;j<n2;j++)\n    R[j]=input[m+1+j];\n    i=0;\n    j=0;\n    k=l;\n    while(i<n1&&j<n2)\n    {\n        if(L[i]<=R[j])\n        {\n            input[k]=L[i];\n            i++;\n            k++;\n        }\n        else\n        {\n            input[k]=R[j];\n            j++;\n            k++;\n        }\n    }\n    while(i<n1)\n    {\n        input[k]=L[i];\n        i++;\n        k++;\n    }\n    while(j<n2)\n    {\n        input[k]=R[j];\n        j++;\n        k++;\n    }\n}\nvoid merge_sort(int input[],int l, int r)\n{\n    int m;\n    if(l<r)\n    {\n        m=(r+l)/2;\n        merge_sort(input,l,m);\n        merge_sort(input,m+1,r);\n        merge(input,l,m,r);\n    }\n    \n}\nvoid mergesort(int input[],int size)\n{\n    int l=0;\n    int r=size-1;\n    merge_sort(input,l,r);\n}\nint main()\n{\nint input[1000],length;\ncin>>length;\nfor(int i=0; i<length; i++)\n{\n    cin>> input[i];\n}\nmergesort(input,length);\nfor(int i=0;i<length;i++)\n{\n    cout<<input[i]<<\" \";\n}\nreturn 0;\n}', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', 'MergeSort(arr[], l,  r)\nIf r > l\n     1. Find the middle point to divide the array into two halves:  \n             middle m = (l+r)/2\n     2. Call mergeSort for first half:   \n             Call mergeSort(arr, l, m)\n     3. Call mergeSort for second half:\n             Call mergeSort(arr, m+1, r)\n     4. Merge the two halves sorted in step 2 and 3:\n             Call merge(arr, l, m, r)', '2020-05-25'),
(25, 2, 5001012018, '#include<stdio.h>\r\nvoid merge(int input[],int l,int m,int r)\r\n{ int i,j,k;\r\n    int n1=m-l+1;\r\n        int n2=r-m;\r\n int L[n1],R[n2];\r\n for(i=0;i<n1;i++)\r\n     L[i]=input[l+i];\r\n for(j=0;j<n2;j++)\r\n     R[j]=input[m+1+j];\r\n  i=0;\r\n j=0;\r\n k=l;\r\n while(i<n1&&j<n2)\r\n {\r\n  if(L[i]<=R[j])\r\n     {\r\n      input[k]=L[i];\r\n      i++;\r\n      k++;\r\n  }\r\n     else\r\n     {\r\n         input[k]=R[j];\r\n         j++;\r\n         k++;\r\n     }\r\n }\r\n     while(i<n1)\r\n     {\r\n         input[k]=L[i];\r\n         i++;\r\n         k++;\r\n     }\r\n     while(j<n2)\r\n     {\r\n         input[k]=R[j];\r\n         j++;\r\n         k++;\r\n         }\r\n}\r\nvoid merge_Sort(int input[],int l,int r)\r\n{ int m;\r\n    if(l<r)\r\n    {\r\n        m=(r+l)/2;\r\n    merge_Sort(input,l,m);\r\n   merge_Sort(input,m+1,r);\r\n merge(input,l,m,r);\r\n}\r\n}\r\nvoid mergeSort(int input[], int size)\r\n{\r\nint l=0;\r\n    int r=size-1;\r\n    merge_Sort(input,l,r);\r\n    }\r\n\r\nint main() {\r\n  int input[100],n,i;\r\n  scanf(\"%d\",&n);\r\n  for(i=0; i < n; i++)\r\n    scanf(\"%d\",&input[i]);\r\n  mergeSort(input, n);\r\n  for(i = 0; i < n; i++) {\r\n      \r\n    printf(\"%d \",input[i]);\r\n      \r\n}\r\n    return 0;\r\n}', 10, '', '', '', '0000-00-00'),
(27, 2, 6801012018, '#include<stdlib.h> \r\n#include<stdio.h> \r\n  \r\nvoid merge(int arr[], int l, int m, int r) \r\n{ \r\n    int i, j, k; \r\n    int n1 = m - l + 1; \r\n    int n2 =  r - m; \r\n  \r\n    \r\n    int L[n1], R[n2]; \r\n  \r\n    \r\n    for (i = 0; i < n1; i++) \r\n        L[i] = arr[l + i]; \r\n    for (j = 0; j < n2; j++) \r\n        R[j] = arr[m + 1+ j]; \r\n    i = 0; \r\n    j = 0; \r\n    k = l; \r\n    while (i < n1 && j < n2) \r\n    { \r\n        if (L[i] <= R[j]) \r\n        { \r\n            arr[k] = L[i]; \r\n            i++; \r\n        } \r\n        else\r\n        { \r\n            arr[k] = R[j]; \r\n            j++; \r\n        } \r\n        k++; \r\n    } \r\n\r\n    while (i < n1) \r\n    { \r\n        arr[k] = L[i]; \r\n        i++; \r\n        k++; \r\n    } \r\n  \r\n   \r\n    while (j < n2) \r\n    { \r\n        arr[k] = R[j]; \r\n        j++; \r\n        k++; \r\n    } \r\n} \r\n  \r\nvoid mergeSort(int arr[], int l, int r) \r\n{ \r\n    if (l < r) \r\n    { \r\n        // Same as (l+r)/2, but avoids overflow for \r\n        // large l and h \r\n        int m = l+(r-l)/2; \r\n  \r\n        // Sort first and second halves \r\n        mergeSort(arr, l, m); \r\n        mergeSort(arr, m+1, r); \r\n  \r\n        merge(arr, l, m, r); \r\n    } \r\n} \r\nvoid printArray(int A[], int size) \r\n{ \r\n    int i; \r\n    for (i=0; i < size; i++) \r\n        printf(\"%d \", A[i]); \r\n    printf(\"\n\"); \r\n} \r\n  \r\nint main() \r\n{ \r\n  \r\nint t;\r\ncin>>t;\r\nwhile(t!=0){\r\nint n;\r\ncin>>n;\r\nint a[n];\r\nfor(int i=0;i<n;i++){\r\ncin>>a[i];\r\n}\r\n    printf(\"Given array is \n\"); \r\n    printArray(arr, arr_size); \r\n  \r\n    mergeSort(a, 0, n - 1); \r\n  \r\n    printf(\"\nSorted array is \n\"); \r\n    printArray(a, n); \r\n    return 0; \r\n\r\nt--;\r\ncout<<endl;\r\n}\r\n} ', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '', 'MergeSort(arr[], l,  r)\r\nIf r > l\r\n     1. Find the middle point to divide the array into two halves:  \r\n             middle m = (l+r)/2\r\n     2. Call mergeSort for first half:   \r\n             Call mergeSort(arr, l, m)\r\n     3. Call mergeSort for second half:\r\n             Call mergeSort(arr, m+1, r)\r\n     4. Merge the two halves sorted in step 2 and 3:\r\n             Call merge(arr, l, m, r)', '2020-05-25'),
(28, 2, 5601012018, '#include<stdlib.h> \r\n#include<stdio.h> \r\n  \r\nvoid merge(int arr[], int l, int m, int r) \r\n{ \r\n    int i, j, k; \r\n    int n1 = m - l + 1; \r\n    int n2 =  r - m; \r\n  \r\n    int L[n1], R[n2]; \r\n  \r\n    for (i = 0; i < n1; i++) \r\n        L[i] = arr[l + i]; \r\n    for (j = 0; j < n2; j++) \r\n        R[j] = arr[m + 1+ j]; \r\n  \r\n    i = 0; \r\n    j = 0; \r\n    k = l; \r\n    while (i < n1 && j < n2) \r\n    { \r\n        if (L[i] <= R[j]) \r\n        { \r\n            arr[k] = L[i]; \r\n            i++; \r\n        } \r\n        else\r\n        { \r\n            arr[k] = R[j]; \r\n            j++; \r\n        } \r\n        k++; \r\n    } \r\n    while (i < n1) \r\n    { \r\n        arr[k] = L[i]; \r\n        i++; \r\n        k++; \r\n    } \r\n    while (j < n2) \r\n    { \r\n        arr[k] = R[j]; \r\n        j++; \r\n        k++; \r\n    } \r\n} \r\n  \r\nvoid mergeSort(int arr[], int l, int r) \r\n{ \r\n    if (l < r) \r\n    { \r\n        int m = l+(r-l)/2; \r\n  \r\n        mergeSort(arr, l, m); \r\n        mergeSort(arr, m+1, r); \r\n  \r\n        merge(arr, l, m, r); \r\n    } \r\n} \r\nvoid printArray(int A[], int size) \r\n{ \r\n    int i; \r\n    for (i=0; i < size; i++) \r\n        printf(\"%d \", A[i]); \r\n} \r\n  \r\nint main() \r\n{ \r\n\r\n    int n;\r\n    scanf(\"%d\",&n);  \r\n    int i, arr[n];\r\n    for(i=0;i<n;i++)\r\n        scanf(\"%d\",&arr[i]); \r\n  \r\n    mergeSort(arr, 0, n - 1); \r\n  \r\n    printArray(arr, n); \r\n    return 0; \r\n}', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', 'MergeSort(arr[], l,  r)\r\nIf r > l\r\n     1. Find the middle point to divide the array into two halves:  \r\n             middle m = (l+r)/2\r\n     2. Call mergeSort for first half:   \r\n             Call mergeSort(arr, l, m)\r\n     3. Call mergeSort for second half:\r\n             Call mergeSort(arr, m+1, r)\r\n     4. Merge the two halves sorted in step 2 and 3:\r\n             Call merge(arr, l, m, r)', '2020-05-25'),
(30, 2, 6001012018, '#include<stdio.h>\r\nvoid merge(int input[],int l,int m,int r)\r\n{ int i,j,k;\r\n    int n1=m-l+1;\r\n        int n2=r-m;\r\n int L[n1],R[n2];\r\n for(i=0;i<n1;i++)\r\n     L[i]=input[l+i];\r\n for(j=0;j<n2;j++)\r\n     R[j]=input[m+1+j];\r\n  i=0;\r\n j=0;\r\n k=l;\r\n while(i<n1&&j<n2)\r\n {\r\n  if(L[i]<=R[j])\r\n     {\r\n      input[k]=L[i];\r\n      i++;\r\n      k++;\r\n  }\r\n     else\r\n     {\r\n         input[k]=R[j];\r\n         j++;\r\n         k++;\r\n     }\r\n }\r\n     while(i<n1)\r\n     {\r\n         input[k]=L[i];\r\n         i++;\r\n         k++;\r\n     }\r\n     while(j<n2)\r\n     {\r\n         input[k]=R[j];\r\n         j++;\r\n         k++;\r\n         }\r\n}\r\nvoid merge_Sort(int input[],int l,int r)\r\n{ int m;\r\n    if(l<r)\r\n    {\r\n        m=(r+l)/2;\r\n    merge_Sort(input,l,m);\r\n   merge_Sort(input,m+1,r);\r\n merge(input,l,m,r);\r\n}\r\n}\r\nvoid mergeSort(int input[], int size)\r\n{\r\nint l=0;\r\n    int r=size-1;\r\n    merge_Sort(input,l,r);\r\n    }\r\n\r\nint main() {\r\n  int input[100],n,i;\r\n  scanf(\"%d\",&n);\r\n  for(i=0; i < n; i++)\r\n    scanf(\"%d\",&input[i]);\r\n  mergeSort(input, n);\r\n  for(i = 0; i < n; i++) {\r\n      \r\n    printf(\"%d \",input[i]);\r\n      \r\n}\r\n    return 0;\r\n}', 10, '', '', '', '0000-00-00'),
(31, 2, 6701012018, 'import java.util.*;\r\npublic class Main {\r\n	static void merge(int []arr,int l,int m,int h)\r\n	{\r\n		int n1 = m-l+1;\r\n		int n2 = h-m;\r\n\r\n		int L[] = new int[n1];\r\n		int R[] = new int[n2];\r\n\r\n		for(int i=0;i<n1;i++)\r\n		{\r\n			L[i] = arr[l+i];\r\n		}\r\n		for(int j=0;j<n2;j++)\r\n		{\r\n			R[j] = arr[j+m+1];\r\n		}\r\n		int k=l;\r\n		int i=0,j=0;\r\n		while(i<n1 && j<n2)\r\n		{\r\n			if(L[i]<=R[j])\r\n			{\r\n				arr[k] = L[i];\r\n				i++;\r\n			}\r\n			else\r\n			{\r\n				arr[k] = R[j];\r\n				j++;\r\n			}\r\n			k++;\r\n		}\r\n\r\n		while(i<n1)\r\n		{\r\n			arr[k] = L[i];\r\n			k++;\r\n			i++;\r\n		}\r\n		while(j<n2)\r\n		{\r\n			arr[k] = R[j];\r\n			k++;\r\n			j++;\r\n		}		\r\n	}\r\n	static void mergesort(int []arr,int l,int h)\r\n	{\r\n		if(l<h)\r\n		{\r\n			int m = (l+h)/2;\r\n			mergesort(arr,l,m);\r\n			mergesort(arr,m+1,h);\r\n			merge(arr,l,m,h);\r\n		}\r\n	}\r\n    public static void main(String args[]) {\r\n		Scanner sc = new Scanner(System.in);\r\n		int n = sc.nextInt();\r\n		int arr[] = new int[n];\r\n		for(int i=0;i<n;i++)\r\n		{\r\n			arr[i] = sc.nextInt();\r\n		}\r\n		mergesort(arr,0,n-1);\r\n		for(int i=0;i<n;i++)\r\n		{\r\n			System.out.print(arr[i] + \" \");\r\n		}\r\n		\r\n    }\r\n}', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', '', '2020-05-25'),
(32, 2, 6301012018, '﻿#include<iostream>\r\nusing namespace std;\r\nvoid merge(int arr[], int l, int m, int r)\r\n{\r\n    int i, j, k;\r\n    int n1 = m - l + 1;\r\n    int n2 =  r - m;\r\n\r\n\r\n    int L[n1], R[n2];\r\n\r\n\r\n    for (i = 0; i < n1; i++)\r\n        L[i] = arr[l + i];\r\n    for (j = 0; j < n2; j++)\r\n        R[j] = arr[m + 1+ j];\r\n\r\n\r\n    i = 0;\r\n    j = 0;\r\n    k = l;\r\n    while (i < n1 && j < n2)\r\n    {\r\n        if (L[i] <= R[j])\r\n        {\r\n            arr[k] = L[i];\r\n            i++;\r\n        }\r\n        else\r\n        {\r\n            arr[k] = R[j];\r\n            j++;\r\n        }\r\n        k++;\r\n    }\r\n\r\n\r\n    while (i < n1)\r\n    {\r\n        arr[k] = L[i];\r\n        i++;\r\n        k++;\r\n    }\r\n\r\n\r\n    while (j < n2)\r\n    {\r\n        arr[k] = R[j];\r\n        j++;\r\n        k++;\r\n    }\r\n}\r\n\r\n\r\nvoid mergeSort(int arr[], int l, int r)\r\n{\r\n    if (l < r)\r\n    {\r\n\r\n\r\n        int m = l+(r-l)/2;\r\n        mergeSort(arr, l, m);\r\n        mergeSort(arr, m+1, r);\r\n\r\n\r\n        merge(arr, l, m, r);\r\n    }\r\n}\r\nvoid printArray(int A[], int size)\r\n{\r\n    int i;\r\n    for (i=0; i < size; i++)\r\n        cout<<A[i]<<\" \";\r\n}\r\n\r\n\r\n\r\n\r\nint main()\r\n{\r\n    int n; cin >> n;\r\n\r\n\r\n    int* arr = new int[n];\r\n\r\n\r\n    for(int i = 0; i < n; i++)\r\n        cin >> arr[i];\r\n\r\n\r\n    int arr_size = sizeof(arr)/sizeof(arr[0]);\r\n\r\n\r\n    mergeSort(arr, 0, n - 1);\r\n    printArray(arr, n);\r\n    return 0;\r\n}', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', '﻿MergeSort(arr[], l,  r)\r\nIf r > l\r\n     1. Find the middle point to divide the array into two halves:  \r\n             middle m = (l+r)/2\r\n    2. Call mergeSort for first half:   \r\n             Call mergeSort(arr, l, m)\r\n     3. Call mergeSort for second half:\r\n             Call mergeSort(arr, m+1, r)\r\n     4. Merge the two halves sorted in step 2 and 3:\r\n             Call merge(arr, l, m, r)', '2020-05-25'),
(33, 2, 5801012018, '#include<stdlib.h> \r\n#include<stdio.h> \r\n  \r\nvoid merge(int arr[], int l, int m, int r) \r\n{ \r\n    int i, j, k; \r\n    int n1 = m - l + 1; \r\n    int n2 =  r - m; \r\n  \r\n    int L[n1], R[n2]; \r\n  \r\n    for (i = 0; i < n1; i++) \r\n        L[i] = arr[l + i]; \r\n    for (j = 0; j < n2; j++) \r\n        R[j] = arr[m + 1+ j]; \r\n  \r\n    i = 0; \r\n    j = 0; \r\n    k = l; \r\n    while (i < n1 && j < n2) \r\n    { \r\n        if (L[i] <= R[j]) \r\n        { \r\n            arr[k] = L[i]; \r\n            i++; \r\n        } \r\n        else\r\n        { \r\n            arr[k] = R[j]; \r\n            j++; \r\n        } \r\n        k++; \r\n    } \r\n    while (i < n1) \r\n    { \r\n        arr[k] = L[i]; \r\n        i++; \r\n        k++; \r\n    } \r\n    while (j < n2) \r\n    { \r\n        arr[k] = R[j]; \r\n        j++; \r\n        k++; \r\n    } \r\n} \r\n  \r\nvoid mergeSort(int arr[], int l, int r) \r\n{ \r\n    if (l < r) \r\n    { \r\n        int m = l+(r-l)/2; \r\n  \r\n        mergeSort(arr, l, m); \r\n        mergeSort(arr, m+1, r); \r\n  \r\n        merge(arr, l, m, r); \r\n    } \r\n} \r\nvoid printArray(int A[], int size) \r\n{ \r\n    int i; \r\n    for (i=0; i < size; i++) \r\n        printf(\"%d \", A[i]); \r\n} \r\n  \r\nint main() \r\n{ \r\n\r\n    int n;\r\n    scanf(\"%d\",&n);  \r\n    int i, arr[n];\r\n    for(i=0;i<n;i++)\r\n        scanf(\"%d\",&arr[i]); \r\n  \r\n    mergeSort(arr, 0, n - 1); \r\n  \r\n    printArray(arr, n); \r\n    return 0; \r\n}', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', 'MergeSort(arr[], l,  r)\r\nIf r > l\r\n     1. Find the middle point to divide the array into two halves:  \r\n             middle m = (l+r)/2\r\n     2. Call mergeSort for first half:   \r\n             Call mergeSort(arr, l, m)\r\n     3. Call mergeSort for second half:\r\n             Call mergeSort(arr, m+1, r)\r\n     4. Merge the two halves sorted in step 2 and 3:\r\n             Call merge(arr, l, m, r)', '2020-05-25'),
(34, 2, 4701012018, '#include<iostream>\nusing namespace std;\nvoid merge(int input[],int l, int m, int r)\n{\n    int i,j,k;\n    int n1=m-l+1;\n    int n2=r-m;\n    int L[n1],R[n2];\n    for(i=0;i<n1;i++)\n    L[i]=input[l+i];\n    for(j=0;j<n2;j++)\n    R[j]=input[m+1+j];\n    i=0;\n    j=0;\n    k=l;\n    while(i<n1&&j<n2)\n    {\n        if(L[i]<=R[j])\n        {\n            input[k]=L[i];\n            i++;\n            k++;\n        }\n        else\n        {\n            input[k]=R[j];\n            j++;\n            k++;\n        }\n    }\n    while(i<n1)\n    {\n        input[k]=L[i];\n        i++;\n        k++;\n    }\n    while(j<n2)\n    {\n        input[k]=R[j];\n        j++;\n        k++;\n    }\n}\nvoid merge_sort(int input[],int l, int r)\n{\n    int m;\n    if(l<r)\n    {\n        m=(r+l)/2;\n        merge_sort(input,l,m);\n        merge_sort(input,m+1,r);\n        merge(input,l,m,r);\n    }\n    \n}\nvoid mergesort(int input[],int size)\n{\n    int l=0;\n    int r=size-1;\n    merge_sort(input,l,r);\n}\nint main()\n{\nint input[1000],length;\ncin>>length;\nfor(int i=0; i<length; i++)\n{\n    cin>> input[i];\n}\nmergesort(input,length);\nfor(int i=0;i<length;i++)\n{\n    cout<<input[i]<<\" \";\n}\nreturn 0;\n}', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', 'MergeSort(arr[], l,  r)\nIf r > l\n     1. Find the middle point to divide the array into two halves:  \n             middle m = (l+r)/2\n     2. Call mergeSort for first half:   \n             Call mergeSort(arr, l, m)\n     3. Call mergeSort for second half:\n             Call mergeSort(arr, m+1, r)\n     4. Merge the two halves sorted in step 2 and 3:\n             Call merge(arr, l, m, r)', '2020-05-25'),
(35, 2, 4301012018, '\r\nimport java.util.Scanner;\r\n\r\npublic class Main\r\n{\r\n    public static void main(String args[])\r\n    {\r\n        Scanner sc = new Scanner(System.in);\r\n        int n = sc.nextInt();\r\n        \r\n        int arr[] = new int[n];\r\n        for(int i = 0; i<= n-1; i++)\r\n        {\r\n            arr[i]= sc.nextInt();\r\n        }\r\n        \r\n        mergeSort(0, n-1, arr);\r\n        \r\n        for(int i = 0; i<= n-1; i++)\r\n        {\r\n            System.out.print(arr[i]+\" \");\r\n        }\r\n        \r\n    }\r\n    \r\n    public static void mergeSort(int low, int high, int[] arr)\r\n    {\r\n        if(low >= high)   \r\n        {\r\n            return;\r\n        }\r\n        \r\n        int mid = (low+high)/2;\r\n        mergeSort(low, mid, arr);\r\n        mergeSort(mid+1, high, arr);\r\n        \r\n        merge(low, mid, high, arr);\r\n        \r\n    }\r\n    \r\n    public static void merge(int s1, int e1, int e2, int[] arr)\r\n    {\r\n        int s2 = e1+1;\r\n        \r\n        int i = s1;\r\n        int j = s2;\r\n        \r\n        int[] newArr = new int[e2-s1+1];\r\n        int k = 0;\r\n        \r\n        while(i<= e1 && j<= e2)\r\n        {\r\n            if(arr[i] < arr[j])\r\n            {\r\n                newArr[k] = arr[i];\r\n                i++;\r\n                k++;\r\n            }\r\n            else\r\n            {\r\n                newArr[k] = arr[j];\r\n                j++;\r\n                k++;\r\n            }\r\n        }\r\n        \r\n        while(i <= e1)\r\n        {\r\n            newArr[k] = arr[i];\r\n            i++;\r\n            k++;\r\n        }\r\n        \r\n        while(j<= e2)\r\n        {\r\n            newArr[k] = arr[j];\r\n            j++;\r\n            k++;\r\n        }\r\n        \r\n        for(int t1 = s1, t2 = 0; t1<= e2; t1++, t2++)\r\n        {\r\n            arr[t1] = newArr[t2];\r\n        }\r\n        \r\n    }\r\n    \r\n}', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', 'Merge Sort\r\nLike QuickSort, Merge Sort is a Divide and Conquer algorithm. It divides input array in two halves, calls itself for the two halves and then merges the two sorted halves. The merge() function is used for merging two halves. The merge(arr, l, m, r) is key process that assumes that arr[l..m] and arr[m+1..r] are sorted and merges the two sorted sub-arrays into one.\r\n\r\nMergeSort(arr[], l,  r)\r\nIf r > l\r\n     1. Find the middle point to divide the array into two halves:  \r\n             middle m = (l+r)/2\r\n     2. Call mergeSort for first half:   \r\n             Call mergeSort(arr, l, m)\r\n     3. Call mergeSort for second half:\r\n             Call mergeSort(arr, m+1, r)\r\n     4. Merge the two halves sorted in step 2 and 3:\r\n             Call merge(arr, l, m, r)', '2020-05-25'),
(36, 2, 5901012018, '\r\n#include<iostream>\r\nusing namespace std;\r\n\r\n\r\nvoid merge(int arr[], int sPos, int ePos)\r\n{\r\n    \r\n    int temp[1000];\r\n    int mid= (sPos+ePos)/2;\r\n    for(int i=mid+1;i<=ePos;i++)\r\n    {\r\n        temp[i]= arr[i];\r\n    }\r\n     \r\n     int i= mid, j=ePos, k=ePos;\r\n     while(i>=sPos&&j>mid)\r\n     {\r\n         if(arr[i]>temp[j])\r\n         {\r\n             arr[k--]= arr[i--];\r\n         }\r\n         else\r\n         {\r\n             arr[k--]= temp[j--];\r\n         }\r\n     }\r\n     while(j>mid)\r\n     {\r\n         arr[k--]= temp[j--];\r\n     }\r\n    \r\n}\r\n\r\nvoid mergeSort(int arr[], int sPos, int ePos)\r\n{\r\n    if(sPos>=ePos) return;\r\n    int mPos= (sPos+ePos)/2;\r\n    \r\n    mergeSort(arr, sPos, mPos);\r\n    mergeSort(arr, mPos+1, ePos);\r\n    merge(arr, sPos, ePos);\r\n    \r\n}\r\n\r\n\r\nint main()\r\n{\r\n    \r\n    int n; cin>>n;\r\n    int arr[n];\r\n    \r\n    for(int i=0;i<n;i++) cin>>arr[i];\r\n      \r\n      \r\n      mergeSort(arr,0,n-1);\r\n      \r\n      for(int i=0;i<n;i++) cout<<arr[i]<<\" \";\r\n    \r\n}\r\n                                            \r\n', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '', '', '0000-00-00'),
(37, 2, 5301012018, '#include<stdlib.h> \r\n#include<stdio.h> \r\n  \r\nvoid merge(int arr[], int l, int m, int r) \r\n{ \r\n    int i, j, k; \r\n    int n1 = m - l + 1; \r\n    int n2 =  r - m; \r\n  \r\n    int L[n1], R[n2]; \r\n  \r\n    for (i = 0; i < n1; i++) \r\n        L[i] = arr[l + i]; \r\n    for (j = 0; j < n2; j++) \r\n        R[j] = arr[m + 1+ j]; \r\n  \r\n    i = 0; \r\n    j = 0; \r\n    k = l; \r\n    while (i < n1 && j < n2) \r\n    { \r\n        if (L[i] <= R[j]) \r\n        { \r\n            arr[k] = L[i]; \r\n            i++; \r\n        } \r\n        else\r\n        { \r\n            arr[k] = R[j]; \r\n            j++; \r\n        } \r\n        k++; \r\n    } \r\n    while (i < n1) \r\n    { \r\n        arr[k] = L[i]; \r\n        i++; \r\n        k++; \r\n    } \r\n    while (j < n2) \r\n    { \r\n        arr[k] = R[j]; \r\n        j++; \r\n        k++; \r\n    } \r\n} \r\n  \r\nvoid mergeSort(int arr[], int l, int r) \r\n{ \r\n    if (l < r) \r\n    { \r\n        int m = l+(r-l)/2; \r\n  \r\n        mergeSort(arr, l, m); \r\n        mergeSort(arr, m+1, r); \r\n  \r\n        merge(arr, l, m, r); \r\n    } \r\n} \r\nvoid printArray(int A[], int size) \r\n{ \r\n    int i; \r\n    for (i=0; i < size; i++) \r\n        printf(\"%d \", A[i]); \r\n} \r\n  \r\nint main() \r\n{ \r\n\r\n    int n;\r\n    scanf(\"%d\",&n);  \r\n    int i, arr[n];\r\n    for(i=0;i<n;i++)\r\n        scanf(\"%d\",&arr[i]); \r\n  \r\n    mergeSort(arr, 0, n - 1); \r\n  \r\n    printArray(arr, n); \r\n    return 0; \r\n}', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', 'MergeSort(arr[], l,  r)\r\nIf r > l\r\n     1. Find the middle point to divide the array into two halves:  \r\n             middle m = (l+r)/2\r\n     2. Call mergeSort for first half:   \r\n             Call mergeSort(arr, l, m)\r\n     3. Call mergeSort for second half:\r\n             Call mergeSort(arr, m+1, r)\r\n     4. Merge the two halves sorted in step 2 and 3:\r\n             Call merge(arr, l, m, r)', '2020-05-25');
INSERT INTO `qtos_map` (`ID`, `Q_ID`, `ROLL`, `SUBMISSION`, `SCORE`, `INPUT`, `OP`, `ALGO`, `DATE`) VALUES
(38, 3, 6801012018, '#include <bits/stdc++.h> \r\nusing namespace std;  \r\n   \r\nvoid swap(int* a, int* b)  \r\n{  \r\n    int t = *a;  \r\n    *a = *b;  \r\n    *b = t;  \r\n}  \r\n  \r\nint partition (int arr[], int low, int high)  \r\n{  \r\n    int pivot = arr[high];  \r\n    int i = (low - 1); \r\n  \r\n    for (int j = low; j <= high - 1; j++)  \r\n    {   \r\n        if (arr[j] < pivot)  \r\n        {  \r\n            i++; \r\n            swap(&arr[i], &arr[j]);  \r\n        }  \r\n    }  \r\n    swap(&arr[i + 1], &arr[high]);  \r\n    return (i + 1);  \r\n}  \r\n  \r\nvoid quickSort(int arr[], int low, int high)  \r\n{  \r\n    if (low < high)  \r\n    {  \r\n        int pi = partition(arr, low, high);   \r\n        quickSort(arr, low, pi - 1);  \r\n        quickSort(arr, pi + 1, high);  \r\n    }  \r\n}  \r\n  \r\nvoid printArray(int arr[], int size)  \r\n{  \r\n    int i;  \r\n    for (i = 0; i < size; i++)  \r\n        cout << arr[i] << \" \";  \r\n    cout << endl;  \r\n}  \r\n  \r\nint main()  \r\n{  \r\nint t;\r\ncin>>t;\r\nwhile(t!=0){\r\nint n;\r\ncin>>n;\r\n    int arr[n] ;  \r\n   for(int i=0;i<n;i++){\r\ncin>>arr[i];\r\n}\r\n    quickSort(arr, 0, n - 1);   \r\n    printArray(arr, n);  \r\nt--;\r\n}\r\n    return 0;  \r\n} ', 0, '1 2000', '-2147483648 -1819111024 -1685415528 -1618043508 -1612784164 -1578269562 -1578269562 -1578268198 -1578250957 -1549622880 -1482250844 -1414878808 -1347506772 -1280134736 -1258291019 -1212762700 -1145390664 -1078018628 -1010646592 -1010646592 -943274556 -943274556 -875902520 -875902520 -808530484 -808530484 -741158448 -741158448 -733213061 -691966062 -673786412 -672315470 -606414376 -606414376 -539042340 -404298268 -336926232 -285211923 -285211923 -201325834 -201325834 -201325834 -201325834 -136915500 -100662789 -100662789 -2 -2 -2 -2 -2 -2 -2 -2 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 2 2 2 2 3 3 3 3 3 3 3 4 4 5 5 5 5 5 5 5 5 5 8 8 8 8 8 8 10 10 14 16 16 17 20 24 24 24 28 28 28 28 28 28 32 32 36 36 40 40 44 49 50 50 63 64 115 116 116 127 127 127 127 127 127 128 191 224 244 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 257 257 319 348 372 502 502 512 512 512 512 512 512 532 744 744 1024 1024 1252 1252 1528 1703 2000 2047 2048 2048 2048 2056 4096 4096 5160 5160 5160 5160 8016 12600 15352 52428 52428 65568 65568 131097 196608 196608 196608 196608 196608 196608 196608 196608 196608 196608 196608 196608 196608 196608 196608 196608 196608 196610 196610 196804 196920 196920 196944 196944 196944 196944 196944 196944 196944 196944 196944 196944 196944 196944 196944 196944 197020 198608 200312 200312 200600 200600 200600 200600 200600 200624 200624 200624 200624 200632 200632 200644 200832 200832 200832 200832 200832 200832 200832 200884 200884 201560 201560 201600 201616 201760 201788 204024 208864 208872 208872 208872 225040 225040 225096 225100 242728 242728 242736 242736 242736 242736 242952 242952 242955 242960 242960 243184 243184 245728 327684 327684 458758 458758 491520 589832 589832 720906 720906 770624 770624 770624 770656 851980 851980 983054 983054 983054 983054 1114128 1114128 1245202 1245202 1376276 1376276 1507350 1507350 1638424 1638424 1769498 1769498 1900572 1900572 2031646 2031646 2162720 2162720 2293794 2293794 2424868 2424868 2555942 2555942 2681284 2681316 2681324 2681364 2681364 2682024 2682076 2682100 2682308 2682308 2682340 2682388 2682412 2682420 2682420 2682464 2682464 2682488 2682544 2682588 2682604 2682636 2682692 2682728 2682768 2682776 2682776 2682776 2682776 2682776 2682776 2683040 2683052 2683052 2683072 2683072 2683080 2683104 2683164 2683164 2683288 2683304 2683304 2683304 2683784 2683816 2683892 2683892 2683936 2684540 2684540 2684540 2684540 2684673 2684676 2684692 2684696 2684796 2684856 2684908 2685052 2685052 2685116 2685116 2685244 2685296 2685312 2685348 2685352 2685416 2685428 2685492 2685508 2685532 2685556 2685556 2685580 2685668 2685716 2685804 2685896 2685964 2685968 2685996 2686052 2686056 2686148 2686188 2686196 2686240 2686266 2686280 2686296 2686336 2686412 2686475 2686488 2686544 2686588 2686588 2686588 2686588 2686588 2686616 2686647 2686647 2686648 2686648 2686648 2686648 2686648 2686652 2686652 2686652 2686652 2686652 2686652 2686656 2686656 2686680 2686680 2686688 2686916 2687016 2687016 2818090 2818090 2949164 2949164 3080238 3080238 3145774 3145776 3145776 3145777 3145782 3211312 3211312 3211312 3211312 3342386 3342386 3473460 3473460 3538992 3604534 3604534 3735608 3735608 3866682 3866682 3932218 3997756 3997756 4128830 4128830 4204160 4259904 4259904 4259936 4357448 4357448 4357448 4390978 4390978 4390978 4391004 4391004 4409280 4409280 4420378 4420378 4420378 4429840 4522052 4522052 4522052 4548674 4653126 4653126 4653126 4699174 4699230 4784200 4784200 4784200 4915274 4915274 4915274 4940344 5006368 5006368 5006368 5006368 5006368 5007456 5007616 5007616 5007616 5007624 5007624 5007624 5007624 5007624 5007624 5007624 5007624 5007624 5007624 5007624 5008896 5011372 5011372 5046348 5046348 5046348 5111900 5177422 5177422 5177422 5232688 5232696 5232696 5232696 5232696 5238760 5308496 5308496 5308496 5374044 5439570 5439570 5439570 5439580 5439596 5570644 5570644 5570644 5636188 5701718 5701718 5701718 5832792 5832792 5832792 5963866 5963866 6029413 6029433 6094940 6094940 6226014 6226014 6357069 6357088 6488162 6619236 6619250 6750309 6750310 6750318 6815843 6881384 6881395 6881396 7012458 7077999 7143525 7143532 7209065 7209071 7209071 7274563 7274606 7274610 7405680 7471205 7471215 7471220 7471220 7471221 7536745 7536748 7536754 7602277 7602286 7602286 7602291 7667828 7798902 7929939 7929976 8061018 8061050 8192124 8192124 8323198 8323198 8388608 8388608 8388608 8388608 8388608 8388608 8388608 8388608 8388608 8388608 8388608 8388608 8388608 8388608 8388608 8388608 8388608 8388608 8388608 8388608 8388608 8388804 8388804 8388804 8388804 8388804 8388804 8388804 8388864 8388944 8388944 8388944 8388944 8388944 8388944 8388944 8388944 8388944 8388980 8389036 8389036 8389036 8400680 8400680 8400680 8400864 8400864 8400872 8400904 8400904 8400904 8400906 8400907 8400912 8400912 8400912 8403064 8403064 8403064 8403066 8403067 8403072 8403072 8403072 8404960 8404960 8404968 8404968 8404968 8405352 8406104 8406104 8406104 8406168 8409056 8462508 8462508 8542888 8548320 8548328 8553072 8553536 8553536 8553544 8556512 8556512 8556520 8556520 8556520 9240914 9240914 9372029 9372029 9437326 10289490 10289491 10551456 10551456 10682530 10682530 10813604 10813604 10944678 10944678 11075752 11075752 11206826 11206826 11337900 11337900 11468974 11468974 11600048 11600048 11731122 11731122 11862196 11862196 11993270 11993270 12124344 12124344 12255418 12255418 12386492 12386492 12517566 12517566 12648640 12648640 12648640 12779714 12779714 12779714 12910788 12910788 12910788 13041862 13041862 13041862 13172936 13172936 13172936 13304010 13304010 13304010 13435084 13435084 13435084 13566158 13566158 13566158 13697232 13697232 13697232 13828306 13828306 13828306 13959380 13959380 13959380 14090454 14090454 14221528 14221528 14221528 14352602 14352602 14352602 14483676 14483676 14483676 14614750 14614750 14745824 14876898 15007972 15139046 15270120 15401194 15532268 15663342 15794416 15925490 16056564 16187606 16187638 16318712 16449786 16580860 16711934 16777218 16777236 16841988 16843510 16892630 16977528 17015874 24641758 24641917 24641918 26288154 26353690 33554944 34603520 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603552 34603592 34603592 34603777 34603777 34603777 34603778 34603778 34603778 34603794 34603794 34865680 34865684 35652096 35652112 35652128 35652128 35652128 35652128 35652128 35652128 35652128 35652128 35652128 35652128 35652128 35652128 35652168 35652353 35652353 35652354 36176424 36176424 36700688 40370720 42205828 42205828 42205828 42205828 42205828 50397186 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397954 50398081 50463008 50463008 50463248 50463489 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463618 51511824 58786320 58786689 58786689 58851856 58852226 58852226 117835012 185207048 214748364 252579084 268435456 319951120 335544340 335544340 335544340 387323156 419430425 419430425 454695192 486604828 522067228 538189843 538189843 538443920 538443920 538714137 538714137 539041824 539041824 539107357 539107357 539369502 539369502 540017350 540017350 540606816 540606816 540672352 540672353 555877084 555877084 589439264 656811300 724183336 791555372 858927408 926299444 993671480 1040187711 1040187711 1061043516 1128415552 1195787588 1263159624 1330531660 1397903696 1465275732 1971917128 1971928876 1971928876 1971938759 1972764928 1972764960 1972764960 1972764960 1982162552 1982189847 1982190659 1982323158 1982331814 1982344999 1982345122 1982352408 1982353328 1982353351 1982353775 1982353775 1982353775 1982353775 1982355716 1982355716 1982357216 1996747986 1996755342 1996756642 1996756704 1996757057 1996757148 1996757199 1996757210 1996757210 1996758339 1996758387 1996800947 1996852437 1997182497 1997341952 1997341952 1997350624 1997351168 1997351888 1997355784 1997357184 1997357184 2005532672 2005614976 2005662250 2005662378 2005662378 2005676794 2005740647 2005740647 2005742706 2005743738 2005743738 2005743738 2005743774 2005743774 2005744682 2005744756 2005744756 2005744756 2005744756 2005744756 2005744803 2005744803 2005744803 2005744803 2005744803 2005744803 2005744803 2005744803 2005744803 2005744803 2005744846 2005744846 2005744846 2005744846 2005775221 2005775221 2005775221 2005775346 2005775346 2005775346 2005938246 2005938281 2005999309 2005999309 2005999309 2005999309 2005999309 2005999309 2008016836 2008016868 2008019028 2008019252 2008019276 2008019612 2008019668 2008020548 2008020684 2130379298 2147483626 2147483647 2147483647 \n', 'partition algo\r\n/* low  --> Starting index,  high  --> Ending index */\r\nquickSort(arr[], low, high)\r\n{\r\n    if (low < high)\r\n    {\r\n        /* pi is partitioning index, arr[pi] is now\r\n           at right place */\r\n        pi = partition(arr, low, high);\r\n\r\n        quickSort(arr, low, pi - 1);  // Before pi\r\n        quickSort(arr, pi + 1, high); // After pi\r\n    }\r\n}', '2020-05-25'),
(39, 2, 7401012018, '#include <stdio.h>\r\n\r\n#define max 10\r\n\r\nint a[11] = { 10, 14, 19, 26, 27, 31, 33, 35, 42, 44, 0 };\r\nint b[10];\r\n\r\nvoid merging(int low, int mid, int high) {\r\n   int l1, l2, i;\r\n\r\n   for(l1 = low, l2 = mid + 1, i = low; l1 <= mid && l2 <= high; i++) {\r\n      if(a[l1] <= a[l2])\r\n         b[i] = a[l1++];\r\n      else\r\n         b[i] = a[l2++];\r\n   }\r\n   \r\n   while(l1 <= mid)    \r\n      b[i++] = a[l1++];\r\n\r\n   while(l2 <= high)   \r\n      b[i++] = a[l2++];\r\n\r\n   for(i = low; i <= high; i++)\r\n      a[i] = b[i];\r\n}\r\n\r\nvoid sort(int low, int high) {\r\n   int mid;\r\n   \r\n   if(low < high) {\r\n      mid = (low + high) / 2;\r\n      sort(low, mid);\r\n      sort(mid+1, high);\r\n      merging(low, mid, high);\r\n   } else { \r\n      return;\r\n   }   \r\n}\r\n\r\nint main() { \r\n   int i;\r\n\r\n   printf(\"List before sorting\n\");\r\n   \r\n   for(i = 0; i <= max; i++)\r\n      printf(\"%d \", a[i]);\r\n\r\n   sort(0, max);\r\n\r\n   printf(\"\nList after sorting\n\");\r\n   \r\n   for(i = 0; i <= max; i++)\r\n      printf(\"%d \", a[i]);\r\n}', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', 'List before sorting\n10 14 19 26 27 31 33 35 42 44 0 \nList after sorting\n0 10 14 19 26 27 31 33 35 42 44 ', 'MergeSort(arr[], l,  r)\r\nIf r > l\r\n     1. Find the middle point to divide the array into two halves:  \r\n             middle m = (l+r)/2\r\n     2. Call mergeSort for first half:   \r\n             Call mergeSort(arr, l, m)\r\n     3. Call mergeSort for second half:\r\n             Call mergeSort(arr, m+1, r)\r\n     4. Merge the two halves sorted in step 2 and 3:\r\n             Call merge(arr, l, m, r)', '2020-05-25'),
(40, 3, 3901012018, 'import java.util.*;\r\npublic class Main {\r\n\r\n	public static void main(String[] args) {\r\n		// TODO Auto-generated method stub\r\n\r\n	Scanner scn = new Scanner(System.in);\r\n	int n = scn.nextInt();\r\n	for(int i = 0; i<n ;i++)\r\n	arr[i] = scn.nextInt();\r\n		QUICKSORT(arr, 0, arr.length - 1);\r\n\r\n		for (int val : arr) {\r\n			System.out.print(val+\" \");\r\n		}\r\n\r\n	}\r\n\r\n	public static void QUICKSORT(int[] arr, int lo, int hi) {\r\n		// base case\r\n		if (lo >= hi)\r\n			return;\r\n\r\n		int mid = (lo + hi) / 2;\r\n		int pivot = arr[mid];\r\n		int left = lo;\r\n		int right = hi;\r\n		while (left <= right) {\r\n			while (arr[left] < pivot) {\r\n				left++;\r\n			}\r\n			while (arr[right] > pivot) {\r\n				right--;\r\n			}\r\n			if (left <= right) {\r\n				int temp = arr[left];\r\n				arr[left] = arr[right];\r\n				arr[right] = temp;\r\n				left++;\r\n				right--;\r\n			}\r\n\r\n			QUICKSORT(arr, lo, right);\r\n			QUICKSORT(arr, left, hi);\r\n		}\r\n	}\r\n}\r\n', 0, '', '', '', '0000-00-00'),
(41, 2, 6601012018, '#include<iostream>\r\n#include<vector>\r\nusing namespace std;\r\nvector<int> merge(vector<int> &a,vector<int> &b)\r\n{\r\n    int m=a.size();\r\n    int n=b.size();\r\n    vector<int> c(m+n,0);\r\n    int i=0;\r\n    int j=0;\r\n    int k=0;\r\n    while(i<a.size() && j<b.size())\r\n    {\r\n        if (a[i]<b[j])\r\n        {\r\n            c[k]=a[i];\r\n            i++;\r\n            k++;\r\n        }\r\n        else\r\n        {\r\n            c[k]=b[j];\r\n            j++;\r\n            k++;\r\n        }\r\n    }\r\n    while (i<a.size())\r\n    {\r\n        c[k]=a[i];\r\n        i++;\r\n        k++;\r\n    }\r\n    while (j<b.size())\r\n    {\r\n        c[k]=b[j];\r\n        j++;\r\n        k++;\r\n    }\r\n    return c;\r\n}\r\nvector<int> mergesort(int s,int l, int a[])\r\n{\r\n    if(s==l)\r\n    {\r\n        vector<int> v;\r\n        v.push_back(a[l]);\r\n        return v;\r\n    }\r\n    int mid=(s+l)/2;\r\n    vector<int> x=mergesort(s,mid,a);\r\n    vector<int> y=mergesort(mid+1,l,a);\r\n    return merge(x,y);\r\n}\r\nint main()\r\n{\r\n    int n;\r\n    cin>>n;\r\n    int arr[n];\r\n    for(int i=0;i<n;i++)\r\n    {\r\n        cin>>arr[i];\r\n    }\r\n    vector<int> m= mergesort(0,n-1,arr);\r\n    for (int i=0;i<m.size();i++)\r\n    {\r\n        cout<<m[i] <<\" \";\r\n    }\r\n    return 0;\r\n}', 8, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', 'MergeSort(arr[], l,  r)\r\nIf r > l\r\n     1. Find the middle point to divide the array into two halves:  \r\n             middle m = (l+r)/2\r\n     2. Call mergeSort for first half:   \r\n             Call mergeSort(arr, l, m)\r\n     3. Call mergeSort for second half:\r\n             Call mergeSort(arr, m+1, r)\r\n     4. Merge the two halves sorted in step 2 and 3:\r\n             Call merge(arr, l, m, r)', '2020-05-25'),
(42, 2, 6101012018, '#include <bits/stdc++.h>\r\nusing namespace std;\r\nvoid merge(int arr[], int l, int m, int r) \r\n{ \r\n    int i, j, k; \r\n    int n1 = m - l + 1; \r\n    int n2 =  r - m; \r\n    int L[n1], R[n2]; \r\n    for (i = 0; i < n1; i++) \r\n        L[i] = arr[l + i]; \r\n    for (j = 0; j < n2; j++) \r\n        R[j] = arr[m + 1+ j]; \r\n    i = 0; \r\n    j = 0; \r\n    k = l;\r\n    while (i < n1 && j < n2) \r\n    { \r\n        if (L[i] <= R[j]) \r\n        { \r\n            arr[k] = L[i]; \r\n            i++; \r\n        } \r\n        else\r\n        { \r\n            arr[k] = R[j]; \r\n            j++; \r\n        } \r\n        k++; \r\n    } \r\n    while (i < n1) \r\n    { \r\n        arr[k] = L[i]; \r\n        i++; \r\n        k++; \r\n    } \r\n    while (j < n2) \r\n    { \r\n        arr[k] = R[j]; \r\n        j++; \r\n        k++; \r\n    } \r\n} \r\nvoid mergeSort(int arr[], int l, int r) \r\n{ \r\n    if (l < r) \r\n    {\r\n        int m = l+(r-l)/2;\r\n        mergeSort(arr, l, m); \r\n        mergeSort(arr, m+1, r); \r\n        merge(arr, l, m, r); \r\n    } \r\n} \r\nint main()\r\n{\r\n    int n;\r\n    cin>>n;\r\n    int arr[n];\r\n    for(int i=0;i<n;i++)\r\n    cin>>arr[i];\r\n    mergeSort(arr,0,n-1);\r\n    for(int i=0;i<n;i++)\r\n    cout<<arr[i]<<\" \";\r\n}', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', 'Step 1 - if it is only one element in the list it is already sorted, return.\r\nStep 2 - divide the list recursively into two halves until it can no more be divided.\r\nStep 3 - merge the smaller lists into new list in sorted order.\r\n\r\n\r\nHave we reached the end of any of the arrays?\r\n    No:\r\n        Compare current elements of both arrays \r\n        Copy smaller element into sorted array\r\n        Move pointer of element containing smaller element\r\n    Yes:\r\n        Copy all remaining elements of non-empty array\r\n\r\nMergeSort(A, p, r):\r\n    if p > r \r\n        return\r\n    q = (p+r)/2\r\n    mergeSort(A, p, q)\r\n    mergeSort(A, q+1, r)\r\n    merge(A, p, q, r)\r\n', '2020-05-25'),
(43, 2, 4401012018, '#include<stdlib.h> \r\n#include<stdio.h> \r\n  \r\nvoid merge(int arr[], int l, int m, int r) \r\n{ \r\n    int i, j, k; \r\n    int n1 = m - l + 1; \r\n    int n2 =  r - m; \r\n  \r\n    \r\n    int L[n1], R[n2]; \r\n  \r\n    \r\n    for (i = 0; i < n1; i++) \r\n        L[i] = arr[l + i]; \r\n    for (j = 0; j < n2; j++) \r\n        R[j] = arr[m + 1+ j]; \r\n    i = 0; \r\n    j = 0; \r\n    k = l; \r\n    while (i < n1 && j < n2) \r\n    { \r\n        if (L[i] <= R[j]) \r\n        { \r\n            arr[k] = L[i]; \r\n            i++; \r\n        } \r\n        else\r\n        { \r\n            arr[k] = R[j]; \r\n            j++; \r\n        } \r\n        k++; \r\n    } \r\n\r\n    while (i < n1) \r\n    { \r\n        arr[k] = L[i]; \r\n        i++; \r\n        k++; \r\n    } \r\n  \r\n   \r\n    while (j < n2) \r\n    { \r\n        arr[k] = R[j]; \r\n        j++; \r\n        k++; \r\n    } \r\n} \r\n  \r\nvoid mergeSort(int arr[], int l, int r) \r\n{ \r\n    if (l < r) \r\n    { \r\n        // Same as (l+r)/2, but avoids overflow for \r\n        // large l and h \r\n        int m = l+(r-l)/2; \r\n  \r\n        // Sort first and second halves \r\n        mergeSort(arr, l, m); \r\n        mergeSort(arr, m+1, r); \r\n  \r\n        merge(arr, l, m, r); \r\n    } \r\n} \r\nvoid printArray(int A[], int size) \r\n{ \r\n    int i; \r\n    for (i=0; i < size; i++) \r\n        printf(\"%d \", A[i]); \r\n    printf(\"\n\"); \r\n} \r\n  \r\nint main() \r\n{ \r\n  \r\nint t;\r\ncin>>t;\r\nwhile(t!=0){\r\nint n;\r\ncin>>n;\r\nint a[n];\r\nfor(int i=0;i<n;i++){\r\ncin>>a[i];\r\n}\r\n    printf(\"Given array is \n\"); \r\n    printArray(arr, arr_size); \r\n  \r\n    mergeSort(a, 0, n - 1); \r\n  \r\n    printf(\"\nSorted array is \n\"); \r\n    printArray(a, n); \r\n    return 0; \r\n\r\nt--;\r\ncout<<endl;\r\n}\r\n} ', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '', 'MergeSort(arr[], l,  r)\r\nIf r > l\r\n     1. Find the middle point to divide the array into two halves:  \r\n             middle m = (l+r)/2\r\n     2. Call mergeSort for first half:   \r\n             Call mergeSort(arr, l, m)\r\n     3. Call mergeSort for second half:\r\n             Call mergeSort(arr, m+1, r)\r\n     4. Merge the two halves sorted in step 2 and 3:\r\n             Call merge(arr, l, m, r)', '2020-05-25'),
(44, 3, 7201012018, '#include<iostream>\r\nusing namespace std;\r\n\r\nvoid swap(int* a, int* b)  \r\n{  \r\n    int t = *a;  \r\n    *a = *b;  \r\n    *b = t;  \r\n} \r\n\r\nint partition (int arr[], int low, int high)  \r\n{  \r\n    int pivot = arr[high];   \r\n    int i = (low - 1); \r\n  \r\n    for (int j = low; j <= high - 1; j++)  \r\n    {  \r\n        if (arr[j] < pivot)  \r\n        {  \r\n            i++; \r\n            swap(&arr[i], &arr[j]);  \r\n        }  \r\n    }  \r\n    swap(&arr[i + 1], &arr[high]);  \r\n    return (i + 1);  \r\n}  \r\n\r\n\r\nvoid quickSort(int arr[], int low, int high)  \r\n{  \r\n    if (low < high)  \r\n    {  \r\n        int pi = partition(arr, low, high);  \r\n        quickSort(arr, low, pi - 1);  \r\n        quickSort(arr, pi + 1, high);  \r\n    }  \r\n}  \r\n  \r\n int main()  \r\n{  \r\n   int n,i;\r\n   cin>>n;\r\n    int arr[n];  \r\n    for(i=0;i<n;i++)\r\n    cin>>arr[i];\r\n    quickSort(arr, 0, n - 1);  \r\n    for(i=0;i<n;i++)\r\n    cout<<arr[i]<<\" \";\r\n    return 0;  \r\n} \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', 0, '', '', '', '0000-00-00'),
(45, 2, 7501012018, '#include<iostream>\r\n#include<vector>\r\nusing namespace std;\r\nvector<int> merge(vector<int> &a,vector<int> &b)\r\n{\r\n    int m=a.size();\r\n    int n=b.size();\r\n    vector<int> c(m+n,0);\r\n    int i=0;\r\n    int j=0;\r\n    int k=0;\r\n    while(i<a.size() && j<b.size())\r\n    {\r\n        if (a[i]<b[j])\r\n        {\r\n            c[k]=a[i];\r\n            i++;\r\n            k++;\r\n        }\r\n        else\r\n        {\r\n            c[k]=b[j];\r\n            j++;\r\n            k++;\r\n        }\r\n    }\r\n    while (i<a.size())\r\n    {\r\n        c[k]=a[i];\r\n        i++;\r\n        k++;\r\n    }\r\n    while (j<b.size())\r\n    {\r\n        c[k]=b[j];\r\n        j++;\r\n        k++;\r\n    }\r\n    return c;\r\n}\r\nvector<int> mergesort(int s,int l, int a[])\r\n{\r\n    if(s==l)\r\n    {\r\n        vector<int> v;\r\n        v.push_back(a[l]);\r\n        return v;\r\n    }\r\n    int mid=(s+l)/2;\r\n    vector<int> x=mergesort(s,mid,a);\r\n    vector<int> y=mergesort(mid+1,l,a);\r\n    return merge(x,y);\r\n}\r\nint main()\r\n{\r\n    int n;\r\n    cin>>n;\r\n    int arr[n];\r\n    for(int i=0;i<n;i++)\r\n    {\r\n        cin>>arr[i];\r\n    }\r\n    vector<int> m= mergesort(0,n-1,arr);\r\n    for (int i=0;i<m.size();i++)\r\n    {\r\n        cout<<m[i] <<\" \";\r\n    }\r\n    return 0;\r\n}', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', 'MergeSort(arr[], l,  r)\r\nIf r > l\r\n     1. Find the middle point to divide the array into two halves:  \r\n             middle m = (l+r)/2\r\n     2. Call mergeSort for first half:   \r\n             Call mergeSort(arr, l, m)\r\n     3. Call mergeSort for second half:\r\n             Call mergeSort(arr, m+1, r)\r\n     4. Merge the two halves sorted in step 2 and 3:\r\n             Call merge(arr, l, m, r)', '2020-05-25'),
(46, 2, 4001012018, '#include<stdlib.h> \r\n#include<stdio.h> \r\n  \r\nvoid merge(int arr[], int l, int m, int r) \r\n{ \r\n    int i, j, k; \r\n    int n1 = m - l + 1; \r\n    int n2 =  r - m; \r\n  \r\n    \r\n    int L[n1], R[n2]; \r\n  \r\n    \r\n    for (i = 0; i < n1; i++) \r\n        L[i] = arr[l + i]; \r\n    for (j = 0; j < n2; j++) \r\n        R[j] = arr[m + 1+ j]; \r\n    i = 0; \r\n    j = 0; \r\n    k = l; \r\n    while (i < n1 && j < n2) \r\n    { \r\n        if (L[i] <= R[j]) \r\n        { \r\n            arr[k] = L[i]; \r\n            i++; \r\n        } \r\n        else\r\n        { \r\n            arr[k] = R[j]; \r\n            j++; \r\n        } \r\n        k++; \r\n    } \r\n\r\n    while (i < n1) \r\n    { \r\n        arr[k] = L[i]; \r\n        i++; \r\n        k++; \r\n    } \r\n  \r\n   \r\n    while (j < n2) \r\n    { \r\n        arr[k] = R[j]; \r\n        j++; \r\n        k++; \r\n    } \r\n} \r\n  \r\nvoid mergeSort(int arr[], int l, int r) \r\n{ \r\n    if (l < r) \r\n    { \r\n        // Same as (l+r)/2, but avoids overflow for \r\n        // large l and h \r\n        int m = l+(r-l)/2; \r\n  \r\n        // Sort first and second halves \r\n        mergeSort(arr, l, m); \r\n        mergeSort(arr, m+1, r); \r\n  \r\n        merge(arr, l, m, r); \r\n    } \r\n} \r\nvoid printArray(int A[], int size) \r\n{ \r\n    int i; \r\n    for (i=0; i < size; i++) \r\n        printf(\"%d \", A[i]); \r\n    printf(\"\n\"); \r\n} \r\n  \r\nint main() \r\n{ \r\n  \r\nint t;\r\ncin>>t;\r\nwhile(t!=0){\r\nint n;\r\ncin>>n;\r\nint a[n];\r\nfor(int i=0;i<n;i++){\r\ncin>>a[i];\r\n}\r\n    printf(\"Given array is \n\"); \r\n    printArray(arr, arr_size); \r\n  \r\n    mergeSort(a, 0, n - 1); \r\n  \r\n    printf(\"\nSorted array is \n\"); \r\n    printArray(a, n); \r\n    return 0; \r\n\r\nt--;\r\ncout<<endl;\r\n}\r\n} ', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '', 'MergeSort(arr[], l,  r)\r\nIf r > l\r\n     1. Find the middle point to divide the array into two halves:  \r\n             middle m = (l+r)/2\r\n     2. Call mergeSort for first half:   \r\n             Call mergeSort(arr, l, m)\r\n     3. Call mergeSort for second half:\r\n             Call mergeSort(arr, m+1, r)\r\n     4. Merge the two halves sorted in step 2 and 3:\r\n             Call merge(arr, l, m, r)', '2020-05-25'),
(47, 3, 5101012018, '#include<iostream>\r\nusing namespace std;\r\n#include <iostream>\r\nusing namespace std;\r\nvoid swap(int *a, int *b)\r\n{\r\n  int t = *a;\r\n  *a = *b;\r\n  *b = t;\r\n}\r\n\r\nint partition(int array[], int low, int high)\r\n{\r\n  int pivot = array[high];\r\n  int i = (low - 1);\r\n  for (int j = low; j < high; j++)\r\n  {\r\n    if (array[j] <= pivot)\r\n    {\r\n      i++;\r\n      swap(&array[i], &array[j]);\r\n    }\r\n  }\r\n\r\n\r\n  swap(&array[i + 1], &array[high]);\r\n  return (i + 1);\r\n}\r\nvoid qs(int array[], int low, int high)\r\n{\r\n  if (low < high)\r\n  {\r\n    int pi = partition(array, low, high);\r\n    qs(array, low, pi - 1);\r\n    qs(array, pi + 1, high);\r\n  }\r\n}\r\n\r\n\r\nint main(){\r\nint n;\r\ncin>>n;\r\nint arr[n];\r\nfor(int i=0;i<n;i++){\r\n    cin>>arr[i];\r\n}\r\nqs(arr,0,n-1);\r\nfor(int i=0;i<n;i++){\r\n    cout<<arr[i];\r\n    if(i!=n-1)\r\n    cout<<\" \";\r\n}\r\nreturn 0;\r\n}\r\n', 0, '1 2000', '2000', 'quickSort(arr[], low, high)\r\n{\r\n	if (low < high)\r\n	{\r\n    	\r\n    	pi = partition(arr, low, high);\r\n \r\n    	quickSort(arr, low, pi - 1);  // Before pi\r\n    	quickSort(arr, pi + 1, high); // After pi\r\n	}\r\n}\r\nPseudo code for partition()\r\n \r\npartition (arr[], low, high)\r\n{\r\n    	pivot = arr[high]; \r\n \r\n	i = (low ? 1)\r\n	for (j = low; j <= high- 1; j++)\r\n	{\r\n            	if (arr[j] < pivot)\r\n    	{\r\n        	i++;	\r\n        	swap arr[i] and arr[j]\r\n    	}\r\n	}\r\n	swap arr[i + 1] and arr[high])\r\n	return (i + 1)\r\n}\r\n', '2020-05-25'),
(48, 3, 4501012018, '#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nvoid quick_sort(int[],int,int);\r\nint partition(int[],int,int);\r\n\r\nint main()\r\n{\r\n    int a[50],n,i;\r\n    cin>>n;\r\n    for(i=0;i<n;i++)\r\n        cin>>a[i];\r\n\r\n    quick_sort(a,0,n-1);\r\n    for(i=0;i<n;i++)\r\n        cout<<a[i]<<\" \";\r\n\r\n    return 0;\r\n}\r\n\r\nvoid quick_sort(int a[],int l,int u)\r\n{\r\n    int j;\r\n    if(l<u)\r\n    {\r\n        j=partition(a,l,u);\r\n        quick_sort(a,l,j-1);\r\n        quick_sort(a,j+1,u);\r\n    }\r\n}\r\n\r\nint partition(int a[],int l,int u)\r\n{\r\n    int v,i,j,temp;\r\n    v=a[l];\r\n    i=l;\r\n    j=u+1;\r\n\r\n    do\r\n    {\r\n        do\r\n            i++;\r\n\r\n        while(a[i]<v&&i<=u);\r\n\r\n        do\r\n            j--;\r\n        while(v<a[j]);\r\n\r\n        if(i<j)\r\n        {\r\n            temp=a[i];\r\n            a[i]=a[j];\r\n            a[j]=temp;\r\n        }\r\n    }while(i<j);\r\n\r\n    a[l]=a[j];\r\n    a[j]=v;\r\n\r\n    return(j);\r\n}\r\n', 10, '1 2000', '2000 ', 'Quick Sort\r\nquickSort(arr[], low, high)\r\n{\r\n	if (low < high)\r\n	{\r\n\r\n    	pi = partition(arr, low, high);\r\n\r\n    	quickSort(arr, low, pi - 1);  // Before pi\r\n    	quickSort(arr, pi + 1, high); // After pi\r\n	}\r\n}\r\nPseudo code for partition()\r\n\r\npartition (arr[], low, high)\r\n{\r\n    	pivot = arr[high];\r\n\r\n	i = (low ? 1)\r\n	for (j = low; j <= high- 1; j++)\r\n	{\r\n            	if (arr[j] < pivot)\r\n    	{\r\n        	i++;\r\n        	swap arr[i] and arr[j]\r\n    	}\r\n	}\r\n	swap arr[i + 1] and arr[high])\r\n	return (i + 1)\r\n}\r\n', '2020-05-25'),
(50, 3, 6001012018, '#include<stdio.h>\r\n\r\nint partition(int arr[],int si,int en){\r\nint pivot=arr[si];\r\nint countsmaller=0,i;\r\nfor(i=si+1;i<=en;i++)\r\n    if(arr[i]<=pivot)\r\n    countsmaller++;\r\n\r\n    int pivotindex=si+countsmaller;\r\n    arr[si]=arr[pivotindex];\r\n    arr[pivotindex]=pivot;\r\n\r\n     i=si;\r\n    int j=en;\r\n\r\n    while(i<pivotindex && j>pivotindex){\r\n        if(arr[i]<=pivot)\r\n            i++;\r\n            else if(arr[j]>pivot)\r\n            j--;\r\n        else{\r\n            int temp=arr[i];\r\n            arr[i]=arr[j];\r\n            arr[j]=temp;\r\n            i++;\r\n            j--;\r\n        }\r\n    }\r\n     return pivotindex;\r\n}\r\n\r\nvoid quicksort(int arr[],int i,int j){\r\nif(i<j){\r\nint p=partition(arr,i,j);\r\nquicksort(arr,i,p-1);\r\nquicksort(arr,p+1,j);\r\n}\r\n}\r\n\r\nint main(){\r\nint arr[100],i;\r\nint n;\r\nscanf(\"%d\",&n);\r\nfor(i=0;i<n;i++)\r\nscanf(\"%d\",&arr[i]);\r\nquicksort(arr,0,n-1);\r\nfor(i=0;i<n;i++)\r\n{\r\n    printf(\"%d \",arr[i]);\r\n}\r\nreturn 0;\r\n}', 10, '', '', '', '0000-00-00'),
(51, 3, 6201012018, '#include<iostream>\r\nusing namespace std;\r\nint partition(int arr[],int low,int high){\r\n    int pivot=arr[high];\r\n    int i=low-1;\r\n    for(int j=low;j<high;j++){\r\n        if(arr[j]<pivot){\r\n            i++;\r\n            swap(arr[j],arr[i]);\r\n        }\r\n    }\r\n    swap(arr[i+1],arr[high]);\r\n    return i+1;\r\n}\r\nvoid quicksort(int arr[],int low,int high){\r\n    if(low>=high){\r\n        return;\r\n    }\r\n    int p=partition(arr,low,high);\r\n    quicksort(arr,low,p-1);\r\n    quicksort(arr,p+1,high);\r\n    return;\r\n}\r\nint main(){\r\n    int arr[10000],n;\r\n    cin>>n;\r\n    for(int i=0;i<n;i++){\r\n        cin>>arr[i];\r\n    }\r\n    quicksort(arr,0,n-1);\r\n    for(int i=0;i<n;i++){\r\n        cout<<arr[i]<<\" \";\r\n    }\r\n}\r\n\r\n\r\n', 10, '', '', '', '0000-00-00'),
(53, 2, 1001012018, '#include <iostream>\r\n \r\nusing namespace std;\r\n \r\n// A function to merge the two half into a sorted data.\r\nvoid Merge(int *a, int low, int high, int mid)\r\n{\r\n	// We have low to mid and mid+1 to high already sorted.\r\n	int i, j, k, temp[high-low+1];\r\n	i = low;\r\n	k = 0;\r\n	j = mid + 1;\r\n \r\n	// Merge the two parts into temp[].\r\n	while (i <= mid && j <= high)\r\n	{\r\n		if (a[i] < a[j])\r\n		{\r\n			temp[k] = a[i];\r\n			k++;\r\n			i++;\r\n		}\r\n		else\r\n		{\r\n			temp[k] = a[j];\r\n			k++;\r\n			j++;\r\n		}\r\n	}\r\n \r\n	// Insert all the remaining values from i to mid into temp[].\r\n	while (i <= mid)\r\n	{\r\n		temp[k] = a[i];\r\n		k++;\r\n		i++;\r\n	}\r\n \r\n	// Insert all the remaining values from j to high into temp[].\r\n	while (j <= high)\r\n	{\r\n		temp[k] = a[j];\r\n		k++;\r\n		j++;\r\n	}\r\n \r\n \r\n	// Assign sorted data stored in temp[] to a[].\r\n	for (i = low; i <= high; i++)\r\n	{\r\n		a[i] = temp[i-low];\r\n	}\r\n}\r\n \r\n// A function to split array into two parts.\r\nvoid MergeSort(int *a, int low, int high)\r\n{\r\n	int mid;\r\n	if (low < high)\r\n	{\r\n		mid=(low+high)/2;\r\n		// Split the data into two half.\r\n		MergeSort(a, low, mid);\r\n		MergeSort(a, mid+1, high);\r\n \r\n		// Merge them to get sorted output.\r\n		Merge(a, low, high, mid);\r\n	}\r\n}\r\n \r\nint main()\r\n{\r\n	int n, i;\r\n	cin>>n;\r\n \r\n	int arr[n];\r\n	for(i = 0; i < n; i++)\r\n	{\r\n		cin>>arr[i];\r\n	}\r\n \r\n	MergeSort(arr, 0, n-1);\r\n \r\n	// Printing the sorted data.\r\n	for (i = 0; i < n; i++)\r\n     {\r\n         cout<<arr[i]<<\" \";\r\n     }\r\n \r\n	return 0;\r\n}\r\n                                            ', 10, '', '', '', '0000-00-00'),
(54, 2, 1701012018, 'import java.util.Scanner;\r\npublic class Main{\r\n\r\npublic static Scanner s = new Scanner(System.in);\r\n\r\n	public static int[] takeInput() {\r\n		int n = s.nextInt();\r\n		int[] arr = new int[n];\r\n		for (int i = 0; i < n; i++) {\r\n			arr[i] = s.nextInt();\r\n		}\r\n		return arr;\r\n	}\r\n\r\n	public static void printArray(int[] arr) {\r\n		for (int i = 0; i < arr.length; i++) {\r\n			System.out.print(arr[i]+ \" \");\r\n		}\r\n	}\r\n\r\n	public static void mergeTwoSortedArray(int[] arr, int start, int end, int mid) {\r\n		int n1 = mid - start + 1;\r\n		int n2 = end - mid;\r\n		int[] arr1 = new int[n1];\r\n		int[] arr2 = new int[n2];\r\n		for (int i = 0; i < n1; ++i)\r\n			arr1[i] = arr[start + i];\r\n		for (int j = 0; j < n2; ++j)\r\n			arr2[j] = arr[mid + 1 + j];\r\n\r\n		int i = 0, j = 0, k = start;\r\n		while (i < arr1.length && j < arr2.length) {\r\n			if (arr1[i] <= arr2[j]) {\r\n				arr[k++] = arr1[i++];\r\n			} else {\r\n				arr[k++] = arr2[j++];\r\n			}\r\n		}\r\n		while (i < arr1.length) {\r\n			arr[k++] = arr1[i++];\r\n		}\r\n		while (j < arr2.length) {\r\n			arr[k++] = arr2[j++];\r\n		}\r\n		return;\r\n	}\r\n\r\n	public static void sort(int[] arr, int start, int end) {\r\n		if (start < end) {\r\n			int mid = (start + end) / 2;\r\n			sort(arr, start, mid);\r\n			sort(arr, mid + 1, end);\r\n			mergeTwoSortedArray(arr, start, end, mid);\r\n		}\r\n	}\r\n\r\n	public static void main(String[] args) {\r\n		int[] arr = takeInput();\r\n		sort(arr, 0, arr.length - 1);\r\n		printArray(arr);\r\n\r\n	}\r\n}\r\n', 10, '', '', 'MergeSort(arr[], l,  r)\r\nIf r > l\r\n     1. Find the middle point to divide the array into two halves:  \r\n             middle m = (l+r)/2\r\n     2. Call mergeSort for first half:   \r\n             Call mergeSort(arr, l, m)\r\n     3. Call mergeSort for second half:\r\n             Call mergeSort(arr, m+1, r)\r\n     4. Merge the two halves sorted in step 2 and 3:\r\n             Call merge(arr, l, m, r)', '0000-00-00'),
(55, 2, 101012018, '/* Java program for Merge Sort */\r\nimport java.util.Scanner;\r\nclass Main\r\n{ \r\n	// Merges two subarrays of arr[]. \r\n	// First subarray is arr[l..m] \r\n	// Second subarray is arr[m+1..r] \r\n	void merge(int arr[], int l, int m, int r) \r\n	{ \r\n		// Find sizes of two subarrays to be merged \r\n		int n1 = m - l + 1; \r\n		int n2 = r - m; \r\n\r\n		/* Create temp arrays */\r\n		int L[] = new int [n1]; \r\n		int R[] = new int [n2]; \r\n\r\n		/*Copy data to temp arrays*/\r\n		for (int i=0; i<n1; ++i) \r\n			L[i] = arr[l + i]; \r\n		for (int j=0; j<n2; ++j) \r\n			R[j] = arr[m + 1+ j]; \r\n\r\n\r\n		/* Merge the temp arrays */\r\n\r\n		// Initial indexes of first and second subarrays \r\n		int i = 0, j = 0; \r\n\r\n		// Initial index of merged subarry array \r\n		int k = l; \r\n		while (i < n1 && j < n2) \r\n		{ \r\n			if (L[i] <= R[j]) \r\n			{ \r\n				arr[k] = L[i]; \r\n				i++; \r\n			} \r\n			else\r\n			{ \r\n				arr[k] = R[j]; \r\n				j++; \r\n			} \r\n			k++; \r\n		} \r\n\r\n		/* Copy remaining elements of L[] if any */\r\n		while (i < n1) \r\n		{ \r\n			arr[k] = L[i]; \r\n			i++; \r\n			k++; \r\n		} \r\n\r\n		/* Copy remaining elements of R[] if any */\r\n		while (j < n2) \r\n		{ \r\n			arr[k] = R[j]; \r\n			j++; \r\n			k++; \r\n		} \r\n	} \r\n\r\n	// Main function that sorts arr[l..r] using \r\n	// merge() \r\n	void sort(int arr[], int l, int r) \r\n	{ \r\n		if (l < r) \r\n		{ \r\n			// Find the middle point \r\n			int m = (l+r)/2; \r\n\r\n			// Sort first and second halves \r\n			sort(arr, l, m); \r\n			sort(arr , m+1, r); \r\n\r\n			// Merge the sorted halves \r\n			merge(arr, l, m, r); \r\n		} \r\n	} \r\n\r\n	// Driver method \r\n	public static void main(String args[]) \r\n	{ \r\n		int n;\r\n        Scanner s = new Scanner(System.in);\r\n        n = s.nextInt();\r\n        int arr[] = new int[n];\r\n        for(int i = 0; i < n; i++)\r\n        {\r\n            arr[i] = s.nextInt();\r\n        }\r\n\r\n		Main ob = new Main(); \r\n		ob.sort(arr, 0, arr.length-1); \r\n		for (int i = 0; i < n; i++)\r\n		{\r\n			System.out.print(arr[i]);\r\n				System.out.print(\" \");\r\n		}  \r\n	} \r\n}', 10, '', '', 'MergeSort(arr[], l,  r)\r\nIf r > l\r\n     1. Find the middle point to divide the array into two halves:  \r\n             middle m = (l+r)/2\r\n     2. Call mergeSort for first half:   \r\n             Call mergeSort(arr, l, m)\r\n     3. Call mergeSort for second half:\r\n             Call mergeSort(arr, m+1, r)\r\n     4. Merge the two halves sorted in step 2 and 3:\r\n             Call merge(arr, l, m, r)', '0000-00-00'),
(56, 2, 3401012018, '#include<iostream>\r\nusing namespace std;\r\n\r\nvoid merge(int arr[], int l, int m, int r) \r\n{ \r\n    int i, j, k; \r\n    int n1 = m - l + 1; \r\n    int n2 =  r - m; \r\n  \r\n   \r\n    int L[n1], R[n2]; \r\n  \r\n   \r\n    for (i = 0; i < n1; i++) \r\n        L[i] = arr[l + i]; \r\n    for (j = 0; j < n2; j++) \r\n        R[j] = arr[m + 1+ j]; \r\n  \r\n  \r\n    i = 0; \r\n    j = 0;  \r\n    k = l;  \r\n    while (i < n1 && j < n2) \r\n    { \r\n        if (L[i] <= R[j]) \r\n        { \r\n            arr[k] = L[i]; \r\n            i++; \r\n        } \r\n        else\r\n        { \r\n            arr[k] = R[j]; \r\n            j++; \r\n        } \r\n        k++; \r\n    } \r\n  \r\n    while (i < n1) \r\n    { \r\n        arr[k] = L[i]; \r\n        i++; \r\n        k++; \r\n    } \r\n \r\n    while (j < n2) \r\n    { \r\n        arr[k] = R[j]; \r\n        j++; \r\n        k++; \r\n    } \r\n} \r\n  \r\nvoid mergeSort(int arr[], int l, int r) \r\n{ \r\n    if (l < r) \r\n    { \r\n        int m = l+(r-l)/2; \r\n  \r\n        mergeSort(arr, l, m); \r\n        mergeSort(arr, m+1, r); \r\n  \r\n        merge(arr, l, m, r); \r\n    } \r\n} \r\n\r\nvoid printArray(int A[], int size) \r\n{ \r\n    int i; \r\n    for (i=0; i < size; i++) \r\n        cout<< A[i]<<\" \"; \r\n    \r\n} \r\n  \r\n\r\nint main()\r\n{\r\n  int n;\r\n  cin>>n;\r\n  int arr[n];\r\n  for(int i=0;i<n;i++)\r\n  {\r\n      cin>>arr[i];\r\n  }\r\n  mergeSort(arr, 0,n-1);\r\n \r\n  printArray(arr,n);\r\n  return 0;\r\n}\r\n\r\n                                            \r\n', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', 'void merge(int A[ ] , int start, int mid, int end) {\r\n//stores the starting position of both parts in temporary variables.\r\nint p = start ,q = mid+1;\r\nint Arr[end-start+1] , k=0;\r\nfor(int i = start ;i <= end ;i++) {\r\nif(p > mid) //checks if first part comes to an end or not .\r\nArr[ k++ ] = A[ q++] ;\r\nelse if ( q > end) //checks if second part comes to an end or not\r\nArr[ k++ ] = A[ p++ ];\r\nelse if( A[ p ] < A[ q ]) //checks which part has smaller element.\r\nArr[ k++ ] = A[ p++ ];\r\nelse\r\nArr[ k++ ] = A[ q++];\r\n}\r\nfor (int p=0 ; p< k ;p ++) {\r\n/* Now the real array has elements in sorted manner including both\r\nparts.*/\r\nA[ start++ ] = Arr[ p ] ;\r\n}\r\n}\r\nvoid merge_sort (int A[ ] , int start , int end )\r\n{\r\nif( start < end ) {\r\nint mid = (start + end ) / 2 ; // defines the current array in 2 parts .\r\nmerge_sort (A, start , mid ) ; // sort the 1st part of array .\r\nmerge_sort (A,mid+1 , end ) ; // sort the 2nd part of array.\r\n// merge the both parts by comparing elements of both the parts.\r\nmerge(A,start , mid , end );\r\n}\r\n}', '0000-00-00'),
(57, 3, 101012018, 'import java.util.Scanner;\r\n\r\npublic class Main {\r\n\r\npublic static Scanner s = new Scanner(System.in);\r\n\r\n	public static void quickSort(int[] arr, int start, int end) {\r\n		if (start >= end)\r\n			return;\r\n		int partitionIndex = partitionQuickSort(arr, start, end);\r\n		quickSort(arr, start, partitionIndex - 1);\r\n		quickSort(arr, partitionIndex + 1, end);\r\n	}\r\n\r\n	public static int partitionQuickSort(int[] arr, int start, int end) {\r\n		int pivotElement = arr[start];\r\n		int count = 0;\r\n		for (int i = start; i <= end; i++) {\r\n			if (arr[i] < pivotElement) {\r\n				count++;\r\n			}\r\n		}\r\n		int pivotPosition = start + count;\r\n		int temp = arr[start];\r\n		arr[start] = arr[pivotPosition];\r\n		arr[pivotPosition] = temp;\r\n		int i = start, j = end;\r\n		while (i < pivotPosition && j > pivotPosition) {\r\n			if (arr[i] < pivotElement)\r\n				i++;\r\n			else if (arr[j] >= pivotElement)\r\n				j--;\r\n			else {\r\n				int tempVar = arr[i];\r\n				arr[i] = arr[j];\r\n				arr[j] = tempVar;\r\n				i++;\r\n				j--;\r\n			}\r\n\r\n		}\r\n		return pivotPosition;\r\n	}\r\n\r\n	public static int[] takeInput() {\r\n		int n = s.nextInt();\r\n		int[] arr = new int[n];\r\n		for (int i = 0; i < n; i++) {\r\n			arr[i] = s.nextInt();\r\n		}\r\n		return arr;\r\n	}\r\n\r\n	public static void printArray(int[] arr) {\r\n		for (int i = 0; i < arr.length; i++) {\r\n			System.out.print(arr[i] + \" \");\r\n		}\r\n	}\r\n\r\n	public static void main(String[] args) {\r\n		int[] arr = takeInput();\r\n		quickSort(arr, 0, arr.length - 1);\r\n		printArray(arr);\r\n	}\r\n}', 10, '1 2000', '', 'quickSort(arr[], low, high)\r\n{\r\n    if (low < high)\r\n    {\r\n       \r\n        pi = partition(arr, low, high);\r\n\r\n        quickSort(arr, low, pi - 1);  \r\n        quickSort(arr, pi + 1, high); \r\n    }\r\n}\r\npartition (arr[], low, high)\r\n{\r\n   \r\n    pivot = arr[high];  \r\n \r\n    i = (low - 1)  // Index of smaller element\r\n\r\n    for (j = low; j <= high- 1; j++)\r\n    {\r\n       \r\n        if (arr[j] < pivot)\r\n        {\r\n            i++;    // increment index of smaller element\r\n            swap arr[i] and arr[j]\r\n        }\r\n    }\r\n    swap arr[i + 1] and arr[high])\r\n    return (i + 1)\r\n}', '0000-00-00'),
(58, 2, 3601012018, '#include<iostream>\r\nusing namespace std;\r\nvoid swapping(int &a, int &b) {\r\n   int temp;\r\n   temp = a;\r\n   a = b;\r\n   b = temp;\r\n}\r\nvoid display(int *array, int size) {\r\n   for(int i = 0; i<size; i++)\r\n      cout << array[i] << \" \";\r\n}\r\nvoid merge(int *array, int l, int m, int r) {\r\n   int i, j, k, nl, nr;\r\n   nl = m-l+1; nr = r-m;\r\n   int larr[nl], rarr[nr];\r\n   for(i = 0; i<nl; i++)\r\n      larr[i] = array[l+i];\r\n   for(j = 0; j<nr; j++)\r\n      rarr[j] = array[m+1+j];\r\n   i = 0; j = 0; k = l;\r\n   while(i < nl && j<nr) {\r\n      if(larr[i] <= rarr[j]) {\r\n         array[k] = larr[i];\r\n         i++;\r\n      }else{\r\n         array[k] = rarr[j];\r\n         j++;\r\n      }\r\n      k++;\r\n   }\r\n   while(i<nl) {\r\n      array[k] = larr[i];\r\n      i++; k++;\r\n   }\r\n   while(j<nr) {\r\n      array[k] = rarr[j];\r\n      j++; k++;\r\n   }\r\n}\r\nvoid mergeSort(int *array, int l, int r) {\r\n   if(l < r) {\r\n      int m = l+(r-l)/2;\r\n      mergeSort(array, l, m);\r\n      mergeSort(array, m+1, r);\r\n      merge(array, l, m, r);\r\n   }\r\n}\r\nint main() {\r\n   int n;\r\n   cin >> n;\r\n   int arr[n];\r\n   for(int i = 0; i<n; i++) {\r\n      cin >> arr[i];\r\n   }\r\n   mergeSort(arr, 0, n-1);\r\n   display(arr, n);\r\n}\r\n', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', 'Begin\r\n   nLeft := m - left+1\r\n   nRight := right – m\r\n   define arrays leftArr and rightArr of size nLeft and nRight respectively\r\n   for i := 0 to nLeft do\r\n      leftArr[i] := array[left +1]\r\n   done\r\n   for j := 0 to nRight do\r\n      rightArr[j] := array[middle + j +1]\r\n   done\r\n   i := 0, j := 0, k := left\r\n   while i < nLeft AND j < nRight do\r\n      if leftArr[i] <= rightArr[j] then\r\n         array[k] = leftArr[i]\r\n         i := i+1\r\n      else\r\n         array[k] = rightArr[j]\r\n         j := j+1\r\n         k := k+1\r\n   done\r\n   while i < nLeft do\r\n      array[k] := leftArr[i]\r\n      i := i+1\r\n      k := k+1\r\n   done\r\n   while j < nRight do\r\n      array[k] := rightArr[j]\r\n      j := j+1\r\n      k := k+1\r\n   done\r\nEnd', '2020-05-25'),
(59, 10, 101012018, '\r\nclass Knapsack \r\n{ \r\n\r\n	static int max(int a, int b) { return (a > b)? a : b; } \r\n	\r\n	static int knapSack(int W, int wt[], int val[], int n) \r\n	{ \r\n		\r\n	if (n == 0 || W == 0) \r\n		return 0; \r\n	\r\n	\r\n	if (wt[n-1] > W) \r\n	return knapSack(W, wt, val, n-1); \r\n	\r\n	\r\n	else return max( val[n-1] + knapSack(W-wt[n-1], wt, val, n-1), \r\n					knapSack(W, wt, val, n-1) \r\n					); \r\n	} \r\n\r\n	\r\n\r\npublic static void main(String args[]) \r\n{ \r\n	Scanner sc=new Scanner(System.in);\r\n	int n = sc.getInt(); \r\n	int W = sc.getInt();\r\n	int val[] = new int[3]; \r\n	for(int i=0;i<val.length;i++)\r\n	    val[i]=sc.getInt();\r\n	int wt[] = new int[3]; \r\n	for(int i=0;i<wt.length;i++)\r\n	    wt[i]=sc.getInt();\r\n	\r\n	System.out.println(knapSack(W, wt, val, n)); \r\n	} \r\n} \r\n\r\n', 10, '5 15 4 2 1 2 10 12 2 1 1 4', '', '', '0000-00-00'),
(60, 2, 2801012018, '#include<iostream>\r\nusing namespace std;\r\nvoid merge(int A[],int lb,int ub,int mid)\r\n{\r\n	int i,j,k,temp[ub-lb+1] ;\r\n	i=lb ;\r\n	j=mid+1 ;\r\n	k=0 ;\r\n	while( i<=mid && j<=ub )\r\n	{\r\n		if( A[i]<A[j] )\r\n		    temp[k++] = A[i++] ;\r\n		else\r\n		    temp[k++] = A[j++] ;\r\n	}\r\n	while( i<=mid )\r\n	{\r\n		temp[k] = A[i] ;\r\n		k++ ;\r\n		i++ ;\r\n	}\r\n	while( j<=ub )\r\n	{\r\n		temp[k] = A[j] ;\r\n		k++ ;\r\n		j++ ;\r\n	}\r\n	for( i=lb ; i<=ub ; i++ )\r\n	{\r\n		A[i] = temp[i-lb] ;\r\n	}\r\n}\r\nvoid MergeSort(int A[],int lb,int ub)\r\n{\r\n	int mid ;\r\n	if( lb<ub )\r\n	{\r\n		mid = (lb+ub)/2 ;\r\n		MergeSort(A,lb,mid) ;\r\n		MergeSort(A,mid+1,ub) ;\r\n		merge(A,lb,ub,mid) ;\r\n	}\r\n}\r\nint main()\r\n{\r\n	int n;\r\n        cin>>n;\r\n	int A[n];\r\n	for( i=0 ; i<n ; i++)\r\n	    cin>>A[i];\r\n	MergeSort(A,0,n-1);\r\n	for( i=0 ; i<n ; i++ )\r\n	    cout<<A[i]<<\" \";\r\n	return 0 ;\r\n}\r\n', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '', 'MergeSort(arr[], l,  r)\r\nIf r > l\r\n     1. Find the middle point to divide the array into two halves:  \r\n             middle m = (l+r)/2\r\n     2. Call mergeSort for first half:   \r\n             Call mergeSort(arr, l, m)\r\n     3. Call mergeSort for second half:\r\n             Call mergeSort(arr, m+1, r)\r\n     4. Merge the two halves sorted in step 2 and 3:\r\n             Call merge(arr, l, m, r)', '2020-05-25'),
(62, 2, 1601012018, '#include<iostream>\r\nusing namespace std;\r\n\r\nvoid merge2sorted(int p1[], int p2[], int arr[], int mid, int s)\r\n{\r\n    int i = 0, j = 0, k = 0;\r\n    while(i < mid && j < s)\r\n    {\r\n        if(p1[i] <= p2[j])\r\n        {\r\n            arr[k++] = p1[i++];\r\n        }\r\n        else\r\n        {\r\n            arr[k++] = p2[j++];\r\n        }\r\n    }\r\n    while(i < mid)\r\n    {\r\n        arr[k++] = p1[i++];\r\n    }\r\n    while(j < s)\r\n    {\r\n        arr[k++] = p2[j++];\r\n    }\r\n}\r\n\r\nvoid mergeSort(int arr[], int size)\r\n{\r\n    if(size == 1)\r\n    {\r\n        return;\r\n    }\r\n    int mid = size / 2;\r\n    int p1[mid], p2[size - mid];\r\n    for(int i = 0; i < mid; i++)\r\n    {\r\n        p1[i] = arr[i];\r\n    }\r\n    for(int i = mid; i < size; i++)\r\n    {\r\n        p2[i - mid] = arr[i];\r\n    }\r\n    mergeSort(p1, mid);\r\n    mergeSort(p2, size - mid);\r\n    merge2sorted(p1, p2, arr, mid, size - mid);\r\n}\r\n\r\nint main()\r\n{\r\n    int n;\r\n    cin >> n;\r\n    int arr[n];\r\n    for(int i = 0; i < n; i++)\r\n    cin >> arr[i];\r\n    mergeSort(arr, n);\r\n    for(int i = 0; i < n; i++)\r\n    cout << arr[i] << \" \";\r\n}', 10, '', '', '', '0000-00-00');
INSERT INTO `qtos_map` (`ID`, `Q_ID`, `ROLL`, `SUBMISSION`, `SCORE`, `INPUT`, `OP`, `ALGO`, `DATE`) VALUES
(63, 3, 1501012018, '#include<iostream>\r\nusing namespace std;\r\n\r\nvoid swap(int *x, int*y){\r\n    int temp = *x;\r\n    *x = *y;\r\n    *y = temp;\r\n}\r\n\r\nint partition(int arr[], int start, int end){\r\n    int pivot = arr[end];\r\n    int i = start-1;\r\n    for(int j=start; j<=end; j++){\r\n        if(arr[j]<pivot){\r\n            i++;\r\n            int temp;\r\n            swap(&arr[i], &arr[j]);\r\n        }\r\n    }\r\n    swap(&arr[i+1], &arr[end]);\r\n    return i+1;\r\n}\r\n\r\nvoid quicksort(int arr[], int start, int end){\r\n    if(start<end){\r\n        int part = partition(arr,start,end);\r\n        quicksort(arr, start, part-1);\r\n        quicksort(arr, part+1, end);\r\n    }\r\n}\r\n\r\nint main(){\r\n    int arr[10000]={};\r\n    int n; cin>>n;\r\n    for(int i=0; i<n; i++) cin>>arr[i];\r\n    quicksort(arr,0,n-1);\r\n    for(int i=0; i<n-1; i++) cout<<arr[i]<<\" \";\r\n    cout<<arr[n-1];\r\n}', 2, '', '', '', '0000-00-00'),
(64, 2, 3301012018, '#include<stdlib.h> \n#include<stdio.h> \n\nvoid merge(int arr[], int l, int m, int r) \n{ \n    int i, j, k; \n    int n1 = m - l + 1; \n    int n2 =  r - m; \n  \n \n    int L[n1], R[n2]; \n  \n  \n    for (i = 0; i < n1; i++) \n        L[i] = arr[l + i]; \n    for (j = 0; j < n2; j++) \n        R[j] = arr[m + 1+ j]; \n  \n\n    i = 0; // Initial index of first subarray \n    j = 0; // Initial index of second subarray \n    k = l; // Initial index of merged subarray \n    while (i < n1 && j < n2) \n    { \n        if (L[i] <= R[j]) \n        { \n            arr[k] = L[i]; \n            i++; \n        } \n        else\n        { \n            arr[k] = R[j]; \n            j++; \n        } \n        k++; \n    } \n  \n   \n    while (i < n1) \n    { \n        arr[k] = L[i]; \n        i++; \n        k++; \n    } \n  \n    \n    while (j < n2) \n    { \n        arr[k] = R[j]; \n        j++; \n        k++; \n    } \n} \n  \n\nvoid mergeSort(int arr[], int l, int r) \n{ \n    if (l < r) \n    { \n        int m = l+(r-l)/2; \n  \n       \n        mergeSort(arr, l, m); \n        mergeSort(arr, m+1, r); \n  \n        merge(arr, l, m, r); \n    } \n} \n\nvoid printArray(int A[], int size) \n{ \n    int i; \n    for (i=0; i < size; i++) \n        printf(\"%d \", A[i]); \n    printf(\"\n\"); \n} \n  \n\nint main() \n{ \n    int arr[] = {6,12,-5,4,1,0,6}; \n    int arr_size = sizeof(arr)/sizeof(arr[0]); \n  \n    printArray(arr, arr_size); \n  \n    mergeSort(arr, 0, arr_size - 1); \n  \n    printf(\"\n \n\");\n    printArray(arr, arr_size); \n    return 0; \n} \n', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '6 12 -5 4 1 0 6 \n\n \n-5 0 1 4 6 6 12 \n', 'MergeSort(arr[], l,  r)\nIf r > l\n     1. Find the middle point to divide the array into two halves:  \n             middle m = (l+r)/2\n     2. Call mergeSort for first half:   \n             Call mergeSort(arr, l, m)\n     3. Call mergeSort for second half:\n             Call mergeSort(arr, m+1, r)\n     4. Merge the two halves sorted in step 2 and 3:\n             Call merge(arr, l, m, r)\n', '2020-05-25'),
(65, 3, 3401012018, '#include<iostream>\r\n\r\nusing namespace std;\r\n\r\nvoid swap(int* a, int* b)  \r\n{  \r\n    int t = *a;  \r\n    *a = *b;  \r\n    *b = t;  \r\n}  \r\n\r\nint partition (int arr[], int low, int high)  \r\n{  \r\n    int pivot = arr[high]; \r\n    int i = (low - 1); \r\n  \r\n    for (int j = low; j <= high - 1; j++)  \r\n    {  \r\n       \r\n        if (arr[j] < pivot)  \r\n        {  \r\n            i++;  \r\n            swap(&arr[i], &arr[j]);  \r\n        }  \r\n    }  \r\n    swap(&arr[i + 1], &arr[high]);  \r\n    return (i + 1);  \r\n}  \r\n\r\nvoid quickSort(int arr[], int low, int high)  \r\n{  \r\n    if (low < high)  \r\n    {  \r\n        int pi = partition(arr, low, high);  \r\n  \r\n        quickSort(arr, low, pi - 1);  \r\n        quickSort(arr, pi + 1, high);  \r\n    }  \r\n}  \r\n\r\nvoid printArray(int arr[], int size)  \r\n{  \r\n    int i;  \r\n    for (i = 0; i < size; i++) \r\n     {  \r\n         cout <<arr[i]<<\" \";\r\n         \r\n     }\r\n         \r\n}  \r\n  \r\nint main()\r\n{\r\n  int n;\r\n  cin>>n;\r\n  int arr[n];\r\n  for(int i=0;i<n;i++)\r\n  {\r\n      cin>>arr[i];\r\n  }\r\n  quickSort(arr, 0, n-1); \r\n \r\n  printArray(arr,n);\r\n  return 0;\r\n}\r\n', 10, '1 2000', '', 'pivot, put x at its correct position in sorted array and put all smaller elements (smaller than x) before x, and put\r\nall greater elements (greater than x) after x\r\nquickSort(arr[], low, high)\r\n{\r\nif (low < high)\r\n{\r\n/* pi is partitioning index, arr[pi] is now\r\nat right place */\r\npi = partition(arr, low, high);\r\nquickSort(arr, low, pi - 1); // Before pi\r\nquickSort(arr, pi + 1, high); // After pi\r\n}}\r\npartition (arr[], low, high)\r\n{\r\n// pivot (Element to be placed at right position)\r\npivot = arr[high];\r\ni = (low - 1) // Index of smaller element\r\nfor (j = low; j <= high- 1; j++)\r\n{\r\n// If current element is smaller than the pivot\r\nif (arr[j] < pivot)\r\n{\r\ni++; // increment index of smaller element\r\nswap arr[i] and arr[j]\r\n}}\r\nswap arr[i + 1] and arr[high])\r\nreturn (i + 1)\r\n}', '0000-00-00'),
(66, 2, 3101012018, '#include<iostream>\r\nusing namespace std;\r\nvoid swapping(int &a, int &b) {     //swap the content of a and b\r\n   int temp;\r\n   temp = a;\r\n   a = b;\r\n   b = temp;\r\n}\r\nvoid display(int *array, int size) {\r\n   for(int i = 0; i<size; i++)\r\n      cout << array[i] << \" \";\r\n}\r\nvoid merge(int *array, int l, int m, int r) {\r\n   int i, j, k, nl, nr;\r\n   //size of left and right sub-arrays\r\n   nl = m-l+1; nr = r-m;\r\n   int larr[nl], rarr[nr];\r\n   //fill left and right sub-arrays\r\n   for(i = 0; i<nl; i++)\r\n      larr[i] = array[l+i];\r\n   for(j = 0; j<nr; j++)\r\n      rarr[j] = array[m+1+j];\r\n   i = 0; j = 0; k = l;\r\n   //marge temp arrays to real array\r\n   while(i < nl && j<nr) {\r\n      if(larr[i] <= rarr[j]) {\r\n         array[k] = larr[i];\r\n         i++;\r\n      }else{\r\n         array[k] = rarr[j];\r\n         j++;\r\n      }\r\n      k++;\r\n   }\r\n   while(i<nl) {       //extra element in left array\r\n      array[k] = larr[i];\r\n      i++; k++;\r\n   }\r\n   while(j<nr) {     //extra element in right array\r\n      array[k] = rarr[j];\r\n      j++; k++;\r\n   }\r\n}\r\nvoid mergeSort(int *array, int l, int r) {\r\n   int m;\r\n   if(l < r) {\r\n      int m = l+(r-l)/2;\r\n      // Sort first and second arrays\r\n      mergeSort(array, l, m);\r\n      mergeSort(array, m+1, r);\r\n      merge(array, l, m, r);\r\n   }\r\n}\r\nint main() {\r\n   int n;\r\n   cin >> n;\r\n   int arr[n];     //create an array with given number of elements\r\n   for(int i = 0; i<n; i++) {\r\n      cin >> arr[i];\r\n   }\r\n   mergeSort(arr, 0, n-1);     //(n-1) for last index\r\n   display(arr, n);\r\n}', 10, '', '', '', '0000-00-00'),
(67, 2, 201012018, '#include<iostream>\r\nusing namespace std;\r\nvoid merge(int *arr, int l, int m, int r) \r\n{ \r\n    int i, j, k; \r\n    int n1 = m - l + 1; \r\n    int n2 =  r - m; \r\n  \r\n    \r\n    int L[n1], R[n2]; \r\n  \r\n    \r\n    for (i = 0; i < n1; i++) \r\n        L[i] = arr[l + i]; \r\n    for (j = 0; j < n2; j++) \r\n        R[j] = arr[m + 1+ j]; \r\n  \r\n   \r\n    i = 0; \r\n    j = 0;\r\n    k = l;\r\n    while (i < n1 && j < n2) \r\n    { \r\n        if (L[i] <= R[j]) \r\n        { \r\n            arr[k] = L[i]; \r\n            i++; \r\n        } \r\n        else\r\n        { \r\n            arr[k] = R[j]; \r\n            j++; \r\n        } \r\n        k++; \r\n    } \r\n  \r\n    \r\n    while (i < n1) \r\n    { \r\n        arr[k] = L[i]; \r\n        i++; \r\n        k++; \r\n    } \r\n  \r\n    \r\n    while (j < n2) \r\n    { \r\n        arr[k] = R[j]; \r\n        j++; \r\n        k++; \r\n    } \r\n} \r\n  \r\n\r\nvoid mergeSort(int *arr, int l, int r) \r\n{ \r\n    if (l < r) \r\n    { \r\n        \r\n        int m = l+(r-l)/2; \r\n        mergeSort(arr, l, m); \r\n        mergeSort(arr, m+1, r); \r\n        merge(arr, l, m, r); \r\n    } \r\n} \r\n\r\n\r\nint main()\r\n{\r\n    int n;\r\n    int arr[100];\r\n    cin>>n;\r\n    for(int i=0;i<n;i++)\r\n    {\r\n        cin>>arr[i];\r\n    }\r\n    mergeSort(arr,0,n-1);\r\n    for(int i=0;i<n;i++)\r\n    {\r\n        cout<<arr[i]<<\" \";\r\n        //if(i!=n-1)\r\n           // cout<<\" \";\r\n        \r\n    }\r\n    return 0;\r\n}', 10, '', '', '', '0000-00-00'),
(68, 2, 901012018, '#include <stdio.h>\r\n#include <conio.h> \r\n#define size 100\r\nvoid merge(int a[], int, int, int); \r\nvoid merge_sort(int a[],int, int); \r\nint main() \r\n{ \r\n    int arr[size], i, n;\r\n    printf(\"\n Enter the number of elements in the array : \"); \r\n    scanf(\"%d\", &n);\r\n    printf(\"\n Enter the elements of the array: \"); \r\n    for(i=0;i<n;i++) \r\n    {  \r\n        scanf(\"%d\", &arr[i]);\r\n    } \r\n    merge_sort(arr, 0, n-1); \r\n    printf(\"\n The sorted array is: \n\"); \r\n    for(i=0;i<n;i++)\r\n    {\r\n        printf(\" %d	\", arr[i]);\r\n    } \r\n}\r\nvoid merge(int arr[], int beg, int mid, int end) \r\n{ \r\n    int i=beg, j=mid+1, index=beg, temp[size], k;\r\n    while((i<=mid) && (j<=end)) \r\n    {  \r\n        if(arr[i] < arr[j])  \r\n        {  \r\n            temp[index] = arr[i];   \r\n            i++;  \r\n            \r\n        }  \r\n        else  \r\n        {   \r\n            temp[index] = arr[j];\r\n            j++; \r\n        }  \r\n        index++; \r\n        \r\n    } \r\n    if(i>mid) \r\n    {  \r\n        while(j<=end)  \r\n        {\r\n            temp[index] = arr[j];  \r\n            j++;  \r\n            index++; \r\n        } \r\n    \r\n    }\r\n    else\r\n    {  \r\n        while(i<=mid)  \r\n        {   \r\n            temp[index] = arr[i];  \r\n            i++;   \r\n            index++;  \r\n        \r\n        } \r\n        \r\n    } \r\n    for(k=beg;k<index;k++) \r\n    arr[k] = temp[k];\r\n\r\n} \r\nvoid merge_sort(int arr[], int beg, int end)\r\n{ \r\n    int mid; \r\n    if(beg<end) \r\n    {  \r\n        mid = (beg+end)/2; \r\n        merge_sort(arr, beg, mid);\r\n        merge_sort(arr, mid+1, end); \r\n        merge(arr, beg, mid, end); \r\n        \r\n    } \r\n    \r\n}\r\n', 0, '', '', '', '0000-00-00'),
(69, 2, 701012018, '#include<stdlib.h> \r\n#include<stdio.h> \r\n#include<iostream>\r\nusing namespace std;\r\n\r\nvoid merge(int arr[], int l, int m, int r) \r\n{ \r\n    int i, j, k; \r\n    int n1 = m - l + 1; \r\n    int n2 =  r - m; \r\n  \r\n    int L[n1], R[n2]; \r\n  \r\n    for (i = 0; i < n1; i++) \r\n        L[i] = arr[l + i]; \r\n    for (j = 0; j < n2; j++) \r\n        R[j] = arr[m + 1+ j]; \r\n  \r\n    \r\n    i = 0; \r\n    j = 0;\r\n    k = l; \r\n    while (i < n1 && j < n2) \r\n    { \r\n        if (L[i] <= R[j]) \r\n        { \r\n            arr[k] = L[i]; \r\n            i++; \r\n        } \r\n        else\r\n        { \r\n            arr[k] = R[j]; \r\n            j++; \r\n        } \r\n        k++; \r\n    } \r\n  \r\n    while (i < n1) \r\n    { \r\n        arr[k] = L[i]; \r\n        i++; \r\n        k++; \r\n    } \r\n    while (j < n2) \r\n    { \r\n        arr[k] = R[j]; \r\n        j++; \r\n        k++; \r\n    } \r\n} \r\n  \r\nvoid mergeSort(int arr[], int l, int r) \r\n{ \r\n    if (l < r) \r\n    { \r\n        int m = l+(r-l)/2; \r\n  \r\n        mergeSort(arr, l, m); \r\n        mergeSort(arr, m+1, r); \r\n  \r\n        merge(arr, l, m, r); \r\n    } \r\n} \r\n\r\nvoid printArray(int A[], int size) \r\n{ \r\n    int i; \r\n    for (i=0; i < size; i++) \r\n        printf(\"%d \", A[i]); \r\n    printf(\"\n\"); \r\n} \r\n\r\nint main() \r\n{ \r\n    int n;\r\n    cin>>n;\r\n    int arr[n]; \r\n    for(int i =0; i<n; i++){\r\n        cin>>arr[i];\r\n    }\r\n  \r\n    mergeSort(arr, 0, n - 1); \r\n  \r\n    printArray(arr, n); \r\n    return 0; \r\n} ', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 \n', 'Divide the unsorted list into  sublists, each containing  element.\r\nTake adjacent pairs of two singleton lists and merge them to form a list of 2 elements.  will now convert into  lists of size 2.\r\nRepeat the process till a single sorted list of obtained.', '0000-00-00'),
(71, 2, 2501012018, '#include<stdlib.h> \r\n#include<stdio.h> \r\n  \r\nvoid merge(int arr[], int l, int m, int r) \r\n{ \r\n    int i, j, k; \r\n    int n1 = m - l + 1; \r\n    int n2 =  r - m; \r\n  \r\n    \r\n    int L[n1], R[n2]; \r\n  \r\n    \r\n    for (i = 0; i < n1; i++) \r\n        L[i] = arr[l + i]; \r\n    for (j = 0; j < n2; j++) \r\n        R[j] = arr[m + 1+ j]; \r\n    i = 0; \r\n    j = 0; \r\n    k = l; \r\n    while (i < n1 && j < n2) \r\n    { \r\n        if (L[i] <= R[j]) \r\n        { \r\n            arr[k] = L[i]; \r\n            i++; \r\n        } \r\n        else\r\n        { \r\n            arr[k] = R[j]; \r\n            j++; \r\n        } \r\n        k++; \r\n    } \r\n\r\n    while (i < n1) \r\n    { \r\n        arr[k] = L[i]; \r\n        i++; \r\n        k++; \r\n    } \r\n  \r\n   \r\n    while (j < n2) \r\n    { \r\n        arr[k] = R[j]; \r\n        j++; \r\n        k++; \r\n    } \r\n} \r\n  \r\nvoid mergeSort(int arr[], int l, int r) \r\n{ \r\n    if (l < r) \r\n    { \r\n        // Same as (l+r)/2, but avoids overflow for \r\n        // large l and h \r\n        int m = l+(r-l)/2; \r\n  \r\n        // Sort first and second halves \r\n        mergeSort(arr, l, m); \r\n        mergeSort(arr, m+1, r); \r\n  \r\n        merge(arr, l, m, r); \r\n    } \r\n} \r\nvoid printArray(int A[], int size) \r\n{ \r\n    int i; \r\n    for (i=0; i < size; i++) \r\n        printf(\"%d \", A[i]); \r\n    printf(\"\n\"); \r\n} \r\n  \r\nint main() \r\n{ \r\n  \r\nint t;\r\ncin>>t;\r\nwhile(t!=0){\r\nint n;\r\ncin>>n;\r\nint a[n];\r\nfor(int i=0;i<n;i++){\r\ncin>>a[i];\r\n}\r\n    printf(\"Given array is \n\"); \r\n    printArray(arr, arr_size); \r\n  \r\n    mergeSort(a, 0, n - 1); \r\n  \r\n    printf(\"\nSorted array is \n\"); \r\n    printArray(a, n); \r\n    return 0; \r\n\r\nt--;\r\ncout<<endl;\r\n}\r\n} ', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '', 'MergeSort(arr[], l,  r)\r\nIf r > l\r\n     1. Find the middle point to divide the array into two halves:  \r\n             middle m = (l+r)/2\r\n     2. Call mergeSort for first half:   \r\n             Call mergeSort(arr, l, m)\r\n     3. Call mergeSort for second half:\r\n             Call mergeSort(arr, m+1, r)\r\n     4. Merge the two halves sorted in step 2 and 3:\r\n             Call merge(arr, l, m, r)', '2020-05-25'),
(72, 2, 2201012018, '#include<stdlib.h> \r\n#include<stdio.h> \r\n  \r\nvoid merge(int arr[], int l, int m, int r) \r\n{ \r\n    int i, j, k; \r\n    int n1 = m - l + 1; \r\n    int n2 =  r - m; \r\n  \r\n    \r\n    int L[n1], R[n2]; \r\n  \r\n    \r\n    for (i = 0; i < n1; i++) \r\n        L[i] = arr[l + i]; \r\n    for (j = 0; j < n2; j++) \r\n        R[j] = arr[m + 1+ j]; \r\n    i = 0; \r\n    j = 0; \r\n    k = l; \r\n    while (i < n1 && j < n2) \r\n    { \r\n        if (L[i] <= R[j]) \r\n        { \r\n            arr[k] = L[i]; \r\n            i++; \r\n        } \r\n        else\r\n        { \r\n            arr[k] = R[j]; \r\n            j++; \r\n        } \r\n        k++; \r\n    } \r\n\r\n    while (i < n1) \r\n    { \r\n        arr[k] = L[i]; \r\n        i++; \r\n        k++; \r\n    } \r\n  \r\n   \r\n    while (j < n2) \r\n    { \r\n        arr[k] = R[j]; \r\n        j++; \r\n        k++; \r\n    } \r\n} \r\n  \r\nvoid mergeSort(int arr[], int l, int r) \r\n{ \r\n    if (l < r) \r\n    { \r\n        // Same as (l+r)/2, but avoids overflow for \r\n        // large l and h \r\n        int m = l+(r-l)/2; \r\n  \r\n        // Sort first and second halves \r\n        mergeSort(arr, l, m); \r\n        mergeSort(arr, m+1, r); \r\n  \r\n        merge(arr, l, m, r); \r\n    } \r\n} \r\nvoid printArray(int A[], int size) \r\n{ \r\n    int i; \r\n    for (i=0; i < size; i++) \r\n        printf(\"%d \", A[i]); \r\n    printf(\"\n\"); \r\n} \r\n  \r\nint main() \r\n{ \r\n  \r\nint t;\r\ncin>>t;\r\nwhile(t!=0){\r\nint n;\r\ncin>>n;\r\nint a[n];\r\nfor(int i=0;i<n;i++){\r\ncin>>a[i];\r\n}\r\n    printf(\"Given array is \n\"); \r\n    printArray(arr, arr_size); \r\n  \r\n    mergeSort(a, 0, n - 1); \r\n  \r\n    printf(\"\nSorted array is \n\"); \r\n    printArray(a, n); \r\n    return 0; \r\n\r\nt--;\r\ncout<<endl;\r\n}\r\n} ', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '', 'MergeSort(arr[], l,  r)\r\nIf r > l\r\n     1. Find the middle point to divide the array into two halves:  \r\n             middle m = (l+r)/2\r\n     2. Call mergeSort for first half:   \r\n             Call mergeSort(arr, l, m)\r\n     3. Call mergeSort for second half:\r\n             Call mergeSort(arr, m+1, r)\r\n     4. Merge the two halves sorted in step 2 and 3:\r\n             Call merge(arr, l, m, r)', '2020-05-25'),
(74, 2, 401012018, '#include<iostream>\r\nusing namespace std;\r\nvoid merge(int *a,int low,int high,int mid)\r\n{\r\n    int i,j,k,temp[high-low+1];\r\n    i=low;\r\n    j=mid+1;\r\n    k=0;\r\n    while(i<=mid && j<=high)\r\n    {\r\n        if(a[i]<a[j])\r\n        {\r\n            temp[k]=a[i];\r\n            k++;\r\n            i++;\r\n        }\r\n        else\r\n        {\r\n            temp[k]=a[i];\r\n            k++;\r\n            j++;\r\n        }\r\n    }\r\n    while(i<=mid)\r\n    {\r\n        temp[k]=a[i];\r\n        k++;\r\n        j++;\r\n    }\r\n    while(j<=high)\r\n    {\r\n        temp[k]=a[j];\r\n        k++;\r\n        j++;\r\n    }\r\n    for(i=low;i<=high;++i)\r\n        a[i]=temp[i-low];\r\n}\r\nvoid mergesort(int *a,int low,int high)\r\n{\r\n    int mid;\r\n    if(low<high)\r\n    {\r\n        mid=(low+high)/2;\r\n        mergesort(a,low,mid);\r\n        mergesort(a,mid+1,high);\r\n        merge(a,low,high,mid);\r\n    }\r\n}\r\nint main()\r\n{\r\n    int n,i,arr[100];\r\n    cin>>n;\r\n    for(i=0;i<n;i++)\r\n    {\r\n        cin>>arr[i];\r\n    }\r\n    mergesort(arr,0,n-1);\r\n    for(i=0;i<n;++i)\r\n        cout<<arr[i]<<\" \";\r\n    return 0;\r\n}', 0, '', '', '', '0000-00-00'),
(75, 2, 3701012018, '#include<iostream>\r\nusing namespace std;\r\nvoid swapping(int &a, int &b) {     \r\n   int temp;\r\n   temp = a;\r\n   a = b;\r\n   b = temp;\r\n}\r\nvoid display(int *array, int size) {\r\n   for(int i = 0; i<size; i++)\r\n      cout << array[i] << \" \";\r\n}\r\nvoid merge(int *array, int l, int m, int r) {\r\n   int i, j, k, nl, nr;\r\n   \r\n   nl = m-l+1; nr = r-m;\r\n   int larr[nl], rarr[nr];\r\n  \r\n   for(i = 0; i<nl; i++)\r\n      larr[i] = array[l+i];\r\n   for(j = 0; j<nr; j++)\r\n      rarr[j] = array[m+1+j];\r\n   i = 0; j = 0; k = l;\r\n  \r\n   while(i < nl && j<nr) {\r\n      if(larr[i] <= rarr[j]) {\r\n         array[k] = larr[i];\r\n         i++;\r\n      }else{\r\n         array[k] = rarr[j];\r\n         j++;\r\n      }\r\n      k++;\r\n   }\r\n   while(i<nl) {      \r\n      array[k] = larr[i];\r\n      i++; k++;\r\n   }\r\n   while(j<nr) {     \r\n      array[k] = rarr[j];\r\n      j++; k++;\r\n   }\r\n}\r\nvoid mergeSort(int *array, int l, int r) {\r\n   int m;\r\n   if(l < r) {\r\n      int m = l+(r-l)/2;\r\n      mergeSort(array, l, m);\r\n      mergeSort(array, m+1, r);\r\n      merge(array, l, m, r);\r\n   }\r\n}\r\nint main() {\r\n   int arr[] = {12, -5, 4, 1, 0, 6};\r\n   mergeSort(arr, 0, 5);     \r\n   display(arr, 6);\r\n}', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '-5 0 1 4 6 12 ', 'MergeSort(arr[], l,  r)\r\nIf r > l\r\n     1. Find the middle point to divide the array into two halves:  \r\n             middle m = (l+r)/2\r\n     2. Call mergeSort for first half:   \r\n             Call mergeSort(arr, l, m)\r\n     3. Call mergeSort for second half:\r\n             Call mergeSort(arr, m+1, r)\r\n     4. Merge the two halves sorted in step 2 and 3:\r\n             Call merge(arr, l, m, r)', '2020-05-25'),
(76, 2, 1101012018, '#include<iostream>\r\nusing namespace std;\r\nvoid quickSort(int input[], int size) {\r\n  if(size == 0)\r\n    return;\r\n  int check = 0;\r\n  for(int i = 1; i < size; ++i)\r\n  {\r\n    if(input[i] <= input[0])\r\n      check++;\r\n  }\r\n  int temp = input[0];\r\n  input[0] = input[check];\r\n  input[check] = temp;\r\n  int left = 0, right = size-1;\r\n  while(left < check)\r\n  {\r\n    while(input[left] <= input[check] && left < check)\r\n      left++;\r\n    while(input[right] > input[check])\r\n      right--;\r\n   \r\n   {\r\n      int k = input[left];\r\n      input[left] = input[right];\r\n      input[right] = k;\r\n      left++;\r\n      right--;\r\n   }\r\n  }\r\n  quickSort(input, check);\r\n  quickSort(input+check+1, size-check-1);\r\n}\r\n\r\nint main()\r\n{\r\n    int n;\r\n    cin>>n;\r\n    int arr[n];\r\n    for(int i = 0; i < n; ++i)\r\n        cin>>arr[i];\r\n        \r\n    quickSort(arr, n);\r\n    //sort(arr, arr+n);\r\n    \r\n    for(int i = 0; i < n; ++i)\r\n    {\r\n        cout<<arr[i]<<\" \";\r\n    }\r\n    \r\n}\r\n                                            ', 10, '', '', '', '0000-00-00'),
(77, 2, 1201012018, '\r\n#include <iostream>\r\n \r\nusing namespace std;\r\nvoid Merge(int *a, int low, int high, int mid)\r\n{\r\n	int i, j, k, temp[high-low+1];\r\n	i = low;\r\n	k = 0;\r\n	j = mid + 1;\r\n	while (i <= mid && j <= high)\r\n	{\r\n		if (a[i] < a[j])\r\n		{\r\n			temp[k] = a[i];\r\n			k++;\r\n			i++;\r\n		}\r\n		else\r\n		{\r\n			temp[k] = a[j];\r\n			k++;\r\n			j++;\r\n		}\r\n	}\r\n	while (i <= mid)\r\n	{\r\n		temp[k] = a[i];\r\n		k++;\r\n		i++;\r\n	}\r\n	while (j <= high)\r\n	{\r\n		temp[k] = a[j];\r\n		k++;\r\n		j++;\r\n	}\r\n	for (i = low; i <= high; i++)\r\n		a[i] = temp[i-low];\r\n	\r\n}\r\nvoid MergeSort(int *a, int low, int high)\r\n{\r\n	int mid;\r\n	if (low < high)\r\n	{\r\n		mid=(low+high)/2;\r\n		MergeSort(a, low, mid);\r\n		MergeSort(a, mid+1, high);\r\n		Merge(a, low, high, mid);\r\n	}\r\n}\r\n \r\nint main()\r\n{\r\n	int n, i;\r\n	cin>>n;\r\n \r\n	int arr[n];\r\n	for(i = 0; i < n; i++)\r\n		cin>>arr[i];\r\n \r\n	MergeSort(arr, 0, n-1);\r\n	for (i = 0; i < n; i++)\r\n         cout<<arr[i]<<\" \";\r\n \r\n	return 0;\r\n}', 10, '', '', '', '0000-00-00'),
(79, 2, 1301012018, '#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nvoid merge(int a[],int s,int m,int e){\r\n    int i=0,j=0,k=s;\r\n    int n1=m-s+1;\r\n    int n2=e-m;\r\n    int *l=new int[n1];\r\n    int *n=new int[n2];\r\n    for(i=0;i<n1;i++){\r\n        l[i]=a[s+i];\r\n    }\r\n    for(i=0;i<n2;i++){\r\n        n[i]=a[m+1+i];\r\n    }\r\n    i=0;\r\n    while(i<n1 && j<n2){\r\n        if(l[i]<=n[j]){\r\n            a[k++]=l[i++];\r\n        }\r\n        else{\r\n            a[k++]=n[j++];\r\n        }\r\n    }\r\n    while(i<n1){\r\n        a[k++]=l[i++];\r\n    }\r\n    while(j<n2){\r\n        a[k++]=n[j++];\r\n    }\r\n    \r\n}\r\n\r\nvoid mergeSort(int a[],int s,int e){\r\n    if(s>=e) return;\r\n    int m=(s+e)/2;\r\n    mergeSort(a,s,m);\r\n    mergeSort(a,m+1,e);\r\n    merge(a,s,m,e);\r\n    \r\n}\r\n\r\nint main(){\r\n    int n;\r\n    cin>>n;\r\n    int a[10000];\r\n    for(int i=0;i<n;i++){\r\n        cin>>a[i];\r\n    }\r\n    mergeSort(a,0,n-1);\r\n    for(int i=0;i<n;i++){\r\n        cout<<a[i]<<\" \";\r\n    }\r\n}\r\n', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', 'If r > l\r\n 1. Find the middle point to divide the array into two halves:\r\n middle m = (l+r)/2\r\n 2. Call mergeSort for first half:\r\n Call mergeSort(arr, l, m)\r\n 3. Call mergeSort for second half:\r\n Call mergeSort(arr, m+1, r)\r\n 4. Merge the two halves sorted in step 2 and 3:\r\n Call merge(arr, l, m, r)\r\n', '0000-00-00'),
(80, 2, 3201012018, '#include <bits/stdc++.h>\r\nusing namespace std;\r\nvoid merge(int arr[], int l, int m, int r) \r\n{ \r\n    int i, j, k; \r\n    int n1 = m - l + 1; \r\n    int n2 =  r - m; \r\n    int L[n1], R[n2]; \r\n    for (i = 0; i < n1; i++) \r\n        L[i] = arr[l + i]; \r\n    for (j = 0; j < n2; j++) \r\n        R[j] = arr[m + 1+ j]; \r\n    i = 0; \r\n    j = 0; \r\n    k = l;\r\n    while (i < n1 && j < n2) \r\n    { \r\n        if (L[i] <= R[j]) \r\n        { \r\n            arr[k] = L[i]; \r\n            i++; \r\n        } \r\n        else\r\n        { \r\n            arr[k] = R[j]; \r\n            j++; \r\n        } \r\n        k++; \r\n    } \r\n    while (i < n1) \r\n    { \r\n        arr[k] = L[i]; \r\n        i++; \r\n        k++; \r\n    } \r\n    while (j < n2) \r\n    { \r\n        arr[k] = R[j]; \r\n        j++; \r\n        k++; \r\n    } \r\n} \r\nvoid mergeSort(int arr[], int l, int r) \r\n{ \r\n    if (l < r) \r\n    {\r\n        int m = l+(r-l)/2;\r\n        mergeSort(arr, l, m); \r\n        mergeSort(arr, m+1, r); \r\n        merge(arr, l, m, r); \r\n    } \r\n} \r\nint main()\r\n{\r\n    int n;\r\n    cin>>n;\r\n    int arr[n];\r\n    for(int i=0;i<n;i++)\r\n    cin>>arr[i];\r\n    mergeSort(arr,0,n-1);\r\n    for(int i=0;i<n;i++)\r\n    cout<<arr[i]<<\" \";\r\n}\r\n ', 10, '', '', '', '0000-00-00'),
(81, 2, 3501012018, '#include<stdlib.h> \r\n#include<stdio.h> \r\n  \r\nvoid merge(int arr[], int l, int m, int r) \r\n{ \r\n    int i, j, k; \r\n    int n1 = m - l + 1; \r\n    int n2 =  r - m; \r\n  \r\n    int L[n1], R[n2]; \r\n  \r\n    for (i = 0; i < n1; i++) \r\n        L[i] = arr[l + i]; \r\n    for (j = 0; j < n2; j++) \r\n        R[j] = arr[m + 1+ j]; \r\n  \r\n    i = 0; \r\n    j = 0; \r\n    k = l; \r\n    while (i < n1 && j < n2) \r\n    { \r\n        if (L[i] <= R[j]) \r\n        { \r\n            arr[k] = L[i]; \r\n            i++; \r\n        } \r\n        else\r\n        { \r\n            arr[k] = R[j]; \r\n            j++; \r\n        } \r\n        k++; \r\n    } \r\n    while (i < n1) \r\n    { \r\n        arr[k] = L[i]; \r\n        i++; \r\n        k++; \r\n    } \r\n    while (j < n2) \r\n    { \r\n        arr[k] = R[j]; \r\n        j++; \r\n        k++; \r\n    } \r\n} \r\n  \r\nvoid mergeSort(int arr[], int l, int r) \r\n{ \r\n    if (l < r) \r\n    { \r\n        int m = l+(r-l)/2; \r\n  \r\n        mergeSort(arr, l, m); \r\n        mergeSort(arr, m+1, r); \r\n  \r\n        merge(arr, l, m, r); \r\n    } \r\n} \r\nvoid printArray(int A[], int size) \r\n{ \r\n    int i; \r\n    for (i=0; i < size; i++) \r\n        printf(\"%d \", A[i]); \r\n} \r\n  \r\nint main() \r\n{ \r\n\r\n    int n;\r\n    scanf(\"%d\",&n);  \r\n    int i, arr[n];\r\n    for(i=0;i<n;i++)\r\n        scanf(\"%d\",&arr[i]); \r\n  \r\n    mergeSort(arr, 0, n - 1); \r\n  \r\n    printArray(arr, n); \r\n    return 0; \r\n}', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', 'MergeSort(arr[], l,  r)\r\nIf r > l\r\n     1. Find the middle point to divide the array into two halves:  \r\n             middle m = (l+r)/2\r\n     2. Call mergeSort for first half:   \r\n             Call mergeSort(arr, l, m)\r\n     3. Call mergeSort for second half:\r\n             Call mergeSort(arr, m+1, r)\r\n     4. Merge the two halves sorted in step 2 and 3:\r\n             Call merge(arr, l, m, r)', '2020-05-25'),
(84, 3, 3001012018, '#include <iostream>\r\nusing namespace std;\r\nvoid swap(int* a, int* b)\r\n{\r\n    int t = *a;\r\n    *a = *b;\r\n    *b = t;\r\n}\r\nint partition (int arr[], int low, int high)\r\n{\r\n    int pivot = arr[high];\r\n    int i = (low - 1);\r\n\r\n    for (int j = low; j <= high - 1; j++)\r\n    {\r\n        if (arr[j] < pivot)\r\n        {\r\n            i++;\r\n            swap(&arr[i], &arr[j]);\r\n        }\r\n    }\r\n    swap(&arr[i + 1], &arr[high]);\r\n    return (i + 1);\r\n}\r\nvoid quickSort(int arr[], int low, int high)\r\n{\r\n    if (low < high)\r\n    {\r\n        int pi = partition(arr, low, high);\r\n        quickSort(arr, low, pi - 1);\r\n        quickSort(arr, pi + 1, high);\r\n    }\r\n}\r\nvoid printArray(int arr[], int size)\r\n{\r\n    int i;\r\n    for (i = 0; i < size; i++)\r\n        cout << arr[i] << \" \";\r\n    cout << endl;\r\n}\r\nint main()\r\n{\r\n    int arr[50];\r\n    int n;\r\n    cin>>n;\r\n    for(int i=0;i<n;i++)\r\n    {\r\n        cin>>arr[i];\r\n    }\r\n    quickSort(arr, 0, n - 1);\r\n    printArray(arr, n);\r\n    return 0;\r\n}\r\n', 0, '1 2000', '2000 \n', 'ALgorithm\r\nfind:\r\n\r\nint find(int i) \r\n{\r\n    \r\n    if (parent[i] == i) \r\n    {\r\n        return i;\r\n    }\r\n    else \r\n    {\r\n        return find(parent[i]);\r\n    }\r\n}\r\n\r\nunion:\r\n\r\n// Unites the set that includes i \r\n// and the set that includes j\r\nvoid union(int i, int j) \r\n{\r\n    // Find the representatives\r\n    // (or the root nodes) for the set\r\n    // that includes i\r\n    \r\n    int irep = this.Find(i),\r\n\r\n    // And do the same for the set \r\n    // that includes j    \r\n    int jrep = this.Find(j);\r\n\r\n    // Make the parent of i’s representative\r\n    // be j’s  representative effectively \r\n    // moving all of i’s set into j’s set)\r\n    this.Parent[irep] = jrep;\r\n}\r\n\r\npath compression:\r\n\r\n// Finds the representative of the set that i\r\n// is an element of.\r\nint find(int i) \r\n{\r\n    // If i is the parent of itself\r\n    if (Parent[i] == i) \r\n    {\r\n        // Then i is the representative \r\n        return i;\r\n    }\r\n    else\r\n    { \r\n        // Recursively find the representative.\r\n        int result = find(Parent[i]);\r\n\r\n        // We cache the result by moving i’s node \r\n        // directly under the representative of this\r\n        // set\r\n        Parent[i] = result;\r\n       \r\n        // And then we return the result\r\n        return result;\r\n     }\r\n}\r\n\r\nunion by rank:\r\n\r\nvoid union(int i, int j) \r\n{\r\n    // Find the representatives (or the root nodes) \r\n    // for the set that includes i\r\n    int irep = this.find(i);\r\n\r\n    // And do the same for the set that includes j\r\n    int jrep = this.Find(j);\r\n\r\n    // Elements are in same set, no need to \r\n    // unite anything.    \r\n    if (irep == jrep)\r\n        return;\r\n\r\n    // Get the rank of i’s tree\r\n    irank = Rank[irep],\r\n\r\n    // Get the rank of j’s tree\r\n    jrank = Rank[jrep];\r\n\r\n    // If i’s rank is less than j’s rank\r\n    if (irank < jrank) \r\n    {\r\n        // Then move i under j\r\n        this.parent[irep] = jrep;\r\n    } \r\n\r\n    // Else if j’s rank is less than i’s rank\r\n    else if (jrank < irank) \r\n    {\r\n        // Then move j under i\r\n        this.Parent[jrep] = irep;\r\n    } \r\n\r\n    // Else if their ranks are the same\r\n    else\r\n    {\r\n\r\n        // Then move i under j (doesn’t matter\r\n        // which one goes where)\r\n        this.Parent[irep] = jrep;\r\n\r\n        // And increment the result tree’s \r\n        // rank by 1\r\n        Rank[jrep]++;\r\n    }\r\n}\r\n', '2020-05-25'),
(85, 3, 701012018, '#include <bits/stdc++.h> \r\nusing namespace std;  \r\n  \r\nvoid swap(int* a, int* b)  \r\n{  \r\n    int t = *a;  \r\n    *a = *b;  \r\n    *b = t;  \r\n}  \r\n\r\nint partition (int arr[], int low, int high)  \r\n{  \r\n    int pivot = arr[high];  \r\n    int i = (low - 1);  \r\n  \r\n    for (int j = low; j <= high - 1; j++)  \r\n    {  \r\n        if (arr[j] < pivot)  \r\n        {  \r\n            i++; \r\n            swap(&arr[i], &arr[j]);  \r\n        }  \r\n    }  \r\n    swap(&arr[i + 1], &arr[high]);  \r\n    return (i + 1);  \r\n}  \r\n  \r\nvoid quickSort(int arr[], int low, int high)  \r\n{  \r\n    if (low < high)  \r\n    {  \r\n        int pi = partition(arr, low, high);  \r\n  \r\n        quickSort(arr, low, pi - 1);  \r\n        quickSort(arr, pi + 1, high);  \r\n    }  \r\n}  \r\n  \r\nvoid printArray(int arr[], int size)  \r\n{  \r\n    int i;  \r\n    for (i = 0; i < size; i++)  \r\n        cout << arr[i] << \" \";  \r\n    cout << endl;  \r\n}  \r\n  \r\nint main()  \r\n{  int n;\r\ncin>>n;\r\n    int arr[n];  \r\n    for(int i=0;i<n;i++){\r\n        cin>>arr[i];\r\n    }\r\n    quickSort(arr, 0, n - 1);\r\n    printArray(arr, n);  \r\n    return 0;  \r\n}  ', 10, '', '', 'Find a “pivot” item in the array. This item is the basis for comparison for a single round.\r\nStart a pointer (the left pointer) at the first item in the array.\r\nStart a pointer (the right pointer) at the last item in the array.\r\nWhile the value at the left pointer in the array is less than the pivot value, move the left pointer to the right (add 1). Continue until the value at the left pointer is greater than or equal to the pivot value.\r\nWhile the value at the right pointer in the array is greater than the pivot value, move the right pointer to the left (subtract 1). Continue until the value at the right pointer is less than or equal to the pivot value.\r\nIf the left pointer is less than or equal to the right pointer, then swap the values at these locations in the array.\r\nMove the left pointer to the right by one and the right pointer to the left by one.\r\nIf the left pointer and right pointer don’t meet, go to step 1.', '0000-00-00'),
(86, 3, 3601012018, '#include <bits/stdc++.h> \r\nusing namespace std;\r\nvoid swap(int* a, int* b) \r\n{ \r\n	int t = *a; \r\n	*a = *b; \r\n	*b = t; \r\n} \r\nint partition (int arr[], int low, int high) \r\n{ \r\n	int pivot = arr[high];\r\n	int i = (low - 1); \r\n\r\n	for (int j = low; j <= high - 1; j++) \r\n	{ \r\n		\r\n		if (arr[j] < pivot) \r\n		{ \r\n			i++; \r\n			swap(&arr[i], &arr[j]); \r\n		} \r\n	} \r\n	swap(&arr[i + 1], &arr[high]); \r\n	return (i + 1); \r\n} \r\n\r\n\r\nvoid quickSort(int arr[], int low, int high) \r\n{ \r\n	if (low < high) \r\n	{ \r\n		int pi = partition(arr, low, high); \r\n\r\n		quickSort(arr, low, pi - 1); \r\n		quickSort(arr, pi + 1, high); \r\n	} \r\n} \r\n\r\n\r\nvoid printArray(int arr[], int size) \r\n{ \r\n	int i; \r\n	for (i = 0; i < size; i++) \r\n		cout << arr[i] << \" \";\r\n} \r\n\r\n\r\nint main() \r\n{ \r\n	int n;\r\n	cin>>n;\r\n	int arr[n];\r\n	for(int i=0;i<n;i++)\r\n	cin>>arr[i];\r\n	quickSort(arr, 0, n - 1); \r\n	printArray(arr, n); \r\n	return 0; \r\n} ', 10, '1 2000', '2000 ', '', '0000-00-00'),
(87, 2, 2301012018, '#include <iostream>\r\nusing namespace std;\r\nvoid merge(int *,int, int , int );\r\nvoid merge_sort(int *arr, int low, int high)\r\n{\r\n    int mid;\r\n    if (low < high)\r\n    {\r\n        mid=(low+high)/2;\r\n        merge_sort(arr,low,mid);\r\n        merge_sort(arr,mid+1,high);\r\n        merge(arr,low,high,mid);\r\n    }\r\n}\r\nvoid merge(int *arr, int low, int high, int mid)\r\n{\r\n    int i, j, k, c[50];\r\n    i = low;\r\n    k = low;\r\n    j = mid + 1;\r\n    while (i <= mid && j <= high)\r\n    {\r\n        if (arr[i] < arr[j])\r\n        {\r\n            c[k] = arr[i];\r\n            k++;\r\n            i++;\r\n        }\r\n        else\r\n        {\r\n            c[k] = arr[j];\r\n            k++;\r\n            j++;\r\n        }\r\n    }\r\n    while (i <= mid)\r\n    {\r\n        c[k] = arr[i];\r\n        k++;\r\n        i++;\r\n    }\r\n    while (j <= high)\r\n    {\r\n        c[k] = arr[j];\r\n        k++;\r\n        j++;\r\n    }\r\n    for (i = low; i < k; i++)  {\r\n        arr[i] = c[i];\r\n    }\r\n}\r\nint main()\r\n{\r\n    int myarray[30], num;\r\n    cin>>num;\r\n    for (int i = 0; i < num; i++) \r\n    { \r\n        cin>>myarray[i];\r\n    }\r\n    merge_sort(myarray, 0, num-1);\r\n    for (int i = 0; i < num; i++)\r\n    {\r\n        cout<<myarray[i]<<\" \";\r\n    }\r\n}\r\n', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', 'This algorithm repeatedly divides the array into two halves until we reach a stage where we try to perform MergeSort on a subarray of size 1. After that, the merge function comes into play and combines the sorted arrays into larger arrays until the whole array is merged.\r\nMergeSort(arr[], l,  r)\r\nIf r > l\r\n     1. Find the middle point to divide the array into two halves:  \r\n             middle m = (l+r)/2\r\n     2. Call mergeSort for first half:   \r\n             Call mergeSort(arr, l, m)\r\n     3. Call mergeSort for second half:\r\n             Call mergeSort(arr, m+1, r)\r\n     4. Merge the two halves sorted in step 2 and 3:\r\n             Call merge(arr, l, m, r)', '2020-05-25'),
(88, 2, 2001012018, '#include <bits/stdc++.h>\r\nusing namespace std;\r\nvoid merge(int arr[], int l, int m, int r) \r\n{ \r\n    int i, j, k; \r\n    int n1 = m - l + 1; \r\n    int n2 =  r - m; \r\n    int L[n1], R[n2]; \r\n    for (i = 0; i < n1; i++) \r\n        L[i] = arr[l + i]; \r\n    for (j = 0; j < n2; j++) \r\n        R[j] = arr[m + 1+ j]; \r\n    i = 0; \r\n    j = 0; \r\n    k = l;\r\n    while (i < n1 && j < n2) \r\n    { \r\n        if (L[i] <= R[j]) \r\n        { \r\n            arr[k] = L[i]; \r\n            i++; \r\n        } \r\n        else\r\n        { \r\n            arr[k] = R[j]; \r\n            j++; \r\n        } \r\n        k++; \r\n    } \r\n    while (i < n1) \r\n    { \r\n        arr[k] = L[i]; \r\n        i++; \r\n        k++; \r\n    } \r\n    while (j < n2) \r\n    { \r\n        arr[k] = R[j]; \r\n        j++; \r\n        k++; \r\n    } \r\n} \r\nvoid mergeSort(int arr[], int l, int r) \r\n{ \r\n    if (l < r) \r\n    {\r\n        int m = l+(r-l)/2;\r\n        mergeSort(arr, l, m); \r\n        mergeSort(arr, m+1, r); \r\n        merge(arr, l, m, r); \r\n    } \r\n} \r\nint main()\r\n{\r\n    int n;\r\n    cin>>n;\r\n    int arr[n];\r\n    for(int i=0;i<n;i++)\r\n    cin>>arr[i];\r\n    mergeSort(arr,0,n-1);\r\n    for(int i=0;i<n;i++)\r\n    cout<<arr[i]<<\" \";\r\n}', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', 'Step 1 - if it is only one element in the list it is already sorted, return.\r\nStep 2 - divide the list recursively into two halves until it can no more be divided.\r\nStep 3 - merge the smaller lists into new list in sorted order.\r\n\r\n\r\nHave we reached the end of any of the arrays?\r\n    No:\r\n        Compare current elements of both arrays \r\n        Copy smaller element into sorted array\r\n        Move pointer of element containing smaller element\r\n    Yes:\r\n        Copy all remaining elements of non-empty array\r\n\r\nMergeSort(A, p, r):\r\n    if p > r \r\n        return\r\n    q = (p+r)/2\r\n    mergeSort(A, p, q)\r\n    mergeSort(A, q+1, r)\r\n    merge(A, p, q, r)\r\n', '2020-05-25'),
(89, 2, 601012018, '#include <iostream>\r\n using namespace std;\r\n \r\n void merge( int arr[], int a , int b, int c)\r\n {\r\n     int i, j, k;\r\n     int n1= b-a+1;\r\n     int n2= c-b;\r\n     \r\n     int la[n1], ra[n2];\r\n     \r\n    for (i=o; i< n1; i++)\r\n    {\r\n        la[i] = arr[a + 1];\r\n    }\r\n    for(j=0; j< n2; j++)\r\n    {\r\n        ra[j] = arr[b + 1 +j];\r\n    \r\n    }\r\n    i = 0;\r\n    j = 0;\r\n    k = 0;\r\n    while ( i< n1 && j < n2)\r\n    {\r\n        if(la[i] <= ra[j])\r\n        {\r\n            arr[k] = la[i];\r\n            i++;\r\n        }\r\n        else\r\n        {\r\n            arr[k] = ra[j];\r\n            j++;\r\n        }\r\n        k++;\r\n        \r\n    }\r\n    while(i < n1)\r\n    {\r\n        arr[k] = la[i];\r\n        i++;\r\n        k++;\r\n        \r\n    }\r\n    while(j < n2)\r\n    {\r\n        arr[k] = ra[j];\r\n        j++;\r\n        k++;\r\n    \r\n    }\r\n    \r\n }\r\n \r\n void mergesort(int arr[], int l, int r)\r\n {\r\n     if (l < r)\r\n     {\r\n         int m = l+(r-1)/2;\r\n         \r\n         mergesort(arr, l, m);\r\n         mergesort(arr, m+1, r);\r\n         \r\n         merge(arr, l, m, r);\r\n         \r\n     }\r\n }\r\n \r\n void ptrarr ( int array[], int size)\r\n {\r\n     int i;\r\n     for( i=0; i< size; i++)\r\n     {\r\n         cout<< array[i];\r\n         cout<<\"\n\";\r\n         \r\n     }\r\n }\r\n \r\n int main()\r\n {\r\n     int arr[];\r\n     cout<<\"enter array\"\r\n     \r\n     \r\n }\r\n abc', 0, '', '', '', '0000-00-00'),
(91, 2, 1901012018, '#include<iostream>\r\nusing namespace std;\r\n#include <iostream>\r\nusing namespace std;\r\nvoid swap(int *a, int *b)\r\n{\r\n int t = *a;\r\n *a = *b;\r\n *b = t;\r\n}\r\nint partition(int array[], int low, int high)\r\n{\r\n int pivot = array[high];\r\n int i = (low - 1);\r\n for (int j = low; j < high; j++)\r\n {\r\n if (array[j] <= pivot)\r\n {\r\n i++;\r\n swap(&array[i], &array[j]);\r\n }\r\n }\r\n swap(&array[i + 1], &array[high]);\r\n return (i + 1);\r\n}\r\nvoid qs(int array[], int low, int high)\r\n{\r\n if (low < high)\r\n {\r\n int pi = partition(array, low, high);\r\n qs(array, low, pi - 1);\r\n qs(array, pi + 1, high);\r\n }\r\n}\r\nint main(){\r\nint n;\r\ncin>>n;\r\nint arr[n];\r\nfor(int i=0;i<n;i++){\r\n cin>>arr[i];\r\n}\r\nqs(arr,0,n-1);\r\nfor(int i=0;i<n;i++){\r\n cout<<arr[i];\r\n //if(i==n-1)\r\n // break;\r\n cout<<\" \";\r\n}\r\nreturn 0;\r\n}\r\n', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', 'MergeSort(arr[], l,  r)\r\nIf r > l\r\n 	1. Find the middle point to divide the array into two halves: \r\n         	middle m = (l+r)/2\r\n	 2. Call mergeSort for first half:  \r\n         	Call mergeSort(arr, l, m)\r\n 	3. Call mergeSort for second half:\r\n         	Call mergeSort(arr, m+1, r)\r\n 	4. Merge the two halves sorted in step 2 and 3:\r\n         	Call merge(arr, l, m, r)', '2020-05-25'),
(92, 2, 301012018, '#include <bits/stdc++.h>\r\nusing namespace std;\r\nvoid merge(int arr[], int l, int m, int r) \r\n{ \r\n    int i, j, k; \r\n    int n1 = m - l + 1; \r\n    int n2 =  r - m; \r\n    int L[n1], R[n2]; \r\n    for (i = 0; i < n1; i++) \r\n        L[i] = arr[l + i]; \r\n    for (j = 0; j < n2; j++) \r\n        R[j] = arr[m + 1+ j]; \r\n    i = 0; \r\n    j = 0; \r\n    k = l;\r\n    while (i < n1 && j < n2) \r\n    { \r\n        if (L[i] <= R[j]) \r\n        { \r\n            arr[k] = L[i]; \r\n            i++; \r\n        } \r\n        else\r\n        { \r\n            arr[k] = R[j]; \r\n            j++; \r\n        } \r\n        k++; \r\n    } \r\n    while (i < n1) \r\n    { \r\n        arr[k] = L[i]; \r\n        i++; \r\n        k++; \r\n    } \r\n    while (j < n2) \r\n    { \r\n        arr[k] = R[j]; \r\n        j++; \r\n        k++; \r\n    } \r\n} \r\nvoid mergeSort(int arr[], int l, int r) \r\n{ \r\n    if (l < r) \r\n    {\r\n        int m = l+(r-l)/2;\r\n        mergeSort(arr, l, m); \r\n        mergeSort(arr, m+1, r); \r\n        merge(arr, l, m, r); \r\n    } \r\n} \r\nint main()\r\n{\r\n    int n;\r\n    cin>>n;\r\n    int arr[n];\r\n    for(int i=0;i<n;i++)\r\n    cin>>arr[i];\r\n    mergeSort(arr,0,n-1);\r\n    for(int i=0;i<n;i++)\r\n    cout<<arr[i]<<\" \";\r\n}', 10, '', '', '', '0000-00-00'),
(93, 3, 2301012018, '#include <iostream>\r\nusing namespace std;\r\nvoid swap(int* a, int* b)\r\n{\r\n    int t = *a;\r\n    *a = *b;\r\n    *b = t;\r\n}\r\nint partition (int arr[], int low, int high)\r\n{\r\n    int pivot = arr[high];\r\n    int i = (low - 1);\r\n\r\n    for (int j = low; j <= high - 1; j++)\r\n    {\r\n        if (arr[j] < pivot)\r\n        {\r\n            i++;\r\n            swap(&arr[i], &arr[j]);\r\n        }\r\n    }\r\n    swap(&arr[i + 1], &arr[high]);\r\n    return (i + 1);\r\n}\r\nvoid quickSort(int arr[], int low, int high)\r\n{\r\n    if (low < high)\r\n    {\r\n        int pi = partition(arr, low, high);\r\n        quickSort(arr, low, pi - 1);\r\n        quickSort(arr, pi + 1, high);\r\n    }\r\n}\r\nvoid printArray(int arr[], int size)\r\n{\r\n    int i;\r\n    for (i = 0; i < size; i++)\r\n        cout << arr[i] << \" \";\r\n    cout << endl;\r\n}\r\nint main()\r\n{\r\n    int arr[50];\r\n    int n;\r\n    cin>>n;\r\n    for(int i=0;i<n;i++)\r\n    {\r\n        cin>>arr[i];\r\n    }\r\n    quickSort(arr, 0, n - 1);\r\n    printArray(arr, n);\r\n    return 0;\r\n}\r\n', 0, '1 2000', '2000 \n', 'There are many different versions of quickSort that pick pivot in different ways.\r\nAlways pick first element as pivot.\r\nAlways pick last element as pivot.\r\nPick a random element as pivot.\r\nPick median as pivot.\r\n\r\nThe key process in quickSort is partition(). Target of partitions is, given an array and an element x of array as pivot, put x at its correct position in sorted array and put all smaller elements (smaller than x) before x, and put all greater elements (greater than x) after x. All this should be done in linear time.', '2020-05-25'),
(95, 7, 7601012018, '#include <iostream>\r\n \r\nusing namespace std;\r\n \r\n// A function to merge the two half into a sorted data.\r\nvoid Merge(int *a, int low, int high, int mid)\r\n{\r\n	// We have low to mid and mid+1 to high already sorted.\r\n	int i, j, k, temp[high-low+1];\r\n	i = low;\r\n	k = 0;\r\n	j = mid + 1;\r\n \r\n	// Merge the two parts into temp[].\r\n	while (i <= mid && j <= high)\r\n	{\r\n		if (a[i] < a[j])\r\n		{\r\n			temp[k] = a[i];\r\n			k++;\r\n			i++;\r\n		}\r\n		else\r\n		{\r\n			temp[k] = a[j];\r\n			k++;\r\n			j++;\r\n		}\r\n	}\r\n \r\n	// Insert all the remaining values from i to mid into temp[].\r\n	while (i <= mid)\r\n	{\r\n		temp[k] = a[i];\r\n		k++;\r\n		i++;\r\n	}\r\n \r\n	// Insert all the remaining values from j to high into temp[].\r\n	while (j <= high)\r\n	{\r\n		temp[k] = a[j];\r\n		k++;\r\n		j++;\r\n	}\r\n \r\n \r\n	// Assign sorted data stored in temp[] to a[].\r\n	for (i = low; i <= high; i++)\r\n	{\r\n		a[i] = temp[i-low];\r\n	}\r\n}\r\n \r\n// A function to split array into two parts.\r\nvoid MergeSort(int *a, int low, int high)\r\n{\r\n	int mid;\r\n	if (low < high)\r\n	{\r\n		mid=(low+high)/2;\r\n		// Split the data into two half.\r\n		MergeSort(a, low, mid);\r\n		MergeSort(a, mid+1, high);\r\n \r\n		// Merge them to get sorted output.\r\n		Merge(a, low, high, mid);\r\n	}\r\n}\r\n \r\nint main()\r\n{\r\n	int n, i;\r\n	cin>>n;\r\n \r\n	int arr[n];\r\n	for(i = 0; i < n; i++)\r\n	{\r\n		cin>>arr[i];\r\n	}\r\n \r\n	MergeSort(arr, 0, n-1);\r\n \r\n	// Printing the sorted data.\r\n	for (i = 0; i < n; i++)\r\n     {\r\n         cout<<arr[i]<<\" \";\r\n     }\r\n \r\n	return 0;\r\n}', 10, '', '', 'randomized quick sort', '2020-05-12'),
(96, 3, 4701012018, '#include<stdio.h>\nvoid quicksort(int number[25],int first,int last)\n{\n   int i, j, pivot, temp;\n   if(first<last)\n   {\n      pivot=first;\n      i=first;\n      j=last;\n      while(i<j)\n      {\n         while(number[i]<=number[pivot]&&i<last)\n            i++;\n         while(number[j]>number[pivot])\n            j--;\n         if(i<j)\n         {\n            temp=number[i];\n            number[i]=number[j];\n            number[j]=temp;\n         }\n      }\n      temp=number[pivot];\n      number[pivot]=number[j];\n      number[j]=temp;\n      quicksort(number,first,j-1);\n      quicksort(number,j+1,last);\n   }\n}\nint main()\n{\n   int i, count, number[25];\n   scanf(\"%d\",&count);\n   for(i=0;i<count;i++)\n      scanf(\"%d\",&number[i]);\n   quicksort(number,0,count-1);\n   for(i=0;i<count;i++)\n      printf(\"%d \",number[i]);\n   return 0;\n}\n', 10, '1 2000', '2000 ', 'PARTITION (ARR, BEG, END, LOC)\nStep 1: [INITIALIZE] SET LEFT = BEG, RIGHT = END, LOC = BEG, FLAG =\nStep 2: Repeat Steps 3 to 6 while FLAG =\nStep 3: Repeat while ARR[LOC] <=ARR[RIGHT]\nAND LOC != RIGHT\nSET RIGHT = RIGHT - 1\n[END OF LOOP]\nStep 4: IF LOC = RIGHT\nSET FLAG = 1\nELSE IF ARR[LOC] > ARR[RIGHT]\nSWAP ARR[LOC] with ARR[RIGHT]\nSET LOC = RIGHT\n[END OF IF]\nStep 5: IF FLAG = 0\nRepeat while ARR[LOC] >= ARR[LEFT] AND LOC != LEFT\nSET LEFT = LEFT + 1\n[END OF LOOP]\nStep 6:IF LOC = LEFT\nSET FLAG = 1\nELSE IF ARR[LOC] < ARR[LEFT]\nSWAP ARR[LOC] with ARR[LEFT]\nSET LOC = LEFT\n[END OF IF]\n[END OF IF]\nStep 7: [END OF LOOP]\nStep 8: END\n\nQUICK_SORT (ARR, BEG, END)\nStep 1: IF (BEG < END)\nCALL PARTITION (ARR, BEG, END, LOC)\nCALL QUICKSORT(ARR, BEG, LOC - 1)\nCALL QUICKSORT(ARR, LOC + 1, END)\n[END OF IF]\nStep 2: END\r', '2020-05-25'),
(97, 3, 4601012018, '#include<stdio.h>\nvoid quicksort(int number[25],int first,int last)\n{\n   int i, j, pivot, temp;\n   if(first<last)\n   {\n      pivot=first;\n      i=first;\n      j=last;\n      while(i<j)\n      {\n         while(number[i]<=number[pivot]&&i<last)\n            i++;\n         while(number[j]>number[pivot])\n            j--;\n         if(i<j)\n         {\n            temp=number[i];\n            number[i]=number[j];\n            number[j]=temp;\n         }\n      }\n      temp=number[pivot];\n      number[pivot]=number[j];\n      number[j]=temp;\n      quicksort(number,first,j-1);\n      quicksort(number,j+1,last);\n   }\n}\nint main()\n{\n   int i, count, number[25];\n   scanf(\"%d\",&count);\n   for(i=0;i<count;i++)\n      scanf(\"%d\",&number[i]);\n   quicksort(number,0,count-1);\n   for(i=0;i<count;i++)\n      printf(\"%d \",number[i]);\n   return 0;\n}\n', 10, '1 2000', '2000 ', 'PARTITION (ARR, BEG, END, LOC)\nStep 1: [INITIALIZE] SET LEFT = BEG, RIGHT = END, LOC = BEG, FLAG =\nStep 2: Repeat Steps 3 to 6 while FLAG =\nStep 3: Repeat while ARR[LOC] <=ARR[RIGHT]\nAND LOC != RIGHT\nSET RIGHT = RIGHT - 1\n[END OF LOOP]\nStep 4: IF LOC = RIGHT\nSET FLAG = 1\nELSE IF ARR[LOC] > ARR[RIGHT]\nSWAP ARR[LOC] with ARR[RIGHT]\nSET LOC = RIGHT\n[END OF IF]\nStep 5: IF FLAG = 0\nRepeat while ARR[LOC] >= ARR[LEFT] AND LOC != LEFT\nSET LEFT = LEFT + 1\n[END OF LOOP]\nStep 6:IF LOC = LEFT\nSET FLAG = 1\nELSE IF ARR[LOC] < ARR[LEFT]\nSWAP ARR[LOC] with ARR[LEFT]\nSET LOC = LEFT\n[END OF IF]\n[END OF IF]\nStep 7: [END OF LOOP]\nStep 8: END\n\nQUICK_SORT (ARR, BEG, END)\nStep 1: IF (BEG < END)\nCALL PARTITION (ARR, BEG, END, LOC)\nCALL QUICKSORT(ARR, BEG, LOC - 1)\nCALL QUICKSORT(ARR, LOC + 1, END)\n[END OF IF]\nStep 2: END\r', '2020-05-25');
INSERT INTO `qtos_map` (`ID`, `Q_ID`, `ROLL`, `SUBMISSION`, `SCORE`, `INPUT`, `OP`, `ALGO`, `DATE`) VALUES
(98, 3, 5001012018, '#include<stdio.h>\r\n\r\nint partition(int arr[],int si,int en){\r\nint pivot=arr[si];\r\nint countsmaller=0,i;\r\nfor(i=si+1;i<=en;i++)\r\n    if(arr[i]<=pivot)\r\n    countsmaller++;\r\n\r\n    int pivotindex=si+countsmaller;\r\n    arr[si]=arr[pivotindex];\r\n    arr[pivotindex]=pivot;\r\n\r\n     i=si;\r\n    int j=en;\r\n\r\n    while(i<pivotindex && j>pivotindex){\r\n        if(arr[i]<=pivot)\r\n            i++;\r\n            else if(arr[j]>pivot)\r\n            j--;\r\n        else{\r\n            int temp=arr[i];\r\n            arr[i]=arr[j];\r\n            arr[j]=temp;\r\n            i++;\r\n            j--;\r\n        }\r\n    }\r\n     return pivotindex;\r\n}\r\n\r\nvoid quicksort(int arr[],int i,int j){\r\nif(i<j){\r\nint p=partition(arr,i,j);\r\nquicksort(arr,i,p-1);\r\nquicksort(arr,p+1,j);\r\n}\r\n}\r\n\r\nint main(){\r\nint arr[100],i;\r\nint n;\r\nscanf(\"%d\",&n);\r\nfor(i=0;i<n;i++)\r\nscanf(\"%d\",&arr[i]);\r\nquicksort(arr,0,n-1);\r\nfor(i=0;i<n;i++)\r\n{\r\n    printf(\"%d \",arr[i]);\r\n}\r\nreturn 0;\r\n}', 10, '', '', '', '0000-00-00'),
(99, 3, 7101012018, '#include <iostream>\r\n \r\nusing namespace std;\r\n \r\nvoid Merge(int *a, int low, int high, int mid)\r\n{\r\n	int i, j, k, temp[high-low+1];\r\n	i = low;\r\n	k = 0;\r\n	j = mid + 1;\r\n \r\n	while (i <= mid && j <= high)\r\n	{\r\n		if (a[i] < a[j])\r\n		{\r\n			temp[k] = a[i];\r\n			k++;\r\n			i++;\r\n		}\r\n		else\r\n		{\r\n			temp[k] = a[j];\r\n			k++;\r\n			j++;\r\n		}\r\n	}\r\n \r\n	while (i <= mid)\r\n	{\r\n		temp[k] = a[i];\r\n		k++;\r\n		i++;\r\n	}\r\n \r\n	while (j <= high)\r\n	{\r\n		temp[k] = a[j];\r\n		k++;\r\n		j++;\r\n	}\r\n \r\n \r\n	\r\n	for (i = low; i <= high; i++)\r\n	{\r\n		a[i] = temp[i-low];\r\n	}\r\n}\r\n \r\nvoid MergeSort(int *a, int low, int high)\r\n{\r\n	int mid;\r\n	if (low < high)\r\n	{\r\n		mid=(low+high)/2;\r\n		MergeSort(a, low, mid);\r\n		MergeSort(a, mid+1, high);\r\n \r\n		Merge(a, low, high, mid);\r\n	}\r\n}\r\n \r\nint main()\r\n{\r\n	int n, i;\r\n	cin>>n;\r\n \r\n	int arr[n];\r\n	for(i = 0; i < n; i++)\r\n	{\r\n		cin>>arr[i];\r\n	}\r\n \r\n	MergeSort(arr, 0, n-1);\r\n \r\n	for (i = 0; i < n; i++)\r\n     {\r\n         cout<<arr[i]<<\" \";\r\n     }\r\n \r\n	return 0;\r\n}', 10, '', '', '', '0000-00-00'),
(100, 7, 5001012018, '#include <stdlib.h>\r\n#include<stdio.h>\r\n#include<math.h>\r\nvoid quicksort(int *ar,int start,int end);      \r\nint  divide(int *ar,int start,int end,int pivot);\r\n\r\nvoid main(){\r\n        int size;\r\n        int itr;\r\n     \r\n        scanf(\"%d\",&size);\r\n        int a[size];\r\n        for(itr=0;itr<size;itr++){\r\n    \r\n    scanf(\"%d\",&a[itr]);\r\n        }\r\n        quicksort(a,0,size-1);\r\n    for(itr=0;itr<size;itr++)\r\n    {\r\n        if(itr!=size-1)\r\n        printf(\"%d \",a[itr]);\r\n        else\r\n          printf(\"%d\",a[itr]);\r\n        \r\n    }\r\n\r\n}\r\n\r\nvoid quicksort(int *ar,int start,int end){\r\n        if(start < end) {\r\n        int pivot = start;\r\n            pivot = rand() % (end - start) + start ;\r\n            pivot = divide(ar,start,end,pivot);\r\n            quicksort(ar,start,pivot-1);\r\n            quicksort (ar,pivot+1,end);\r\n    }\r\n}      \r\nint  divide(int *ar,int start,int end,int pivot){\r\n        int itr,temp,next,next1;\r\n        temp =ar[pivot];\r\n        ar[pivot]=ar[start]; \r\n        ar[start]=temp;\r\n        pivot =start;\r\n        next =start+1;\r\n        while(next<=end){\r\n                if(ar[next]<ar[pivot]){\r\n                        temp = ar[next];\r\n            next1 = next;\r\n                        while(next1!=pivot+1){\r\n                               ar[next1]=ar[next1-1];\r\n                                next1--;\r\n                        }\r\n                        ar[next1]=ar[pivot];\r\n                        ar[pivot]=temp;\r\n                        pivot++;\r\n                }\r\n            next++;\r\n    }\r\nreturn pivot;   \r\n}', 10, '', '', '', '0000-00-00'),
(101, 7, 6001012018, '#include<stdio.h>\r\n#include<math.h>\r\n#include<stdlib.h>\r\nvoid quicksort(int *ar,int start,int end);      \r\nint  divide(int *ar,int start,int end,int pivot);\r\n\r\nvoid main(){\r\n        int size;\r\n        int itr;\r\n        scanf(\"%d\",&size);\r\n        int a[size];\r\n        for(itr=0;itr<size;itr++){\r\n        scanf(\"%d\",&a[itr]);\r\n        }\r\n        quicksort(a,0,size-1);\r\n    for(itr=0;itr<size;itr++)\r\n     if(itr==size-1)\r\n     printf(\"%d\",a[itr]);\r\n     else\r\n     printf(\"%d \",a[itr]);\r\n\r\n}\r\n\r\nvoid quicksort(int *ar,int start,int end){\r\n        if(start < end) {\r\n        int pivot = start;\r\n            pivot = rand() % (end - start) + start ;\r\n            pivot = divide(ar,start,end,pivot);\r\n            quicksort(ar,start,pivot-1);\r\n            quicksort (ar,pivot+1,end);\r\n    }\r\n}      \r\nint  divide(int *ar,int start,int end,int pivot){\r\n        int itr,temp,next,next1;\r\n        temp =ar[pivot];\r\n        ar[pivot]=ar[start]; \r\n        ar[start]=temp;\r\n        pivot =start;\r\n        next =start+1;\r\n        while(next<=end){\r\n                if(ar[next]<ar[pivot]){\r\n                        temp = ar[next];\r\n            next1 = next;\r\n                        while(next1!=pivot+1){\r\n                               ar[next1]=ar[next1-1];\r\n                                next1--;\r\n                        }\r\n                        ar[next1]=ar[pivot];\r\n                        ar[pivot]=temp;\r\n                        pivot++;\r\n                }\r\n            next++;\r\n    }\r\nreturn pivot;   \r\n}', 10, '', '', '', '0000-00-00'),
(102, 3, 6301012018, '#include <bits/stdc++.h> \r\nusing namespace std;  \r\n  \r\n// A utility function to swap two elements  \r\nvoid swap(int* a, int* b)  \r\n{  \r\n    int t = *a;  \r\n    *a = *b;  \r\n    *b = t;  \r\n}  \r\n  \r\n\r\nint partition (int arr[], int low, int high)  \r\n{  \r\n    int pivot = arr[high]; // pivot  \r\n    int i = (low - 1); // Index of smaller element  \r\n  \r\n    for (int j = low; j <= high - 1; j++)  \r\n    {  \r\n        // If current element is smaller than the pivot  \r\n        if (arr[j] < pivot)  \r\n        {  \r\n            i++; // increment index of smaller element  \r\n            swap(&arr[i], &arr[j]);  \r\n        }  \r\n    }  \r\n    swap(&arr[i + 1], &arr[high]);  \r\n    return (i + 1);  \r\n}  \r\n \r\nvoid quickSort(int arr[], int low, int high)  \r\n{  \r\n    if (low < high)  \r\n    {  \r\n       \r\n        int pi = partition(arr, low, high);  \r\n  \r\n        quickSort(arr, low, pi - 1);  \r\n        quickSort(arr, pi + 1, high);  \r\n    }  \r\n}  \r\n  \r\nvoid printArray(int arr[], int size)  \r\n{  \r\n    int i;  \r\n    for (i = 0; i < size; i++)  \r\n        cout << arr[i] << \" \";  \r\n\r\n}  \r\n  \r\n// Driver Code \r\nint main()  \r\n{  \r\n\r\n	int n;\r\n	cin>>n;\r\n	int arr[n];\r\n	for(int i=0;i<n;i++)\r\n	{\r\n	cin>>arr[i];\r\n	} \r\n    quickSort(arr, 0, n - 1);  \r\n    printArray(arr, n);  \r\n    return 0;  \r\n}', 10, '1 2000', '2000 ', 'quickSort(arr[], low, high)\r\n{\r\n	if (low < high)\r\n	{\r\n    	\r\n    	pi = partition(arr, low, high);\r\n \r\n    	quickSort(arr, low, pi - 1);  // Before pi\r\n    	quickSort(arr, pi + 1, high); // After pi\r\n	}\r\n}\r\nPseudo code for partition()\r\n \r\npartition (arr[], low, high)\r\n{\r\n    	pivot = arr[high]; \r\n \r\n	i = (low – 1)\r\n	for (j = low; j <= high- 1; j++)\r\n	{\r\n            	if (arr[j] < pivot)\r\n    	{\r\n        	i++;	\r\n        	swap arr[i] and arr[j]\r\n    	}\r\n	}\r\n	swap arr[i + 1] and arr[high])\r\n	return (i + 1)\r\n}\r\n', '2020-05-25'),
(103, 3, 6601012018, '#include<iostream>\r\nusing namespace std;\r\nvoid swap(int* a, int* b)  \r\n{  \r\n    int t = *a;  \r\n    *a = *b;  \r\n    *b = t;  \r\n}  \r\nint partition (int arr[], int low, int high)  \r\n{  \r\n    int pivot = arr[high]; \r\n    int i = (low - 1); \r\n    for (int j=low;j<=high-1;j++)  \r\n    {  \r\n        if (arr[j]<=pivot)  \r\n        {  \r\n            i++;   \r\n            swap(&arr[i], &arr[j]);  \r\n        }  \r\n    }  \r\n    swap(&arr[i+1],&arr[high]);  \r\n    return (i+1);  \r\n}  \r\nvoid quickSort(int arr[], int low, int high)  \r\n{  \r\n    if (low < high)  \r\n    {  \r\n    \r\n        int pi = partition(arr, low, high);  \r\n        quickSort(arr, low, pi - 1);  \r\n        quickSort(arr, pi, high);  \r\n    }  \r\n}  \r\nvoid printArray(int arr[], int size)  \r\n{  \r\n    for (int i=0;i<size;i++)\r\n    {\r\n        cout<<arr[i]<<\" \";\r\n    }\r\n}  \r\nint main()\r\n{\r\n   int n;\r\n   cin>>n;\r\n   int a[n];\r\n   for(int i=0;i<n;i++)\r\n   {\r\n       cin>>a[i];\r\n   }\r\n   quickSort(a,0,n-1);\r\n   printArray(a,n);\r\n}', 10, '1 2000', '2000 ', 'quickSort(arr[], low, high)\r\n{\r\n    if (low < high)\r\n    {\r\n        /* pi is partitioning index, arr[pi] is now\r\n           at right place */\r\n        pi = partition(arr, low, high);\r\n\r\n        quickSort(arr, low, pi - 1);  // Before pi\r\n        quickSort(arr, pi + 1, high); // After pi\r\n    }\r\n}', '2020-05-25'),
(104, 7, 6201012018, '#include <cstdlib>\r\n#include <iostream>\r\nusing namespace std;\r\n\r\nint partition(int arr[], int low, int high)\r\n{\r\n int pivot = arr[low];\r\n int i = low - 1, j = high + 1;\r\n\r\n while (true) {\r\n\r\n\r\n do {\r\n i++;\r\n } while (arr[i] < pivot);\r\n do {\r\n j--;\r\n } while (arr[j] > pivot);\r\n\r\n if (i >= j)\r\n return j;\r\n\r\n swap(arr[i], arr[j]);\r\n }\r\n}\r\n\r\nint partition_r(int arr[], int low, int high)\r\n{\r\n\r\n int random = low + rand() % (high - low);\r\n\r\n swap(arr[random], arr[low]);\r\n\r\n return partition(arr, low, high);\r\n}\r\n\r\nvoid quickSort(int arr[], int low, int high)\r\n{\r\n if (low < high) {\r\n\r\n int pi = partition_r(arr, low, high);\r\n\r\n quickSort(arr, low, pi);\r\n quickSort(arr, pi + 1, high);\r\n }\r\n}\r\n\r\n\r\n\r\nvoid printArray(int arr[], int n)\r\n{\r\n for (int i = 0; i < n; i++)\r\n cout<< arr[i]<<\" \";\r\n\r\n}\r\n\r\nint main()\r\n{\r\n int no;\r\n cin >> no;\r\n int arr[no];\r\n for(int i =0; i< no; i++){\r\n int elem;\r\n cin>> elem;\r\n arr[i] = elem;\r\n }\r\n int n = sizeof(arr) / sizeof(arr[0]);\r\n quickSort(arr, 0, n - 1);\r\n printArray(arr, n);\r\n return 0;\r\n}\r\n\r\n', 8, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', '﻿procedure mergesort( var a as array )\r\n   if ( n == 1 ) return a\r\n\r\n\r\n   var l1 as array = a[0] ... a[n/2]\r\n   var l2 as array = a[n/2+1] ... a[n]\r\n\r\n\r\n   l1 = mergesort( l1 )\r\n   l2 = mergesort( l2 )\r\n\r\n\r\n   return merge( l1, l2 )\r\nend procedure\r\n\r\n\r\nprocedure merge( var a as array, var b as array )\r\n\r\n\r\n   var c as array\r\n   while ( a and b have elements )\r\n      if ( a[0] > b[0] )\r\n         add b[0] to the end of c\r\n         remove b[0] from b\r\n      else\r\n         add a[0] to the end of c\r\n         remove a[0] from a\r\n      end if\r\n   end while\r\n   \r\n   while ( a has elements )\r\n      add a[0] to the end of c\r\n      remove a[0] from a\r\n   end while\r\n   \r\n   while ( b has elements )\r\n      add b[0] to the end of c\r\n      remove b[0] from b\r\n   end while\r\n   \r\n   return c\r\n        \r\nend procedure', '2020-05-25'),
(106, 12, 4701012018, '#include <iostream> \nusing namespace std; \nclass Edge \n{ \n    public: \n    int src, dest, weight; \n}; \nclass Graph \n{ \n    public: \n    int V, E; \n    Edge* edge; \n}; \nGraph* createGraph(int V, int E) \n{ \n    Graph* graph = new Graph; \n    graph->V = V; \n    graph->E = E; \n    graph->edge = new Edge[E]; \n    return graph; \n} \nclass subset \n{ \n    public: \n    int parent; \n    int rank; \n}; \nint find(subset subsets[], int i) \n{ \n    if (subsets[i].parent != i) \n        subsets[i].parent = find(subsets, subsets[i].parent); \n    return subsets[i].parent; \n} \nvoid Union(subset subsets[], int x, int y) \n{ \n    int xroot = find(subsets, x); \n    int yroot = find(subsets, y); \n    if (subsets[xroot].rank < subsets[yroot].rank) \n        subsets[xroot].parent = yroot; \n    else if (subsets[xroot].rank > subsets[yroot].rank) \n        subsets[yroot].parent = xroot; \n    else\n    { \n        subsets[yroot].parent = xroot; \n        subsets[xroot].rank++; \n    } \n} \nint myComp(const void* a, const void* b) \n{ \n    Edge* a1 = (Edge*)a; \n    Edge* b1 = (Edge*)b; \n    return a1->weight > b1->weight; \n} \nvoid KruskalMST(Graph* graph) \n{ \n    int V = graph->V; \n    Edge result[V]; \n    int e = 0; \n    int i = 0; \n    qsort(graph->edge, graph->E, sizeof(graph->edge[0]), myComp); \n    subset *subsets = new subset[( V * sizeof(subset) )]; \n    for (int v = 0; v < V; ++v) \n    { \n        subsets[v].parent = v; \n        subsets[v].rank = 0; \n    } \n    while (e < V - 1 && i < graph->E) \n    { \n        Edge next_edge = graph->edge[i++]; \n        int x = find(subsets, next_edge.src); \n        int y = find(subsets, next_edge.dest); \n        if (x != y) \n        { \n            result[e++] = next_edge; \n            Union(subsets, x, y); \n        } \n    } \n    cout<<\"Following are the edges in the constructed MST\n\"; \n    for (i = 0; i < e; ++i) \n        cout<<result[i].src<<\" -- \"<<result[i].dest<<\" ==> \"<<result[i].weight<<endl; \n    return; \n} \nint main() \n{ \n    int V = 4; \n    int E = 5; \n    Graph* graph = createGraph(V, E); \n    graph->edge[0].src = 0; \n    graph->edge[0].dest = 1; \n    graph->edge[0].weight = 10; \n    graph->edge[1].src = 0; \n    graph->edge[1].dest = 2; \n    graph->edge[1].weight = 6; \n    graph->edge[2].src = 0; \n    graph->edge[2].dest = 3; \n    graph->edge[2].weight = 5; \n    graph->edge[3].src = 1; \n    graph->edge[3].dest = 3; \n    graph->edge[3].weight = 15; \n    graph->edge[4].src = 2; \n    graph->edge[4].dest = 3; \n    graph->edge[4].weight = 4; \n    KruskalMST(graph); \n    return 0; \n} \n\n', 1000, '', '', '1. Sort all the edges in non-decreasing order of their weight.\r\n2. Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If cycle is not formed, include this edge. Else, discard it.\r\n3. Repeat step#2 until there are (V-1) edges in the spanning tree.', '2020-05-25'),
(108, 7, 6301012018, '\r\nimport java.lang.*; \r\nimport java.util.*; \r\nclass Main{ public static void random(int low,int high,int []arr) \r\n{ Random rand= new Random(); int pivot = rand.nextInt(high-low) + low; \r\nint temp1=arr[pivot]; arr[pivot]=arr[high]; arr[high]=temp1; } \r\npublic static int partition(int arr[], int low, int high) { int pivot = arr[high]; int i = (low-1); \r\nfor (int j = low; j < high; j++) { if (arr[j] <= pivot) { i++; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } }\r\nint temp = arr[i+1]; arr[i+1] = arr[high]; arr[high] = temp; return i+1; } public static void sort(int arr[], int low, int high) \r\n{ if (low < high) { int pi = partition(arr, low, high); sort(arr, low, pi-1); sort(arr, pi+1, high); } } static void printArray(int arr[]) \r\n{ int n = arr.length; for (int i = 0; i < n; ++i) System.out.print(arr[i]+\" \"); } public static void main(String[]args){ \r\n    Scanner s=new Scanner(System.in); int n=s.nextInt(); int []arr=new int[n]; for(int i=0;i<n;i++)arr[i]=s.nextInt(); sort(arr,0,n-1); \r\n    printArray(arr); } }\r\n\r\n \r\n\r\n \r\n\r\n', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', '', '0000-00-00'),
(109, 8, 5001012018, '#include<iostream>\r\n#include<vector>\r\n#include<cmath>\r\n#include<algorithm>\r\nusing namespace std;\r\n\r\nint nextpowerof2(int k)\r\n{\r\n    return pow(2, int(ceil(log2(k))));\r\n}\r\nvoid display(vector<vector<int> > &matrix, int m, int n)\r\n{\r\n    for (int i = 0; i < m; i++)\r\n    {\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            if (j != 0)\r\n            {\r\n                cout <<\" \";\r\n            }\r\n            cout << matrix[i][j];\r\n        }\r\n        cout << \" \";\r\n    }\r\n}\r\n\r\nvoid add(vector<vector<int> > &A, vector<vector<int> > &B, vector<vector<int> > &C, int size)\r\n{\r\n    int i, j;\r\n\r\n    for (i = 0; i < size; i++)\r\n    {\r\n        for (j = 0; j < size; j++)\r\n        {\r\n            C[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid sub(vector<vector<int> > &A, vector<vector<int> > &B, vector<vector<int> > &C, int size)\r\n{\r\n    int i, j;\r\n\r\n    for (i = 0; i < size; i++)\r\n    {\r\n        for (j = 0; j < size; j++)\r\n        {\r\n            C[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid STRASSEN_algorithmA(vector<vector<int> > &A, vector<vector<int> > &B, vector<vector<int> > &C, int size)\r\n{\r\n    if (size == 1)\r\n    {\r\n        C[0][0] = A[0][0] * B[0][0];\r\n        return;\r\n    }\r\n    else\r\n    {\r\n        int new_size = size / 2;\r\n        vector<int> z(new_size);\r\n        vector<vector<int> >\r\n            a11(new_size, z), a12(new_size, z), a21(new_size, z), a22(new_size, z),\r\n            b11(new_size, z), b12(new_size, z), b21(new_size, z), b22(new_size, z),\r\n            c11(new_size, z), c12(new_size, z), c21(new_size, z), c22(new_size, z),\r\n            p1(new_size, z), p2(new_size, z), p3(new_size, z), p4(new_size, z),\r\n            p5(new_size, z), p6(new_size, z), p7(new_size, z),\r\n            aResult(new_size, z), bResult(new_size, z);\r\n\r\nint i, j;\r\nfor (i = 0; i < new_size; i++)\r\n        {\r\n            for (j = 0; j < new_size; j++)\r\n            {\r\n                a11[i][j] = A[i][j];\r\n                a12[i][j] = A[i][j + new_size];\r\n                a21[i][j] = A[i + new_size][j];\r\n                a22[i][j] = A[i + new_size][j + new_size];\r\n\r\n                b11[i][j] = B[i][j];\r\n                b12[i][j] = B[i][j + new_size];\r\n                b21[i][j] = B[i + new_size][j];\r\n                b22[i][j] = B[i + new_size][j + new_size];\r\n            }\r\n}\r\n\r\n        add(a11, a22, aResult, new_size);\r\n        add(b11, b22, bResult, new_size);\r\n        STRASSEN_algorithmA(aResult, bResult, p1, new_size);\r\n\r\n        add(a21, a22, aResult, new_size);\r\n        STRASSEN_algorithmA(aResult, b11, p2, new_size);\r\n\r\n        sub(b12, b22, bResult, new_size);\r\n        STRASSEN_algorithmA(a11, bResult, p3, new_size);\r\n\r\n\r\n        sub(b21, b11, bResult, new_size);\r\n        STRASSEN_algorithmA(a22, bResult, p4, new_size);\r\n        add(a11, a12, aResult, new_size);\r\n        STRASSEN_algorithmA(aResult, b22, p5, new_size);\r\n\r\n        sub(a21, a11, aResult, new_size);\r\n        add(b11, b12, bResult, new_size);\r\n        STRASSEN_algorithmA(aResult, bResult, p6, new_size);\r\n\r\n        sub(a12, a22, aResult, new_size);\r\n        add(b21, b22, bResult, new_size);\r\n        STRASSEN_algorithmA(aResult, bResult, p7, new_size);\r\n\r\n        add(p3, p5, c12, new_size);\r\n        add(p2, p4, c21, new_size);\r\n\r\n        add(p1, p4, aResult, new_size);\r\n        add(aResult, p7, bResult, new_size);\r\n        sub(bResult, p5, c11, new_size);\r\n\r\n        add(p1, p3, aResult, new_size);\r\n        add(aResult, p6, bResult, new_size);\r\n        sub(bResult, p2, c22, new_size);\r\n        for (i = 0; i < new_size; i++)\r\n        {\r\n            for (j = 0; j < new_size; j++)\r\n            {\r\n                C[i][j] = c11[i][j];\r\n                C[i][j + new_size] = c12[i][j];\r\n                C[i + new_size][j] = c21[i][j];\r\n                C[i + new_size][j + new_size] = c22[i][j];\r\n            }\r\n        }\r\n    }\r\n}\r\nvoid STRASSEN_algorithm(vector<vector<int> > &A, vector<vector<int> > &B, int m, int n, int a, int b)\r\n{\r\n    int c1=std::max(a,b);\r\n    int c2=std::max(c1,m);\r\n    int c3=std::max(c1,n);\r\n    int k = c3;\r\n\r\n    int s = nextpowerof2(k);\r\n\r\n    vector<int> z(s);\r\n    vector<vector<int> > Aa(s,z),Bb(s,z),Cc(s,z);\r\n\r\n    for (unsigned int i = 0; i < m; i++)\r\n    {\r\n        for (unsigned int j = 0; j < n; j++)\r\n        {\r\n            Aa[i][j] = A[i][j];\r\n        }\r\n    }\r\n    for (unsigned int i = 0; i < a; i++)\r\n    {\r\n        for (unsigned int j = 0; j < b; j++)\r\n        {\r\n            Bb[i][j] = B[i][j];\r\n        }\r\n    }\r\n    STRASSEN_algorithmA(Aa,Bb,Cc,s);\r\n    vector<int> temp1(b);\r\n    vector<vector<int> > C(m, temp1);\r\n    for (unsigned int i = 0; i < m; i++)\r\n    {\r\n        for (unsigned int j = 0; j < b; j++)\r\n        {\r\n            C[i][j] = Cc[i][j];\r\n        }\r\n    }\r\n    display(C, m, b);\r\n}\r\n\r\nbool check(int n, int a)\r\n{\r\n    if (n == a)\r\n        return true;\r\n    else\r\n        return false;\r\n}\r\n\r\nint main()\r\n{\r\n    int n, a, b;\r\n    cin >> n;\r\n\r\n    vector<vector<int> > A;\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        vector<int> temp;\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            int i;\r\n            cin >> i;\r\n            temp.push_back(i);\r\n        }\r\n        A.push_back(temp);\r\n    }\r\n\r\n    vector<vector<int> > B;\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        vector<int> temp;\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            int i;\r\n            cin >> i;\r\n            temp.push_back(i);\r\n        }\r\n        B.push_back(temp);\r\n    }\r\n\r\n\r\n        STRASSEN_algorithm(A,B,n,n,n,n);\r\n\r\n    return 0;\r\n}\r\n\r\n', 0, '', '', 'Algorithm\r\n1) Create a set mstSet that keeps track of vertices already included in MST.\r\n2) Assign a key value to all vertices in the input graph. Initialize all key values as INFINITE. Assign key value as 0 for the first vertex so that it is picked first.\r\n3) While mstSet doesn?t include all vertices\r\n?.a) Pick a vertex u which is not there in mstSet and has minimum key value.\r\n?.b) Include u to mstSet.\r\n?.c) Update key value of all adjacent vertices of u. To update the key values, iterate through all adjacent vertices. For every adjacent vertex v, if weight of edge u-v is less than the previous key value of v, update the key value as weight of u-v.', '2020-05-25'),
(110, 12, 5101012018, '#include <iostream> \r\nusing namespace std; \r\nclass Edge \r\n{ \r\n    public: \r\n    int src, dest, weight; \r\n}; \r\nclass Graph \r\n{ \r\n    public: \r\n    int V, E; \r\n    Edge* edge; \r\n}; \r\nGraph* createGraph(int V, int E) \r\n{ \r\n    Graph* graph = new Graph; \r\n    graph->V = V; \r\n    graph->E = E; \r\n    graph->edge = new Edge[E]; \r\n    return graph; \r\n} \r\nclass subset \r\n{ \r\n    public: \r\n    int parent; \r\n    int rank; \r\n}; \r\nint find(subset subsets[], int i) \r\n{ \r\n    if (subsets[i].parent != i) \r\n        subsets[i].parent = find(subsets, subsets[i].parent); \r\n    return subsets[i].parent; \r\n} \r\nvoid Union(subset subsets[], int x, int y) \r\n{ \r\n    int xroot = find(subsets, x); \r\n    int yroot = find(subsets, y); \r\n    if (subsets[xroot].rank < subsets[yroot].rank) \r\n        subsets[xroot].parent = yroot; \r\n    else if (subsets[xroot].rank > subsets[yroot].rank) \r\n        subsets[yroot].parent = xroot; \r\n    else\r\n    { \r\n        subsets[yroot].parent = xroot; \r\n        subsets[xroot].rank++; \r\n    } \r\n} \r\nint myComp(const void* a, const void* b) \r\n{ \r\n    Edge* a1 = (Edge*)a; \r\n    Edge* b1 = (Edge*)b; \r\n    return a1->weight > b1->weight; \r\n} \r\nvoid KruskalMST(Graph* graph) \r\n{ \r\n    int V = graph->V; \r\n    Edge result[V]; \r\n    int e = 0; \r\n    int i = 0; \r\n    qsort(graph->edge, graph->E, sizeof(graph->edge[0]), myComp); \r\n    subset *subsets = new subset[( V * sizeof(subset) )]; \r\n    for (int v = 0; v < V; ++v) \r\n    { \r\n        subsets[v].parent = v; \r\n        subsets[v].rank = 0; \r\n    } \r\n    while (e < V - 1 && i < graph->E) \r\n    { \r\n        Edge next_edge = graph->edge[i++]; \r\n        int x = find(subsets, next_edge.src); \r\n        int y = find(subsets, next_edge.dest); \r\n        if (x != y) \r\n        { \r\n            result[e++] = next_edge; \r\n            Union(subsets, x, y); \r\n        } \r\n    } \r\n    cout<<\"Following are the edges in the constructed MST\n\"; \r\n    for (i = 0; i < e; ++i) \r\n        cout<<result[i].src<<\" -- \"<<result[i].dest<<\" ==> \"<<result[i].weight<<endl; \r\n    return; \r\n} \r\nint main() \r\n{ \r\n    int V = 4; \r\n    int E = 5; \r\n    Graph* graph = createGraph(V, E); \r\n    graph->edge[0].src = 0; \r\n    graph->edge[0].dest = 1; \r\n    graph->edge[0].weight = 10; \r\n    graph->edge[1].src = 0; \r\n    graph->edge[1].dest = 2; \r\n    graph->edge[1].weight = 6; \r\n    graph->edge[2].src = 0; \r\n    graph->edge[2].dest = 3; \r\n    graph->edge[2].weight = 5; \r\n    graph->edge[3].src = 1; \r\n    graph->edge[3].dest = 3; \r\n    graph->edge[3].weight = 15; \r\n    graph->edge[4].src = 2; \r\n    graph->edge[4].dest = 3; \r\n    graph->edge[4].weight = 4; \r\n    KruskalMST(graph); \r\n    return 0; \r\n}', 1000, '', '', '', '0000-00-00'),
(111, 3, 6101012018, '#include <bits/stdc++.h> \r\nusing namespace std;  \r\n  \r\n  \r\nvoid swap(int* a, int* b)  \r\n{  \r\n    int t = *a;  \r\n    *a = *b;  \r\n    *b = t;  \r\n}  \r\n  \r\nint partition (int arr[], int low, int high)  \r\n{  \r\n    int pivot = arr[high]; \r\n    int i = (low - 1); \r\n  \r\n    for (int j = low; j <= high - 1; j++)  \r\n    {  \r\n        \r\n        if (arr[j] < pivot)  \r\n        {  \r\n            i++;  \r\n            swap(&arr[i], &arr[j]);  \r\n        }  \r\n    }  \r\n    swap(&arr[i + 1], &arr[high]);  \r\n    return (i + 1);  \r\n}  \r\n\r\nvoid quickSort(int arr[], int low, int high)  \r\n{  \r\n    if (low < high)  \r\n    {  \r\n        \r\n        int pi = partition(arr, low, high);  \r\n  \r\n\r\n        \r\n        quickSort(arr, low, pi - 1);  \r\n        quickSort(arr, pi + 1, high);  \r\n    }  \r\n}  \r\n  \r\n\r\nvoid printArray(int arr[], int size)  \r\n{  \r\n    int i;  \r\n    for (i = 0; i < size; i++)  \r\n        cout << arr[i] << \" \";  \r\n      \r\n}  \r\n  \r\n\r\nint main()  \r\n{  \r\n    \r\n    int n;\r\n    cin>>n;\r\n    int arr[n];\r\n    for(int i=0; i<n ; i++)\r\n    {\r\n        cin>>arr[i];\r\n    }\r\n    \r\n    quickSort(arr, 0, n - 1);  \r\n      \r\n    printArray(arr, n);  \r\n    return 0;  \r\n}  \r\n                                            \r\n', 10, '1 2000', '2000 ', 'Quick Sort Algorithm\r\n1. If n < = 1, then return.\r\n \r\n2. Pick any element V in a[]. This is called the pivot.\r\n \r\n3. Rearrange elements of the array by moving all elements xi > V right of V and all elements x?i < = V left of V. If the place of the V after re-arrangement is j, all elements with value less than V, appear in a[0], a[1] . . . . a[j ? 1] and all those with value greater than V appear in a[j + 1] . . . . a[n ? 1].\r\n \r\n4. Apply quick sort recursively to a[0] . . . . a[j ? 1] and to a[j + 1] . . . . a[\r\n', '2020-05-25'),
(112, 12, 7101012018, '#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nclass Edge\r\n{\r\n    public:\r\n    int src, dest, weight;\r\n};\r\nclass Graph\r\n{\r\n    public:\r\n    int V, E;\r\n    Edge* edge;\r\n};\r\n\r\nGraph* createGraph(int V, int E)\r\n{\r\n    Graph* graph = new Graph;\r\n    graph->V = V;\r\n    graph->E = E;\r\n\r\n    graph->edge = new Edge[E];\r\n\r\n    return graph;\r\n}\r\nclass subset\r\n{\r\n    public:\r\n    int parent;\r\n    int rank;\r\n};\r\n\r\n\r\nint find(subset subsets[], int i)\r\n{\r\n    if (subsets[i].parent != i)\r\n        subsets[i].parent = find(subsets, subsets[i].parent);\r\n\r\n    return subsets[i].parent;\r\n}\r\nvoid Union(subset subsets[], int x, int y)\r\n{\r\n    int xroot = find(subsets, x);\r\n    int yroot = find(subsets, y);\r\n    if (subsets[xroot].rank < subsets[yroot].rank)\r\n        subsets[xroot].parent = yroot;\r\n    else if (subsets[xroot].rank > subsets[yroot].rank)\r\n        subsets[yroot].parent = xroot;\r\n\r\n    else\r\n    {\r\n        subsets[yroot].parent = xroot;\r\n        subsets[xroot].rank++;\r\n    }\r\n}\r\nint myComp(const void* a, const void* b)\r\n{\r\n    Edge* a1 = (Edge*)a;\r\n    Edge* b1 = (Edge*)b;\r\n    return a1->weight > b1->weight;\r\n}\r\nvoid KruskalMST(Graph* graph)\r\n{\r\n    int V = graph->V;\r\n    Edge result[V];\r\n    int e = 0;\r\n    int i = 0;\r\n    qsort(graph->edge, graph->E, sizeof(graph->edge[0]), myComp);\r\n\r\n    subset *subsets = new subset[( V * sizeof(subset) )];\r\n\r\n    for (int v = 0; v < V; ++v)\r\n    {\r\n        subsets[v].parent = v;\r\n        subsets[v].rank = 0;\r\n    }\r\n    while (e < V - 1 && i < graph->E)\r\n    {\r\n\r\n        Edge next_edge = graph->edge[i++];\r\n\r\n        int x = find(subsets, next_edge.src);\r\n        int y = find(subsets, next_edge.dest);\r\n\r\n        if (x != y)\r\n        {\r\n            result[e++] = next_edge;\r\n            Union(subsets, x, y);\r\n        }\r\n    }\r\n    for (i = 0; i < e; ++i)\r\n        cout<<result[i].src<<\" -- \"<<result[i].dest<<\" ==> \"<<result[i].weight<<endl;\r\n    return;\r\n}\r\nint main()\r\n{\r\n    int V = 4;\r\n    int E = 5;\r\n    Graph* graph = createGraph(V, E);\r\n    graph->edge[0].src = 0;\r\n    graph->edge[0].dest = 1;\r\n    graph->edge[0].weight = 10;\r\n\r\n    graph->edge[1].src = 0;\r\n    graph->edge[1].dest = 2;\r\n    graph->edge[1].weight = 6;\r\n\r\n    graph->edge[2].src = 0;\r\n    graph->edge[2].dest = 3;\r\n    graph->edge[2].weight = 5;\r\n\r\n    graph->edge[3].src = 1;\r\n    graph->edge[3].dest = 3;\r\n    graph->edge[3].weight = 15;\r\n\r\n    graph->edge[4].src = 2;\r\n    graph->edge[4].dest = 3;\r\n    graph->edge[4].weight = 4;\r\n    cout<<\"(Edge ==> Wt)\n\";\r\n    KruskalMST(graph);\r\n\r\n    return 1;\r\n}\r\n\r\n', 1000, '', '', 'Prefix Codes, means the codes (bit sequences) are assigned in such a way that the code assigned to one character is not the prefix of code assigned to any other character. This is how Huffman Coding makes sure that there is no ambiguity when decoding the generated bitstream.\r\nLet us understand prefix codes with a counter example. Let there be four characters a, b, c and d, and their corresponding variable length codes be 00, 01, 0 and 1. This coding leads to ambiguity because code assigned to c is the prefix of codes assigned to a and b. If the compressed bit stream is 0001, the de-compressed output may be ?cccd? or ?ccb? or ?acd? or ?ab?.\r\n\r\nThere are mainly two major parts in Huffman Coding\r\n1) Build a Huffman Tree from input characters.\r\n2) Traverse the Huffman Tree and assign codes to characters.\r\n\r\nSteps to build Huffman Tree\r\nInput is an array of unique characters along with their frequency of occurrences and output is Huffman Tree.\r\n\r\n1. Create a leaf node for each unique character and build a min heap of all leaf nodes (Min Heap is used as a priority queue. The value of frequency field is used to compare two nodes in min heap. Initially, the least frequent character is at root)\r\n\r\n2. Extract two nodes with the minimum frequency from the min heap.\r\n\r\n3. Create a new internal node with a frequency equal to the sum of the two nodes frequencies. Make the first extracted node as its left child and the other extracted node as its right child. Add this node to the min heap.\r\n\r\n4. Repeat steps#2 and #3 until the heap contains only one node. The remaining node is the root node and the tree is complete.', '2020-05-25'),
(113, 7, 3901012018, 'import java.util.*; \r\n  \r\n class Main  \r\n{  \r\n    public static int N = 5; \r\n    public static int[] arr = new int[N]; \r\n      \r\n    // This Function helps in calculating random  \r\n    // numbers between low(inclusive) and high(inclusive) \r\n    void random(int low,int high) \r\n    { \r\n      \r\n        Random rand= new Random(); \r\n        int pivot = rand.nextInt(high-low) + low; \r\n          \r\n        int temp1=arr[pivot]; \r\n        arr[pivot]=arr[high]; \r\n        arr[high]=temp1; \r\n    } \r\n      \r\n    /* This function takes last element as pivot,  \r\n    places the pivot element at its correct  \r\n    position in sorted array, and places all  \r\n    smaller (smaller than pivot) to left of  \r\n    pivot and all greater elements to right  \r\n    of pivot */\r\n      \r\n    int partition(int arr[], int low, int high)  \r\n    {  \r\n        // pivot is choosen randomly \r\n        int pivot = arr[high];  \r\n      \r\n  \r\n        int i = (low-1); // index of smaller element  \r\n        for (int j = low; j < high; j++)  \r\n        {  \r\n            // If current element is smaller than or  \r\n            // equal to pivot  \r\n            if (arr[j] <= pivot)  \r\n            {  \r\n                i++;  \r\n  \r\n                // swap arr[i] and arr[j]  \r\n                int temp = arr[i];  \r\n                arr[i] = arr[j];  \r\n                arr[j] = temp;  \r\n            }  \r\n        }  \r\n  \r\n        // swap arr[i+1] and arr[high] (or pivot)  \r\n        int temp = arr[i+1];  \r\n        arr[i+1] = arr[high];  \r\n        arr[high] = temp;  \r\n  \r\n        return i+1;  \r\n    }  \r\n  \r\n  \r\n    /* The main function that implements QuickSort()  \r\n    arr[] --> Array to be sorted,  \r\n    low --> Starting index,  \r\n    high --> Ending index */\r\n    void sort(int arr[], int low, int high)  \r\n    {  \r\n        if (low < high)  \r\n        {  \r\n            /* pi is partitioning index, arr[pi] is  \r\n            now at right place */\r\n            int pi = partition(arr, low, high);  \r\n  \r\n            // Recursively sort elements before  \r\n            // partition and after partition  \r\n            sort(arr, low, pi-1);  \r\n            sort(arr, pi+1, high);  \r\n        }  \r\n    }  \r\n  \r\n    /* A utility function to print array of size n */\r\n    static void printArray(int arr[])  \r\n    {  \r\n        int n = arr.length;  \r\n        for (int i = 0; i < n; ++i)  \r\n            System.out.print(arr[i]+\" \");  \r\n        System.out.println();  \r\n    }  \r\n  \r\n    // Driver code  \r\n    public static void main(String args[])  \r\n    {  \r\n        Scanner sn = new Scanner(System.in);\r\n        int n = sc.nextInt();\r\n        int[] arr = new int[n];\r\n        for(int i = 0; i<n; i++)\r\n        arr[i] = sc.nextInt();\r\n  \r\n        RandomisedQuickSort ob = new RandomisedQuickSort();  \r\n        ob.sort(arr, 0, n-1);  \r\n  \r\n        System.out.println(\"sorted array\");  \r\n        printArray(arr);  \r\n    }  \r\n}  ', 0, '', '', '', '0000-00-00'),
(114, 8, 6201012018, '#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint nextpowerof2(int k)\n{\n    return pow(2, int(ceil(log2(k))));\n}\nvoid display(vector< vector<int>> &matrix, int m, int n)\n{\n    for (int i = 0; i < m; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (j != 0)\n            {\n                cout <<\" \";\n            }\n            cout << matrix[i][j];\n        }\n        cout << endl;\n    }\n}\n\nvoid add(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n    int i, j;\n\n    for (i = 0; i < size; i++)\n    {\n        for (j = 0; j < size; j++)\n        {\n            C[i][j] = A[i][j] + B[i][j];\n        }\n    }\n}\n\nvoid sub(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n    int i, j;\n\n    for (i = 0; i < size; i++)\n    {\n        for (j = 0; j < size; j++)\n        {\n            C[i][j] = A[i][j] - B[i][j];\n        }\n    }\n}\n\nvoid STRASSEN_algorithmA(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n    if (size == 1)\n    {\n        C[0][0] = A[0][0] * B[0][0];\n        return;\n    }\n    else\n    {\n        int new_size = size / 2;\n        vector<int> z(new_size);\n        vector<vector<int>>\n            a11(new_size, z), a12(new_size, z), a21(new_size, z), a22(new_size, z),\n            b11(new_size, z), b12(new_size, z), b21(new_size, z), b22(new_size, z),\n            c11(new_size, z), c12(new_size, z), c21(new_size, z), c22(new_size, z),\n            p1(new_size, z), p2(new_size, z), p3(new_size, z), p4(new_size, z),\n            p5(new_size, z), p6(new_size, z), p7(new_size, z),\n            aResult(new_size, z), bResult(new_size, z);\n\nint i, j;\nfor (i = 0; i < new_size; i++)\n        {\n            for (j = 0; j < new_size; j++)\n            {\n                a11[i][j] = A[i][j];\n                a12[i][j] = A[i][j + new_size];\n                a21[i][j] = A[i + new_size][j];\n                a22[i][j] = A[i + new_size][j + new_size];\n\n                b11[i][j] = B[i][j];\n                b12[i][j] = B[i][j + new_size];\n                b21[i][j] = B[i + new_size][j];\n                b22[i][j] = B[i + new_size][j + new_size];\n            }\n}\n\n        add(a11, a22, aResult, new_size);\n        add(b11, b22, bResult, new_size);\n        STRASSEN_algorithmA(aResult, bResult, p1, new_size);\n\n        add(a21, a22, aResult, new_size);\n        STRASSEN_algorithmA(aResult, b11, p2, new_size);\n\n        sub(b12, b22, bResult, new_size);\n        STRASSEN_algorithmA(a11, bResult, p3, new_size);\n\n\n        sub(b21, b11, bResult, new_size);\n        STRASSEN_algorithmA(a22, bResult, p4, new_size);\n        add(a11, a12, aResult, new_size);\n        STRASSEN_algorithmA(aResult, b22, p5, new_size);\n\n        sub(a21, a11, aResult, new_size);\n        add(b11, b12, bResult, new_size);\n        STRASSEN_algorithmA(aResult, bResult, p6, new_size);\n\n        sub(a12, a22, aResult, new_size);\n        add(b21, b22, bResult, new_size);\n        STRASSEN_algorithmA(aResult, bResult, p7, new_size);\n\n        add(p3, p5, c12, new_size);\n        add(p2, p4, c21, new_size);\n\n        add(p1, p4, aResult, new_size);\n        add(aResult, p7, bResult, new_size);\n        sub(bResult, p5, c11, new_size);\n\n        add(p1, p3, aResult, new_size);\n        add(aResult, p6, bResult, new_size);\n        sub(bResult, p2, c22, new_size);\n        for (i = 0; i < new_size; i++)\n        {\n            for (j = 0; j < new_size; j++)\n            {\n                C[i][j] = c11[i][j];\n                C[i][j + new_size] = c12[i][j];\n                C[i + new_size][j] = c21[i][j];\n                C[i + new_size][j + new_size] = c22[i][j];\n            }\n        }\n    }\n}\nvoid STRASSEN_algorithm(vector<vector<int>> &A, vector<vector<int>> &B, int m, int n, int a, int b)\n{\n    int k = max({m, n, a, b});\n\n    int s = nextpowerof2(k);\n\n    vector<int> z(s);\n    vector<vector<int>> Aa(s, z), Bb(s, z), Cc(s, z);\n\n    for (unsigned int i = 0; i < m; i++)\n    {\n        for (unsigned int j = 0; j < n; j++)\n        {\n            Aa[i][j] = A[i][j];\n        }\n    }\n    for (unsigned int i = 0; i < a; i++)\n    {\n        for (unsigned int j = 0; j < b; j++)\n        {\n            Bb[i][j] = B[i][j];\n        }\n    }\n    STRASSEN_algorithmA(Aa, Bb, Cc, s);\n    vector<int> temp1(b);\n    vector<vector<int>> C(m, temp1);\n    for (unsigned int i = 0; i < m; i++)\n    {\n        for (unsigned int j = 0; j < b; j++)\n        {\n            C[i][j] = Cc[i][j];\n        }\n    }\n    display(C, m, b);\n}\n\nbool check(int n, int a)\n{\n    if (n == a)\n        return true;\n    else\n        return false;\n}\n\nint main()\n{\n    int n, a, b;\n    cin >> n;\n\n    vector<vector<int>> A;\n    for (int i = 0; i < n; i++)\n    {\n        vector<int> temp;\n        for (int j = 0; j < n; j++)\n        {\n            int i;\n            cin >> i;\n            temp.push_back(i);\n        }\n        A.push_back(temp);\n    }\n\n    vector<vector<int>> B;\n    for (int i = 0; i < n; i++)\n    {\n        vector<int> temp;\n        for (int j = 0; j < n; j++)\n        {\n            int i;\n            cin >> i;\n            temp.push_back(i);\n        }\n        B.push_back(temp);\n    }\n\n\n        STRASSEN_algorithm(A, B, n, n, n, n);\n\n    return 0;\n}\n\n', 0, '', '', 'Algorithm\r\nFollowing are the detailed steps.\r\n \r\nInput: Graph and a source vertex src\r\nOutput: Shortest distance to all vertices from src. If there is a negative weight cycle, then shortest distances are not calculated, negative weight cycle is reported.\r\n \r\n \r\n \r\n \r\n1) This step initializes distances from source to all vertices as infinite and distance to source itself as 0. Create an array dist[] of size |V| with all values as infinite except dist[src] where src is source vertex.\r\n \r\n2) This step calculates shortest distances. Do following |V|-1 times where |V| is the number of vertices in given graph.\r\n…..a) Do following for each edge u-v\r\n………………If dist[v] > dist[u] + weight of edge uv, then update dist[v]\r\n………………….dist[v] = dist[u] + weight of edge uv\r\n \r\n3) This step reports if there is a negative weight cycle in graph. Do following for each edge u-v\r\n……If dist[v] > dist[u] + weight of edge uv, then “Graph contains negative weight cycle”\r\nThe idea of step 3 is, step 2 guarantees shortest distances if graph doesn’t contain negative weight cycle. If we iterate through all edges one more time and get a shorter path for any vertex, then there is a negative weight cycle\r\n', '2020-05-25'),
(115, 10, 5001012018, '#include<stdio.h>\r\n\r\n#include<stdio.h> \r\n#include<limits.h>\r\nint max(int a, int b) { return (a > b)? a : b; } \r\nint knapSack(int W, int wt[], int val[], int n) \r\n{ \r\n   if (n == 0 || W == 0) \r\n       return 0; \r\n   if (wt[n-1] > W) \r\n       return knapSack(W, wt, val, n-1); \r\n  \r\n   else return max( val[n-1] + knapSack(W-wt[n-1], wt, val, n-1), \r\n                    knapSack(W, wt, val, n-1) ); \r\n} \r\n  \r\nint main() \r\n{ \r\n    int n;\r\n    int  W ,i;\r\n    scanf(\"%d\",&n);\r\n    scanf(\"%d\",&W);\r\n    int wt[n],val[n];\r\n    for(i=0;i<n;i++)\r\n    scanf(\"%d\",&val[i]);\r\n    for(i=0;i<n;i++)\r\n    scanf(\"%d\",&wt[i]);\r\n    printf(\"%d\", knapSack(W, wt, val, n)); \r\n    return 0; \r\n}', 10, '', '', '', '0000-00-00'),
(117, 12, 4501012018, '#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\nusing namespace std;\r\n#define edge pair<int,int>\r\nclass Graph {\r\nprivate:\r\n    vector<pair<int, edge> > G;\r\n    vector<pair<int, edge> > T;\r\n    int *parent;\r\n    int V;\r\npublic:\r\n    Graph(int V);\r\n    void AddEdge(int u, int v, int w);\r\n    int find_set(int i);\r\n    void union_set(int u, int v);\r\n    void kruskal();\r\n    void print();\r\n};\r\nGraph::Graph(int V) {\r\n    parent = new int[V];\r\n    for (int i = 0; i < V; i++)\r\n        parent[i] = i;\r\n    G.clear();\r\n    T.clear();\r\n}\r\nvoid Graph::AddEdge(int u, int v, int w) {\r\n    G.push_back(make_pair(w, edge(u, v)));\r\n}\r\nint Graph::find_set(int i) {\r\n    if (i == parent[i])\r\n        return i;\r\n    else\r\n        return find_set(parent[i]);\r\n}\r\nvoid Graph::union_set(int u, int v) {\r\n    parent[u] = parent[v];\r\n}\r\nvoid Graph::kruskal() {\r\n    int i, uRep, vRep;\r\n    sort(G.begin(), G.end());\r\n    for (i = 0; i < G.size(); i++) {\r\n        uRep = find_set(G[i].second.first);\r\n        vRep = find_set(G[i].second.second);\r\n        if (uRep != vRep) {\r\n            T.push_back(G[i]);\r\n            union_set(uRep, vRep);\r\n        }\r\n    }\r\n}\r\nvoid Graph::print() {\r\n    cout << \"Edge :\" << \" Weight\" << endl;\r\n    for (int i = 0; i < T.size(); i++) {\r\n        cout << T[i].second.first << \"---\" << T[i].second.second << \"==>\"<< T[i].first;\r\n        cout << endl;\r\n    }\r\n}\r\nint main() {\r\n    int n,m;\r\n    cout<<\"\nNUMBER OF VERTEX = 4 AND EDGES = 5\n\";\r\n    n=4,m=5;\r\n    Graph g(n);\r\n    cout<<\"\nSOURCE DESTINATION WEIGHT : 0 1 10 0 2 6 0 3 5 1 3 15 2 3 4\n\n\";\r\n\r\n    g.AddEdge(0,1,10);\r\n    g.AddEdge(0,2,6);\r\n    g.AddEdge(0,3,5);\r\n    g.AddEdge(1,3,15);\r\n    g.AddEdge(2,3,4);\r\n    g.kruskal();\r\n    g.print();\r\n    return 0;\r\n}\r\n', 1000, '', '', 'Kruskal\r\n\r\n\n1. Sort all the edges in non-decreasing order of their weight.\n\r\n2. Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If cycle is not formed, include this edge. Else, discard it.\r\n\n3. Repeat step#2 until there are (V-1) edges in the spanning tree.', '2020-05-25'),
(118, 10, 6001012018, '#include<stdio.h> \r\n#include<limits.h>\r\nint max(int a, int b) { return (a > b)? a : b; } \r\nint knapSack(int W, int wt[], int val[], int n) \r\n{ \r\n   if (n == 0 || W == 0) \r\n       return 0; \r\n   if (wt[n-1] > W) \r\n       return knapSack(W, wt, val, n-1); \r\n  \r\n   else return max( val[n-1] + knapSack(W-wt[n-1], wt, val, n-1), \r\n                    knapSack(W, wt, val, n-1) ); \r\n} \r\n  \r\nint main() \r\n{ \r\n    int n;\r\n    int  W ,i;\r\n    scanf(\"%d\",&n);\r\n    scanf(\"%d\",&W);\r\n    int wt[n],val[n];\r\n    for(i=0;i<n;i++)\r\n    scanf(\"%d\",&val[i]);\r\n    for(i=0;i<n;i++)\r\n    scanf(\"%d\",&wt[i]);\r\n    printf(\"%d\", knapSack(W, wt, val, n)); \r\n    return 0; \r\n} ', 10, '', '', '', '0000-00-00'),
(120, 10, 6201012018, '#include<stdio.h> \r\n#include<limits.h>\r\nint max(int a, int b) { return (a > b)? a : b; } \r\nint knapSack(int W, int wt[], int val[], int n) \r\n{ \r\n   if (n == 0 || W == 0) \r\n       return 0; \r\n   if (wt[n-1] > W) \r\n       return knapSack(W, wt, val, n-1); \r\n  \r\n   else return max( val[n-1] + knapSack(W-wt[n-1], wt, val, n-1), \r\n                    knapSack(W, wt, val, n-1) ); \r\n} \r\n  \r\nint main() \r\n{ \r\n    int n;\r\n    int  W ,i;\r\n    scanf(\"%d\",&n);\r\n    scanf(\"%d\",&W);\r\n    int wt[n],val[n];\r\n    for(i=0;i<n;i++)\r\n    scanf(\"%d\",&val[i]);\r\n    for(i=0;i<n;i++)\r\n    scanf(\"%d\",&wt[i]);\r\n    printf(\"%d\", knapSack(W, wt, val, n)); \r\n    return 0; \r\n} ', 10, '', '', '', '0000-00-00');
INSERT INTO `qtos_map` (`ID`, `Q_ID`, `ROLL`, `SUBMISSION`, `SCORE`, `INPUT`, `OP`, `ALGO`, `DATE`) VALUES
(121, 3, 4401012018, '#include <bits/stdc++.h> \r\nusing namespace std;  \r\n   \r\nvoid swap(int* a, int* b)  \r\n{  \r\n    int t = *a;  \r\n    *a = *b;  \r\n    *b = t;  \r\n}  \r\n  \r\nint partition (int arr[], int low, int high)  \r\n{  \r\n    int pivot = arr[high];  \r\n    int i = (low - 1); \r\n  \r\n    for (int j = low; j <= high - 1; j++)  \r\n    {   \r\n        if (arr[j] < pivot)  \r\n        {  \r\n            i++; \r\n            swap(&arr[i], &arr[j]);  \r\n        }  \r\n    }  \r\n    swap(&arr[i + 1], &arr[high]);  \r\n    return (i + 1);  \r\n}  \r\n  \r\nvoid quickSort(int arr[], int low, int high)  \r\n{  \r\n    if (low < high)  \r\n    {  \r\n        int pi = partition(arr, low, high);   \r\n        quickSort(arr, low, pi - 1);  \r\n        quickSort(arr, pi + 1, high);  \r\n    }  \r\n}  \r\n  \r\nvoid printArray(int arr[], int size)  \r\n{  \r\n    int i;  \r\n    for (i = 0; i < size; i++)  \r\n        cout << arr[i] << \" \";  \r\n    cout << endl;  \r\n}  \r\n  \r\nint main()  \r\n{  \r\nint t;\r\ncin>>t;\r\nwhile(t!=0){\r\nint n;\r\ncin>>n;\r\n    int arr[n] ;  \r\n   for(int i=0;i<n;i++){\r\ncin>>arr[i];\r\n}\r\n    quickSort(arr, 0, n - 1);   \r\n    printArray(arr, n);  \r\nt--;\r\n}\r\n    return 0;  \r\n} ', 0, '1 2000', '-2147483648 -1965555704 -1965552300 -1965552300 -1965546372 -1819111024 -1685415528 -1618043508 -1612784164 -1549622880 -1482250844 -1414878808 -1347506772 -1280134736 -1258291019 -1212762700 -1145390664 -1078018628 -1010646592 -1010646592 -943274556 -943274556 -875902520 -875902520 -808530484 -808530484 -741158448 -741158448 -673786412 -606414376 -606414376 -539042340 -404298268 -336926232 -285211923 -285211923 -201325834 -201325834 -201325834 -201325834 -136915500 -100662789 -100662789 -65622245 -56302016 -52566220 -2 -2 -2 -2 -2 -2 -2 -2 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 2 2 2 2 3 3 3 3 3 3 3 4 4 5 5 5 5 5 5 5 5 5 8 8 8 8 8 8 10 10 14 16 16 17 20 24 24 24 28 28 28 28 28 28 32 32 36 36 40 40 44 49 50 50 63 64 115 116 116 127 127 127 127 127 127 128 191 224 244 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 257 257 319 348 372 502 502 512 512 512 512 512 512 532 744 744 1024 1024 1252 1252 1528 1703 2000 2047 2048 2048 2048 2056 2152 2152 2152 2152 4096 4096 8016 12600 15352 52428 52428 65568 65568 131097 196610 196610 327684 327684 458758 458758 491520 589832 589832 720906 720906 851980 851980 983054 983054 983054 983054 1114128 1114128 1245202 1245202 1376276 1376276 1507350 1507350 1638424 1638424 1769498 1769498 1900572 1900572 2031646 2031646 2162720 2162720 2293794 2293794 2337547 2337547 2337547 2337579 2424868 2424868 2555942 2555942 2681284 2681316 2681324 2681364 2681364 2682024 2682076 2682100 2682308 2682308 2682340 2682388 2682412 2682420 2682420 2682464 2682464 2682488 2682544 2682588 2682604 2682636 2682692 2682728 2682768 2682776 2682776 2682776 2682776 2682776 2682776 2683040 2683052 2683052 2683072 2683072 2683080 2683104 2683164 2683164 2683288 2683304 2683304 2683304 2683784 2683816 2683892 2683892 2683936 2684540 2684540 2684540 2684540 2684673 2684676 2684692 2684696 2684796 2684856 2684908 2685052 2685052 2685116 2685116 2685244 2685296 2685312 2685348 2685352 2685416 2685428 2685492 2685508 2685532 2685556 2685556 2685580 2685668 2685716 2685804 2685896 2685964 2685968 2685996 2686052 2686056 2686148 2686188 2686196 2686240 2686266 2686280 2686296 2686336 2686412 2686475 2686488 2686544 2686588 2686588 2686588 2686588 2686588 2686616 2686647 2686647 2686648 2686648 2686648 2686648 2686648 2686652 2686652 2686652 2686652 2686652 2686652 2686656 2686656 2686680 2686680 2686688 2686916 2687016 2687016 2818090 2818090 2949164 2949164 3080238 3080238 3145774 3145776 3145776 3145777 3145782 3211312 3211312 3211312 3211312 3342386 3342386 3473460 3473460 3538992 3604534 3604534 3735608 3735608 3866682 3866682 3932218 3997756 3997756 4128830 4128830 4204160 4259904 4259904 4259936 4357448 4357448 4357448 4390978 4390978 4390978 4391004 4391004 4409280 4409280 4420378 4420378 4420378 4429840 4522052 4522052 4522052 4548674 4653126 4653126 4653126 4699174 4699230 4784200 4784200 4784200 4915274 4915274 4915274 4940344 5006368 5006368 5006368 5006368 5006368 5007456 5007616 5007616 5007616 5007624 5007624 5007624 5007624 5007624 5007624 5007624 5007624 5007624 5007624 5007624 5008896 5011372 5011372 5046348 5046348 5046348 5111900 5177422 5177422 5177422 5308496 5308496 5308496 5374044 5439570 5439570 5439570 5439580 5439596 5505024 5505024 5505024 5505024 5505024 5505024 5505024 5505024 5505024 5505024 5505024 5505024 5505024 5505024 5505024 5505024 5505024 5505024 5505024 5505024 5505024 5505220 5505220 5505220 5505220 5505220 5505220 5505220 5505280 5505360 5505360 5505360 5505360 5505360 5505360 5505360 5505360 5505360 5505396 5505452 5505452 5505452 5517096 5517096 5517096 5517280 5517280 5517288 5517320 5517320 5517320 5517322 5517323 5517328 5517328 5517328 5519480 5519480 5519480 5519482 5519483 5519488 5519488 5519488 5521376 5521376 5521384 5521384 5521384 5521768 5522520 5522520 5522520 5522584 5525472 5570644 5570644 5570644 5636188 5659304 5664736 5664744 5669488 5669952 5669952 5669960 5672928 5672928 5672936 5672936 5672936 5701718 5701718 5701718 5832792 5832792 5832792 5963866 5963866 6029413 6029433 6094940 6094940 6226014 6226014 6357069 6357088 6488162 6619236 6619250 6674480 6674488 6674488 6674488 6674488 6680552 6750309 6750310 6750318 6815843 6881384 6881395 6881396 7012458 7077999 7143525 7143532 7209065 7209071 7209071 7274563 7274606 7274610 7405680 7471205 7471215 7471220 7471220 7471221 7536745 7536748 7536754 7602277 7602286 7602286 7602291 7667828 7798902 7929939 7929976 8061018 8061050 8126464 8126464 8126464 8126464 8126464 8126464 8126464 8126464 8126464 8126464 8126464 8126464 8126464 8126464 8126464 8126464 8126464 8126660 8126776 8126776 8126800 8126800 8126800 8126800 8126800 8126800 8126800 8126800 8126800 8126800 8126800 8126800 8126800 8126800 8126876 8128464 8130168 8130168 8130456 8130456 8130456 8130456 8130456 8130480 8130480 8130480 8130480 8130488 8130488 8130500 8130688 8130688 8130688 8130688 8130688 8130688 8130688 8130740 8130740 8131416 8131416 8131456 8131472 8131616 8131644 8133880 8138720 8138728 8138728 8138728 8154896 8154896 8154952 8154956 8172584 8172584 8172592 8172592 8172592 8172592 8172808 8172808 8172811 8172816 8172816 8173040 8173040 8175584 8192124 8192124 8323198 8323198 8462508 8462508 9240914 9240914 9372029 9372029 9437326 10289490 10289491 10551456 10551456 10682530 10682530 10813604 10813604 10944678 10944678 11075752 11075752 11206826 11206826 11337900 11337900 11468974 11468974 11600048 11600048 11731122 11731122 11862196 11862196 11993270 11993270 12124344 12124344 12255418 12255418 12386492 12386492 12517566 12517566 12648640 12648640 12648640 12779714 12779714 12779714 12910788 12910788 12910788 13041862 13041862 13041862 13172936 13172936 13172936 13304010 13304010 13304010 13435084 13435084 13435084 13566158 13566158 13566158 13697232 13697232 13697232 13828306 13828306 13828306 13959380 13959380 13959380 14090454 14090454 14221528 14221528 14221528 14352602 14352602 14352602 14483676 14483676 14483676 14614750 14614750 14745824 14876898 15007972 15139046 15270120 15401194 15532268 15663342 15794416 15925490 16056564 16187606 16187638 16318712 16449786 16580860 16711934 16777218 16777236 16841988 16843510 16892630 22258754 24641758 24641917 24641918 24907384 26288154 26353690 33554944 34603520 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603552 34603592 34603592 34603777 34603777 34603777 34603778 34603778 34603778 34603794 34603794 34865680 34865684 35652096 35652112 35652128 35652128 35652128 35652128 35652128 35652128 35652128 35652128 35652128 35652128 35652128 35652128 35652168 35652353 35652353 35652354 36176424 36176424 36700688 40370720 42205828 42205828 42205828 42205828 42205828 50397186 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397954 50398081 50463008 50463008 50463248 50463489 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463618 51511824 58786320 58786689 58786689 58851856 58852226 58852226 117835012 185207048 214748364 252579084 268435456 319951120 335544340 335544340 335544340 387323156 419430425 419430425 454695192 486604828 522067228 538189843 538189843 538443920 538443920 538714137 538714137 539041824 539041824 539107357 539107357 539369502 539369502 540017350 540017350 540606816 540606816 540672352 540672353 555877084 555877084 589439264 656811300 724183336 791555372 858927408 926299444 993671480 1040187711 1040187711 1061043516 1128415552 1195787588 1263159624 1330531660 1397903696 1465275732 1982665032 1982676780 1982676780 1982686663 1983512832 1983512864 1983512864 1983512864 1985213650 1985221006 1985222306 1985222368 1985222721 1985222812 1985222863 1985222874 1985222874 1985224003 1985224051 1985266611 1985318101 1985648161 1985807616 1985807616 1985816288 1985816832 1985817552 1985821448 1985822848 1985822848 1994614392 1994641687 1994642499 1994774998 1994783654 1994796839 1994796962 1994804248 1994805168 1994805191 1994805615 1994805615 1994805615 1994805615 1994807556 1994807556 1994809056 1999081103 1999081135 1999083527 1999083647 1999083807 1999084447 1999084503 1999085327 1999085447 1999241216 1999323520 1999370794 1999370922 1999370922 1999385338 1999449191 1999449191 1999451250 1999452282 1999452282 1999452282 1999452318 1999452318 1999453226 1999453300 1999453300 1999453300 1999453300 1999453300 1999453347 1999453347 1999453347 1999453347 1999453347 1999453347 1999453347 1999453347 1999453347 1999453347 1999453390 1999453390 1999453390 1999453390 1999483765 1999483765 1999483765 1999483890 1999483890 1999483890 1999646790 1999646825 1999707853 1999707853 1999707853 1999707853 1999707853 1999707853 2130379298 2147483626 2147483647 2147483647 \n', 'partition algo\r\n/* low  --> Starting index,  high  --> Ending index */\r\nquickSort(arr[], low, high)\r\n{\r\n    if (low < high)\r\n    {\r\n        /* pi is partitioning index, arr[pi] is now\r\n           at right place */\r\n        pi = partition(arr, low, high);\r\n\r\n        quickSort(arr, low, pi - 1);  // Before pi\r\n        quickSort(arr, pi + 1, high); // After pi\r\n    }\r\n}', '2020-05-25'),
(122, 13, 4701012018, '#include <iostream>\r\n#include <vector>\r\n#include <queue>\r\n#include <functional>\r\n#include <utility>\r\nusing namespace std;\r\nconst int MAX = 1e4 + 5;\r\ntypedef pair<long long, int> PII;\r\nbool marked[MAX];\r\nvector <PII> adj[MAX];\r\nlong long prim(int x)\r\n{\r\n    priority_queue<PII, vector<PII>, greater<PII> > Q;\r\n    int y;\r\n    long long minimumCost = 0;\r\n    PII p;\r\n    Q.push(make_pair(0, x));\r\n    while(!Q.empty())\r\n    {\r\n        p = Q.top();\r\n        Q.pop();\r\n        x = p.second;\r\n        if(marked[x] == true)\r\n            continue;\r\n        minimumCost += p.first;\r\n        marked[x] = true;\r\n        for(int i = 0;i < adj[x].size();++i)\r\n        {\r\n            y = adj[x][i].second;\r\n            if(marked[y] == false)\r\n                Q.push(adj[x][i]);\r\n        }\r\n    }\r\n    return minimumCost;\r\n}\r\nint main()\r\n{\r\n    int nodes, edges, x, y;\r\n    long long weight, minimumCost;\r\n    cin >> nodes >> edges;\r\n    for(int i = 0;i < edges;++i)\r\n    {\r\n        cin >> x >> y >> weight;\r\n        adj[x].push_back(make_pair(weight, y));\r\n        adj[y].push_back(make_pair(weight, x));\r\n    }\r\n    minimumCost = prim(1);\r\n    cout << minimumCost << endl;\r\n    return 0;\r\n}', 1000, '', '', '1) Create a set mstSet that keeps track of vertices already included in MST.\r\n2) Assign a key value to all vertices in the input graph. Initialize all key values as INFINITE. Assign key value as 0 for the first vertex so that it is picked first.\r\n3) While mstSet doesn’t include all vertices\r\n….a) Pick a vertex u which is not there in mstSet and has minimum key value.\r\n….b) Include u to mstSet.\r\n….c) Update key value of all adjacent vertices of u. To update the key values, iterate through all adjacent vertices. For every adjacent vertex v, if weight of edge u-v is less than the previous key value of v, update the key value as weight of u-v', '2020-05-25'),
(123, 13, 4501012018, '#include <iostream>\r\n#include <vector>\r\n#include <queue>\r\n#include <functional>\r\n#include <utility>\r\n\r\nusing namespace std;\r\nconst int MAX = 1e4 + 5;\r\ntypedef pair<long long, int> PII;\r\nbool marked[MAX];\r\nvector<PII>adj[MAX];\r\n\r\nlong long prim(int x)\r\n{\r\npriority_queue<PII, vector<PII>, greater<PII> > Q;\r\nint y;\r\nlong long minimumCost = 0;\r\n    PII p;\r\nQ.push(make_pair(0, x));\r\nwhile(!Q.empty())\r\n    {\r\n        p = Q.top();\r\nQ.pop();\r\n        x = p.second;\r\nif(marked[x] == true)\r\ncontinue;\r\nminimumCost += p.first;\r\nmarked[x] = true;\r\nfor(int i = 0;i <adj[x].size();++i)\r\n        {\r\n            y = adj[x][i].second;\r\nif(marked[y] == false)\r\nQ.push(adj[x][i]);\r\n        }\r\n    }\r\nreturn minimumCost;\r\n}\r\n\r\nint main()\r\n{\r\nint nodes, edges, x, y;\r\nlong long weight, minimumCost;\r\ncin>> nodes >> edges;\r\nfor(int i = 0;i < edges;++i)\r\n    {\r\ncin>> x >> y >> weight;\r\nadj[x].push_back(make_pair(weight, y));\r\nadj[y].push_back(make_pair(weight, x));\r\n    }\r\nminimumCost = prim(1);\r\ncout<<minimumCost;\r\nreturn 0;\r\n}\r\n', 1000, '', '', 'Prims \nAlgorithm\n\r\n\r\n1) Create a set mstSet that keeps track of vertices already included in MST.\r\n\n2) Assign a key value to all vertices in the input graph. Initialize all key values as INFINITE. Assign key value as 0 for the first vertex so that it is picked first.\r\n\n3) While mstSet doesn?t include all vertices\n\r\n?.a) Pick a vertex u which is not there in mstSet and has minimum key value.\r\n\n?.b) Include u to mstSet.\r\n\n?.c) Update key value of all adjacent vertices of u. To update the key values, iterate through all adjacent vertices. For every adjacent vertex v, if weight of edge u-v is less than the previous key value of v, update the key value as weight of u-v.', '2020-05-25'),
(124, 3, 4001012018, '#include <bits/stdc++.h> \r\nusing namespace std;  \r\n   \r\nvoid swap(int* a, int* b)  \r\n{  \r\n    int t = *a;  \r\n    *a = *b;  \r\n    *b = t;  \r\n}  \r\n  \r\nint partition (int arr[], int low, int high)  \r\n{  \r\n    int pivot = arr[high];  \r\n    int i = (low - 1); \r\n  \r\n    for (int j = low; j <= high - 1; j++)  \r\n    {   \r\n        if (arr[j] < pivot)  \r\n        {  \r\n            i++; \r\n            swap(&arr[i], &arr[j]);  \r\n        }  \r\n    }  \r\n    swap(&arr[i + 1], &arr[high]);  \r\n    return (i + 1);  \r\n}  \r\n  \r\nvoid quickSort(int arr[], int low, int high)  \r\n{  \r\n    if (low < high)  \r\n    {  \r\n        int pi = partition(arr, low, high);   \r\n        quickSort(arr, low, pi - 1);  \r\n        quickSort(arr, pi + 1, high);  \r\n    }  \r\n}  \r\n  \r\nvoid printArray(int arr[], int size)  \r\n{  \r\n    int i;  \r\n    for (i = 0; i < size; i++)  \r\n        cout << arr[i] << \" \";  \r\n    cout << endl;  \r\n}  \r\n  \r\nint main()  \r\n{  \r\nint t;\r\ncin>>t;\r\nwhile(t!=0){\r\nint n;\r\ncin>>n;\r\n    int arr[n] ;  \r\n   for(int i=0;i<n;i++){\r\ncin>>arr[i];\r\n}\r\n    quickSort(arr, 0, n - 1);   \r\n    printArray(arr, n);  \r\nt--;\r\n}\r\n    return 0;  \r\n} ', 0, '1 2000', '-1962933878 -1962933878 -1175125013 -1157627717 -1073741807 -905969462 -905969462 -838860084 -838860084 -838860084 -838860084 -194488364 -194488364 -134217223 -17974607 -17974607 -65536 -688 -367 -190 -187 -183 -2 -2 -2 -2 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 5 5 8 9 9 9 10 10 10 13 14 16 16 16 16 17 17 17 17 18 18 18 18 20 22 22 24 24 24 24 24 24 24 24 24 25 28 28 31 31 31 31 32 32 32 32 32 32 33 44 44 50 63 64 64 64 66 70 80 80 100 100 115 115 115 115 127 127 127 127 127 127 127 127 127 127 127 127 127 127 127 127 127 127 127 127 127 128 128 128 143 160 164 183 183 183 187 216 224 224 236 236 255 255 255 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 280 391 452 462 512 512 512 512 532 628 716 736 909 909 909 909 996 1252 1252 1252 1395 1905 1905 1905 1952 1952 1952 1952 2000 4096 4100 7956 7968 8016 13084 13084 52428 52428 55297 65568 65568 131072 131097 196610 196610 262144 327684 327684 393743 458758 458758 589832 589832 655360 655360 655596 655596 655612 655612 661336 661336 661336 663128 663208 663216 720906 720906 851980 851980 983054 983054 983054 983054 1114128 1114128 1245202 1245202 1310738 1376276 1376276 1507350 1507350 1638424 1638424 1769498 1769498 1900572 1900572 2031646 2031646 2097152 2162720 2162720 2293794 2293794 2424868 2424868 2555942 2555942 2621442 2687016 2687016 2818090 2818090 2949164 2949164 3006464 3006464 3006464 3006464 3018752 3018752 3018752 3018752 3018752 3080238 3080238 3145776 3211312 3211312 3276848 3342386 3342386 3473460 3473460 3538992 3604534 3604534 3735608 3735608 3866682 3866682 3997756 3997756 4128830 4128830 4199040 4199040 4199040 4199040 4199822 4201088 4259904 4259904 4259936 4295123 4295123 4336627 4336627 4338772 4338873 4338873 4362768 4383243 4390978 4390978 4390978 4391004 4391004 4510886 4510942 4522052 4522052 4522052 4587568 4653126 4653126 4653126 4659728 4665628 4665628 4711456 4711456 4711456 4711456 4711456 4711456 4711456 4712704 4712712 4712712 4712712 4712712 4712712 4712712 4712712 4732986 4733024 4784200 4784200 4784200 4915274 4915274 4915274 5046348 5046348 5046348 5111900 5177422 5177422 5177422 5308496 5308496 5308496 5374044 5439570 5439570 5439570 5439580 5439596 5570644 5570644 5570644 5636188 5701718 5701718 5701718 5832792 5832792 5832792 5963866 5963866 6029413 6029433 6094940 6094940 6226014 6226014 6357069 6357088 6488162 6619236 6619250 6750309 6750310 6750318 6815843 6881329 6881384 6881395 6881396 6939540 6940492 6940564 6940588 6940628 6940636 6940644 6940648 6940673 6940684 6940728 6940728 6940728 6940812 6940812 6940872 6940872 6940876 6940884 6940912 6940924 6940936 6940944 6940944 6940972 6941044 6941100 6941172 6941185 6941212 6941244 6941248 6941256 6941268 6941308 6941316 6941324 6941328 6941352 6941364 6941408 6941408 6941408 6941408 6941492 6941492 6941492 6941552 6941552 6941552 6941564 6941604 6941652 6941724 6941724 6941752 6941752 6941768 6941768 6941768 6941800 6941892 6941908 6941940 6941956 6941976 6941988 6942004 6942004 6942008 6942032 6942032 6942048 6942048 6942084 6942264 6942280 6942280 6942304 6942312 6942312 6942312 6942312 6942312 6942312 6942424 6942432 6942432 6942458 6942624 6942632 6942632 6942684 6942684 6942684 6942688 6942688 6942724 6942724 6942758 6942808 6942824 6942840 6942840 6942840 6942840 6942840 6943180 6943184 6943200 6943204 6943308 6943448 6943448 6943452 6943492 6943508 6943823 6943823 6943823 6943824 6944100 6944100 6944100 6944100 6944257 6944340 6944356 6944376 6944376 6944376 6944376 6944408 6944428 6944436 6944472 6944492 6944512 6944512 6944512 6944512 6944512 6944520 6944584 6944584 6944612 6944612 6944664 6944672 6944720 6944720 6944720 6944720 6944720 6944720 6944752 6944777 6944804 6944872 6944916 6944984 6945072 6945104 6945140 6945216 6945232 6945296 6945312 6945340 6945500 6945536 6945628 6945644 6945648 6945656 6945664 6945680 6945684 6945712 6945716 6945760 6945832 6945840 6945840 6945892 6945904 6945932 6945940 6945956 6945964 6945984 6946024 6946080 6946140 6946216 6946216 6946264 6946264 6946272 6946316 6946316 6946316 6946316 6946316 6946316 6946376 6946376 6946376 6946376 6946376 6946376 6946380 6946380 6946384 6946384 6946408 6946408 6946440 6946444 6946444 6946444 6946444 6946444 6946444 6946444 6946528 6946764 6946764 6946764 7012458 7077999 7143525 7143532 7209065 7209071 7209071 7274563 7274606 7274610 7405680 7471205 7471215 7471220 7471220 7471221 7536745 7536748 7536754 7602277 7602286 7602286 7602291 7667712 7667712 7667712 7667712 7667712 7667712 7667712 7667712 7667712 7667712 7667712 7667712 7667712 7667712 7667828 7667904 7667904 7668336 7668400 7668400 7679680 7679704 7680440 7680592 7680592 7680592 7680592 7680652 7680912 7680936 7680944 7681976 7681976 7683112 7683112 7683120 7683120 7683120 7683576 7683600 7683600 7689504 7690000 7798902 7929939 7929976 8061018 8061050 8192124 8192124 8323198 8323198 8388608 8388618 8462508 8462508 9240914 9372029 9437326 10289490 10551456 10682530 10813604 10944678 11075752 11206826 11337900 11468974 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534416 11534528 11534528 11534528 11534528 11534528 11534528 11534528 11534707 11534960 11534960 11534960 11534960 11535024 11535052 11535124 11535528 11535528 11535536 11535542 11535544 11535544 11535544 11535552 11535552 11535768 11535800 11536356 11537616 11537616 11537616 11537624 11537624 11537648 11537656 11537760 11537760 11537760 11537760 11537768 11537768 11537768 11537768 11537768 11537768 11537780 11537784 11537816 11538008 11538008 11538008 11538752 11538752 11538760 11538760 11538760 11538760 11538760 11538976 11539120 11539120 11539120 11539148 11541460 11541568 11541576 11543624 11543632 11543632 11543638 11547736 11547736 11547736 11547736 11547736 11547744 11547744 11547744 11547744 11547744 11547744 11555704 11555928 11555928 11557256 11562976 11600048 11731122 11862196 11993270 12124344 12255418 12386492 12517566 12648640 12648640 12779714 12779714 12910788 12910788 13041862 13041862 13041862 13172936 13172936 13303857 13304010 13304010 13435084 13435084 13566158 13566158 13697232 13697232 13828306 13828306 13828306 13959380 13959380 14090454 14090454 14221528 14221528 14352602 14352602 14483676 14483676 14614750 15532268 15663342 15794416 15925490 16056564 16187606 16187638 16318712 16449786 16580860 16711934 16777216 16777244 16777244 16777472 16777504 16777523 16777570 16777596 16777596 16842888 16883776 16907328 16907360 20976256 24641758 24641917 26288154 26353690 28332000 33554434 33554434 33554944 33619971 34603520 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603552 34603592 34603592 34603777 34603777 34603777 34603778 34603778 34603794 34603794 34865190 34865680 34865684 35652096 35652112 35652128 35652128 35652128 35652128 35652128 35652128 35652128 35652128 35652128 35652128 35652128 35652128 35652168 35652353 35652353 35652354 36176424 36176424 36700688 37076676 37076676 37076676 37076676 37076676 40370720 42205828 42205828 42205828 42205828 42205828 50331651 50331651 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397954 50398081 50463248 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463618 51511824 58786320 58786689 58786689 58851856 58852226 58852226 83886085 83886085 83886085 178619701 178619701 178620149 178620149 214748364 285212689 285212689 318767123 385941526 469762076 520093727 538189843 538443920 538443920 538714137 538714137 539041824 539041824 539107357 539107357 539369502 539369502 540017350 540017350 540606816 540672352 555877084 589431474 754974765 754974765 754974765 822215426 956301369 1423598602 1423598698 1423598698 1423600150 1912602995 1912602995 1912602995 1912602995 1912602995 1912602995 1912603505 1999264796 1999264796 1999264796 1999264842 1999264844 1999265252 1999265264 1999265384 1999883395 1999883437 1999884052 1999884173 1999913350 1999913350 1999939454 1999939535 1999939705 1999940023 1999940834 1999940858 1999970277 2005641531 2005656460 2005656595 2005691061 2005691360 2005691553 2005691603 2005691684 2005716160 2005757941 2006073464 2006074880 2006074880 2006074880 2006077888 2006084864 2006084992 2006084992 2007433216 2007433216 2007439896 2007440816 2007453232 2007469464 2007469464 2007651659 2007661828 2007662726 2007663020 2007665950 2007666073 2007666613 2007666613 2007666707 2007667850 2007667850 2007669099 2007669099 2007669440 2007669440 2007675087 2007675087 2007678700 2007680720 2007680720 2007680720 2007682368 2007682368 2007682368 2007683615 2007683615 2007683615 2007683615 2007683615 2007683615 2007683615 2007683615 2007683615 2007689248 2007689881 2007695327 2007726727 2007808051 2007808051 2007808051 2007808051 2007808051 2007808051 2007808051 2007827065 2007827065 2007827065 2007839323 2007891968 2007899900 2007899948 2007899948 2007900028 2007900028 2007900220 2007919848 2007919944 2007922144 2007922144 2007932992 2007932992 2007932992 2007939727 2007941332 2007941398 2007985579 2007985579 2007985618 2007985618 2008149701 2008149711 2008149751 2008153370 2008153557 2008155634 2008156432 2008418957 2008419042 2008606084 2008606084 2008606084 2008606084 2098388789 2105213097 2105221429 2105221717 2105221893 2105222037 2105222169 2105222305 2105222593 2105222633 2105222721 2105222833 2105223073 2105223521 2105223577 2105223641 2105226313 2105226621 2105226905 2105227413 2147352624 2147483647 \n', 'partition algo\r\n/* low  --> Starting index,  high  --> Ending index */\r\nquickSort(arr[], low, high)\r\n{\r\n    if (low < high)\r\n    {\r\n        /* pi is partitioning index, arr[pi] is now\r\n           at right place */\r\n        pi = partition(arr, low, high);\r\n\r\n        quickSort(arr, low, pi - 1);  // Before pi\r\n        quickSort(arr, pi + 1, high); // After pi\r\n    }\r\n}', '2020-05-25'),
(125, 10, 4501012018, '#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define lli long long int\r\nlli knapsack(lli val[],lli wt[],lli n,lli w)\r\n{\r\nlli knap[n+1][w+1];\r\nfor(lli i=0;i<=n;i++)\r\n    {\r\nfor(lli j=0;j<=w;j++)\r\n        {\r\nif(i==0||j==0)\r\nknap[i][j]=0;\r\nelse if(j>=wt[i-1])\r\n                knap[i][j]=max(val[i-1]+knap[i-1][j-wt[i-1]],knap[i-1][j]);\r\nelse\r\nknap[i][j]=knap[i-1][j];\r\n        }\r\n    }\r\nreturn knap[n][w];\r\n}\r\nint main()\r\n{\r\nlli n,w;\r\ncin>>n>>w;\r\nlli val[n],wt[n];\r\nfor(lli i=0;i<n;i++)\r\ncin>>val[i];\r\nfor(lli i=0;i<n;i++)\r\ncin>>wt[i];\r\ncout<<knapsack(val,wt,n,w);\r\nreturn 0;\r\n}\r\n', 10, '5 15 4 2 1 2 10 12 2 1 1 4', '15', 'Algorithm:\r\n\r\n1.	Declare a table DP[][] of size (Number of items+1*Capacity+1) to store the intermediate states and initialise it with ?-1? denoting all states as blank.\r\n2.	Define a function knapsack which takes as argument (`W->Weight left to be filled, ?N?->number of left items)\r\n3.	Base case will be if we have ?left weight=0? or ?number of items left=0? , then return 0\r\n4.	Also consider the case when DP[i][j]!=-1 then straight away return that state as it is previously calculated.\r\n5.	If the current item?s weight is greater than left weight so that item cannot be included therefore return DP[n-1][W]=knapsack(n-1,W)\r\n6.	Else return DP[n-1][W]= max(val+knapsack(W-val,n-1),knapsack(W-val,n-1)) which means returning the maximum of the two cases when the current item is included or not included\r\n', '2020-05-25'),
(126, 13, 5101012018, '#include<iostream>\r\nusing namespace std; \r\n#define V 5  \r\nint minKey(int key[], bool mstSet[])  \r\n{  \r\n    int min = INT_MAX, min_index;  \r\n    for (int v = 0; v < V; v++)  \r\n        if (mstSet[v] == false && key[v] < min)  \r\n            min = key[v], min_index = v;  \r\n    return min_index;  \r\n} \r\nvoid printMST(int parent[], int graph[V][V])  \r\n{  \r\n    cout<<\"Edge 	    Weight\n\";  \r\n    for (int i = 1; i < V; i++)  \r\n        cout<<parent[i]<<\" --- \"<<i<<\" \"<<\"==>\"<<\" \"<<graph[i][parent[i]]<<\" \n\";  \r\n}   \r\nvoid primMST(int graph[V][V])  \r\n{  \r\n    int parent[V];  \r\n    int key[V]; \r\n    bool mstSet[V];   \r\n    for (int i = 0; i < V; i++)  \r\n        key[i] = INT_MAX, mstSet[i] = false;  \r\n    key[0] = 0;  \r\n    parent[0] = -1; \r\n    for (int count = 0; count < V - 1; count++) \r\n    {   \r\n        int u = minKey(key, mstSet);  \r\n        mstSet[u] = true;  \r\n        for (int v = 0; v < V; v++)  \r\n            if (graph[u][v] && mstSet[v] == false && graph[u][v] < key[v])  \r\n                parent[v] = u, key[v] = graph[u][v];  \r\n    }  \r\n    printMST(parent, graph);  \r\n}  \r\nint main()  \r\n{  \r\n    int graph[V][V] = { { 0, 2, 0, 6, 0 },  \r\n                        { 2, 0, 3, 8, 5 },  \r\n                        { 0, 3, 0, 0, 7 },  \r\n                        { 6, 8, 0, 0, 9 },  \r\n                        { 0, 5, 7, 9, 0 } };  \r\n    primMST(graph);  \r\n    return 0;  \r\n}', 1000, '', '', '', '0000-00-00'),
(127, 3, 7501012018, '#include<iostream>\r\nusing namespace std;\r\nvoid swap(int* a, int* b)  \r\n{  \r\n    int t = *a;  \r\n    *a = *b;  \r\n    *b = t;  \r\n}  \r\nint partition (int arr[], int low, int high)  \r\n{  \r\n    int pivot = arr[high]; \r\n    int i = (low - 1); \r\n    for (int j=low;j<=high-1;j++)  \r\n    {  \r\n        if (arr[j]<=pivot)  \r\n        {  \r\n            i++;   \r\n            swap(&arr[i], &arr[j]);  \r\n        }  \r\n    }  \r\n    swap(&arr[i+1],&arr[high]);  \r\n    return (i+1);  \r\n}  \r\nvoid quickSort(int arr[], int low, int high)  \r\n{  \r\n    if (low < high)  \r\n    {  \r\n    \r\n        int pi = partition(arr, low, high);  \r\n        quickSort(arr, low, pi - 1);  \r\n        quickSort(arr, pi, high);  \r\n    }  \r\n}  \r\nvoid printArray(int arr[], int size)  \r\n{  \r\n    for (int i=0;i<size;i++)\r\n    {\r\n        cout<<arr[i]<<\" \";\r\n    }\r\n}  \r\nint main()\r\n{\r\n   int n;\r\n   cin>>n;\r\n   int a[n];\r\n   for(int i=0;i<n;i++)\r\n   {\r\n       cin>>a[i];\r\n   }\r\n   quickSort(a,0,n-1);\r\n   printArray(a,n);\r\n}', 10, '1 2000', '2000 ', 'quickSort(arr[], low, high)\r\n{\r\n    if (low < high)\r\n    {\r\n        /* pi is partitioning index, arr[pi] is now\r\n           at right place */\r\n        pi = partition(arr, low, high);\r\n\r\n        quickSort(arr, low, pi - 1);  // Before pi\r\n        quickSort(arr, pi + 1, high); // After pi\r\n    }\r\n}', '2020-05-25'),
(129, 7, 6101012018, '#include<iostream>\r\n#include<cstdlib>\r\n \r\nusing namespace std;\r\n \r\n\r\nvoid swap(int *a, int *b)\r\n{\r\n	int temp; \r\n	temp = *a;\r\n	*a = *b;\r\n	*b = temp;\r\n}\r\n \r\n\r\nint Partition(int a[], int low, int high)\r\n{\r\n	int pivot, index, i;\r\n	index = low;\r\n	pivot = high;\r\n \r\n	\r\n	for(i=low; i < high; i++)\r\n	{\r\n		if(a[i] < a[pivot])\r\n		{\r\n			swap(&a[i], &a[index]);\r\n			index++;\r\n		}\r\n	}\r\n	\r\n	swap(&a[pivot], &a[index]);\r\n \r\n	return index;\r\n}\r\n \r\n.\r\nint RandomPivotPartition(int a[], int low, int high)\r\n{\r\n	int pvt, n, temp;\r\n	n = rand();\r\n	\r\n	pvt = low + n%(high-low+1);\r\n \r\n	\r\n	swap(&a[high], &a[pvt]);\r\n \r\n	return Partition(a, low, high);\r\n}\r\n \r\n\r\nint QuickSort(int a[], int low, int high)\r\n{\r\n	int pindex;\r\n	if(low < high)\r\n	{\r\n		\r\n		pindex = RandomPivotPartition(a, low, high);\r\n		\r\n		QuickSort(a, low, pindex-1);\r\n		QuickSort(a, pindex+1, high);\r\n	}\r\n	return 0;\r\n}\r\n \r\nint main()\r\n{\r\n	int n, i;\r\n	cout<<\"\nEnter the number of data element to be sorted: \";\r\n	cin>>n;\r\n \r\n	int arr[n];\r\n	for(i = 0; i < n; i++)\r\n	{\r\n		cout<<\"Enter element \"<<i+1<<\": \";\r\n		cin>>arr[i];\r\n	}\r\n \r\n	QuickSort(arr, 0, n-1);\r\n \r\n	\r\n	cout<<\"\nSorted Data \";\r\n	for (i = 0; i < n; i++)\r\n        	cout<<\"->\"<<arr[i];\r\n \r\n	return 0;\r\n}', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '', 'partition(arr[], low, high) \r\n    pivot = arr[high]\r\n    i = low\r\n    for j := low to high ? 1 do\r\n        if arr[j] <= pivot then\r\n            swap arr[i] with arr[j]\r\n            i = i + 1\r\n    swap arr[i] with arr[high]\r\n    return i\r\n\r\npartition_r(arr[], low, high)\r\n    r = Random Number from low to high\r\n    Swap arr[r] and arr[high]\r\n    return partition(arr, low, high)\r\n\r\nrandomisedquicksort(arr[], low, high)\r\n    if low < high\r\n        p = partition_r(arr, low, high)\r\n        quicksort(arr, p-1, high)\r\n        quicksort(arr, p+1, high)\r\n', '2020-05-25'),
(130, 10, 5101012018, '#include<stdio.h>\r\n#include<limits.h>\r\nint max(int a, int b) { return (a > b)? a : b; }\r\nint knapSack(int W, int wt[], int val[], int n)\r\n{\r\n   if (n == 0 || W == 0)\r\n       return 0;\r\n   if (wt[n-1] > W)\r\n       return knapSack(W, wt, val, n-1);\r\n\r\n   else return max( val[n-1] + knapSack(W-wt[n-1], wt, val, n-1),\r\n                    knapSack(W, wt, val, n-1) );\r\n}\r\n\r\nint main()\r\n{\r\n    int n;\r\n    int  W ,i;\r\n    scanf(\"%d\",&n);\r\n    scanf(\"%d\",&W);\r\n    int wt[n],val[n];\r\n    for(i=0;i<n;i++)\r\n    scanf(\"%d\",&val[i]);\r\n    for(i=0;i<n;i++)\r\n    scanf(\"%d\",&wt[i]);\r\n    printf(\"%d\", knapSack(W, wt, val, n));\r\n    return 0;\r\n}\r\n', 10, '5 15 4 2 1 2 10 12 2 1 1 4', '15', '??D\0y\0n\0a\0m\0i\0c\0-\00\0-\01\0-\0k\0n\0a\0p\0s\0a\0c\0k\0 \0(\0v\0,\0 \0w\0,\0 \0n\0,\0 \0W\0)\0\r\0\n\0f\0o\0r\0 \0w\0 \0=\0 \00\0 \0t\0o\0 \0W\0 \0d\0o\0\r\0\n\0 \0 \0 \0c\0[\00\0,\0 \0w\0]\0 \0=\0 \00\0\r\0\n\0f\0o\0r\0 \0i\0 \0=\0 \01\0 \0t\0o\0 \0n\0 \0d\0o\0 \0 \0\r\0\n\0 \0 \0 \0c\0[\0i\0,\0 \00\0]\0 \0=\0 \00\0\r\0\n\0 \0 \0 \0f\0o\0r\0 \0w\0 \0=\0 \01\0 \0t\0o\0 \0W\0 \0d\0o\0\r\0\n\0 \0 \0	\0i\0f\0 \0w\0i\0 \0d\" \0w\0 \0t\0h\0e\0n\0\r\0\n\0 \0 \0 \0 \0 \0	\0i\0f\0 \0v\0i\0 \0+\0 \0c\0[\0i\0-\01\0,\0 \0w\0-\0w\0i\0]\0 \0t\0h\0e\0n\0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0	\0c\0[\0i\0,\0 \0w\0]\0 \0=\0 \0v\0i\0 \0+\0 \0c\0[\0i\0-\01\0,\0 \0w\0-\0w\0i\0]\0\r\0\n\0 \0 \0 \0 \0 \0	\0e\0l\0s\0e\0 \0c\0[\0i\0,\0 \0w\0]\0 \0=\0 \0c\0[\0i\0-\01\0,\0 \0w\0]\0\r\0\n\0 \0 \0	\0e\0l\0s\0e\0\r\0\n\0 \0 \0 \0 \0 \0	\0c\0[\0i\0,\0 \0w\0]\0 \0=\0 \0c\0[\0i\0-\01\0,\0 \0w\0]\0', '2020-05-25'),
(131, 10, 4701012018, '#include<stdio.h>\r\n#include<limits.h>\r\nint max(int a, int b) { return (a > b)? a : b; }\r\nint knapSack(int W, int wt[], int val[], int n)\r\n{\r\n   if (n == 0 || W == 0)\r\n       return 0;\r\n   if (wt[n-1] > W)\r\n       return knapSack(W, wt, val, n-1);\r\n\r\n   else return max( val[n-1] + knapSack(W-wt[n-1], wt, val, n-1),\r\n                    knapSack(W, wt, val, n-1) );\r\n}\r\n\r\nint main()\r\n{\r\n    int n;\r\n    int  W ,i;\r\n    scanf(\"%d\",&n);\r\n    scanf(\"%d\",&W);\r\n    int wt[n],val[n];\r\n    for(i=0;i<n;i++)\r\n    scanf(\"%d\",&val[i]);\r\n    for(i=0;i<n;i++)\r\n    scanf(\"%d\",&wt[i]);\r\n    printf(\"%d\", knapSack(W, wt, val, n));\r\n    return 0;\r\n}\r\n', 10, '5 15 4 2 1 2 10 12 2 1 1 4', '15', '??D\0y\0n\0a\0m\0i\0c\0-\00\0-\01\0-\0k\0n\0a\0p\0s\0a\0c\0k\0 \0(\0v\0,\0 \0w\0,\0 \0n\0,\0 \0W\0)\0\r\0\n\0f\0o\0r\0 \0w\0 \0=\0 \00\0 \0t\0o\0 \0W\0 \0d\0o\0\r\0\n\0 \0 \0 \0c\0[\00\0,\0 \0w\0]\0 \0=\0 \00\0\r\0\n\0f\0o\0r\0 \0i\0 \0=\0 \01\0 \0t\0o\0 \0n\0 \0d\0o\0 \0 \0\r\0\n\0 \0 \0 \0c\0[\0i\0,\0 \00\0]\0 \0=\0 \00\0\r\0\n\0 \0 \0 \0f\0o\0r\0 \0w\0 \0=\0 \01\0 \0t\0o\0 \0W\0 \0d\0o\0\r\0\n\0 \0 \0	\0i\0f\0 \0w\0i\0 \0d\" \0w\0 \0t\0h\0e\0n\0\r\0\n\0 \0 \0 \0 \0 \0	\0i\0f\0 \0v\0i\0 \0+\0 \0c\0[\0i\0-\01\0,\0 \0w\0-\0w\0i\0]\0 \0t\0h\0e\0n\0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0	\0c\0[\0i\0,\0 \0w\0]\0 \0=\0 \0v\0i\0 \0+\0 \0c\0[\0i\0-\01\0,\0 \0w\0-\0w\0i\0]\0\r\0\n\0 \0 \0 \0 \0 \0	\0e\0l\0s\0e\0 \0c\0[\0i\0,\0 \0w\0]\0 \0=\0 \0c\0[\0i\0-\01\0,\0 \0w\0]\0\r\0\n\0 \0 \0	\0e\0l\0s\0e\0\r\0\n\0 \0 \0 \0 \0 \0	\0c\0[\0i\0,\0 \0w\0]\0 \0=\0 \0c\0[\0i\0-\01\0,\0 \0w\0]\0', '2020-05-25'),
(134, 7, 4401012018, '#include <bits/stdc++.h> \r\nusing namespace std;  \r\n   \r\nvoid swap(int* a, int* b)  \r\n{  \r\n    int t = *a;  \r\n    *a = *b;  \r\n    *b = t;  \r\n}  \r\n  \r\nint partition (int arr[], int low, int high)  \r\n{  \r\n    int pivot = arr[high];  \r\n    int i = (low - 1); \r\n  \r\n    for (int j = low; j <= high - 1; j++)  \r\n    {   \r\n        if (arr[j] < pivot)  \r\n        {  \r\n            i++; \r\n            swap(&arr[i], &arr[j]);  \r\n        }  \r\n    }  \r\n    swap(&arr[i + 1], &arr[high]);  \r\n    return (i + 1);  \r\n}  \r\n  \r\nvoid quickSort(int arr[], int low, int high)  \r\n{  \r\n    if (low < high)  \r\n    {  \r\n        int pi = partition(arr, low, high);   \r\n        quickSort(arr, low, pi - 1);  \r\n        quickSort(arr, pi + 1, high);  \r\n    }  \r\n}  \r\n  \r\nvoid printArray(int arr[], int size)  \r\n{  \r\n    int i;  \r\n    for (i = 0; i < size; i++)  \r\n        cout << arr[i] << \" \";  \r\n    cout << endl;  \r\n}  \r\n  \r\nint main()  \r\n{  \r\nint t;\r\ncin>>t;\r\nwhile(t!=0){\r\nint n;\r\ncin>>n;\r\n    int arr[n] ;  \r\n   for(int i=0;i<n;i++){\r\ncin>>arr[i];\r\n}\r\n    quickSort(arr, 0, n - 1);   \r\n    printArray(arr, n);  \r\nt--;\r\n}\r\n    return 0;  \r\n} ', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '\n1 5 6 6 8 8 9 9 \n16 32 1000 14000 \n0 16 32 2686688 \n0 16 32 2686688 \n0 16 32 2686688 \n0 16 32 2686688 \n0 16 32 2686688 \n0 16 32 2686688 \n0 16 32 2686688 \n0 16 32 2686688 \n0 16 32 2686688 \n0 16 32 2686688 \n', 'partition algo\r\n/* low  --> Starting index,  high  --> Ending index */\r\nquickSort(arr[], low, high)\r\n{\r\n    if (low < high)\r\n    {\r\n        /* pi is partitioning index, arr[pi] is now\r\n           at right place */\r\n        pi = partition(arr, low, high);\r\n\r\n        quickSort(arr, low, pi - 1);  // Before pi\r\n        quickSort(arr, pi + 1, high); // After pi\r\n    }\r\n}', '2020-05-25'),
(135, 10, 4401012018, '﻿#include<iostream>\r\n#include<vector>\r\nusing namespace std;\r\nint knapsack(vector<int>& weight,vector<int>& v,int t)\r\n{\r\n    vector<vector<int>> dp(v.size()+1,vector<int>(t+1,0));\r\n    for(int i=0;i<dp.size();i++)\r\n    {\r\n        for(int j=1;j<dp[0].size();j++)\r\n        {\r\n            if(i==0)\r\n            {\r\n                dp[i][j] = j - weight[i] >= 0 ? v[i] : 0;\r\n            }\r\n            else\r\n            {\r\n                if(j-weight[i]>=0)\r\n                {\r\n                    dp[i][j]+=max(dp[i-1][j],dp[i-1][j-weight[i]]+v[i]);\r\n                }\r\n                else\r\n                {\r\n                    dp[i][j]=dp[i-1][j];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return dp[v.size()][t];\r\n}\r\nint main()\r\n{\r\n    int n,x;\r\n    cin>>n>>x;\r\n    vector<int>w(n,0);\r\n    vector<int>v(n,0);\r\n    for(int i=0;i<n;i++)\r\n    {\r\n        cin>>v[i];\r\n    }\r\n    for(int i=0;i<n;i++)\r\n    {\r\n        cin>>w[i];\r\n    }\r\n   cout<< knapsack(w,v,x);\r\n}', 0, '5 15 4 2 1 2 10 12 2 1 1 4', '', 'Approach: A simple solution is to consider all subsets of items and calculate the total weight and value of all subsets. Consider the only subsets whose total weight is smaller than W. From all such subsets, pick the maximum value subset.\r\nOptimal Sub-structure: To consider all subsets of items, there can be two cases for every item.\r\n\r\nCase 1: The item is included in the optimal subset.\r\nCase 2: The item is not included in the optimal set.\r\nTherefore, the maximum value that can be obtained from ‘n’ items is the max of the following two values.\r\n\r\n1.Maximum value obtained by n-1 items and W weight (excluding nth item).\r\n2.Value of nth item plus maximum value obtained by n-1 items and W minus the weight of the nth item (including nth item).\r\nIf the weight of ‘nth’ item is greater than ‘W’, then the nth item cannot be included and Case 1 is the only possibility.', '2020-05-25'),
(136, 10, 6601012018, '﻿#include<iostream>\r\n#include<vector>\r\nusing namespace std;\r\nint knapsack(vector<int>& weight,vector<int>& v,int t)\r\n{\r\n    vector<vector<int>> dp(v.size()+1,vector<int>(t+1,0));\r\n    for(int i=0;i<dp.size();i++)\r\n    {\r\n        for(int j=1;j<dp[0].size();j++)\r\n        {\r\n            if(i==0)\r\n            {\r\n                dp[i][j] = j - weight[i] >= 0 ? v[i] : 0;\r\n            }\r\n            else\r\n            {\r\n                if(j-weight[i]>=0)\r\n                {\r\n                    dp[i][j]+=max(dp[i-1][j],dp[i-1][j-weight[i]]+v[i]);\r\n                }\r\n                else\r\n                {\r\n                    dp[i][j]=dp[i-1][j];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return dp[v.size()][t];\r\n}\r\nint main()\r\n{\r\n    int n,x;\r\n    cin>>n>>x;\r\n    vector<int>w(n,0);\r\n    vector<int>v(n,0);\r\n    for(int i=0;i<n;i++)\r\n    {\r\n        cin>>v[i];\r\n    }\r\n    for(int i=0;i<n;i++)\r\n    {\r\n        cin>>w[i];\r\n    }\r\n   cout<< knapsack(w,v,x);\r\n}', 0, '5 15 4 2 1 2 10 12 2 1 1 4', '', '﻿An efficient solution is to use the Greedy approach. The basic idea of the greedy approach is to calculate the ratio value/weight for each item and sort the item on the basis of this ratio. Then take the item with the highest ratio and add them until we can’t add the next item as a whole and at the end add the next item as much as we can. Which will always be the optimal solution to this problem.\r\n\r\n\r\nAlgorithm: Greedy-Fractional-Knapsack (w[1..n], p[1..n], W) \r\nfor i = 1 to n \r\n   do x[i] = 0 \r\nweight = 0 \r\nfor i = 1 to n \r\n   if weight + w[i] ≤ W then  \r\n      x[i] = 1 \r\n      weight = weight + w[i] \r\n   else \r\n      x[i] = (W - weight) / w[i] \r\n      weight = W \r\n      break \r\nreturn x', '2020-05-25'),
(137, 12, 4401012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n  \r\nclass Edge  \r\n{  \r\n    public: \r\n    int src, dest, weight;  \r\n};  \r\nclass Graph  \r\n{  \r\n    public: \r\n    int V, E;  \r\n    Edge* edge;  \r\n};  \r\nGraph* createGraph(int V, int E)  \r\n{  \r\n    Graph* graph = new Graph;  \r\n    graph->V = V;  \r\n    graph->E = E;  \r\n  \r\n    graph->edge = new Edge[E];  \r\n  \r\n    return graph;  \r\n}   \r\nclass subset  \r\n{  \r\n    public: \r\n    int parent;  \r\n    int rank;  \r\n};  \r\nint find(subset subsets[], int i)  \r\n{  \r\n    if (subsets[i].parent != i)  \r\n        subsets[i].parent = find(subsets, subsets[i].parent);  \r\n  \r\n    return subsets[i].parent;  \r\n}    \r\nvoid Union(subset subsets[], int x, int y)  \r\n{  \r\n    int xroot = find(subsets, x);  \r\n    int yroot = find(subsets, y);    \r\n    if (subsets[xroot].rank < subsets[yroot].rank)  \r\n        subsets[xroot].parent = yroot;  \r\n    else if (subsets[xroot].rank > subsets[yroot].rank)  \r\n        subsets[yroot].parent = xroot;  \r\n    else\r\n    {  \r\n        subsets[yroot].parent = xroot;  \r\n        subsets[xroot].rank++;  \r\n    }  \r\n}   \r\nint myComp(const void* a, const void* b)  \r\n{  \r\n    Edge* a1 = (Edge*)a;  \r\n    Edge* b1 = (Edge*)b;  \r\n    return a1->weight > b1->weight;  \r\n}  \r\nvoid KruskalMST(Graph* graph)  \r\n{  \r\n    int V = graph->V;  \r\n    Edge result[V];  \r\n    int e = 0; \r\n    int i = 0;  \r\n \r\n    qsort(graph->edge, graph->E, sizeof(graph->edge[0]), myComp);  \r\n    subset *subsets = new subset[( V * sizeof(subset) )];    \r\n    for (int v = 0; v < V; ++v)  \r\n    {  \r\n        subsets[v].parent = v;  \r\n        subsets[v].rank = 0;  \r\n    }  \r\n\r\n    while (e < V - 1 && i < graph->E)  \r\n    {  \r\n        Edge next_edge = graph->edge[i++];  \r\n  \r\n        int x = find(subsets, next_edge.src);  \r\n        int y = find(subsets, next_edge.dest);  \r\n  \r\n        if (x != y)  \r\n        {  \r\n            result[e++] = next_edge;  \r\n            Union(subsets, x, y);  \r\n        }  \r\n   \r\n    }   \r\n    cout<<\"Following are the edges in the constructed MST\n\";  \r\n    for (i = 0; i < e; ++i)  \r\n        cout<<result[i].src<<\" -- \"<<result[i].dest<<\" == \"<<result[i].weight<<endl;  \r\n    return;  \r\n}  \r\n  \r\nint main()  \r\n{  \r\nint V=4;\r\nint E=5;\r\n\r\n    Graph* graph = createGraph(V, E);   \r\n    graph->edge[0].src = 0;  \r\n    graph->edge[0].dest = 1;  \r\n    graph->edge[0].weight = 10;   \r\n    graph->edge[1].src = 0;  \r\n    graph->edge[1].dest = 2;  \r\n    graph->edge[1].weight = 6;  \r\n\r\n    graph->edge[2].src = 0;  \r\n    graph->edge[2].dest = 3;  \r\n    graph->edge[2].weight = 5;   \r\n    graph->edge[3].src = 1;  \r\n    graph->edge[3].dest = 3;  \r\n    graph->edge[3].weight = 15;  \r\n  \r\n    graph->edge[4].src = 2;  \r\n    graph->edge[4].dest = 3;  \r\n    graph->edge[4].weight = 4;  \r\n  \r\n    KruskalMST(graph);  \r\n    return 0;  \r\n}  ', 1000, '', '', '1. Sort all the edges in non-decreasing order of their weight.\r\n2. Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If cycle is not formed, include this edge. Else, discard it.\r\n3. Repeat step#2 until there are (V-1) edges in the spanning tree.\r\n\r\n', '2020-05-25');
INSERT INTO `qtos_map` (`ID`, `Q_ID`, `ROLL`, `SUBMISSION`, `SCORE`, `INPUT`, `OP`, `ALGO`, `DATE`) VALUES
(138, 3, 3101012018, '#include<iostream>\r\nusing namespace std;\r\n\r\nvoid swap(int *a,int *b)\r\n{\r\n    int temp=*a;\r\n    *a=*b;\r\n    *b=temp;\r\n}\r\n\r\nint partition (int arr[], int low, int high) \r\n{ \r\n    int pivot = arr[high];   \r\n    int i = (low - 1);\r\n  \r\n    for (int j = low; j <= high- 1; j++) \r\n    { \r\n        \r\n        if (arr[j] <= pivot) \r\n        { \r\n            i++;\r\n            swap(&arr[i], &arr[j]); \r\n        } \r\n    } \r\n    swap(&arr[i + 1], &arr[high]); \r\n    return (i + 1); \r\n} \r\n  \r\n\r\nvoid quickSort(int arr[], int low, int high) \r\n{ \r\n    if (low < high) \r\n    { \r\n        int pi = partition(arr, low, high); \r\n        quickSort(arr, low, pi - 1); \r\n        quickSort(arr, pi + 1, high); \r\n    } \r\n} \r\n  \r\nvoid printArray(int arr[], int size) \r\n{ \r\n    int i; \r\n    for (i=0; i < size; i++) \r\n        cout<<arr[i]<<\" \"; \r\n} \r\n\r\nint main() \r\n{ \r\n    int arr[100]; \r\n    int n;\r\n    cin>>n;\r\n    for(int i=0;i<n;i++)\r\n    {\r\n        cin>>arr[i];\r\n    }\r\n    quickSort(arr, 0, n-1); \r\n    printArray(arr, n); \r\n    return 0; \r\n} \r\n        ', 10, '', '', '', '0000-00-00'),
(139, 7, 3101012018, '<br>#include <ctime>\r\n#include <cstdlib>\r\n#include <iostream> \r\nusing namespace std; \r\n  \r\n\r\nint partition(int arr[], int low, int high) \r\n{ \r\n    int pivot = arr[high];  \r\n    int i = (low - 1); \r\n  \r\n    for (int j = low; j <= high - 1; j++) { \r\n  \r\n       \r\n        if (arr[j] <= pivot) { \r\n  \r\n            i++;\r\n            swap(arr[i], arr[j]); \r\n        } \r\n    } \r\n    swap(arr[i + 1], arr[high]); \r\n    return (i + 1); \r\n} \r\n  \r\n\r\nint partition_r(int arr[], int low, int high) \r\n{ \r\n   \r\n    srand(time(NULL)); \r\n    int random = low + rand() % (high - low); \r\n  \r\n   \r\n    swap(arr[random], arr[high]); \r\n  \r\n    return partition(arr, low, high); \r\n} \r\n  \r\n\r\nvoid quickSort(int arr[], int low, int high) \r\n{ \r\n    if (low < high) { \r\n  \r\n        \r\n        int pi = partition_r(arr, low, high); \r\n        quickSort(arr, low, pi - 1); \r\n        quickSort(arr, pi + 1, high); \r\n    } \r\n} \r\n  \r\n\r\nvoid printArray(int arr[], int size) \r\n{ \r\n    for (int i = 0; i < size; i++)\r\n    {\r\n        cout<<arr[i];\r\n        cout<<\" \";\r\n    }\r\n        \r\n} \r\n  \r\n\r\nint main() \r\n{ \r\n    int arr[100]; \r\n    int n; \r\n    cin>>n;\r\n    for(int i = 0; i < n; i++) \r\n        cin>>arr[i]; \r\n    quickSort(arr, 0, n - 1);\r\n    printArray(arr, n); \r\n    return 0; \r\n}\r\n<br>', 10, '', '', '', '0000-00-00'),
(140, 3, 201012018, '#include<iostream>\r\nusing namespace std;\r\n\r\nvoid swap(int *a,int *b)\r\n{\r\n    int temp=*a;\r\n    *a=*b;\r\n    *b=temp;\r\n}\r\n\r\nint partition (int arr[], int low, int high) \r\n{ \r\n    int pivot = arr[high];   \r\n    int i = (low - 1);\r\n  \r\n    for (int j = low; j <= high- 1; j++) \r\n    { \r\n        \r\n        if (arr[j] <= pivot) \r\n        { \r\n            i++;\r\n            swap(&arr[i], &arr[j]); \r\n        } \r\n    } \r\n    swap(&arr[i + 1], &arr[high]); \r\n    return (i + 1); \r\n} \r\n  \r\n\r\nvoid quickSort(int arr[], int low, int high) \r\n{ \r\n    if (low < high) \r\n    { \r\n        int pi = partition(arr, low, high); \r\n        quickSort(arr, low, pi - 1); \r\n        quickSort(arr, pi + 1, high); \r\n    } \r\n} \r\n  \r\nvoid printArray(int arr[], int size) \r\n{ \r\n    int i; \r\n    for (i=0; i < size; i++) \r\n        cout<<arr[i]<<\" \"; \r\n} \r\n\r\nint main() \r\n{ \r\n    int arr[100]; \r\n    int n;\r\n    cin>>n;\r\n    for(int i=0;i<n;i++)\r\n    {\r\n        cin>>arr[i];\r\n    }\r\n    quickSort(arr, 0, n-1); \r\n    printArray(arr, n); \r\n    return 0; \r\n}\r\n', 2, '', '', '', '0000-00-00'),
(141, 7, 201012018, '#include <stdlib.h>\r\n#include <iostream> \r\nusing namespace std; \r\n  \r\nvoid swap(int *a,int *b)\r\n{\r\n    int temp=*a;\r\n    *a=*b;\r\n    *b=temp;\r\n}\r\n\r\nint partition(int arr[], int low, int high) \r\n{ \r\n    int pivot = arr[high];  \r\n    int i = (low - 1); \r\n  \r\n    for (int j = low; j <= high - 1; j++) { \r\n  \r\n       \r\n        if (arr[j] <= pivot) { \r\n            i++;\r\n            swap(arr[i], arr[j]); \r\n        } \r\n    } \r\n    swap(arr[i + 1], arr[high]); \r\n    return (i + 1); \r\n} \r\n  \r\n\r\nint partition_r(int arr[], int low, int high) \r\n{ \r\n   \r\n    srand(time(NULL)); \r\n    int random = low + rand() % (high - low); \r\n  \r\n   \r\n    swap(arr[random], arr[high]); \r\n  \r\n    return partition(arr, low, high); \r\n} \r\n  \r\n\r\nvoid quickSort(int arr[], int low, int high) \r\n{ \r\n    if (low < high) { \r\n  \r\n        \r\n        int pi = partition_r(arr, low, high); \r\n        quickSort(arr, low, pi - 1); \r\n        quickSort(arr, pi + 1, high); \r\n    } \r\n} \r\n  \r\n\r\nvoid printArray(int arr[], int size) \r\n{ \r\n    for (int i = 0; i < size; i++)\r\n    {\r\n        cout<<arr[i];\r\n        cout<<\" \";\r\n    }\r\n        \r\n} \r\n  \r\n\r\nint main() \r\n{ \r\n    int arr[100]; \r\n    int n; \r\n    cin>>n;\r\n    for(int i = 0; i < n; i++) \r\n        cin<<arr[i]; \r\n    quickSort(arr, 0, n - 1);\r\n    printArray(arr, n); \r\n    return 0; \r\n}', 0, '', '', '', '0000-00-00'),
(142, 7, 2501012018, '#include <cstdlib> \r\n#include<ctime>\r\n #include <iostream> \r\nusing namespace std; \r\nint partition(int arr[], int low, int high) \r\n{\r\n int pivot = arr[high]; // pivot\r\n int i = (low - 1); // Index of smaller element\r\n for (int j = low; j <= high - 1; j++) \r\n{ \r\n    if (arr[j] <= pivot) \r\n{     i++; \r\n     swap(arr[i], arr[j]); \r\n} \r\n} \r\nswap(arr[i + 1], arr[high]); \r\nreturn (i + 1);\r\n } \r\nint partition_r(int arr[], int low, int high) \r\n{ \r\nsrand(time(NULL));\r\n int random = low + rand() % (high - low); \r\nswap(arr[random], arr[high]);\r\n return partition(arr, low, high); \r\n}  \r\nvoid quickSort(int arr[], int low, int high) \r\n{ \r\nif (low < high)\r\n { \r\nint pi = partition_r(arr, low, high); \r\nquickSort(arr, low, pi - 1);\r\n quickSort(arr, pi + 1, high); \r\n} \r\n}\r\n /* Function to print an array */ \r\nvoid printArray(int arr[], int size) \r\n{ int i; for (i = 0; i < size; i++) cout<<arr[i]<<\" \"; } \r\n// Driver program to test above functions \r\nint main()\r\n { \r\nint n; \r\ncin>>n; \r\nint arr[n]; \r\nfor(int i=0;i<n;i++) { cin>>arr[i]; } \r\nquickSort(arr, 0, n - 1); \r\nprintArray(arr, n);\r\n return 0;\r\n } \r\n\r\n', 10, '', '', '', '0000-00-00'),
(143, 7, 3401012018, '#include <cstdlib> \r\n#include<ctime>\r\n#include <iostream> \r\nusing namespace std; \r\n  \r\nint partition(int arr[], int low, int high) \r\n{ \r\n    int pivot = arr[high]; \r\n    int i = (low - 1); \r\n  \r\n    for (int j = low; j <= high - 1; j++) { \r\n  \r\n        if (arr[j] <= pivot)\r\n        { \r\n            i++; \r\n            swap(arr[i], arr[j]); \r\n        } \r\n    } \r\n    swap(arr[i + 1], arr[high]); \r\n    return (i + 1); \r\n} \r\n\r\nint partition_r(int arr[], int low, int high) \r\n{ \r\n    srand(time(NULL)); \r\n    int random = low + rand() % (high - low); \r\n  \r\n   \r\n    swap(arr[random], arr[high]); \r\n  \r\n    return partition(arr, low, high); \r\n} \r\n  \r\n\r\nvoid quickSort(int arr[], int low, int high) \r\n{ \r\n    if (low < high) { \r\n  \r\n        \r\n        int pi = partition_r(arr, low, high); \r\n  \r\n        quickSort(arr, low, pi - 1); \r\n        quickSort(arr, pi + 1, high); \r\n    } \r\n} \r\n  \r\n\r\nvoid printArray(int arr[], int size) \r\n{ \r\n    int i; \r\n    for (i = 0; i < size; i++) \r\n        cout<<arr[i]<<\" \"; \r\n} \r\n\r\nint main() \r\n{ \r\n    int n;\r\n    cin>>n;\r\n    int arr[n];\r\n    for(int i=0;i<n;i++)\r\n    {\r\n        cin>>arr[i];\r\n    }\r\n    quickSort(arr, 0, n - 1); \r\n    \r\n    printArray(arr, n); \r\n    return 0; \r\n} ', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', 'partition(arr[], lo, hi)\r\npivot = arr[hi]\r\ni = lo // place for swapping\r\nfor j := lo to hi â€“ 1 do\r\nif arr[j] <= pivot then\r\nswap arr[i] with arr[j]\r\ni = i + 1\r\nswap arr[i] with arr[hi]\r\nreturn i\r\npartition_r(arr[], lo, hi)\r\nr = Random Number from lo to hi\r\nSwap arr[r] and arr[hi]\r\nreturn partition(arr, lo, hi)\r\nquicksort(arr[], lo, hi)\r\nif lo < hi\r\np = partition_r(arr, lo, hi)\r\nquicksort(arr, p-1, hi)\r\nquicksort(arr, p+1, hi)', '0000-00-00'),
(145, 7, 3301012018, '\n\n#include <cstdlib> \n#include <iostream> \nusing namespace std; \n\n\nint partition(int arr[], int low, int high) \n{ \n	int pivot = arr[high]; // pivot \n	int i = (low - 1); // Index of smaller element \n\n	for (int j = low; j <= high - 1; j++) { \n\n		// If current element is smaller than or \n		// equal to pivot \n		if (arr[j] <= pivot) { \n\n			i++; // increment index of smaller element \n			swap(arr[i], arr[j]); \n		} \n	} \n	swap(arr[i + 1], arr[high]); \n	return (i + 1); \n} \n\n// Generates Random Pivot, swaps pivot with \n// end element and calls the partition function \nint partition_r(int arr[], int low, int high) \n{ \n	// Generate a random number in between \n	// low .. high \n	srand(time(NULL)); \n	int random = low + rand() % (high - low); \n\n	// Swap A[random] with A[high] \n	swap(arr[random], arr[high]); \n\n	return partition(arr, low, high); \n} \n\n/* The main function that implements QuickSort \narr[] --> Array to be sorted, \nlow --> Starting index, \nhigh --> Ending index */\nvoid quickSort(int arr[], int low, int high) \n{ \n	if (low < high) { \n\n		/* pi is partitioning index, arr[p] is now \n		at right place */\n		int pi = partition_r(arr, low, high); \n\n		// Separately sort elements before \n		// partition and after partition \n		quickSort(arr, low, pi - 1); \n		quickSort(arr, pi + 1, high); \n	} \n} \n\n/* Function to print an array */\nvoid printArray(int arr[], int size) \n{ \n	int i; \n	for (i = 0; i < size; i++) \n		printf(\"%d \", arr[i]); \n	printf(\"\n\"); \n} \n\n// Driver program to test above functions \nint main() \n{ \n	int arr[] = { 6,12,-5,4,1,0,6 }; \n	int n = sizeof(arr) / sizeof(arr[0]); \n	quickSort(arr, 0, n - 1); \n	printf(\"\n\n\"); \n	printArray(arr, n); \n	return 0; \n} \n\n', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '\n\n-5 0 1 4 6 6 12 \n', 'partition(arr[], lo, hi) \n    pivot = arr[hi]\n    i = lo     // place for swapping\n    for j := lo to hi – 1 do\n        if arr[j] <= pivot then\n            swap arr[i] with arr[j]\n            i = i + 1\n    swap arr[i] with arr[hi]\n    return i\n\npartition_r(arr[], lo, hi)\n    r = Random Number from lo to hi\n    Swap arr[r] and arr[hi]\n    return partition(arr, lo, hi)\n\nquicksort(arr[], lo, hi)\n    if lo < hi\n        p = partition_r(arr, lo, hi)\n        quicksort(arr, p-1, hi)\n        quicksort(arr, p+1, hi)\n', '2020-05-25'),
(146, 7, 401012018, '#include<stdio.h>\r\n#include<stdlib.h>\r\n#include<conio.h>\r\n#include<time.h>\r\n\r\nint arr[100], n;\r\n\r\nint partition(int arr[], int m, int p);\r\nvoid interchange(int arr[], int i, int j);\r\nvoid QuickSort(int arr[], int p, int q);\r\nvoid show();\r\nint main()\r\n\r\n{\r\n\r\n\r\n  int i;\r\n\r\n  time_t start, end;\r\n\r\n  time_t diff;\r\n\r\n  scanf(\"%d\", &n);\r\n\r\n  randomize();    \r\n\r\n  for(i=0; i<n; i++)\r\n\r\n  {\r\n\r\n     arr[i]=random(100);\r\n\r\n  }\r\n\r\n  for(i=0; i<n; i++)\r\n\r\n  {\r\n\r\n    printf(\"%d \", arr[i]);\r\n\r\n  }\r\n\r\n\r\n\r\n   start=time(NULL);\r\n\r\n   printf(\"\n\nThe passes are:\");\r\n\r\n   QuickSort(arr, 0, n-1);\r\n\r\n   end=time(NULL);\r\n\r\n   diff=difftime(end, start);\r\n\r\n   printf(\"\n\nThe sorted array is \");\r\n\r\n   for(i=0; i<n; i++)\r\n\r\n   printf(\"%d \", arr[i]);\r\n\r\n   printf(\"\n\nTime taken is %ld seconds\", diff);\r\n\r\n   getch();\r\n\r\n   return 0;\r\n}\r\n\r\n\r\n\r\nint partition(int arr[], int m, int p)\r\n\r\n{\r\n\r\n     int v=arr[m];\r\n\r\n     int i=m;\r\n\r\n     int j=p;\r\n\r\n    do\r\n\r\n    {\r\n\r\n        do\r\n\r\n             i++;\r\n\r\n        while(arr[i]<v);\r\n\r\n        do\r\n\r\n        j--;\r\n\r\n        while(arr[j]>v);\r\n\r\n        if(i<j)\r\n\r\n        interchange(arr, i, j);\r\n\r\n    }while(i<=j);\r\n\r\n    arr[m]=arr[j];\r\n\r\n    arr[j]=v;\r\n\r\n    return j;\r\n\r\n}\r\n\r\n\r\n\r\n//-------INTERCHANGE THE ELEMENTS-------\r\n\r\nvoid interchange(int arr[], int i, int j)\r\n\r\n{\r\n\r\n int p;\r\n\r\n p=arr[i];\r\n\r\n arr[i]=arr[j];\r\n\r\n arr[j]=p;\r\n\r\n}\r\n\r\n\r\n\r\n//-------QUICK SORT-------\r\n\r\nvoid QuickSort(int arr[], int p, int q)\r\n\r\n{\r\n\r\n int j, k, temp;\r\n\r\n if(p<q)    //If there are more than 1 element, divide p into 2 sub-problems\r\n\r\n {\r\n\r\n  k=rand() % (q-p+1)+p;\r\n\r\n  interchange(arr, k, p);\r\n\r\n/*  temp=arr[k];\r\n\r\n  arr[k]=arr[p];\r\n\r\n  arr[p]=temp;  */\r\n\r\n  j=partition(arr, p, q+1);  //j is the position of partioning element\r\n\r\n  show();\r\n\r\n  //Solve sub-problems\r\n\r\n  QuickSort(arr, p, j-1);\r\n\r\n  QuickSort(arr, j+1, q);\r\n\r\n\r\n\r\n }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n//-------PRINT ELEMENTS OF THE ARRAY FOR EACH PASS-------\r\n\r\nvoid show()\r\n\r\n{\r\n\r\n    int j;\r\n\r\n//    printf(\"\nPasses are: \");\r\n\r\n    printf(\"\n\");\r\n\r\n    for(j=0; j<n; j++)\r\n\r\n printf(\"   %d\", arr[j]);\r\n\r\n}\r\n\r\n\r\nint main() \r\n{ \r\n    int arr[50];\r\n    int n;\r\n    scanf(\"%d\",&n);\r\n    for(int i=0;i<n;++i)\r\n      scanf(\"%d\",arr[i]);\r\n    quickSort(arr, 0, n - 1); \r\n    printArray(arr, n); \r\n    return 0; \r\n} \r\n', 0, '', '', '', '0000-00-00'),
(147, 10, 3401012018, '??#\0i\0n\0c\0l\0u\0d\0e\0<\0i\0o\0s\0t\0r\0e\0a\0m\0>\0\r\0\n\0u\0s\0i\0n\0g\0 \0n\0a\0m\0e\0s\0p\0a\0c\0e\0 \0s\0t\0d\0;\0\r\0\n\0\r\0\n\0i\0n\0t\0 \0m\0a\0x\0(\0i\0n\0t\0 \0a\0,\0 \0i\0n\0t\0 \0b\0)\0 \0{\0 \0r\0e\0t\0u\0r\0n\0 \0(\0a\0 \0>\0 \0b\0)\0?\0 \0a\0 \0:\0 \0b\0;\0 \0}\0\r\0\n\0\r\0\n\0i\0n\0t\0 \0k\0n\0a\0p\0S\0a\0c\0k\0(\0i\0n\0t\0 \0W\0,\0 \0i\0n\0t\0 \0w\0t\0[\0]\0,\0 \0i\0n\0t\0 \0v\0a\0l\0[\0]\0,\0 \0i\0n\0t\0 \0n\0)\0\r\0\n\0{\0\r\0\n\0 \0 \0 \0i\0n\0t\0 \0i\0,\0 \0w\0;\0\r\0\n\0 \0 \0 \0i\0n\0t\0 \0K\0[\0n\0+\01\0]\0[\0W\0+\01\0]\0;\0\r\0\n\0\r\0\n\0 \0 \0 \0f\0o\0r\0 \0(\0i\0 \0=\0 \00\0;\0 \0i\0 \0<\0=\0 \0n\0;\0 \0i\0+\0+\0)\0\r\0\n\0 \0 \0 \0{\0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0f\0o\0r\0 \0(\0w\0 \0=\0 \00\0;\0 \0w\0 \0<\0=\0 \0W\0;\0 \0w\0+\0+\0)\0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0{\0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0i\0f\0 \0(\0i\0=\0=\00\0 \0|\0|\0 \0w\0=\0=\00\0)\0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0K\0[\0i\0]\0[\0w\0]\0 \0=\0 \00\0;\0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0e\0l\0s\0e\0 \0i\0f\0 \0(\0w\0t\0[\0i\0-\01\0]\0 \0<\0=\0 \0w\0)\0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0K\0[\0i\0]\0[\0w\0]\0 \0=\0 \0m\0a\0x\0(\0v\0a\0l\0[\0i\0-\01\0]\0 \0+\0 \0K\0[\0i\0-\01\0]\0[\0w\0-\0w\0t\0[\0i\0-\01\0]\0]\0,\0 \0 \0K\0[\0i\0-\01\0]\0[\0w\0]\0)\0;\0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0e\0l\0s\0e\0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0K\0[\0i\0]\0[\0w\0]\0 \0=\0 \0K\0[\0i\0-\01\0]\0[\0w\0]\0;\0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0}\0\r\0\n\0 \0 \0 \0}\0\r\0\n\0\r\0\n\0 \0 \0 \0r\0e\0t\0u\0r\0n\0 \0K\0[\0n\0]\0[\0W\0]\0;\0\r\0\n\0}\0\r\0\n\0\r\0\n\0i\0n\0t\0 \0m\0a\0i\0n\0(\0)\0\r\0\n\0{\0\r\0\n\0 \0 \0 \0 \0i\0n\0t\0 \0n\0,\0W\0;\0\r\0\n\0 \0 \0 \0 \0c\0i\0n\0>\0>\0n\0>\0>\0W\0;\0\r\0\n\0\r\0\n\0 \0 \0 \0 \0i\0n\0t\0 \0v\0a\0l\0[\0n\0]\0;\0\r\0\n\0 \0 \0 \0 \0f\0o\0r\0(\0i\0n\0t\0 \0i\0=\00\0;\0i\0<\0n\0;\0i\0+\0+\0)\0\r\0\n\0 \0 \0 \0 \0{\0\r\0\n\0 \0 \0 \0 \0 \0 \0c\0i\0n\0>\0>\0v\0a\0l\0[\0i\0]\0;\0\r\0\n\0 \0 \0 \0 \0}\0\r\0\n\0 \0 \0 \0 \0i\0n\0t\0 \0w\0t\0[\0n\0]\0;\0\r\0\n\0 \0 \0 \0 \0f\0o\0r\0(\0i\0n\0t\0 \0i\0=\00\0;\0i\0<\0n\0;\0i\0+\0+\0)\0\r\0\n\0 \0 \0 \0 \0{\0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0c\0i\0n\0>\0>\0w\0t\0[\0i\0]\0;\0\r\0\n\0 \0 \0 \0 \0}\0\r\0\n\0\r\0\n\0 \0 \0 \0 \0c\0o\0u\0t\0<\0<\0k\0n\0a\0p\0S\0a\0c\0k\0(\0W\0,\0 \0w\0t\0,\0 \0v\0a\0l\0,\0 \0n\0)\0;\0\r\0\n\0 \0 \0 \0 \0r\0e\0t\0u\0r\0n\0 \00\0;\0\r\0\n\0}\0\r\0\n\0\r\0\n\0', 0, '5 15 4 2 1 2 10 12 2 1 1 4', '', '??1\0.\0D\0e\0c\0l\0a\0r\0e\0 \0a\0 \02\0-\0d\0 \0a\0r\0r\0a\0y\0 \0D\0P\0[\0]\0[\0]\0 \0o\0f\0 \0d\0i\0m\0e\0n\0s\0i\0o\0n\0s\0 \0(\0N\0u\0m\0b\0e\0r\0 \0o\0f\0 \0w\0e\0i\0g\0h\0t\0 \0e\0l\0e\0m\0e\0n\0t\0s\0+\01\0)\0*\0(\0c\0a\0p\0a\0c\0i\0t\0y\0)\0\r\0\n\02\0.\0C\0o\0n\0s\0i\0d\0e\0r\0 \0 0\0t\0h\0  \0r\0o\0w\0 \0a\0s\0 \0 w\0e\0i\0g\0h\0t\0 \0v\0a\0l\0u\0e\0=\00\0  \0a\0n\0d\0 \0 0\0t\0h\0  \0c\0o\0l\0u\0m\0n\0 \0a\0s\0 \0 c\0a\0p\0a\0c\0i\0t\0y\0=\00\0  \0f\0i\0l\0l\0 \0t\0h\0e\0 \0 0\0t\0h\0  \0r\0o\0w\0 \0a\0n\0d\0 \0 0\0t\0h\0  \0c\0o\0l\0u\0m\0n\0 \0w\0i\0t\0h\0 \0 0\0 .\0\r\0\n\03\0.\0N\0o\0w\0 \0l\0o\0o\0p\0 \0t\0h\0r\0o\0u\0g\0h\0 \0a\0l\0l\0 \0w\0e\0i\0g\0h\0t\0 \0e\0l\0e\0m\0e\0n\0t\0s\0 \0 w\0i\0 .\0\r\0\n\04\0.\0F\0o\0r\0 \0e\0a\0c\0h\0 \0 w\0i\0  \0l\0o\0o\0p\0 \0t\0h\0r\0o\0u\0g\0h\0 \0a\0l\0l\0 \0w\0e\0i\0g\0h\0t\0s\0 \0i\0n\0 \0t\0h\0e\0 \0c\0o\0l\0u\0m\0n\0s\0 \0 w\0j\0>\0w\0i\0  \0a\0n\0d\0 \0D\0P\0[\0i\0]\0[\0j\0]\0=\0m\0a\0x\0(\0D\0P\0[\0i\0-\01\0]\0[\0j\0]\0,\0v\0a\0l\0[\0w\0i\0]\0+\0D\0P\0[\0i\0-\01\0]\0[\0j\0-\0w\0i\0]\0)\0.\0\r\0\n\05\0.\0r\0e\0t\0u\0r\0n\0 \0t\0h\0e\0 \0v\0a\0l\0u\0e\0 \0D\0P\0[\0N\0u\0m\0b\0e\0r\0 \0o\0f\0 \0w\0e\0i\0g\0h\0t\0 \0e\0l\0e\0m\0e\0n\0t\0s\0]\0[\0c\0a\0p\0a\0c\0i\0t\0y\0]\0', '2020-05-25'),
(148, 2, 2701012018, '#include<iostream>\r\nusing namespace std;\r\nvoid swapping(int &a, int &b) {     \r\n   int temp;\r\n   temp = a;\r\n   a = b;\r\n   b = temp;\r\n}\r\nvoid display(int *array, int size) {\r\n   for(int i = 0; i<size; i++)\r\n      cout << array[i] << \" \";\r\n}\r\nvoid merge(int *array, int l, int m, int r) {\r\n   int i, j, k, nl, nr;\r\n   \r\n   nl = m-l+1; nr = r-m;\r\n   int larr[nl], rarr[nr];\r\n  \r\n   for(i = 0; i<nl; i++)\r\n      larr[i] = array[l+i];\r\n   for(j = 0; j<nr; j++)\r\n      rarr[j] = array[m+1+j];\r\n   i = 0; j = 0; k = l;\r\n  \r\n   while(i < nl && j<nr) {\r\n      if(larr[i] <= rarr[j]) {\r\n         array[k] = larr[i];\r\n         i++;\r\n      }else{\r\n         array[k] = rarr[j];\r\n         j++;\r\n      }\r\n      k++;\r\n   }\r\n   while(i<nl) {      \r\n      array[k] = larr[i];\r\n      i++; k++;\r\n   }\r\n   while(j<nr) {     \r\n      array[k] = rarr[j];\r\n      j++; k++;\r\n   }\r\n}\r\nvoid mergeSort(int *array, int l, int r) {\r\n   int m;\r\n   if(l < r) {\r\n      int m = l+(r-l)/2;\r\n      mergeSort(array, l, m);\r\n      mergeSort(array, m+1, r);\r\n      merge(array, l, m, r);\r\n   }\r\n}\r\nint main() {\r\n   int arr[] = {12, -5, 4, 1, 0, 6};\r\n   mergeSort(arr, 0, 5);     \r\n   display(arr, 6);\r\n}', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '-5 0 1 4 6 12 ', 'MergeSort(arr[], l,  r)\r\nIf r > l\r\n     1. Find the middle point to divide the array into two halves:  \r\n             middle m = (l+r)/2\r\n     2. Call mergeSort for first half:   \r\n             Call mergeSort(arr, l, m)\r\n     3. Call mergeSort for second half:\r\n             Call mergeSort(arr, m+1, r)\r\n     4. Merge the two halves sorted in step 2 and 3:\r\n             Call merge(arr, l, m, r)', '2020-05-25'),
(149, 8, 3201012018, '#include <assert.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <time.h>\r\n \r\n#define M 2\r\n#define N (1<<M)\r\n \r\ntypedef double datatype;\r\n#define DATATYPE_FORMAT \"%4.2g\"\r\ntypedef datatype mat[N][N]; \r\ntypedef struct\r\n{\r\n        int ra, rb, ca, cb;\r\n} corners;\r\n\r\n \r\n\r\nvoid identity(mat A, corners a)\r\n{\r\n    int i, j;\r\n    for (i = a.ra; i < a.rb; i++)\r\n        for (j = a.ca; j < a.cb; j++)\r\n            A[i][j] = (datatype) (i == j);\r\n}\r\n\r\nvoid set(mat A, corners a, datatype k)\r\n{\r\n    int i, j;\r\n    for (i = a.ra; i < a.rb; i++)\r\n        for (j = a.ca; j < a.cb; j++)\r\n            A[i][j] = k;\r\n}\r\n \r\n\r\nvoid randk(mat A, corners a, double l, double h)\r\n{\r\n    int i, j;\r\n    for (i = a.ra; i < a.rb; i++)\r\n        for (j = a.ca; j < a.cb; j++)\r\n            A[i][j] = (datatype) (l + (h - l) * (rand() / (double) RAND_MAX));\r\n}\r\n \r\n\r\nvoid print(mat A, corners a, char *name)\r\n{\r\n    int i, j;\r\n    \r\n    for (i = a.ra; i < a.rb; i++)\r\n    {\r\n        for (j = a.ca; j < a.cb; j++)\r\n            printf(DATATYPE_FORMAT \", \", A[i][j]);\r\n        printf(\"\n\");\r\n    }\r\n  \r\n}\r\n \r\n\r\nvoid add(mat A, mat B, mat C, corners a, corners b, corners c)\r\n{\r\n    int rd = a.rb - a.ra;\r\n    int cd = a.cb - a.ca;\r\n    int i, j;\r\n    for (i = 0; i < rd; i++)\r\n    {\r\n        for (j = 0; j < cd; j++)\r\n        {\r\n            C[i + c.ra][j + c.ca] = A[i + a.ra][j + a.ca] + B[i + b.ra][j\r\n                    + b.ca];\r\n        }\r\n    }\r\n}\r\n\r\nvoid sub(mat A, mat B, mat C, corners a, corners b, corners c)\r\n{\r\n    int rd = a.rb - a.ra;\r\n    int cd = a.cb - a.ca;\r\n    int i, j;\r\n    for (i = 0; i < rd; i++)\r\n    {\r\n        for (j = 0; j < cd; j++)\r\n        {\r\n            C[i + c.ra][j + c.ca] = A[i + a.ra][j + a.ca] - B[i + b.ra][j\r\n                    + b.ca];\r\n        }\r\n    }\r\n}\r\n \r\n\r\nvoid find_corner(corners a, int i, int j, corners *b)\r\n{\r\n    int rm = a.ra + (a.rb - a.ra) / 2;\r\n    int cm = a.ca + (a.cb - a.ca) / 2;\r\n    *b = a;\r\n    if (i == 0)\r\n        b->rb = rm; // top rows\r\n    else\r\n        b->ra = rm; // bot rows\r\n    if (j == 0)\r\n        b->cb = cm; // left cols\r\n    else\r\n        b->ca = cm; // right cols\r\n}\r\n \r\n\r\nvoid mul(mat A, mat B, mat C, corners a, corners b, corners c)\r\n{\r\n    corners aii[2][2], bii[2][2], cii[2][2], p;\r\n    mat P[7], S, T;\r\n    int i, j, m, n, k;\r\n \r\n    // Check: A[m n] * B[n k] = C[m k]\r\n    m = a.rb - a.ra;\r\n    assert(m==(c.rb-c.ra));\r\n    n = a.cb - a.ca;\r\n    assert(n==(b.rb-b.ra));\r\n    k = b.cb - b.ca;\r\n    assert(k==(c.cb-c.ca));\r\n    assert(m>0);\r\n \r\n    if (n == 1)\r\n    {\r\n        C[c.ra][c.ca] += A[a.ra][a.ca] * B[b.ra][b.ca];\r\n        return;\r\n    }\r\n \r\n  \r\n    for (i = 0; i < 2; i++)\r\n    {\r\n        for (j = 0; j < 2; j++)\r\n        {\r\n            find_corner(a, i, j, &aii[i][j]);\r\n            find_corner(b, i, j, &bii[i][j]);\r\n            find_corner(c, i, j, &cii[i][j]);\r\n        }\r\n    }\r\n \r\n    p.ra = p.ca = 0;\r\n    p.rb = p.cb = m / 2;\r\n \r\n#define LEN(A) (sizeof(A)/sizeof(A[0]))\r\n    for (i = 0; i < LEN(P); i++)\r\n        set(P[i], p, 0);\r\n \r\n#define ST0 set(S,p,0); set(T,p,0)\r\n \r\n    ST0;\r\n    add(A, A, S, aii[0][0], aii[1][1], p);\r\n    add(B, B, T, bii[0][0], bii[1][1], p);\r\n    mul(S, T, P[0], p, p, p);\r\n \r\n    \r\n    ST0;\r\n    add(A, A, S, aii[1][0], aii[1][1], p);\r\n    mul(S, B, P[1], p, bii[0][0], p);\r\n \r\n   \r\n    ST0;\r\n    sub(B, B, T, bii[0][1], bii[1][1], p);\r\n    mul(A, T, P[2], aii[0][0], p, p);\r\n \r\n   \r\n    ST0;\r\n    sub(B, B, T, bii[1][0], bii[0][0], p);\r\n    mul(A, T, P[3], aii[1][1], p, p);\r\n \r\n\r\n    ST0;\r\n    add(A, A, S, aii[0][0], aii[0][1], p);\r\n    mul(S, B, P[4], p, bii[1][1], p);\r\n \r\n    \r\n    ST0;\r\n    sub(A, A, S, aii[1][0], aii[0][0], p);\r\n    add(B, B, T, bii[0][0], bii[0][1], p);\r\n    mul(S, T, P[5], p, p, p);\r\n \r\n\r\n    ST0;\r\n    sub(A, A, S, aii[0][1], aii[1][1], p);\r\n    add(B, B, T, bii[1][0], bii[1][1], p);\r\n    mul(S, T, P[6], p, p, p);\r\n \r\n   \r\n    add(P[0], P[3], S, p, p, p);\r\n    sub(S, P[4], T, p, p, p);\r\n    add(T, P[6], C, p, p, cii[0][0]);\r\n \r\n\r\n    add(P[2], P[4], C, p, p, cii[0][1]);\r\n \r\n    \r\n    add(P[1], P[3], C, p, p, cii[1][0]);\r\n \r\n \r\n    add(P[0], P[2], S, p, p, p);\r\n    sub(S, P[1], T, p, p, p);\r\n    add(T, P[5], C, p, p, cii[1][1]);\r\n \r\n}\r\nint main()\r\n{\r\n    mat A, B, C;\r\n    corners ai = { 0, N, 0, N };\r\n    corners bi = { 0, N, 0, N };\r\n    corners ci = { 0, N, 0, N };\r\n    srand(time(0));\r\n  \r\n    randk(A, ai, 0, 2);\r\n    randk(B, bi, 0, 2);\r\n    print(A, ai, \"A\");\r\n    print(B, bi, \"B\");\r\n    set(C, ci, 0);\r\n  \r\n    mul(A, B, C, ai, bi, ci);\r\n    print(C, ci, \"C\");\r\n    return 0;\r\n}', 0, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', ' 1.9,    2, 0.42, 0.49, \n 1.2,  1.4,  1.3,  1.9, \n 1.1,  1.5,  1.4, 0.44, \n 1.5,  1.2,  1.6,  1.8, \n0.55, 0.79, 0.32,  1.4, \n0.88, 0.0016,  1.7,  1.8, \n0.82, 0.23,    1,  1.1, \n0.07,  1.3, 0.89, 0.89, \n 3.2,  2.3,  4.7,  7.1, \n 3.1,  3.7,  5.8,  7.3, \n 3.2,  1.8,  4.8,  6.2, \n 3.3,  3.9,  5.8,  7.6, \n', '', '2020-05-25'),
(150, 3, 3201012018, '\r\n#include <iostream>\r\n \r\nusing namespace std;\r\n \r\nvoid quick_sort(int[],int,int);\r\nint partition(int[],int,int);\r\n \r\nint main()\r\n{\r\n    int a[50],n,i;\r\n\r\n    cin>>n;\r\n\r\n    \r\n    for(i=0;i<n;i++)\r\n        cin>>a[i];\r\n        \r\n    quick_sort(a,0,n-1);\r\n    \r\n    \r\n    for(i=0;i<n;i++)\r\n    if(i!= n)\r\n        cout<<a[i]<<\" \";\r\n        //cout<<a[n-1];\r\n    \r\n    return 0;        \r\n}\r\n \r\nvoid quick_sort(int a[],int l,int u)\r\n{\r\n    int j;\r\n    if(l<u)\r\n    {\r\n        j=partition(a,l,u);\r\n        quick_sort(a,l,j-1);\r\n        quick_sort(a,j+1,u);\r\n    }\r\n}\r\n \r\nint partition(int a[],int l,int u)\r\n{\r\n    int v,i,j,temp;\r\n    v=a[l];\r\n    i=l;\r\n    j=u+1;\r\n    \r\n    do\r\n    {\r\n        do\r\n            i++;\r\n            \r\n        while(a[i]<v&&i<=u);\r\n        \r\n        do\r\n            j--;\r\n        while(v<a[j]);\r\n        \r\n        if(i<j)\r\n        {\r\n            temp=a[i];\r\n            a[i]=a[j];\r\n            a[j]=temp;\r\n        }\r\n    }while(i<j);\r\n    \r\n    a[l]=a[j];\r\n    a[j]=v;\r\n    \r\n    return(j);\r\n}\r\n\r\n                                  ', 10, '', '', '', '0000-00-00'),
(152, 2, 1801012018, '#include<iostream>\r\nusing namespace std;\r\n\r\nvoid merge2sorted(int p1[], int p2[], int arr[], int mid, int s)\r\n{\r\n    int i = 0, j = 0, k = 0;\r\n    while(i < mid && j < s)\r\n    {\r\n        if(p1[i] <= p2[j])\r\n        {\r\n            arr[k++] = p1[i++];\r\n        }\r\n        else\r\n        {\r\n            arr[k++] = p2[j++];\r\n        }\r\n    }\r\n    while(i < mid)\r\n    {\r\n        arr[k++] = p1[i++];\r\n    }\r\n    while(j < s)\r\n    {\r\n        arr[k++] = p2[j++];\r\n    }\r\n}\r\n\r\nvoid mergeSort(int arr[], int size)\r\n{\r\n    if(size == 1)\r\n    {\r\n        return;\r\n    }\r\n    int mid = size / 2;\r\n    int p1[mid], p2[size - mid];\r\n    for(int i = 0; i < mid; i++)\r\n    {\r\n        p1[i] = arr[i];\r\n    }\r\n    for(int i = mid; i < size; i++)\r\n    {\r\n        p2[i - mid] = arr[i];\r\n    }\r\n    mergeSort(p1, mid);\r\n    mergeSort(p2, size - mid);\r\n    merge2sorted(p1, p2, arr, mid, size - mid);\r\n}\r\n\r\nint main()\r\n{\r\n    int n;\r\n    cin >> n;\r\n    int arr[n];\r\n    for(int i = 0; i < n; i++)\r\n    cin >> arr[i];\r\n    mergeSort(arr, n);\r\n    for(int i = 0; i < n; i++)\r\n    cout << arr[i] << \" \";\r\n}\r\n  \r\n', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', 'If r > l\r\n     1. Find the middle point to divide the array into two halves:  \r\n             middle m = (l+r)/2\r\n     2. Call mergeSort for first half:   \r\n             Call mergeSort(arr, l, m)\r\n     3. Call mergeSort for second half:\r\n             Call mergeSort(arr, m+1, r)\r\n     4. Merge the two halves sorted in step 2 and 3:\r\n             Call merge(arr, l, m, r)', '0000-00-00'),
(153, 3, 301012018, '#include <bits/stdc++.h> \r\nusing namespace std;  \r\n  \r\n  \r\nvoid swap(int* a, int* b)  \r\n{  \r\n    int t = *a;  \r\n    *a = *b;  \r\n    *b = t;  \r\n}  \r\n  \r\nint partition (int arr[], int low, int high)  \r\n{  \r\n    int pivot = arr[high]; \r\n    int i = (low - 1); \r\n  \r\n    for (int j = low; j <= high - 1; j++)  \r\n    {  \r\n        \r\n        if (arr[j] < pivot)  \r\n        {  \r\n            i++;  \r\n            swap(&arr[i], &arr[j]);  \r\n        }  \r\n    }  \r\n    swap(&arr[i + 1], &arr[high]);  \r\n    return (i + 1);  \r\n}  \r\n\r\nvoid quickSort(int arr[], int low, int high)  \r\n{  \r\n    if (low < high)  \r\n    {  \r\n        \r\n        int pi = partition(arr, low, high);  \r\n  \r\n\r\n        \r\n        quickSort(arr, low, pi - 1);  \r\n        quickSort(arr, pi + 1, high);  \r\n    }  \r\n}  \r\n  \r\n\r\nvoid printArray(int arr[], int size)  \r\n{  \r\n    int i;  \r\n    for (i = 0; i < size; i++)  \r\n        cout << arr[i] << \" \";  \r\n      \r\n}  \r\n  \r\n\r\nint main()  \r\n{  \r\n    \r\n    int n;\r\n    cin>>n;\r\n    int arr[n];\r\n    for(int i=0; i<n ; i++)\r\n    {\r\n        cin>>arr[i];\r\n    }\r\n    \r\n    quickSort(arr, 0, n - 1);  \r\n      \r\n    printArray(arr, n);  \r\n    return 0;  \r\n}  \r\n                                            \r\n', 10, '', '', '', '0000-00-00'),
(154, 2, 3801012018, '#include <bits/stdc++.h>\r\nusing namespace std;\r\nvoid merge(int arr[], int l, int m, int r) \r\n{ \r\n    int i, j, k; \r\n    int n1 = m - l + 1; \r\n    int n2 =  r - m; \r\n    int L[n1], R[n2]; \r\n    for (i = 0; i < n1; i++) \r\n        L[i] = arr[l + i]; \r\n    for (j = 0; j < n2; j++) \r\n        R[j] = arr[m + 1+ j]; \r\n    i = 0;\r\n    j = 0;\r\n    k = l; \r\n    while (i < n1 && j < n2) \r\n    { \r\n        if (L[i] <= R[j]) \r\n        { \r\n            arr[k] = L[i]; \r\n            i++; \r\n        } \r\n        else\r\n        { \r\n            arr[k] = R[j]; \r\n            j++; \r\n        } \r\n        k++; \r\n    } \r\n    while (i < n1) \r\n    { \r\n        arr[k] = L[i]; \r\n        i++; \r\n        k++; \r\n    } \r\n    while (j < n2) \r\n    { \r\n        arr[k] = R[j]; \r\n        j++; \r\n        k++; \r\n    } \r\n} \r\nvoid mergeSort(int arr[], int l, int r) \r\n{ \r\n    if (l < r) \r\n    { \r\n        int m = l+(r-l)/2; \r\n        mergeSort(arr, l, m); \r\n        mergeSort(arr, m+1, r); \r\n        merge(arr, l, m, r); \r\n    } \r\n} \r\nint main()\r\n{\r\n    int n;\r\n    cin>>n;\r\n    int arr[n];\r\n    for(int i=0;i<n;i++)\r\n    cin>>arr[i];\r\n    mergeSort(arr,0,n-1);\r\n    for(int i=0;i<n;i++)\r\n    cout<<arr[i]<<\" \";\r\n    return 0;\r\n}', 10, '', '', '\r\n\r\nALGORITHM\r\n\r\n void merge(int A[ ] , int start, int mid, int end) {\r\n //stores the starting position of both parts in temporary variables.\r\nint p = start ,q = mid+1;\r\n\r\nint Arr[end-start+1] , k=0;\r\n\r\nfor(int i = start ;i <= end ;i++) {\r\n    if(p > mid)      //checks if first part comes to an end or not .\r\n       Arr[ k++ ] = A[ q++] ;\r\n\r\n   else if ( q > end)   //checks if second part comes to an end or not\r\n       Arr[ k++ ] = A[ p++ ];\r\n\r\n   else if( A[ p ] < A[ q ])     //checks which part has smaller element.\r\n      Arr[ k++ ] = A[ p++ ];\r\n\r\n   else\r\n      Arr[ k++ ] = A[ q++];\r\n }\r\n  for (int p=0 ; p< k ;p ++) {\r\n   /* Now the real array has elements in sorted manner including both \r\n        parts.*/\r\n     A[ start++ ] = Arr[ p ] ;                          \r\n  }\r\n}\r\n void merge_sort (int A[ ] , int start , int end )\r\n   {\r\n           if( start < end ) {\r\n           int mid = (start + end ) / 2 ;           // defines the current array in 2 parts .\r\n           merge_sort (A, start , mid ) ;                 // sort the 1st part of array .\r\n           merge_sort (A,mid+1 , end ) ;              // sort the 2nd part of array.\r\n\r\n         // merge the both parts by comparing elements of both the parts.\r\n          merge(A,start , mid , end );   \r\n   }                    \r\n}', '0000-00-00'),
(155, 10, 1001012018, '#include<stdio.h> \r\n#include<limits.h>\r\nint max(int a, int b) { return (a > b)? a : b; } \r\nint knapSack(int W, int wt[], int val[], int n) \r\n{ \r\n   if (n == 0 || W == 0) \r\n       return 0; \r\n   if (wt[n-1] > W) \r\n       return knapSack(W, wt, val, n-1); \r\n  \r\n   else return max( val[n-1] + knapSack(W-wt[n-1], wt, val, n-1), \r\n                    knapSack(W, wt, val, n-1) ); \r\n} \r\n  \r\nint main() \r\n{ \r\n    int n;\r\n    int  W ,i;\r\n    scanf(\"%d\",&n);\r\n    scanf(\"%d\",&W);\r\n    int wt[n],val[n];\r\n    for(i=0;i<n;i++)\r\n    scanf(\"%d\",&val[i]);\r\n    for(i=0;i<n;i++)\r\n    scanf(\"%d\",&wt[i]);\r\n    printf(\"%d\", knapSack(W, wt, val, n)); \r\n    return 0; \r\n}', 10, '', '', '', '0000-00-00'),
(156, 3, 2001012018, '#include <bits/stdc++.h> \r\nusing namespace std;  \r\n  \r\n  \r\nvoid swap(int* a, int* b)  \r\n{  \r\n    int t = *a;  \r\n    *a = *b;  \r\n    *b = t;  \r\n}  \r\n  \r\nint partition (int arr[], int low, int high)  \r\n{  \r\n    int pivot = arr[high]; \r\n    int i = (low - 1); \r\n  \r\n    for (int j = low; j <= high - 1; j++)  \r\n    {  \r\n        \r\n        if (arr[j] < pivot)  \r\n        {  \r\n            i++;  \r\n            swap(&arr[i], &arr[j]);  \r\n        }  \r\n    }  \r\n    swap(&arr[i + 1], &arr[high]);  \r\n    return (i + 1);  \r\n}  \r\n\r\nvoid quickSort(int arr[], int low, int high)  \r\n{  \r\n    if (low < high)  \r\n    {  \r\n        \r\n        int pi = partition(arr, low, high);  \r\n  \r\n\r\n        \r\n        quickSort(arr, low, pi - 1);  \r\n        quickSort(arr, pi + 1, high);  \r\n    }  \r\n}  \r\n  \r\n\r\nvoid printArray(int arr[], int size)  \r\n{  \r\n    int i;  \r\n    for (i = 0; i < size; i++)  \r\n        cout << arr[i] << \" \";  \r\n      \r\n}  \r\n  \r\n\r\nint main()  \r\n{  \r\n    \r\n    int n;\r\n    cin>>n;\r\n    int arr[n];\r\n    for(int i=0; i<n ; i++)\r\n    {\r\n        cin>>arr[i];\r\n    }\r\n    \r\n    quickSort(arr, 0, n - 1);  \r\n      \r\n    printArray(arr, n);  \r\n    return 0;  \r\n}  \r\n                                            \r\n', 10, '1 2000', '2000 ', 'Quick Sort Algorithm\r\n1. If n < = 1, then return.\r\n \r\n2. Pick any element V in a[]. This is called the pivot.\r\n \r\n3. Rearrange elements of the array by moving all elements xi > V right of V and all elements x?i < = V left of V. If the place of the V after re-arrangement is j, all elements with value less than V, appear in a[0], a[1] . . . . a[j ? 1] and all those with value greater than V appear in a[j + 1] . . . . a[n ? 1].\r\n \r\n4. Apply quick sort recursively to a[0] . . . . a[j ? 1] and to a[j + 1] . . . . a[\r\n', '2020-05-25'),
(157, 3, 3801012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\nvoid swap(int* a, int* b) \r\n{ \r\n	int t = *a; \r\n	*a = *b; \r\n	*b = t; \r\n}\r\nint partition (int arr[], int low, int high) \r\n{ \r\n	int pivot = arr[high]; \r\n	int i = (low - 1); \r\n	for (int j = low; j <= high - 1; j++) \r\n	{ \r\n		if (arr[j] < pivot) \r\n		{ \r\n			i++; \r\n			swap(&arr[i], &arr[j]); \r\n		} \r\n	} \r\n	swap(&arr[i + 1], &arr[high]); \r\n	return (i + 1); \r\n} \r\nvoid quickSort(int arr[], int low, int high) \r\n{ \r\n	if (low < high) \r\n	{ \r\n		int pi = partition(arr, low, high); \r\n		quickSort(arr, low, pi - 1); \r\n		quickSort(arr, pi + 1, high); \r\n	} \r\n} \r\nvoid printArray(int arr[], int size) \r\n{ \r\n	int i; \r\n	for (i = 0; i < size; i++) \r\n		cout << arr[i] << \" \"; \r\n} \r\nint main() \r\n{ \r\n    int n;\r\n    cin>>n;\r\n    int arr[n];\r\n    for(int i=0;i<n;i++)\r\n        cin>>arr[i];\r\n	quickSort(arr, 0, n - 1); \r\n	printArray(arr, n); \r\n	return 0; \r\n} \r\n', 10, '', '', '\r\n\r\nALGORITHM\r\n\r\nint partition ( int A[],int start ,int end) {\r\n    int i = start + 1;\r\n    int piv = A[start] ;            //make the first element as pivot element.\r\n    for(int j =start + 1; j <= end ; j++ )  {\r\n    /*rearrange the array by putting elements which are less than pivot\r\n       on one side and which are greater that on other. */\r\n\r\n          if ( A[ j ] < piv) {\r\n                 swap (A[ i ],A [ j ]);\r\n            i += 1;\r\n        }\r\n   }\r\n   swap ( A[ start ] ,A[ i-1 ] ) ;  //put the pivot element in its proper place.\r\n   return i-1;                      //return the position of the pivot\r\n}\r\nvoid quick_sort ( int A[ ] ,int start , int end ) {\r\n   if( start < end ) {\r\n        //stores the position of pivot element\r\n         int piv_pos = partition (A,start , end ) ;     \r\n         quick_sort (A,start , piv_pos -1);    //sorts the left side of pivot.\r\n         quick_sort ( A,piv_pos +1 , end) ; //sorts the right side of pivot.\r\n   }\r\n}', '0000-00-00'),
(158, 3, 2701012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\nvoid swap(int* a, int* b) \r\n{ \r\n	int t = *a; \r\n	*a = *b; \r\n	*b = t; \r\n} \r\nint partition (int arr[], int low, int high) \r\n{ \r\n	int pivot = arr[high]; // pivot \r\n	int i = (low - 1); \r\n\r\n	for (int j = low; j <= high - 1; j++) \r\n	{ \r\n	\r\n		if (arr[j] < pivot) \r\n		{ \r\n			i++; \r\n			swap(&arr[i], &arr[j]); \r\n		} \r\n	} \r\n	swap(&arr[i + 1], &arr[high]); \r\n	return (i + 1); \r\n} \r\n\r\nvoid quickSort(int arr[], int low, int high) \r\n{ \r\n	if (low < high) \r\n	{ \r\n		\r\n		int pi = partition(arr, low, high); \r\n\r\n		quickSort(arr, low, pi - 1); \r\n		quickSort(arr, pi + 1, high); \r\n	} \r\n} \r\n\r\nvoid printArray(int arr[], int size) \r\n{ \r\n	int i; \r\n	for (i = 0; i < size; i++) \r\n		cout << arr[i] << \" \"; \r\n} \r\n \r\nint main() \r\n{ \r\n	int arr[] = {12, -5, 4, 1, 0, 6}; \r\n	int n = sizeof(arr) / sizeof(arr[0]); \r\n	quickSort(arr, 0, n - 1); \r\n	printArray(arr, n); \r\n	return 0; \r\n} ', 0, '1 2000', '-5 0 1 4 6 12 ', 'quickSort(arr[], low, high)\r\n{\r\n    if (low < high)\r\n    {\r\n        /* pi is partitioning index, arr[pi] is now\r\n           at right place */\r\n        pi = partition(arr, low, high);\r\n\r\n        quickSort(arr, low, pi - 1);  // Before pi\r\n        quickSort(arr, pi + 1, high); // After pi\r\n    }\r\n}', '2020-05-25'),
(159, 7, 3801012018, '#include <bits/stdc++.h>\r\nusing namespace std; \r\nint partition(int arr[], int low, int high) \r\n{ \r\n	int pivot = arr[high]; \r\n	int i = (low - 1); \r\n	for (int j = low; j <= high - 1; j++) { \r\n		if (arr[j] <= pivot) { \r\n		    i++;\r\n			swap(arr[i], arr[j]); \r\n		} \r\n	} \r\n	swap(arr[i + 1], arr[high]); \r\n	return (i + 1); \r\n} \r\nint partition_r(int arr[], int low, int high) \r\n{ \r\n	srand(time(NULL)); \r\n	int random = low + rand() % (high - low); \r\n	swap(arr[random], arr[high]); \r\n	return partition(arr, low, high); \r\n} \r\nvoid quickSort(int arr[], int low, int high) \r\n{ \r\n	if (low < high) { \r\n		int pi = partition_r(arr, low, high); \r\n		quickSort(arr, low, pi - 1); \r\n		quickSort(arr, pi + 1, high); \r\n	} \r\n} \r\nvoid printArray(int arr[], int size) \r\n{ \r\n	int i; \r\n	for (i = 0; i < size; i++) \r\n	  cout<<arr[i]<<\" \";\r\n} \r\nint main() \r\n{ \r\n    int n;\r\n    cin>>n;\r\n    int arr[n];\r\n    for(int i=0;i<n;i++)\r\n    cin>>arr[i];\r\n	quickSort(arr, 0, n - 1); \r\n	printArray(arr, n); \r\n	return 0; \r\n} \r\n', 10, '', '', '', '0000-00-00'),
(160, 7, 2701012018, '#include <bits/stdc++.h>\r\nusing namespace std; \r\n\r\nint partition(int arr[], int low, int high) \r\n{ \r\n	int pivot = arr[low]; \r\n	int i = low - 1, j = high + 1; \r\n\r\n	while (true) { \r\n\r\n		\r\n		do { \r\n			i++; \r\n		} while (arr[i] < pivot); \r\n\r\n	\r\n		do { \r\n			j--; \r\n		} while (arr[j] > pivot); \r\n\r\n		\r\n		if (i >= j) \r\n			return j; \r\n\r\n		swap(arr[i], arr[j]); \r\n	} \r\n} \r\n\r\n\r\nint partition_r(int arr[], int low, int high) \r\n{ \r\n	\r\n	srand(time(NULL)); \r\n	int random = low + rand() % (high - low); \r\n\r\n\r\n	swap(arr[random], arr[low]); \r\n\r\n	return partition(arr, low, high); \r\n} \r\n\r\n\r\nvoid quickSort(int arr[], int low, int high) \r\n{ \r\n	if (low < high) { \r\n		\r\n		int pi = partition_r(arr, low, high); \r\n\r\n	\r\n		quickSort(arr, low, pi); \r\n		quickSort(arr, pi + 1, high); \r\n	} \r\n} \r\n\r\n\r\nvoid printArray(int arr[], int n) \r\n{ \r\n	for (int i = 0; i < n; i++) \r\n		cout<<arr[i]<<\" \";\r\n} \r\n\r\n\r\nint main() \r\n{   \r\n    int n;\r\n    cin>>n;\r\n    int arr[n];\r\n    for(int i=0;i<n;i++)\r\n    cin>>arr[i];\r\n	quickSort(arr, 0, n - 1); \r\n	printArray(arr, n); \r\n	return 0; \r\n} \r\n', 10, '', '', '', '0000-00-00'),
(162, 7, 3201012018, '#include <cstdlib> \r\n#include<ctime>\r\n #include <iostream> \r\nusing namespace std; \r\nint partition(int arr[], int low, int high) \r\n{\r\n int pivot = arr[high]; // pivot\r\n int i = (low - 1); // Index of smaller element\r\n for (int j = low; j <= high - 1; j++) \r\n{ \r\n    if (arr[j] <= pivot) \r\n{     i++; \r\n     swap(arr[i], arr[j]); \r\n} \r\n} \r\nswap(arr[i + 1], arr[high]); \r\nreturn (i + 1);\r\n } \r\nint partition_r(int arr[], int low, int high) \r\n{ \r\nsrand(time(NULL));\r\n int random = low + rand() % (high - low); \r\nswap(arr[random], arr[high]);\r\n return partition(arr, low, high); \r\n}  \r\nvoid quickSort(int arr[], int low, int high) \r\n{ \r\nif (low < high)\r\n { \r\nint pi = partition_r(arr, low, high); \r\nquickSort(arr, low, pi - 1);\r\n quickSort(arr, pi + 1, high); \r\n} \r\n}\r\n /* Function to print an array */ \r\nvoid printArray(int arr[], int size) \r\n{ int i; for (i = 0; i < size; i++) cout<<arr[i]<<\" \"; } \r\n// Driver program to test above functions \r\nint main()\r\n { \r\nint n; \r\ncin>>n; \r\nint arr[n]; \r\nfor(int i=0;i<n;i++) { cin>>arr[i]; } \r\nquickSort(arr, 0, n - 1); \r\nprintArray(arr, n);\r\n return 0;\r\n } \r\n\r\n\r\n                                            \r\n', 10, '', '', '', '0000-00-00'),
(163, 3, 1101012018, '#include<iostream>\r\nusing namespace std;\r\nvoid quickSort(int input[], int size) {\r\n  if(size == 0)\r\n    return;\r\n  int check = 0;\r\n  for(int i = 1; i < size; ++i)\r\n  {\r\n    if(input[i] <= input[0])\r\n      check++;\r\n  }\r\n  int temp = input[0];\r\n  input[0] = input[check];\r\n  input[check] = temp;\r\n  int left = 0, right = size-1;\r\n  while(left < check)\r\n  {\r\n    while(input[left] <= input[check] && left < check)\r\n      left++;\r\n    while(input[right] > input[check])\r\n      right--;\r\n   \r\n   {\r\n      int k = input[left];\r\n      input[left] = input[right];\r\n      input[right] = k;\r\n      left++;\r\n      right--;\r\n   }\r\n  }\r\n  quickSort(input, check);\r\n  quickSort(input+check+1, size-check-1);\r\n}\r\n\r\nint main()\r\n{\r\n    int n;\r\n    cin>>n;\r\n    int arr[n];\r\n    for(int i = 0; i < n; ++i)\r\n        cin>>arr[i];\r\n        \r\n    quickSort(arr, n);\r\n    //sort(arr, arr+n);\r\n    \r\n    for(int i = 0; i < n; ++i)\r\n    {\r\n        cout<<arr[i]<<\" \";\r\n    }\r\n    \r\n}\r\n', 10, '', '', '', '0000-00-00'),
(164, 3, 3301012018, '#include <bits/stdc++.h> \nusing namespace std;  \n  \n// A utility function to swap two elements  \nvoid swap(int* a, int* b)  \n{  \n    int t = *a;  \n    *a = *b;  \n    *b = t;  \n}  \n  \nint partition (int arr[], int low, int high)  \n{  \n    int pivot = arr[high]; // pivot  \n    int i = (low - 1); // Index of smaller element  \n  \n    for (int j = low; j <= high - 1; j++)  \n    {  \n        // If current element is smaller than the pivot  \n        if (arr[j] < pivot)  \n        {  \n            i++; // increment index of smaller element  \n            swap(&arr[i], &arr[j]);  \n        }  \n    }  \n    swap(&arr[i + 1], &arr[high]);  \n    return (i + 1);  \n}  \n  \n/* The main function that implements QuickSort   */\nvoid quickSort(int arr[], int low, int high)  \n{  \n    if (low < high)  \n    {  \n        /* pi is partitioning index, arr[p] is now  \n        at right place */\n        int pi = partition(arr, low, high);  \n  \n        // Separately sort elements before  \n        // partition and after partition  \n        quickSort(arr, low, pi - 1);  \n        quickSort(arr, pi + 1, high);  \n    }  \n}  \n  \n/* Function to print an array */\nvoid printArray(int arr[], int size)  \n{  \n    int i;  \n    for (i = 0; i < size; i++)  \n        cout << arr[i] << \" \";  \n    cout << endl;  \n}  \n  \n// Driver Code \nint main()  \n{  \n    int arr[] = {6,12,-5,4,1,0,6};  \n    int n = sizeof(arr) / sizeof(arr[0]);  \n    quickSort(arr, 0, n - 1);  \n    cout << \"\n\n\";  \n    printArray(arr, n);  \n    return 0;  \n}  \n', 0, '1 2000', '\n\n-5 0 1 4 6 6 12 \n', 'Quick Sort Pivot Algorithm\nStep 1 − Choose the highest index value has pivot\nStep 2 − Take two variables to point left and right of the list excluding pivot\nStep 3 − left points to the low index\nStep 4 − right points to the high\nStep 5 − while value at left is less than pivot move right\nStep 6 − while value at right is greater than pivot move left\nStep 7 − if both step 5 and step 6 does not match swap left and right\nStep 8 − if left ≥ right, the point where they met is new pivot\n\nQuick Sort Algorithm\nStep 1 − Make the right-most index value pivot\nStep 2 − partition the array using pivot value\nStep 3 − quicksort left partition recursively\nStep 4 − quicksort right partition recursively\n', '2020-05-25'),
(165, 7, 601012018, '#include <bits/stdc++.h>\r\nusing namespace std; \r\n\r\nint partition(int arr[], int low, int high) \r\n{ \r\n	int pivot = arr[low]; \r\n	int i = low - 1, j = high + 1; \r\n\r\n	while (true) { \r\n\r\n		\r\n		do { \r\n			i++; \r\n		} while (arr[i] < pivot); \r\n\r\n	\r\n		do { \r\n			j--; \r\n		} while (arr[j] > pivot); \r\n\r\n		\r\n		if (i >= j) \r\n			return j; \r\n\r\n		swap(arr[i], arr[j]); \r\n	} \r\n} \r\n\r\n\r\nint partition_r(int arr[], int low, int high) \r\n{ \r\n	\r\n	srand(time(NULL)); \r\n	int random = low + rand() % (high - low); \r\n\r\n\r\n	swap(arr[random], arr[low]); \r\n\r\n	return partition(arr, low, high); \r\n} \r\n\r\n\r\nvoid quickSort(int arr[], int low, int high) \r\n{ \r\n	if (low < high) { \r\n		\r\n		int pi = partition_r(arr, low, high); \r\n\r\n	\r\n		quickSort(arr, low, pi); \r\n		quickSort(arr, pi + 1, high); \r\n	} \r\n} \r\n\r\n\r\nvoid printArray(int arr[], int n) \r\n{ \r\n	for (int i = 0; i < n; i++) \r\n		cout<<arr[i]<<\" \";\r\n} \r\n\r\n\r\nint main() \r\n{   \r\n    int n;\r\n    cin>>n;\r\n    int arr[n];\r\n    for(int i=0;i<n;i++)\r\n    cin>>arr[i];\r\n	quickSort(arr, 0, n - 1); \r\n	printArray(arr, n); \r\n	return 0; \r\n} ', 10, '', '', '', '0000-00-00'),
(166, 3, 401012018, '#include<iostream>\r\nusing namespace std;\r\nvoid quicksort(int[],int,int);\r\nint partition(int[],int,int);\r\nint main()\r\n{\r\n  int a[50],n,i;\r\n  cin>>n;\r\n  for(i=0;i<n;++i)\r\n    cin>>a[i];\r\n  quicksort(a,0,n-1);\r\n  for(i=0;i<n;++i)\r\n    cout<<a[i]<<\" \";\r\n  return 0;    \r\n}\r\nvoid quicksort(int a[],int l,int u)\r\n{\r\n    int j;\r\n    if(l<=u)\r\n    {\r\n        j=partition(a,l,u);\r\n        quicksort(a,l,j-1);\r\n        quicksort(a,j+1,u);\r\n    }\r\n    \r\n}\r\nvoid swap(int a[],int b[])\r\n{\r\n    int t=*a;\r\n    *a=*b;\r\n    *b=t;\r\n}\r\nint partition(int a[],int l,int u)\r\n{\r\n    int p=a[u];\r\n    int i=l-1;\r\n    for(int j=l;j<=u-1;++j)\r\n    {\r\n        if(a[j]<=p)\r\n        {\r\n            ++i;\r\n            swap(&a[i],&a[j]);\r\n        }\r\n    }\r\n    swap(&a[i+1],&a[u]);\r\n    return (i+1);\r\n}\r\n', 10, '', '', '', '0000-00-00'),
(168, 3, 2501012018, '//QUICK\r\n#include <iostream>\r\n \r\nusing namespace std;\r\n \r\nvoid quick_sort(int[],int,int);\r\nint partition(int[],int,int);\r\n \r\nint main()\r\n{\r\n    int a[50],n,i;\r\n\r\n    cin>>n;\r\n\r\n    \r\n    for(i=0;i<n;i++)\r\n        cin>>a[i];\r\n        \r\n    quick_sort(a,0,n-1);\r\n    \r\n    \r\n    for(i=0;i<n;i++)\r\n    if(i!= n)\r\n        cout<<a[i]<<\" \";\r\n        //cout<<a[n-1];\r\n    \r\n    return 0;        \r\n}\r\n \r\nvoid quick_sort(int a[],int l,int u)\r\n{\r\n    int j;\r\n    if(l<u)\r\n    {\r\n        j=partition(a,l,u);\r\n        quick_sort(a,l,j-1);\r\n        quick_sort(a,j+1,u);\r\n    }\r\n}\r\n \r\nint partition(int a[],int l,int u)\r\n{\r\n    int v,i,j,temp;\r\n    v=a[l];\r\n    i=l;\r\n    j=u+1;\r\n    \r\n    do\r\n    {\r\n        do\r\n            i++;\r\n            \r\n        while(a[i]<v&&i<=u);\r\n        \r\n        do\r\n            j--;\r\n        while(v<a[j]);\r\n        \r\n        if(i<j)\r\n        {\r\n            temp=a[i];\r\n            a[i]=a[j];\r\n            a[j]=temp;\r\n        }\r\n    }while(i<j);\r\n    \r\n    a[l]=a[j];\r\n    a[j]=v;\r\n    \r\n    return(j);\r\n}\r\n', 10, '', '', '', '0000-00-00'),
(169, 3, 1901012018, '#include<iostream>\r\nusing namespace std;\r\n#include <iostream>\r\nusing namespace std;\r\nvoid swap(int *a, int *b)\r\n{\r\n  int t = *a;\r\n  *a = *b;\r\n  *b = t;\r\n}\r\n\r\nint partition(int array[], int low, int high)\r\n{\r\n  int pivot = array[high];\r\n  int i = (low - 1);\r\n  for (int j = low; j < high; j++)\r\n  {\r\n    if (array[j] <= pivot)\r\n    {\r\n      i++;\r\n      swap(&array[i], &array[j]);\r\n    }\r\n  }\r\n\r\n\r\n  swap(&array[i + 1], &array[high]);\r\n  return (i + 1);\r\n}\r\nvoid qs(int array[], int low, int high)\r\n{\r\n  if (low < high)\r\n  {\r\n    int pi = partition(array, low, high);\r\n    qs(array, low, pi - 1);\r\n    qs(array, pi + 1, high);\r\n  }\r\n}\r\n\r\n\r\nint main(){\r\nint n;\r\ncin>>n;\r\nint arr[n];\r\nfor(int i=0;i<n;i++){\r\n    cin>>arr[i];\r\n}\r\nqs(arr,0,n-1);\r\nfor(int i=0;i<n;i++){\r\n    cout<<arr[i];\r\n    // if(i==n-1)\r\n    // break;\r\n    cout<<\" \";\r\n}\r\nreturn 0;\r\n}', 10, '', '', '', '0000-00-00');
INSERT INTO `qtos_map` (`ID`, `Q_ID`, `ROLL`, `SUBMISSION`, `SCORE`, `INPUT`, `OP`, `ALGO`, `DATE`) VALUES
(170, 3, 1801012018, '#include<iostream>\r\nusing namespace std;\r\nvoid quickSort(int input[], int size) {\r\n  if(size == 0)\r\n    return;\r\n  int check = 0;\r\n  for(int i = 1; i < size; ++i)\r\n  {\r\n    if(input[i] <= input[0])\r\n      check++;\r\n  }\r\n  int temp = input[0];\r\n  input[0] = input[check];\r\n  input[check] = temp;\r\n  int left = 0, right = size-1;\r\n  while(left < check)\r\n  {\r\n    while(input[left] <= input[check] && left < check)\r\n      left++;\r\n    while(input[right] > input[check])\r\n      right--;\r\n   \r\n   {\r\n      int k = input[left];\r\n      input[left] = input[right];\r\n      input[right] = k;\r\n      left++;\r\n      right--;\r\n   }\r\n  }\r\n  quickSort(input, check);\r\n  quickSort(input+check+1, size-check-1);\r\n}\r\n\r\nint main()\r\n{\r\n    int n;\r\n    cin>>n;\r\n    int arr[n];\r\n    for(int i = 0; i < n; ++i)\r\n        cin>>arr[i];\r\n        \r\n    quickSort(arr, n);\r\n    //sort(arr, arr+n);\r\n    \r\n    for(int i = 0; i < n; ++i)\r\n    {\r\n        cout<<arr[i]<<\" \";\r\n        }\r\n    \r\n}', 10, '', '', 'partition (arr[], low, high)\r\n{\r\n    // pivot (Element to be placed at right position)\r\n    pivot = arr[high];  \r\n \r\n    i = (low - 1)  // Index of smaller element\r\n\r\n    for (j = low; j <= high- 1; j++)\r\n    {\r\n        // If current element is smaller than the pivot\r\n        if (arr[j] < pivot)\r\n        {\r\n            i++;    // increment index of smaller element\r\n            swap arr[i] and arr[j]\r\n        }\r\n    }\r\n    swap arr[i + 1] and arr[high])\r\n    return (i + 1)\r\n}', '0000-00-00'),
(172, 13, 1001012018, '#include <iostream> \r\nusing namespace std; \r\nclass Edge \r\n{ \r\n    public: \r\n    int src, dest, weight; \r\n}; \r\nclass Graph \r\n{ \r\n    public: \r\n    int V, E; \r\n    Edge* edge; \r\n}; \r\nGraph* createGraph(int V, int E) \r\n{ \r\n    Graph* graph = new Graph; \r\n    graph->V = V; \r\n    graph->E = E; \r\n    graph->edge = new Edge[E]; \r\n    return graph; \r\n} \r\nclass subset \r\n{ \r\n    public: \r\n    int parent; \r\n    int rank; \r\n}; \r\nint find(subset subsets[], int i) \r\n{ \r\n    if (subsets[i].parent != i) \r\n        subsets[i].parent = find(subsets, subsets[i].parent); \r\n    return subsets[i].parent; \r\n} \r\nvoid Union(subset subsets[], int x, int y) \r\n{ \r\n    int xroot = find(subsets, x); \r\n    int yroot = find(subsets, y); \r\n    if (subsets[xroot].rank < subsets[yroot].rank) \r\n        subsets[xroot].parent = yroot; \r\n    else if (subsets[xroot].rank > subsets[yroot].rank) \r\n        subsets[yroot].parent = xroot; \r\n    else\r\n    { \r\n        subsets[yroot].parent = xroot; \r\n        subsets[xroot].rank++; \r\n    } \r\n} \r\nint myComp(const void* a, const void* b) \r\n{ \r\n    Edge* a1 = (Edge*)a; \r\n    Edge* b1 = (Edge*)b; \r\n    return a1->weight > b1->weight; \r\n} \r\nvoid KruskalMST(Graph* graph) \r\n{ \r\n    int V = graph->V; \r\n    Edge result[V]; \r\n    int e = 0; \r\n    int i = 0; \r\n    qsort(graph->edge, graph->E, sizeof(graph->edge[0]), myComp); \r\n    subset *subsets = new subset[( V * sizeof(subset) )]; \r\n    for (int v = 0; v < V; ++v) \r\n    { \r\n        subsets[v].parent = v; \r\n        subsets[v].rank = 0; \r\n    } \r\n    while (e < V - 1 && i < graph->E) \r\n    { \r\n        Edge next_edge = graph->edge[i++]; \r\n        int x = find(subsets, next_edge.src); \r\n        int y = find(subsets, next_edge.dest); \r\n        if (x != y) \r\n        { \r\n            result[e++] = next_edge; \r\n            Union(subsets, x, y); \r\n        } \r\n    } \r\n    cout<<\"Following are the edges in the constructed MST\n\"; \r\n    for (i = 0; i < e; ++i) \r\n        cout<<result[i].src<<\" -- \"<<result[i].dest<<\" ==> \"<<result[i].weight<<endl; \r\n    return; \r\n} \r\nint main() \r\n{ \r\n    int V = 4; \r\n    int E = 5; \r\n    Graph* graph = createGraph(V, E); \r\n    graph->edge[0].src = 0; \r\n    graph->edge[0].dest = 1; \r\n    graph->edge[0].weight = 10; \r\n    graph->edge[1].src = 0; \r\n    graph->edge[1].dest = 2; \r\n    graph->edge[1].weight = 6; \r\n    graph->edge[2].src = 0; \r\n    graph->edge[2].dest = 3; \r\n    graph->edge[2].weight = 5; \r\n    graph->edge[3].src = 1; \r\n    graph->edge[3].dest = 3; \r\n    graph->edge[3].weight = 15; \r\n    graph->edge[4].src = 2; \r\n    graph->edge[4].dest = 3; \r\n    graph->edge[4].weight = 4; \r\n    KruskalMST(graph); \r\n    return 0; \r\n}', 1000, '', '', '', '0000-00-00'),
(173, 7, 1101012018, '#include<iostream>\r\n#include<cstdlib>\r\n\r\nusing namespace std;\r\nint PARTITION(int [],int ,int );\r\nvoid R_QUICKSORT(int [],int ,int );\r\nint R_PARTITION(int [],int,int );\r\n\r\nint main()\r\n{\r\n    int n;\r\n    //cout<<\"Enter the size of the array\"<<endl;\r\n    cin>>n;\r\n    int a[n];\r\n    //cout<<\"Enter the elements in the array\"<<endl;\r\n    for(int i=1;i<=n;i++)\r\n    {\r\n        cin>>a[i];\r\n    }\r\n\r\n    //cout<<\"sorting using randomized quick sort\"<<endl;\r\n    int p=1,r=n;\r\n\r\n    R_QUICKSORT(a,p,r);\r\n\r\n   //cout<<\"sorted form\"<<endl;\r\n   for(int i=1;i<=n;i++)\r\n   {\r\n       cout<<a[i]<<\" \";\r\n   }\r\n     return 0;\r\n}\r\n\r\nvoid R_QUICKSORT(int a[],int p,int r)\r\n    {\r\n        int q;\r\n        if(p<r)\r\n        {\r\n         q=R_PARTITION(a,p,r);\r\n         R_QUICKSORT(a,p,q-1);\r\n         R_QUICKSORT(a,q+1,r);\r\n        }\r\n    }\r\n\r\n int R_PARTITION(int a[],int p,int r)\r\n {\r\n        int i=p+rand()%(r-p+1);\r\n        int temp;\r\n        temp=a[r];\r\n        a[r]=a[i];\r\n        a[i]=temp;\r\n        return PARTITION(a,p,r);\r\n  }\r\n\r\n int PARTITION(int a[],int p,int r)\r\n {\r\n        int temp,temp1;\r\n        int x=a[r];\r\n        int i=p-1;\r\n        for(int j=p;j<=r-1;j++)\r\n        {\r\n            if(a[j]<=x)\r\n            {\r\n\r\n                i=i+1;\r\n                temp=a[i];\r\n                a[i]=a[j];\r\n                a[j]=temp;\r\n            }\r\n        }\r\n        temp1=a[i+1];\r\n        a[i+1]=a[r];\r\n        a[r]=temp1;\r\n        return i+1;\r\n  }', 10, '', '', '', '0000-00-00'),
(174, 10, 1901012018, '#include<stdio.h>\r\n#include<limits.h>\r\nint max(int a, int b) { return (a > b)? a : b; }\r\nint knapSack(int W, int wt[], int val[], int n)\r\n{\r\n if (n == 0 || W == 0)\r\n return 0;\r\n if (wt[n-1] > W)\r\n return knapSack(W, wt, val, n-1);\r\n\r\n else return max( val[n-1] + knapSack(W-wt[n-1], wt, val, n-1),\r\n knapSack(W, wt, val, n-1) );\r\n}\r\n\r\nint main()\r\n{\r\n int n;\r\n int W ,i;\r\n scanf(\"%d\",&n);\r\n scanf(\"%d\",&W);\r\n int wt[n],val[n];\r\n for(i=0;i<n;i++)\r\n scanf(\"%d\",&val[i]);\r\n for(i=0;i<n;i++)\r\n scanf(\"%d\",&wt[i]);\r\n printf(\"%d\", knapSack(W, wt, val, n));\r\n return 0;\r\n}\r\n', 10, '5 15 4 2 1 2 10 12 2 1 1 4', '15', 'Partitioning the individuals into different sets according to the groups in which they fall. This method is known as disjoint set data structure which maintains collection of disjoint sets and each set is represented by its representative which is one of its members.\r\n\r\nApproach:\r\n\r\n    How to Resolve sets ? Initially all elements belong to different sets. After working on the given relations, we select a member as representative. There can by many ways to select a representative, a simple one is to select with the biggest index.\r\n    Check if 2 persons are in the same group ? If representatives of two individuals are same, then they?ll become friends.\r\n\r\n \r\nData Structures used:\r\nArray : An array of integers, called parent[]. If we are dealing with n items, i?th element of the array represents the i?th item. More precisely, the i?th element of the array is the parent of the i?th item. These relationships create one, or more, virtual trees.\r\n\r\nTree : It is a disjoint set. If two elements are in the same tree, then they are in the same disjoint set. The root node (or the topmost node) of each tree is called the representative of the set. There is always a single unique representative of each set. A simple rule to identify representative is, if i is the representative of a set, then parent[i] = i. If i is not the representative of his set, then it can be found by traveling up the tree until we find the representative.\r\n\r\n \r\nOperations :\r\n\r\nFind : Can be implemented by recursively traversing the parent array until we hit a node who is parent of itself.\r\n\r\n// Finds the representative of the set  \r\n// that i is an element of\r\nint find(int i) \r\n{\r\n    // If i is the parent of itself\r\n    if (parent[i] == i) \r\n    {\r\n        // Then i is the representative of \r\n        // this set\r\n        return i;\r\n    }\r\n    else \r\n    {\r\n        // Else if i is not the parent of \r\n        // itself, then i is not the \r\n        // representative of his set. So we \r\n        // recursively call Find on its parent\r\n        return find(parent[i]);\r\n    }\r\n}\r\n\r\nUnion: It takes, as input, two elements. And finds the representatives of their sets using the find operation, and finally puts either one of the trees (representing the set) under the root node of the other tree, effectively merging the trees and the sets.\r\n\r\n// Unites the set that includes i \r\n// and the set that includes j\r\nvoid union(int i, int j) \r\n{\r\n    // Find the representatives\r\n    // (or the root nodes) for the set\r\n    // that includes i\r\n    \r\n    int irep = this.Find(i),\r\n\r\n    // And do the same for the set \r\n    // that includes j    \r\n    int jrep = this.Find(j);\r\n\r\n    // Make the parent of i?s representative\r\n    // be j?s  representative effectively \r\n    // moving all of i?s set into j?s set)\r\n    this.Parent[irep] = jrep;\r\n}\r\n\r\nImprovements (Union by Rank and Path Compression)\r\nThe efficiency depends heavily on the height of the tree. We need to minimize the height of tree in order improve the efficiency. We can use Path Compression and Union by rank methods to do so.\r\n\r\nPath Compression (Modifications to find()) : It speeds up the data structure by compressing the height of the trees. It can be achieved by inserting a small caching mechanism into the Find operation. Take a look at the code for more details:\r\n\r\n// Finds the representative of the set that i\r\n// is an element of.\r\nint find(int i) \r\n{\r\n    // If i is the parent of itself\r\n    if (Parent[i] == i) \r\n    {\r\n        // Then i is the representative \r\n        return i;\r\n    }\r\n    else\r\n    { \r\n        // Recursively find the representative.\r\n        int result = find(Parent[i]);\r\n\r\n        // We cache the result by moving i?s node \r\n        // directly under the representative of this\r\n        // set\r\n        Parent[i] = result;\r\n       \r\n        // And then we return the result\r\n        return result;\r\n     }\r\n}\r\n\r\nUnion by Rank: First of all, we need a new array of integers called rank[]. Size of this array is same as the parent array. If i is a representative of a set, rank[i] is the height of the tree representing the set.\r\nNow recall that, in the Union operation, it doesn?t matter which of the two trees is moved under the other (see last two image examples above). Now what we want to do is minimize the height of the resulting tree. If we are uniting two trees (or sets), let?s call them left and right, then it all depends on the rank of left and the rank of right.\r\n\r\n\r\n    If the rank of left is less than the rank of right, then it?s best to move left under right, because that won?t change the rank of right (while moving right under left would increase the height). In the same way, if the rank of right is less than the rank of left, then we should move right under left.\r\n    If the ranks are equal, it doesn?t matter which tree goes under the other, but the rank of the result will always be one greater than the rank of the trees.\r\n\r\n// Unites the set that includes i and the set \r\n// that includes j\r\nvoid union(int i, int j) \r\n{\r\n    // Find the representatives (or the root nodes) \r\n    // for the set that includes i\r\n    int irep = this.find(i);\r\n\r\n    // And do the same for the set that includes j\r\n    int jrep = this.Find(j);\r\n\r\n    // Elements are in same set, no need to \r\n    // unite anything.    \r\n    if (irep == jrep)\r\n        return;\r\n\r\n    // Get the rank of i?s tree\r\n    irank = Rank[irep],\r\n\r\n    // Get the rank of j?s tree\r\n    jrank = Rank[jrep];\r\n\r\n    // If i?s rank is less than j?s rank\r\n    if (irank < jrank) \r\n    {\r\n        // Then move i under j\r\n        this.parent[irep] = jrep;\r\n    } \r\n\r\n    // Else if j?s rank is less than i?s rank\r\n    else if (jrank < irank) \r\n    {\r\n        // Then move j under i\r\n        this.Parent[jrep] = irep;\r\n    } \r\n\r\n    // Else if their ranks are the same\r\n    else\r\n    {\r\n\r\n        // Then move i under j (doesn?t matter\r\n        // which one goes where)\r\n        this.Parent[irep] = jrep;\r\n\r\n        // And increment the result tree?s \r\n        // rank by 1\r\n        Rank[jrep]++;\r\n    }\r\n}\r\nPartitioning the individuals into different sets according to the groups in which they fall. This method is known as disjoint set data structure which maintains collection of disjoint sets and each set is represented by its representative which is one of its members.\r\n\r\nApproach:\r\n\r\n    How to Resolve sets ? Initially all elements belong to different sets. After working on the given relations, we select a member as representative. There can by many ways to select a representative, a simple one is to select with the biggest index.\r\n    Check if 2 persons are in the same group ? If representatives of two individuals are same, then they?ll become friends.\r\n\r\n \r\nData Structures used:\r\nArray : An array of integers, called parent[]. If we are dealing with n items, i?th element of the array represents the i?th item. More precisely, the i?th element of the array is the parent of the i?th item. These relationships create one, or more, virtual trees.\r\n\r\nTree : It is a disjoint set. If two elements are in the same tree, then they are in the same disjoint set. The root node (or the topmost node) of each tree is called the representative of the set. There is always a single unique representative of each set. A simple rule to identify representative is, if i is the representative of a set, then parent[i] = i. If i is not the representative of his set, then it can be found by traveling up the tree until we find the representative.\r\n\r\n \r\nOperations :\r\n\r\nFind : Can be implemented by recursively traversing the parent array until we hit a node who is parent of itself.\r\n\r\n// Finds the representative of the set  \r\n// that i is an element of\r\nint find(int i) \r\n{\r\n    // If i is the parent of itself\r\n    if (parent[i] == i) \r\n    {\r\n        // Then i is the representative of \r\n        // this set\r\n        return i;\r\n    }\r\n    else \r\n    {\r\n        // Else if i is not the parent of \r\n        // itself, then i is not the \r\n        // representative of his set. So we \r\n        // recursively call Find on its parent\r\n        return find(parent[i]);\r\n    }\r\n}\r\n\r\nUnion: It takes, as input, two elements. And finds the representatives of their sets using the find operation, and finally puts either one of the trees (representing the set) under the root node of the other tree, effectively merging the trees and the sets.\r\n\r\n// Unites the set that includes i \r\n// and the set that includes j\r\nvoid union(int i, int j) \r\n{\r\n    // Find the representatives\r\n    // (or the root nodes) for the set\r\n    // that includes i\r\n    \r\n    int irep = this.Find(i),\r\n\r\n    // And do the same for the set \r\n    // that includes j    \r\n    int jrep = this.Find(j);\r\n\r\n    // Make the parent of i?s representative\r\n    // be j?s  representative effectively \r\n    // moving all of i?s set into j?s set)\r\n    this.Parent[irep] = jrep;\r\n}\r\n\r\nImprovements (Union by Rank and Path Compression)\r\nThe efficiency depends heavily on the height of the tree. We need to minimize the height of tree in order improve the efficiency. We can use Path Compression and Union by rank methods to do so.\r\n\r\nPath Compression (Modifications to find()) : It speeds up the data structure by compressing the height of the trees. It can be achieved by inserting a small caching mechanism into the Find operation. Take a look at the code for more details:\r\n\r\n// Finds the representative of the set that i\r\n// is an element of.\r\nint find(int i) \r\n{\r\n    // If i is the parent of itself\r\n    if (Parent[i] == i) \r\n    {\r\n        // Then i is the representative \r\n        return i;\r\n    }\r\n    else\r\n    { \r\n        // Recursively find the representative.\r\n        int result = find(Parent[i]);\r\n\r\n        // We cache the result by moving i?s node \r\n        // directly under the representative of this\r\n        // set\r\n        Parent[i] = result;\r\n       \r\n        // And then we return the result\r\n        return result;\r\n     }\r\n}\r\n\r\nUnion by Rank: First of all, we need a new array of integers called rank[]. Size of this array is same as the parent array. If i is a representative of a set, rank[i] is the height of the tree representing the set.\r\nNow recall that, in the Union operation, it doesn?t matter which of the two trees is moved under the other (see last two image examples above). Now what we want to do is minimize the height of the resulting tree. If we are uniting two trees (or sets), let?s call them left and right, then it all depends on the rank of left and the rank of right.\r\n\r\n\r\n    If the rank of left is less than the rank of right, then it?s best to move left under right, because that won?t change the rank of right (while moving right under left would increase the height). In the same way, if the rank of right is less than the rank of left, then we should move right under left.\r\n    If the ranks are equal, it doesn?t matter which tree goes under the other, but the rank of the result will always be one greater than the rank of the trees.\r\n\r\n// Unites the set that includes i and the set \r\n// that includes j\r\nvoid union(int i, int j) \r\n{\r\n    // Find the representatives (or the root nodes) \r\n    // for the set that includes i\r\n    int irep = this.find(i);\r\n\r\n    // And do the same for the set that includes j\r\n    int jrep = this.Find(j);\r\n\r\n    // Elements are in same set, no need to \r\n    // unite anything.    \r\n    if (irep == jrep)\r\n        return;\r\n\r\n    // Get the rank of i?s tree\r\n    irank = Rank[irep],\r\n\r\n    // Get the rank of j?s tree\r\n    jrank = Rank[jrep];\r\n\r\n    // If i?s rank is less than j?s rank\r\n    if (irank < jrank) \r\n    {\r\n        // Then move i under j\r\n        this.parent[irep] = jrep;\r\n    } \r\n\r\n    // Else if j?s rank is less than i?s rank\r\n    else if (jrank < irank) \r\n    {\r\n        // Then move j under i\r\n        this.Parent[jrep] = irep;\r\n    } \r\n\r\n    // Else if their ranks are the same\r\n    else\r\n    {\r\n\r\n        // Then move i under j (doesn?t matter\r\n        // which one goes where)\r\n        this.Parent[irep] = jrep;\r\n\r\n        // And increment the result tree?s \r\n        // rank by 1\r\n        Rank[jrep]++;\r\n    }\r\n}\r\n', '2020-05-25'),
(175, 12, 1001012018, '#include <iostream> \r\nusing namespace std; \r\nclass Edge \r\n{ \r\n    public: \r\n    int src, dest, weight; \r\n}; \r\nclass Graph \r\n{ \r\n    public: \r\n    int V, E; \r\n    Edge* edge; \r\n}; \r\nGraph* createGraph(int V, int E) \r\n{ \r\n    Graph* graph = new Graph; \r\n    graph->V = V; \r\n    graph->E = E; \r\n    graph->edge = new Edge[E]; \r\n    return graph; \r\n} \r\nclass subset \r\n{ \r\n    public: \r\n    int parent; \r\n    int rank; \r\n}; \r\nint find(subset subsets[], int i) \r\n{ \r\n    if (subsets[i].parent != i) \r\n        subsets[i].parent = find(subsets, subsets[i].parent); \r\n    return subsets[i].parent; \r\n} \r\nvoid Union(subset subsets[], int x, int y) \r\n{ \r\n    int xroot = find(subsets, x); \r\n    int yroot = find(subsets, y); \r\n    if (subsets[xroot].rank < subsets[yroot].rank) \r\n        subsets[xroot].parent = yroot; \r\n    else if (subsets[xroot].rank > subsets[yroot].rank) \r\n        subsets[yroot].parent = xroot; \r\n    else\r\n    { \r\n        subsets[yroot].parent = xroot; \r\n        subsets[xroot].rank++; \r\n    } \r\n} \r\nint myComp(const void* a, const void* b) \r\n{ \r\n    Edge* a1 = (Edge*)a; \r\n    Edge* b1 = (Edge*)b; \r\n    return a1->weight > b1->weight; \r\n} \r\nvoid KruskalMST(Graph* graph) \r\n{ \r\n    int V = graph->V; \r\n    Edge result[V]; \r\n    int e = 0; \r\n    int i = 0; \r\n    qsort(graph->edge, graph->E, sizeof(graph->edge[0]), myComp); \r\n    subset *subsets = new subset[( V * sizeof(subset) )]; \r\n    for (int v = 0; v < V; ++v) \r\n    { \r\n        subsets[v].parent = v; \r\n        subsets[v].rank = 0; \r\n    } \r\n    while (e < V - 1 && i < graph->E) \r\n    { \r\n        Edge next_edge = graph->edge[i++]; \r\n        int x = find(subsets, next_edge.src); \r\n        int y = find(subsets, next_edge.dest); \r\n        if (x != y) \r\n        { \r\n            result[e++] = next_edge; \r\n            Union(subsets, x, y); \r\n        } \r\n    } \r\n    cout<<\"Following are the edges in the constructed MST\r\n\"; \r\n    for (i = 0; i < e; ++i) \r\n        cout<<result[i].src<<\" -- \"<<result[i].dest<<\" ==> \"<<result[i].weight<<endl; \r\n    return; \r\n} \r\nint main() \r\n{ \r\n    int V = 4; \r\n    int E = 5; \r\n    Graph* graph = createGraph(V, E); \r\n    graph->edge[0].src = 0; \r\n    graph->edge[0].dest = 1; \r\n    graph->edge[0].weight = 10; \r\n    graph->edge[1].src = 0; \r\n    graph->edge[1].dest = 2; \r\n    graph->edge[1].weight = 6; \r\n    graph->edge[2].src = 0; \r\n    graph->edge[2].dest = 3; \r\n    graph->edge[2].weight = 5; \r\n    graph->edge[3].src = 1; \r\n    graph->edge[3].dest = 3; \r\n    graph->edge[3].weight = 15; \r\n    graph->edge[4].src = 2; \r\n    graph->edge[4].dest = 3; \r\n    graph->edge[4].weight = 4; \r\n    KruskalMST(graph); \r\n    return 0; \r\n}', 1000, '', '', '', '0000-00-00'),
(176, 7, 1801012018, '#include<iostream>\r\n#include<cstdlib>\r\n\r\nusing namespace std;\r\nint PARTITION(int [],int ,int );\r\nvoid R_QUICKSORT(int [],int ,int );\r\nint R_PARTITION(int [],int,int );\r\n\r\nint main()\r\n{\r\n    int n;\r\n    //cout<<\"Enter the size of the array\"<<endl;\r\n    cin>>n;\r\n    int a[n];\r\n    //cout<<\"Enter the elements in the array\"<<endl;\r\n    for(int i=1;i<=n;i++)\r\n    {\r\n        cin>>a[i];\r\n    }\r\n\r\n    //cout<<\"sorting using randomized quick sort\"<<endl;\r\n    int p=1,r=n;\r\n\r\n    R_QUICKSORT(a,p,r);\r\n\r\n   //cout<<\"sorted form\"<<endl;\r\n   for(int i=1;i<=n;i++)\r\n   {\r\n       cout<<a[i]<<\" \";\r\n   }\r\n     return 0;\r\n}\r\n\r\nvoid R_QUICKSORT(int a[],int p,int r)\r\n    {\r\n        int q;\r\n        if(p<r)\r\n        {\r\n         q=R_PARTITION(a,p,r);\r\n         R_QUICKSORT(a,p,q-1);\r\n         R_QUICKSORT(a,q+1,r);\r\n        }\r\n    }\r\n\r\n int R_PARTITION(int a[],int p,int r)\r\n {\r\n        int i=p+rand()%(r-p+1);\r\n        int temp;\r\n        temp=a[r];\r\n        a[r]=a[i];\r\n        a[i]=temp;\r\n        return PARTITION(a,p,r);\r\n  }\r\n\r\n int PARTITION(int a[],int p,int r)\r\n {\r\n        int temp,temp1;\r\n        int x=a[r];\r\n        int i=p-1;\r\n        for(int j=p;j<=r-1;j++)\r\n        {\r\n            if(a[j]<=x)\r\n            {\r\n\r\n                i=i+1;\r\n                temp=a[i];\r\n                a[i]=a[j];\r\n                a[j]=temp;\r\n            }\r\n        }\r\n        temp1=a[i+1];\r\n        a[i+1]=a[r];\r\n        a[r]=temp1;\r\n        return i+1;\r\n  }', 10, '', '', '', '0000-00-00'),
(177, 7, 1601012018, '#include<iostream>\r\n#include<cstdlib>\r\n\r\nusing namespace std;\r\nint PARTITION(int [],int ,int );\r\nvoid R_QUICKSORT(int [],int ,int );\r\nint R_PARTITION(int [],int,int );\r\n\r\nint main()\r\n{\r\n    int n;\r\n    //cout<<\"Enter the size of the array\"<<endl;\r\n    cin>>n;\r\n    int a[n];\r\n    //cout<<\"Enter the elements in the array\"<<endl;\r\n    for(int i=1;i<=n;i++)\r\n    {\r\n        cin>>a[i];\r\n    }\r\n\r\n    //cout<<\"sorting using randomized quick sort\"<<endl;\r\n    int p=1,r=n;\r\n\r\n    R_QUICKSORT(a,p,r);\r\n\r\n   //cout<<\"sorted form\"<<endl;\r\n   for(int i=1;i<=n;i++)\r\n   {\r\n       cout<<a[i]<<\" \";\r\n   }\r\n     return 0;\r\n}\r\n\r\nvoid R_QUICKSORT(int a[],int p,int r)\r\n    {\r\n        int q;\r\n        if(p<r)\r\n        {\r\n         q=R_PARTITION(a,p,r);\r\n         R_QUICKSORT(a,p,q-1);\r\n         R_QUICKSORT(a,q+1,r);\r\n        }\r\n    }\r\n\r\n int R_PARTITION(int a[],int p,int r)\r\n {\r\n        int i=p+rand()%(r-p+1);\r\n        int temp;\r\n        temp=a[r];\r\n        a[r]=a[i];\r\n        a[i]=temp;\r\n        return PARTITION(a,p,r);\r\n  }\r\n\r\n int PARTITION(int a[],int p,int r)\r\n {\r\n        int temp,temp1;\r\n        int x=a[r];\r\n        int i=p-1;\r\n        for(int j=p;j<=r-1;j++)\r\n        {\r\n            if(a[j]<=x)\r\n            {\r\n\r\n                i=i+1;\r\n                temp=a[i];\r\n                a[i]=a[j];\r\n                a[j]=temp;\r\n            }\r\n        }\r\n        temp1=a[i+1];\r\n        a[i+1]=a[r];\r\n        a[r]=temp1;\r\n        return i+1;\r\n  }\r\n                                            ', 10, '', '', '', '0000-00-00'),
(178, 3, 1601012018, '#include<iostream>\r\nusing namespace std;\r\nvoid quickSort(int input[], int size) {\r\n  if(size == 0)\r\n    return;\r\n  int check = 0;\r\n  for(int i = 1; i < size; ++i)\r\n  {\r\n    if(input[i] <= input[0])\r\n      check++;\r\n  }\r\n  int temp = input[0];\r\n  input[0] = input[check];\r\n  input[check] = temp;\r\n  int left = 0, right = size-1;\r\n  while(left < check)\r\n  {\r\n    while(input[left] <= input[check] && left < check)\r\n      left++;\r\n    while(input[right] > input[check])\r\n      right--;\r\n   \r\n   {\r\n      int k = input[left];\r\n      input[left] = input[right];\r\n      input[right] = k;\r\n      left++;\r\n      right--;\r\n   }\r\n  }\r\n  quickSort(input, check);\r\n  quickSort(input+check+1, size-check-1);\r\n}\r\n\r\nint main()\r\n{\r\n    int n;\r\n    cin>>n;\r\n    int arr[n];\r\n    for(int i = 0; i < n; ++i)\r\n        cin>>arr[i];\r\n        \r\n    quickSort(arr, n);\r\n    //sort(arr, arr+n);\r\n    \r\n    for(int i = 0; i < n; ++i)\r\n    {\r\n        cout<<arr[i]<<\" \";\r\n    }\r\n    \r\n}', 10, '', '', '', '0000-00-00'),
(179, 7, 2001012018, '\r\n#include <cstdlib>\r\n#include <iostream>\r\nusing namespace std;\r\n\r\nint partition(int arr[], int low, int high)\r\n{\r\n	int pivot = arr[high];\r\n	int i = (low - 1);\r\n\r\n	for (int j = low; j <= high - 1; j++) {\r\n		if (arr[j] <= pivot) {\r\n\r\n			i++;\r\n			swap(arr[i], arr[j]);\r\n		}\r\n	}\r\n	swap(arr[i + 1], arr[high]);\r\n	return (i + 1);\r\n}\r\n\r\nint partition_r(int arr[], int low, int high)\r\n{\r\n\r\n	int random = low + rand() % (high - low);\r\n\r\n	swap(arr[random], arr[high]);\r\n\r\n	return partition(arr, low, high);\r\n}\r\n\r\nvoid quickSort(int arr[], int low, int high)\r\n{\r\n	if (low < high) {\r\n\r\n		int pi = partition_r(arr, low, high);\r\n		quickSort(arr, low, pi - 1);\r\n		quickSort(arr, pi + 1, high);\r\n	}\r\n}\r\n\r\nvoid printArray(int arr[], int size)\r\n{\r\n	int i;\r\n	for (i = 0; i < size; i++)\r\n    cout<<arr[i]<<\" \";\r\n}\r\n\r\nint main()\r\n{\r\n	int n;\r\n	cin>>n;\r\n	int arr[n];\r\n	for(int i=0; i<=n; i++)\r\n    {\r\n        cin>>arr[i];\r\n    }\r\n	quickSort(arr, 0, n - 1);\r\n	printArray(arr, n);\r\n	return 0;\r\n}\r\n\r\n', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', 'partition(arr[], low, high) \r\n    pivot = arr[high]\r\n    i = low\r\n    for j := low to high ? 1 do\r\n        if arr[j] <= pivot then\r\n            swap arr[i] with arr[j]\r\n            i = i + 1\r\n    swap arr[i] with arr[high]\r\n    return i\r\n\r\npartition_r(arr[], low, high)\r\n    r = Random Number from low to high\r\n    Swap arr[r] and arr[high]\r\n    return partition(arr, low, high)\r\n\r\nrandomisedquicksort(arr[], low, high)\r\n    if low < high\r\n        p = partition_r(arr, low, high)\r\n        quicksort(arr, p-1, high)\r\n        quicksort(arr, p+1, high)\r\n', '2020-05-25'),
(180, 3, 1201012018, '\r\n#include <iostream>\r\nusing namespace std;\r\nvoid swap(int *a, int *b)\r\n{\r\n  int t = *a;\r\n  *a = *b;\r\n  *b = t;\r\n}\r\n\r\nint partition(int array[], int low, int high)\r\n{\r\n  int pivot = array[high];\r\n  int i = (low - 1);\r\n  for (int j = low; j < high; j++)\r\n  {\r\n    if (array[j] <= pivot)\r\n    {\r\n      i++;\r\n      swap(&array[i], &array[j]);\r\n    }\r\n  }\r\n\r\n\r\n  swap(&array[i + 1], &array[high]);\r\n  return (i + 1);\r\n}\r\nvoid qs(int array[], int low, int high)\r\n{\r\n  if (low < high)\r\n  {\r\n    int pi = partition(array, low, high);\r\n    qs(array, low, pi - 1);\r\n    qs(array, pi + 1, high);\r\n  }\r\n}\r\n\r\n\r\nint main(){\r\nint n;\r\ncin>>n;\r\nint arr[n];\r\nfor(int i=0;i<n;i++){\r\n    cin>>arr[i];\r\n}\r\nqs(arr,0,n-1);\r\nfor(int i=0;i<n;i++){\r\n    cout<<arr[i];\r\n    // if(i==n-1)\r\n    // break;\r\n    cout<<\" \";\r\n}\r\nreturn 0;\r\n}', 10, '', '', '', '0000-00-00'),
(181, 3, 1401012018, '//QUICK\r\n#include <iostream>\r\n \r\nusing namespace std;\r\n \r\nvoid quick_sort(int[],int,int);\r\nint partition(int[],int,int);\r\n \r\nint main()\r\n{\r\n    int a[50],n,i;\r\n\r\n    cin>>n;\r\n\r\n    \r\n    for(i=0;i<n;i++)\r\n        cin>>a[i];\r\n        \r\n    quick_sort(a,0,n-1);\r\n    \r\n    \r\n    for(i=0;i<n;i++)\r\n    if(i!= n)\r\n        cout<<a[i]<<\" \";\r\n        //cout<<a[n-1];\r\n    \r\n    return 0;        \r\n}\r\n \r\nvoid quick_sort(int a[],int l,int u)\r\n{\r\n    int j;\r\n    if(l<u)\r\n    {\r\n        j=partition(a,l,u);\r\n        quick_sort(a,l,j-1);\r\n        quick_sort(a,j+1,u);\r\n    }\r\n}\r\n \r\nint partition(int a[],int l,int u)\r\n{\r\n    int v,i,j,temp;\r\n    v=a[l];\r\n    i=l;\r\n    j=u+1;\r\n    \r\n    do\r\n    {\r\n        do\r\n            i++;\r\n            \r\n        while(a[i]<v&&i<=u);\r\n        \r\n        do\r\n            j--;\r\n        while(v<a[j]);\r\n        \r\n        if(i<j)\r\n        {\r\n            temp=a[i];\r\n            a[i]=a[j];\r\n            a[j]=temp;\r\n        }\r\n    }while(i<j);\r\n    \r\n    a[l]=a[j];\r\n    a[j]=v;\r\n    \r\n    return(j);\r\n}', 10, '', '', '', '0000-00-00'),
(182, 7, 301012018, '#include <bits/stdc++.h> \r\nusing namespace std;  \r\n  \r\n  \r\nvoid swap(int* a, int* b)  \r\n{  \r\n    int t = *a;  \r\n    *a = *b;  \r\n    *b = t;  \r\n}  \r\n  \r\nint partition (int arr[], int low, int high)  \r\n{  \r\n    int pivot = arr[high]; \r\n    int i = (low - 1); \r\n  \r\n    for (int j = low; j <= high - 1; j++)  \r\n    {  \r\n        \r\n        if (arr[j] < pivot)  \r\n        {  \r\n            i++;  \r\n            swap(&arr[i], &arr[j]);  \r\n        }  \r\n    }  \r\n    swap(&arr[i + 1], &arr[high]);  \r\n    return (i + 1);  \r\n}  \r\n\r\nvoid quickSort(int arr[], int low, int high)  \r\n{  \r\n    if (low < high)  \r\n    {  \r\n        \r\n        int pi = partition(arr, low, high);  \r\n  \r\n\r\n        \r\n        quickSort(arr, low, pi - 1);  \r\n        quickSort(arr, pi + 1, high);  \r\n    }  \r\n}  \r\n  \r\n\r\nvoid printArray(int arr[], int size)  \r\n{  \r\n    int i;  \r\n    for (i = 0; i < size; i++)  \r\n        cout << arr[i] << \" \";  \r\n      \r\n}  \r\n  \r\n\r\nint main()  \r\n{  \r\n    \r\n    int n;\r\n    cin>>n;\r\n    int arr[n];\r\n    for(int i=0; i<n ; i++)\r\n    {\r\n        cin>>arr[i];\r\n    }\r\n    \r\n    quickSort(arr, 0, n - 1);  \r\n      \r\n    printArray(arr, n);  \r\n    return 0;  \r\n}  \r\n                       ', 10, '', '', '', '0000-00-00'),
(183, 10, 1201012018, '#include<stdio.h> \r\n#include<limits.h>\r\nint max(int a, int b) { return (a > b)? a : b; } \r\nint knapSack(int W, int wt[], int val[], int n) \r\n{ \r\n   if (n == 0 || W == 0) \r\n       return 0; \r\n   if (wt[n-1] > W) \r\n       return knapSack(W, wt, val, n-1); \r\n  \r\n   else return max( val[n-1] + knapSack(W-wt[n-1], wt, val, n-1), \r\n                    knapSack(W, wt, val, n-1) ); \r\n} \r\n  \r\nint main() \r\n{ \r\n    int n;\r\n    int  W ,i;\r\n    scanf(\"%d\",&n);\r\n    scanf(\"%d\",&W);\r\n    int wt[n],val[n];\r\n    for(i=0;i<n;i++)\r\n    scanf(\"%d\",&val[i]);\r\n    for(i=0;i<n;i++)\r\n    scanf(\"%d\",&wt[i]);\r\n    printf(\"%d\", knapSack(W, wt, val, n)); \r\n    return 0; \r\n}', 10, '', '', '', '0000-00-00'),
(184, 12, 1201012018, '#include <iostream> \r\nusing namespace std; \r\nclass Edge \r\n{ \r\n    public: \r\n    int src, dest, weight; \r\n}; \r\nclass Graph \r\n{ \r\n    public: \r\n    int V, E; \r\n    Edge* edge; \r\n}; \r\nGraph* createGraph(int V, int E) \r\n{ \r\n    Graph* graph = new Graph; \r\n    graph->V = V; \r\n    graph->E = E; \r\n    graph->edge = new Edge[E]; \r\n    return graph; \r\n} \r\nclass subset \r\n{ \r\n    public: \r\n    int parent; \r\n    int rank; \r\n}; \r\nint find(subset subsets[], int i) \r\n{ \r\n    if (subsets[i].parent != i) \r\n        subsets[i].parent = find(subsets, subsets[i].parent); \r\n    return subsets[i].parent; \r\n} \r\nvoid Union(subset subsets[], int x, int y) \r\n{ \r\n    int xroot = find(subsets, x); \r\n    int yroot = find(subsets, y); \r\n    if (subsets[xroot].rank < subsets[yroot].rank) \r\n        subsets[xroot].parent = yroot; \r\n    else if (subsets[xroot].rank > subsets[yroot].rank) \r\n        subsets[yroot].parent = xroot; \r\n    else\r\n    { \r\n        subsets[yroot].parent = xroot; \r\n        subsets[xroot].rank++; \r\n    } \r\n} \r\nint myComp(const void* a, const void* b) \r\n{ \r\n    Edge* a1 = (Edge*)a; \r\n    Edge* b1 = (Edge*)b; \r\n    return a1->weight > b1->weight; \r\n} \r\nvoid KruskalMST(Graph* graph) \r\n{ \r\n    int V = graph->V; \r\n    Edge result[V]; \r\n    int e = 0; \r\n    int i = 0; \r\n    qsort(graph->edge, graph->E, sizeof(graph->edge[0]), myComp); \r\n    subset *subsets = new subset[( V * sizeof(subset) )]; \r\n    for (int v = 0; v < V; ++v) \r\n    { \r\n        subsets[v].parent = v; \r\n        subsets[v].rank = 0; \r\n    } \r\n    while (e < V - 1 && i < graph->E) \r\n    { \r\n        Edge next_edge = graph->edge[i++]; \r\n        int x = find(subsets, next_edge.src); \r\n        int y = find(subsets, next_edge.dest); \r\n        if (x != y) \r\n        { \r\n            result[e++] = next_edge; \r\n            Union(subsets, x, y); \r\n        } \r\n    }\r\n    cout<<\"Edge    Wt\";\r\n    for (i = 0; i < e; ++i) \r\n        cout<<result[i].src<<\" -- \"<<result[i].dest<<\" ==> \"<<result[i].weight<<endl; \r\n    return; \r\n} \r\nint main() \r\n{ \r\n    int V = 4; \r\n    int E = 5; \r\n    Graph* graph = createGraph(V, E); \r\n    graph->edge[0].src = 0; \r\n    graph->edge[0].dest = 1; \r\n    graph->edge[0].weight = 10; \r\n    graph->edge[1].src = 0; \r\n    graph->edge[1].dest = 2; \r\n    graph->edge[1].weight = 6; \r\n    graph->edge[2].src = 0; \r\n    graph->edge[2].dest = 3; \r\n    graph->edge[2].weight = 5; \r\n    graph->edge[3].src = 1; \r\n    graph->edge[3].dest = 3; \r\n    graph->edge[3].weight = 15; \r\n    graph->edge[4].src = 2; \r\n    graph->edge[4].dest = 3; \r\n    graph->edge[4].weight = 4; \r\n    KruskalMST(graph); \r\n    return 0; \r\n}', 1000, '', '', '', '0000-00-00'),
(187, 7, 2301012018, '#include<iostream>\r\n#include<cstdlib>\r\nusing namespace std;\r\nvoid swap(int *a, int *b)\r\n{\r\n	int temp;\r\n	temp = *a;\r\n	*a = *b;\r\n	*b = temp;\r\n}\r\nint Partition(int a[], int low, int high)\r\n{\r\n	int pivot, index, i;\r\n	index = low;\r\n	pivot = high;\r\n	for(i=low; i < high; i++)\r\n	{\r\n		if(a[i] < a[pivot])\r\n		{\r\n			swap(&a[i], &a[index]);\r\n			index++;\r\n		}\r\n	}\r\n	swap(&a[pivot], &a[index]);\r\n\r\n	return index;\r\n}\r\n\r\nint RandomPivotPartition(int a[], int low, int high)\r\n{\r\n	int pvt, n, temp;\r\n	n = rand();\r\n	pvt = low + n%(high-low+1);\r\n	swap(&a[high], &a[pvt]);\r\n\r\n	return Partition(a, low, high);\r\n}\r\nint QuickSort(int a[], int low, int high)\r\n{\r\n	int pindex;\r\n	if(low < high)\r\n	{\r\n		pindex = RandomPivotPartition(a, low, high);\r\n		QuickSort(a, low, pindex-1);\r\n		QuickSort(a, pindex+1, high);\r\n	}\r\n	return 0;\r\n}\r\n\r\nint main()\r\n{\r\n	int n, i;\r\n	cin>>n;\r\n	int arr[n];\r\n	for(i = 0; i < n; i++)\r\n	{\r\n		cin>>arr[i];\r\n	}\r\n\r\n	QuickSort(arr, 0, n-1);\r\n	for (i = 0; i < n; i++)\r\n        	cout<<arr[i]<<\" \";\r\n	return 0;\r\n}\r\n', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', 'The randomised quick sort algorithm is as follows:\r\nTake input of data.\r\nCall QuickSort() function.\r\nThrough RandomPivotPartition(), select pivot randomly.\r\nCreate a partition of the array on the basis of the pivot.\r\nRecursively insert the partitions into QuickSort() and repeat step 2 until low is lesser than high.\r\nReturn to main and display the result.\r\nExit. ', '2020-05-25'),
(188, 3, 501012018, '#include <stdio.h>\r\n \r\nvoid mergeSort(int [], int, int, int);\r\nvoid partition(int [],int, int);\r\n \r\nint main()\r\n{\r\n    int list[50];\r\n    int i, size;\r\n \r\n    scanf(\"%d\", &size);\r\n \r\n    for(i = 0; i < size; i++)\r\n    {\r\n         scanf(\"%d\", &list[i]);\r\n    }\r\n    partition(list, 0, size - 1);\r\n \r\n    for(i = 0;i < size; i++)\r\n    {\r\n         printf(\"%d \",list[i]);\r\n    }\r\n \r\n   return 0;\r\n}\r\n \r\nvoid partition(int list[],int low,int high)\r\n{\r\n    int mid;\r\n \r\n    if(low < high)\r\n    {\r\n        mid = (low + high) / 2;\r\n        partition(list, low, mid);\r\n        partition(list, mid + 1, high);\r\n        mergeSort(list, low, mid, high);\r\n    }\r\n}\r\n \r\nvoid mergeSort(int list[],int low,int mid,int high)\r\n{\r\n    int i, mi, k, lo, temp[50];\r\n \r\n    lo = low;\r\n    i = low;\r\n    mi = mid + 1;\r\n    while ((lo <= mid) && (mi <= high))\r\n    {\r\n        if (list[lo] <= list[mi])\r\n        {\r\n            temp[i] = list[lo];\r\n            lo++;\r\n        }\r\n        else\r\n        {\r\n            temp[i] = list[mi];\r\n            mi++;\r\n        }\r\n        i++;\r\n    }\r\n    if (lo > mid)\r\n    {\r\n        for (k = mi; k <= high; k++)\r\n        {\r\n            temp[i] = list[k];\r\n            i++;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        for (k = lo; k <= mid; k++)\r\n        {\r\n             temp[i] = list[k];\r\n             i++;\r\n        }\r\n    }\r\n \r\n    for (k = low; k <= high; k++)\r\n    {\r\n        list[k] = temp[k];\r\n    }\r\n}', 10, '', '', '\r\n\r\n\r\nquickSort(arr[], low, high)\r\n{\r\n    if (low < high)\r\n    {\r\n        /* pi is partitioning index, arr[pi] is now\r\n           at right place */\r\n        pi = partition(arr, low, high);\r\n\r\n        quickSort(arr, low, pi - 1);  // Before pi\r\n        quickSort(arr, pi + 1, high); // After pi\r\n    }\r\n}', '0000-00-00'),
(191, 8, 2501012018, '#include<iostream.h>\r\n#include<conio.h>\r\nvoid main()\r\n{\r\n	clrscr();\r\n	int n,mat1[n][n], mat2[n][n], mat3[n][n], sum=0, i, j, k;\r\n	\r\n	cin>>n;\r\n	\r\n	for(i=0; i<n; i++)\r\n	{\r\n		for(j=0; j<n; j++)\r\n		{\r\n			cin>>mat1[i][j];\r\n		}\r\n	}\r\n	\r\n	for(i=0; i<n; i++)\r\n	{\r\n		for(j=0; j<n; j++)\r\n		{\r\n			cin>>mat2[i][j];\r\n		}\r\n	}\r\n\r\n	for(i=0; i<n; i++)\r\n	{\r\n		for(j=0; j<n; j++)\r\n		{\r\n			sum=0;\r\n			for(k=0; k<n; k++)\r\n			{\r\n				sum = sum + mat1[i][k] * mat2[k][j];\r\n			}\r\n			mat3[i][j] = sum;\r\n		}\r\n	}\r\n\r\n	for(i=0; i<n; i++)\r\n	{\r\n		for(j=0; j<n; j++)\r\n		{\r\n			cout<<mat3[i][j]<<\" \";\r\n		}\r\n		cout<<\" \";\r\n	}\r\n	getch();\r\n}', 10, '', '', '', '0000-00-00'),
(192, 7, 3001012018, '#include<iostream>\r\n#include<cstdlib>\r\nusing namespace std;\r\nvoid swap(int *a, int *b)\r\n{\r\n	int temp;\r\n	temp = *a;\r\n	*a = *b;\r\n	*b = temp;\r\n}\r\nint Partition(int a[], int low, int high)\r\n{\r\n	int pivot, index, i;\r\n	index = low;\r\n	pivot = high;\r\n	for(i=low; i < high; i++)\r\n	{\r\n		if(a[i] < a[pivot])\r\n		{\r\n			swap(&a[i], &a[index]);\r\n			index++;\r\n		}\r\n	}\r\n	swap(&a[pivot], &a[index]);\r\n\r\n	return index;\r\n}\r\n\r\nint RandomPivotPartition(int a[], int low, int high)\r\n{\r\n	int pvt, n, temp;\r\n	n = rand();\r\n	pvt = low + n%(high-low+1);\r\n	swap(&a[high], &a[pvt]);\r\n\r\n	return Partition(a, low, high);\r\n}\r\nint QuickSort(int a[], int low, int high)\r\n{\r\n	int pindex;\r\n	if(low < high)\r\n	{\r\n		pindex = RandomPivotPartition(a, low, high);\r\n		QuickSort(a, low, pindex-1);\r\n		QuickSort(a, pindex+1, high);\r\n	}\r\n	return 0;\r\n}\r\n\r\nint main()\r\n{\r\n	int n, i;\r\n	cin>>n;\r\n	int arr[n];\r\n	for(i = 0; i < n; i++)\r\n	{\r\n		cin>>arr[i];\r\n	}\r\n\r\n	QuickSort(arr, 0, n-1);\r\n	for (i = 0; i < n; i++)\r\n        	cout<<arr[i]<<\" \";\r\n	return 0;\r\n}\r\n', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', 'Algorithm:\r\n\r\n Greedy-Fractional-Knapsack (w[1..n], p[1..n], W) \r\nfor i = 1 to n \r\n   do x[i] = 0 \r\nweight = 0 \r\nfor i = 1 to n \r\n   if weight + w[i] ≤ W then  \r\n      x[i] = 1 \r\n      weight = weight + w[i] \r\n   else \r\n      x[i] = (W - weight) / w[i] \r\n      weight = W \r\n      break \r\nreturn x', '2020-05-25'),
(193, 2, 501012018, '#include <stdio.h>\r\n \r\nvoid mergeSort(int [], int, int, int);\r\nvoid partition(int [],int, int);\r\n \r\nint main()\r\n{\r\n    int list[50];\r\n    int i, size;\r\n \r\n    scanf(\"%d\", &size);\r\n \r\n    for(i = 0; i < size; i++)\r\n    {\r\n         scanf(\"%d\", &list[i]);\r\n    }\r\n    partition(list, 0, size - 1);\r\n \r\n    for(i = 0;i < size; i++)\r\n    {\r\n         printf(\"%d \",list[i]);\r\n    }\r\n \r\n   return 0;\r\n}\r\n \r\nvoid partition(int list[],int low,int high)\r\n{\r\n    int mid;\r\n \r\n    if(low < high)\r\n    {\r\n        mid = (low + high) / 2;\r\n        partition(list, low, mid);\r\n        partition(list, mid + 1, high);\r\n        mergeSort(list, low, mid, high);\r\n    }\r\n}\r\n \r\nvoid mergeSort(int list[],int low,int mid,int high)\r\n{\r\n    int i, mi, k, lo, temp[50];\r\n \r\n    lo = low;\r\n    i = low;\r\n    mi = mid + 1;\r\n    while ((lo <= mid) && (mi <= high))\r\n    {\r\n        if (list[lo] <= list[mi])\r\n        {\r\n            temp[i] = list[lo];\r\n            lo++;\r\n        }\r\n        else\r\n        {\r\n            temp[i] = list[mi];\r\n            mi++;\r\n        }\r\n        i++;\r\n    }\r\n    if (lo > mid)\r\n    {\r\n        for (k = mi; k <= high; k++)\r\n        {\r\n            temp[i] = list[k];\r\n            i++;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        for (k = lo; k <= mid; k++)\r\n        {\r\n             temp[i] = list[k];\r\n             i++;\r\n        }\r\n    }\r\n \r\n    for (k = low; k <= high; k++)\r\n    {\r\n        list[k] = temp[k];\r\n    }\r\n}', 10, '', '', '\r\n\r\n\r\n\r\n\r\nvoid mergeSort(int arr[], int l, int r)\r\n{\r\nif (l < r)\r\n{\r\n// Finding mid element\r\nint m = l+(r-l)/2;\r\n// Recursively sorting both the halves\r\nmergeSort(arr, l, m);\r\nmergeSort(arr, m+1, r);\r\n \r\n// Merge the array\r\nmerge(arr, l, m, r);\r\n}\r\n}', '0000-00-00'),
(196, 10, 2001012018, '#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint knapSack(int W, int wt[], int val[], int n)\r\n{\r\nif (n == 0 || W == 0)\r\n    return 0;\r\nif (wt[n-1] > W)\r\n    return knapSack(W, wt, val, n-1);\r\nelse return max( val[n-1] + knapSack(W-wt[n-1], wt, val, n-1),\r\n                    knapSack(W, wt, val, n-1) );\r\n}\r\n\r\n\r\nint main()\r\n{\r\n    int n;\r\n    cin>>n;\r\n    int val[n];\r\n    int wt[n];\r\n    int W ;\r\n    cin>>W;\r\n    for(int i=0;i<n;i++){\r\n        cin>>val[i];\r\n    }\r\n    for(int i=0;i<n;i++){\r\n        cin>>wt[i];\r\n    }\r\n    cout<<knapSack(W, wt, val, n);\r\n    return 0;\r\n}\r\n\r\n', 10, '5 15 4 2 1 2 10 12 2 1 1 4', '15', 'Algorithm :\r\nDefine a function knapsack which takes as argument (`W->Weight left to be filled, ‘N’->number of left items)\r\nBase case will be if we have ‘left weight=0’ or ‘number of items left=0’ , then return 0\r\nIf the current item’s weight is greater than left weight so that item cannot be included therefore return(n-1,W)\r\nElse return max(val+knapsack(W-val,n-1),knapsack(W,n-1)) which means returning the maximum of the two cases when the current item is included or not included', '2020-05-25'),
(198, 7, 501012018, '#include <stdio.h>\r\n \r\nvoid mergeSort(int [], int, int, int);\r\nvoid partition(int [],int, int);\r\n \r\nint main()\r\n{\r\n    int list[50];\r\n    int i, size;\r\n \r\n    scanf(\"%d\", &size);\r\n \r\n    for(i = 0; i < size; i++)\r\n    {\r\n         scanf(\"%d\", &list[i]);\r\n    }\r\n    partition(list, 0, size - 1);\r\n \r\n    for(i = 0;i < size; i++)\r\n    {\r\n         printf(\"%d \",list[i]);\r\n    }\r\n \r\n   return 0;\r\n}\r\n \r\nvoid partition(int list[],int low,int high)\r\n{\r\n    int mid;\r\n \r\n    if(low < high)\r\n    {\r\n        mid = (low + high) / 2;\r\n        partition(list, low, mid);\r\n        partition(list, mid + 1, high);\r\n        mergeSort(list, low, mid, high);\r\n    }\r\n}\r\n \r\nvoid mergeSort(int list[],int low,int mid,int high)\r\n{\r\n    int i, mi, k, lo, temp[50];\r\n \r\n    lo = low;\r\n    i = low;\r\n    mi = mid + 1;\r\n    while ((lo <= mid) && (mi <= high))\r\n    {\r\n        if (list[lo] <= list[mi])\r\n        {\r\n            temp[i] = list[lo];\r\n            lo++;\r\n        }\r\n        else\r\n        {\r\n            temp[i] = list[mi];\r\n            mi++;\r\n        }\r\n        i++;\r\n    }\r\n    if (lo > mid)\r\n    {\r\n        for (k = mi; k <= high; k++)\r\n        {\r\n            temp[i] = list[k];\r\n            i++;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        for (k = lo; k <= mid; k++)\r\n        {\r\n             temp[i] = list[k];\r\n             i++;\r\n        }\r\n    }\r\n \r\n    for (k = low; k <= high; k++)\r\n    {\r\n        list[k] = temp[k];\r\n    }\r\n}', 10, '', '', '', '0000-00-00'),
(199, 2, 2101012018, '#include<stdlib.h> \r\n#include<stdio.h> \r\n\r\nvoid merge(int arr[], int l, int m, int r) \r\n{ \r\n    int i, j, k; \r\n    int n1 = m - l + 1; \r\n    int n2 =  r - m; \r\n  \r\n   \r\n    int L[n1], R[n2]; \r\n  \r\n    \r\n    for (i = 0; i < n1; i++) \r\n        L[i] = arr[l + i]; \r\n    for (j = 0; j < n2; j++) \r\n        R[j] = arr[m + 1+ j]; \r\n  \r\n    \r\n    i = 0;\r\n    j = 0; \r\n    k = l; \r\n    while (i < n1 && j < n2) \r\n    { \r\n        if (L[i] <= R[j]) \r\n        { \r\n            arr[k] = L[i]; \r\n            i++; \r\n        } \r\n        else\r\n        { \r\n            arr[k] = R[j]; \r\n            j++; \r\n        } \r\n        k++; \r\n    } \r\n  \r\n    \r\n    while (i < n1) \r\n    { \r\n        arr[k] = L[i]; \r\n        i++; \r\n        k++; \r\n    } \r\n  \r\n   \r\n    while (j < n2) \r\n    { \r\n        arr[k] = R[j]; \r\n        j++; \r\n        k++; \r\n    } \r\n} \r\n\r\nvoid mergeSort(int arr[], int l, int r) \r\n{ \r\n    if (l < r) \r\n    { \r\n       \r\n        int m = l+(r-l)/2; \r\n  \r\n        mergeSort(arr, l, m); \r\n        mergeSort(arr, m+1, r); \r\n  \r\n        merge(arr, l, m, r); \r\n    } \r\n} \r\n\r\nvoid printArray(int A[], int size) \r\n{ \r\n    int i; \r\n    for (i=0; i < size; i++) \r\n        printf(\"%d \", A[i]); \r\n    printf(\"\r\n\"); \r\n} \r\n  \r\n/\r\nint main() \r\n{ \r\n    int n;\r\n    cin>>n;\r\n    \r\n    for (int i=0; i < n; i++) \r\n        scanf(\"%d \", &A[i]); \r\n  \r\n  \r\n    mergeSort(arr, 0, arr_size - 1); \r\n \r\n    printArray(arr, arr_size); \r\n    return 0; \r\n} ', 10, '', '', '', '0000-00-00');
INSERT INTO `qtos_map` (`ID`, `Q_ID`, `ROLL`, `SUBMISSION`, `SCORE`, `INPUT`, `OP`, `ALGO`, `DATE`) VALUES
(200, 8, 2901012018, ' \r\n#include<iostream>\r\n#include<conio.h>\r\n#include<stdio.h>\r\nusing namespace std; \r\n\r\ntypedef long long lld; \r\n\r\ninline lld** MatrixMultiply(lld** a, lld** b, int n, \r\n                                      int l, int m) \r\n{ \r\n    lld** c = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        c[i] = new lld[m]; \r\n  \r\n    for (int i = 0; i < n; i++) { \r\n        for (int j = 0; j < m; j++) { \r\n            c[i][j] = 0; \r\n            for (int k = 0; k < l; k++) { \r\n                c[i][j] += a[i][k] * b[k][j]; \r\n            } \r\n        } \r\n    } \r\n    return c; \r\n} \r\n  \r\ninline lld** Strassen(lld** a, lld** b, int n,  \r\n                                int l, int m) \r\n{ \r\n    if (n == 1 || l == 1 || m == 1)  \r\n        return MatrixMultiply(a, b, n, l, m); \r\n  \r\n    lld** c = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        c[i] = new lld[m]; \r\n  \r\n    int adjN = (n >> 1) + (n & 1); \r\n    int adjL = (l >> 1) + (l & 1); \r\n    int adjM = (m >> 1) + (m & 1); \r\n  \r\n    lld**** As = new lld***[2]; \r\n    for (int x = 0; x < 2; x++) { \r\n        As[x] = new lld**[2]; \r\n        for (int y = 0; y < 2; y++) { \r\n            As[x][y] = new lld*[adjN]; \r\n            for (int i = 0; i < adjN; i++) { \r\n                As[x][y][i] = new lld[adjL]; \r\n                for (int j = 0; j < adjL; j++) { \r\n                    int I = i + (x & 1) * adjN; \r\n                    int J = j + (y & 1) * adjL; \r\n                    As[x][y][i][j] = (I < n && J < l) ? a[I][J] : 0; \r\n                } \r\n            } \r\n        } \r\n    } \r\n  \r\n    lld**** Bs = new lld***[2]; \r\n    for (int x = 0; x < 2; x++) { \r\n        Bs[x] = new lld**[2]; \r\n        for (int y = 0; y < 2; y++) { \r\n            Bs[x][y] = new lld*[adjN]; \r\n            for (int i = 0; i < adjL; i++) { \r\n                Bs[x][y][i] = new lld[adjM]; \r\n                for (int j = 0; j < adjM; j++) { \r\n                    int I = i + (x & 1) * adjL; \r\n                    int J = j + (y & 1) * adjM; \r\n                    Bs[x][y][i][j] = (I < l && J < m) ? b[I][J] : 0; \r\n                } \r\n            } \r\n        } \r\n    } \r\n  \r\n    lld*** s = new lld**[10]; \r\n    for (int i = 0; i < 10; i++) { \r\n        switch (i) { \r\n        case 0: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][1][j][k] - Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 1: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] + As[0][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 2: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[1][0][j][k] + As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 3: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[1][0][j][k] - Bs[0][0][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 4: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] + As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 5: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 6: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][1][j][k] - As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 7: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[1][0][j][k] + Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 8: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] - As[1][0][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 9: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[0][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        } \r\n    } \r\n  \r\n    lld*** p = new lld**[7]; \r\n    p[0] = Strassen(As[0][0], s[0], adjN, adjL, adjM); \r\n    p[1] = Strassen(s[1], Bs[1][1], adjN, adjL, adjM); \r\n    p[2] = Strassen(s[2], Bs[0][0], adjN, adjL, adjM); \r\n    p[3] = Strassen(As[1][1], s[3], adjN, adjL, adjM); \r\n    p[4] = Strassen(s[4], s[5], adjN, adjL, adjM); \r\n    p[5] = Strassen(s[6], s[7], adjN, adjL, adjM); \r\n    p[6] = Strassen(s[8], s[9], adjN, adjL, adjM); \r\n  \r\n    for (int i = 0; i < adjN; i++) { \r\n        for (int j = 0; j < adjM; j++) { \r\n            c[i][j] = p[4][i][j] + p[3][i][j] - p[1][i][j] + p[5][i][j]; \r\n            if (j + adjM < m) \r\n                c[i][j + adjM] = p[0][i][j] + p[1][i][j]; \r\n            if (i + adjN < n) \r\n                c[i + adjN][j] = p[2][i][j] + p[3][i][j]; \r\n            if (i + adjN < n && j + adjM < m) \r\n                c[i + adjN][j + adjM] = p[4][i][j] + p[0][i][j] - p[2][i][j] - p[6][i][j]; \r\n        } \r\n    } \r\n  \r\n    for (int x = 0; x < 2; x++) { \r\n        for (int y = 0; y < 2; y++) { \r\n            for (int i = 0; i < adjN; i++) { \r\n                delete[] As[x][y][i]; \r\n            } \r\n            delete[] As[x][y]; \r\n        } \r\n        delete[] As[x]; \r\n    } \r\n    delete[] As; \r\n  \r\n    for (int x = 0; x < 2; x++) { \r\n        for (int y = 0; y < 2; y++) { \r\n            for (int i = 0; i < adjL; i++) { \r\n                delete[] Bs[x][y][i]; \r\n            } \r\n            delete[] Bs[x][y]; \r\n        } \r\n        delete[] Bs[x]; \r\n    } \r\n    delete[] Bs; \r\n  \r\n    for (int i = 0; i < 10; i++) { \r\n        switch (i) { \r\n        case 0: \r\n        case 3: \r\n        case 5: \r\n        case 7: \r\n        case 9: \r\n            for (int j = 0; j < adjL; j++) { \r\n                delete[] s[i][j]; \r\n            } \r\n            break; \r\n        case 1: \r\n        case 2: \r\n        case 4: \r\n        case 6: \r\n        case 8: \r\n            for (int j = 0; j < adjN; j++) { \r\n                delete[] s[i][j]; \r\n            } \r\n            break; \r\n        } \r\n        delete[] s[i]; \r\n    } \r\n    delete[] s; \r\n  \r\n    for (int i = 0; i < 7; i++) { \r\n        for (int j = 0; j < (n >> 1); j++) { \r\n            delete[] p[i][j]; \r\n        } \r\n        delete[] p[i]; \r\n    } \r\n    delete[] p; \r\n  \r\n    return c; \r\n} \r\n  \r\nint main() \r\n{ \r\n    lld** matA; \r\n    int n;\r\n    cin>>n;\r\n    matA = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        matA[i] = new lld[n]; \r\n\r\n    for(int i=0;i<n;i++)\r\n        {\r\n            for(int j=0;j<n;j++)\r\n            {\r\n                cin>>matA[i][j];\r\n            }\r\n        }\r\n   \r\n  \r\n    lld** matB; \r\n    matB = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        matB[i] = new lld[n]; \r\n       \r\n    for(int i=0;i<n;i++)\r\n        {\r\n            for(int j=0;j<n;j++)\r\n            {\r\n                cin>>matB[i][j];\r\n            }\r\n        }\r\n  \r\n    lld** matC = Strassen(matA, matB, n, n, n); \r\n    for (int i = 0; i < n; i++) { \r\n        for (int j = 0; j < n; j++) { \r\n            printf(\"%lld \", matC[i][j]); \r\n        } \r\n        printf(\"\n\"); \r\n    } \r\n  \r\n    return 0; \r\n} ', 0, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '-17 -4 -7 \n10 2 11 \n40 92 107 \n', 'void multiply(int A[][N], int B[][N], int C[][N]) \r\n{ \r\n    for (int i = 0; i < N; i++) \r\n    { \r\n        for (int j = 0; j < N; j++) \r\n        { \r\n            C[i][j] = 0; \r\n            for (int k = 0; k < N; k++) \r\n            { \r\n                C[i][j] += A[i][k]*B[k][j]; \r\n            } \r\n        } \r\n    } \r\n} ', '2020-05-25'),
(202, 8, 501012018, '#include <iostream>  \r\nusing namespace std;  \r\nint main()  \r\n{  \r\nint a[10][10],b[10][10],mul[10][10],r,c,i,j,k;    \r\n\r\ncin>>r;    \r\nfor(i=0;i<r;i++)    \r\n{    \r\nfor(j=0;j<r;j++)    \r\n{    \r\ncin>>a[i][j];  \r\n}    \r\n}    \r\nfor(i=0;i<r;i++)    \r\n{    \r\nfor(j=0;j<r;j++)    \r\n{    \r\ncin>>b[i][j];    \r\n}    \r\n}    \r\n\r\nfor(i=0;i<r;i++)    \r\n{    \r\nfor(j=0;j<r;j++)    \r\n{    \r\nmul[i][j]=0;    \r\nfor(k=0;k<r;k++)    \r\n{    \r\nmul[i][j]+=a[i][k]*b[k][j];    \r\n}    \r\n}    \r\n}    \r\n//for printing result    \r\nfor(i=0;i<r;i++)    \r\n{    \r\nfor(j=0;j<c;j++)    \r\n{    \r\ncout<<mul[i][j]<<\" \";    \r\n}    \r\ncout<<\"\n\";    \r\n}    \r\nreturn 0;  \r\n}    ', 10, '', '', '', '0000-00-00'),
(203, 8, 2301012018, '#include<iostream.h>\r\n#include<conio.h>\r\nvoid main()\r\n{int a[2][2],b[2][2],c[2][2];\r\n int m1,m2,m3,m4,m5,m6,m7,i,j;\r\n for(i=0;i<2;i++)\r\n {\r\n  for(j=0;j<2;j++)\r\n  {\r\n   cin>>a[i][j];\r\n  }\r\n }\r\n for(i=0;i<2;i++)\r\n {\r\n  for(j=0;j<2;j++)\r\n  {\r\n   cin>>b[i][j];\r\n  }\r\n }\r\n \r\n for(i=0;i<2;i++)\r\n {\r\n  for(j=0;j<2;j++)\r\n  {\r\n   cout<<a[i][j];\r\n  }\r\n  cout<<\"\n\";\r\n }\r\n\r\n for(i=0;i<2;i++)\r\n {\r\n  for(j=0;j<2;j++)\r\n  {\r\n   cout<<b[i][j];\r\n  }\r\n  cout<<\"\n\";\r\n }\r\n m1= (a[0][0] + a[1][1])*(b[0][0]+b[1][1]);\r\n m2= (a[1][0]+a[1][1])*b[0][0];\r\n m3= a[0][0]*(b[0][1]-b[1][1]);\r\n m4= a[1][1]*(b[1][0]-b[0][0]);\r\n m5= (a[0][0]+a[0][1])*b[1][1];\r\n m6= (a[1][0]-a[0][0])*(b[0][0]+b[0][1]);\r\n m7= (a[0][1]-a[1][1])*(b[1][0]+b[1][1]);\r\n c[0][0]=m1+m4-m5+m7;\r\n c[0][1]=m3+m5;\r\n c[1][0]=m2+m4;\r\n c[1][1]=m1-m2+m3+m6;\r\n for(i=0;i<2;i++)\r\n {\r\n  for(j=0;j<2;j++)\r\n  {\r\n   cout<<c[i][j];\r\n  }\r\n  cout<<\"\n\";\r\n }\r\n getch();\r\n}', 10, '', '', '', '0000-00-00'),
(204, 7, 1401012018, '#include <cstdlib> \r\n#include<ctime>\r\n #include <iostream> \r\nusing namespace std; \r\nint partition(int arr[], int low, int high) \r\n{\r\n int pivot = arr[high]; // pivot\r\n int i = (low - 1); // Index of smaller element\r\n for (int j = low; j <= high - 1; j++) \r\n{ \r\n    if (arr[j] <= pivot) \r\n{     i++; \r\n     swap(arr[i], arr[j]); \r\n} \r\n} \r\nswap(arr[i + 1], arr[high]); \r\nreturn (i + 1);\r\n } \r\nint partition_r(int arr[], int low, int high) \r\n{ \r\nsrand(time(NULL));\r\n int random = low + rand() % (high - low); \r\nswap(arr[random], arr[high]);\r\n return partition(arr, low, high); \r\n}  \r\nvoid quickSort(int arr[], int low, int high) \r\n{ \r\nif (low < high)\r\n { \r\nint pi = partition_r(arr, low, high); \r\nquickSort(arr, low, pi - 1);\r\n quickSort(arr, pi + 1, high); \r\n} \r\n}\r\n /* Function to print an array */ \r\nvoid printArray(int arr[], int size) \r\n{ int i; for (i = 0; i < size; i++) cout<<arr[i]<<\" \"; } \r\n// Driver program to test above functions \r\nint main()\r\n { \r\nint n; \r\ncin>>n; \r\nint arr[n]; \r\nfor(int i=0;i<n;i++) { cin>>arr[i]; } \r\nquickSort(arr, 0, n - 1); \r\nprintArray(arr, n);\r\n return 0;\r\n } \r\n', 10, '', '', '', '0000-00-00'),
(205, 14, 2301012018, '#include<iostream>\r\n#define MAX 10\r\nusing namespace std;\r\n\r\ntypedef struct edge\r\n{\r\n  int src;\r\n  int dest;\r\n  int wt;\r\n}edge;\r\n\r\nvoid bellman_ford(int nv,edge e[],int src_graph,int ne)\r\n{\r\n  int u,v,weight,i,j=0;\r\n  int dis[MAX];\r\n  \r\n  for(i=0;i<nv;i++)\r\n  {\r\n    dis[i]=999;\r\n  }\r\n\r\n  dis[src_graph]=0;\r\n\r\n  for(i=0;i<nv-1;i++)\r\n  {\r\n    for(j=0;j<ne;j++)\r\n    {\r\n      u=e[j].src;\r\n      v=e[j].dest;\r\n      weight=e[j].wt;\r\n    \r\n\r\n      if(dis[u]!=999 && dis[u]+weight < dis[v])\r\n      {\r\n        dis[v]=dis[u]+weight;\r\n      }  \r\n    }\r\n    \r\n  }\r\n\r\n  for(j=0;j<ne;j++)\r\n  {\r\n    u=e[j].src;\r\n    v=e[j].dest;\r\n    weight=e[j].wt;\r\n    \r\n  }\r\n\r\n  for(i=1;i<=nv;i++)\r\n  {\r\n    cout<<\"\n\"<<i<<\"	\"<<dis[i];\r\n  }\r\n\r\n}\r\n\r\n\r\nint main()\r\n{\r\n  int nv,ne,src_graph;\r\n  edge e[MAX];\r\n\r\n  cin>>nv;  \r\n  cin>>src_graph;  \r\n  cin>>ne;\r\n  \r\n  for(int i=0;i<ne;i++)\r\n  {\r\n    cout<<i+1<<\" \";\r\n    cin>>e[i].src;\r\n    cin>>e[i].dest;\r\n    cin>>e[i].wt;  \r\n  }\r\n  \r\n  bellman_ford(nv,e,src_graph,ne);\r\n  \r\n  return 0;\r\n}', 1000, '', '', '', '0000-00-00'),
(206, 8, 3001012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\ntypedef long long lld; \r\n  \r\n  \r\ninline lld** MatrixMultiply(lld** a, lld** b, int n, \r\n                                      int l, int m) \r\n{ \r\n    lld** c = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        c[i] = new lld[m]; \r\n  \r\n    for (int i = 0; i < n; i++) { \r\n        for (int j = 0; j < m; j++) { \r\n            c[i][j] = 0; \r\n            for (int k = 0; k < l; k++) { \r\n                c[i][j] += a[i][k] * b[k][j]; \r\n            } \r\n        } \r\n    } \r\n    return c; \r\n} \r\n  \r\ninline lld** Strassen(lld** a, lld** b, int n,  \r\n                                int l, int m) \r\n{ \r\n    if (n == 1 || l == 1 || m == 1)  \r\n        return MatrixMultiply(a, b, n, l, m); \r\n  \r\n    lld** c = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        c[i] = new lld[m]; \r\n  \r\n    int adjN = (n >> 1) + (n & 1); \r\n    int adjL = (l >> 1) + (l & 1); \r\n    int adjM = (m >> 1) + (m & 1); \r\n  \r\n    lld**** As = new lld***[2]; \r\n    for (int x = 0; x < 2; x++) { \r\n        As[x] = new lld**[2]; \r\n        for (int y = 0; y < 2; y++) { \r\n            As[x][y] = new lld*[adjN]; \r\n            for (int i = 0; i < adjN; i++) { \r\n                As[x][y][i] = new lld[adjL]; \r\n                for (int j = 0; j < adjL; j++) { \r\n                    int I = i + (x & 1) * adjN; \r\n                    int J = j + (y & 1) * adjL; \r\n                    As[x][y][i][j] = (I < n && J < l) ? a[I][J] : 0; \r\n                } \r\n            } \r\n        } \r\n    } \r\n  \r\n    lld**** Bs = new lld***[2]; \r\n    for (int x = 0; x < 2; x++) { \r\n        Bs[x] = new lld**[2]; \r\n        for (int y = 0; y < 2; y++) { \r\n            Bs[x][y] = new lld*[adjN]; \r\n            for (int i = 0; i < adjL; i++) { \r\n                Bs[x][y][i] = new lld[adjM]; \r\n                for (int j = 0; j < adjM; j++) { \r\n                    int I = i + (x & 1) * adjL; \r\n                    int J = j + (y & 1) * adjM; \r\n                    Bs[x][y][i][j] = (I < l && J < m) ? b[I][J] : 0; \r\n                } \r\n            } \r\n        } \r\n    } \r\n  \r\n    lld*** s = new lld**[10]; \r\n    for (int i = 0; i < 10; i++) { \r\n        switch (i) { \r\n        case 0: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][1][j][k] - Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 1: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] + As[0][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 2: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[1][0][j][k] + As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 3: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[1][0][j][k] - Bs[0][0][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 4: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] + As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 5: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 6: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][1][j][k] - As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 7: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[1][0][j][k] + Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 8: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] - As[1][0][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 9: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[0][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        } \r\n    } \r\n  \r\n    lld*** p = new lld**[7]; \r\n    p[0] = Strassen(As[0][0], s[0], adjN, adjL, adjM); \r\n    p[1] = Strassen(s[1], Bs[1][1], adjN, adjL, adjM); \r\n    p[2] = Strassen(s[2], Bs[0][0], adjN, adjL, adjM); \r\n    p[3] = Strassen(As[1][1], s[3], adjN, adjL, adjM); \r\n    p[4] = Strassen(s[4], s[5], adjN, adjL, adjM); \r\n    p[5] = Strassen(s[6], s[7], adjN, adjL, adjM); \r\n    p[6] = Strassen(s[8], s[9], adjN, adjL, adjM); \r\n  \r\n    for (int i = 0; i < adjN; i++) { \r\n        for (int j = 0; j < adjM; j++) { \r\n            c[i][j] = p[4][i][j] + p[3][i][j] - p[1][i][j] + p[5][i][j]; \r\n            if (j + adjM < m) \r\n                c[i][j + adjM] = p[0][i][j] + p[1][i][j]; \r\n            if (i + adjN < n) \r\n                c[i + adjN][j] = p[2][i][j] + p[3][i][j]; \r\n            if (i + adjN < n && j + adjM < m) \r\n                c[i + adjN][j + adjM] = p[4][i][j] + p[0][i][j] - p[2][i][j] - p[6][i][j]; \r\n        } \r\n    } \r\n  \r\n    for (int x = 0; x < 2; x++) { \r\n        for (int y = 0; y < 2; y++) { \r\n            for (int i = 0; i < adjN; i++) { \r\n                delete[] As[x][y][i]; \r\n            } \r\n            delete[] As[x][y]; \r\n        } \r\n        delete[] As[x]; \r\n    } \r\n    delete[] As; \r\n  \r\n    for (int x = 0; x < 2; x++) { \r\n        for (int y = 0; y < 2; y++) { \r\n            for (int i = 0; i < adjL; i++) { \r\n                delete[] Bs[x][y][i]; \r\n            } \r\n            delete[] Bs[x][y]; \r\n        } \r\n        delete[] Bs[x]; \r\n    } \r\n    delete[] Bs; \r\n  \r\n    for (int i = 0; i < 10; i++) { \r\n        switch (i) { \r\n        case 0: \r\n        case 3: \r\n        case 5: \r\n        case 7: \r\n        case 9: \r\n            for (int j = 0; j < adjL; j++) { \r\n                delete[] s[i][j]; \r\n            } \r\n            break; \r\n        case 1: \r\n        case 2: \r\n        case 4: \r\n        case 6: \r\n        case 8: \r\n            for (int j = 0; j < adjN; j++) { \r\n                delete[] s[i][j]; \r\n            } \r\n            break; \r\n        } \r\n        delete[] s[i]; \r\n    } \r\n    delete[] s; \r\n  \r\n    for (int i = 0; i < 7; i++) { \r\n        for (int j = 0; j < (n >> 1); j++) { \r\n            delete[] p[i][j]; \r\n        } \r\n        delete[] p[i]; \r\n    } \r\n    delete[] p; \r\n  \r\n    return c; \r\n} \r\n  \r\nint main() \r\n{ \r\n    lld** matA; \r\n    matA = new lld*[2]; \r\n    for (int i = 0; i < 2; i++) \r\n        matA[i] = new lld[3]; \r\n    matA[0][0] = 1; \r\n    matA[0][1] = 2; \r\n    matA[0][2] = 3; \r\n    matA[1][0] = 4; \r\n    matA[1][1] = 5; \r\n    matA[1][2] = 6; \r\n  \r\n    lld** matB; \r\n    matB = new lld*[3]; \r\n    for (int i = 0; i < 3; i++) \r\n        matB[i] = new lld[2]; \r\n    matB[0][0] = 7; \r\n    matB[0][1] = 8; \r\n    matB[1][0] = 9; \r\n    matB[1][1] = 10; \r\n    matB[2][0] = 11; \r\n    matB[2][1] = 12; \r\n  \r\n    lld** matC = Strassen(matA, matB, 2, 3, 2); \r\n    for (int i = 0; i < 2; i++) { \r\n        for (int j = 0; j < 2; j++) { \r\n            cout<< matC[i][j]; \r\n        } \r\n        cout<<endl;\r\n    } \r\n  \r\n    return 0; \r\n} ', 10, '', '', '', '0000-00-00'),
(207, 8, 2801012018, ' \r\n#include<iostream>\r\n#include<conio.h>\r\n#include<stdio.h>\r\nusing namespace std; \r\n\r\ntypedef long long lld; \r\n\r\ninline lld** MatrixMultiply(lld** a, lld** b, int n, \r\n                                      int l, int m) \r\n{ \r\n    lld** c = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        c[i] = new lld[m]; \r\n  \r\n    for (int i = 0; i < n; i++) { \r\n        for (int j = 0; j < m; j++) { \r\n            c[i][j] = 0; \r\n            for (int k = 0; k < l; k++) { \r\n                c[i][j] += a[i][k] * b[k][j]; \r\n            } \r\n        } \r\n    } \r\n    return c; \r\n} \r\n  \r\ninline lld** Strassen(lld** a, lld** b, int n,  \r\n                                int l, int m) \r\n{ \r\n    if (n == 1 || l == 1 || m == 1)  \r\n        return MatrixMultiply(a, b, n, l, m); \r\n  \r\n    lld** c = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        c[i] = new lld[m]; \r\n  \r\n    int adjN = (n >> 1) + (n & 1); \r\n    int adjL = (l >> 1) + (l & 1); \r\n    int adjM = (m >> 1) + (m & 1); \r\n  \r\n    lld**** As = new lld***[2]; \r\n    for (int x = 0; x < 2; x++) { \r\n        As[x] = new lld**[2]; \r\n        for (int y = 0; y < 2; y++) { \r\n            As[x][y] = new lld*[adjN]; \r\n            for (int i = 0; i < adjN; i++) { \r\n                As[x][y][i] = new lld[adjL]; \r\n                for (int j = 0; j < adjL; j++) { \r\n                    int I = i + (x & 1) * adjN; \r\n                    int J = j + (y & 1) * adjL; \r\n                    As[x][y][i][j] = (I < n && J < l) ? a[I][J] : 0; \r\n                } \r\n            } \r\n        } \r\n    } \r\n  \r\n    lld**** Bs = new lld***[2]; \r\n    for (int x = 0; x < 2; x++) { \r\n        Bs[x] = new lld**[2]; \r\n        for (int y = 0; y < 2; y++) { \r\n            Bs[x][y] = new lld*[adjN]; \r\n            for (int i = 0; i < adjL; i++) { \r\n                Bs[x][y][i] = new lld[adjM]; \r\n                for (int j = 0; j < adjM; j++) { \r\n                    int I = i + (x & 1) * adjL; \r\n                    int J = j + (y & 1) * adjM; \r\n                    Bs[x][y][i][j] = (I < l && J < m) ? b[I][J] : 0; \r\n                } \r\n            } \r\n        } \r\n    } \r\n  \r\n    lld*** s = new lld**[10]; \r\n    for (int i = 0; i < 10; i++) { \r\n        switch (i) { \r\n        case 0: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][1][j][k] - Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 1: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] + As[0][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 2: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[1][0][j][k] + As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 3: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[1][0][j][k] - Bs[0][0][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 4: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] + As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 5: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 6: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][1][j][k] - As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 7: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[1][0][j][k] + Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 8: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] - As[1][0][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 9: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[0][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        } \r\n    } \r\n  \r\n    lld*** p = new lld**[7]; \r\n    p[0] = Strassen(As[0][0], s[0], adjN, adjL, adjM); \r\n    p[1] = Strassen(s[1], Bs[1][1], adjN, adjL, adjM); \r\n    p[2] = Strassen(s[2], Bs[0][0], adjN, adjL, adjM); \r\n    p[3] = Strassen(As[1][1], s[3], adjN, adjL, adjM); \r\n    p[4] = Strassen(s[4], s[5], adjN, adjL, adjM); \r\n    p[5] = Strassen(s[6], s[7], adjN, adjL, adjM); \r\n    p[6] = Strassen(s[8], s[9], adjN, adjL, adjM); \r\n  \r\n    for (int i = 0; i < adjN; i++) { \r\n        for (int j = 0; j < adjM; j++) { \r\n            c[i][j] = p[4][i][j] + p[3][i][j] - p[1][i][j] + p[5][i][j]; \r\n            if (j + adjM < m) \r\n                c[i][j + adjM] = p[0][i][j] + p[1][i][j]; \r\n            if (i + adjN < n) \r\n                c[i + adjN][j] = p[2][i][j] + p[3][i][j]; \r\n            if (i + adjN < n && j + adjM < m) \r\n                c[i + adjN][j + adjM] = p[4][i][j] + p[0][i][j] - p[2][i][j] - p[6][i][j]; \r\n        } \r\n    } \r\n  \r\n    for (int x = 0; x < 2; x++) { \r\n        for (int y = 0; y < 2; y++) { \r\n            for (int i = 0; i < adjN; i++) { \r\n                delete[] As[x][y][i]; \r\n            } \r\n            delete[] As[x][y]; \r\n        } \r\n        delete[] As[x]; \r\n    } \r\n    delete[] As; \r\n  \r\n    for (int x = 0; x < 2; x++) { \r\n        for (int y = 0; y < 2; y++) { \r\n            for (int i = 0; i < adjL; i++) { \r\n                delete[] Bs[x][y][i]; \r\n            } \r\n            delete[] Bs[x][y]; \r\n        } \r\n        delete[] Bs[x]; \r\n    } \r\n    delete[] Bs; \r\n  \r\n    for (int i = 0; i < 10; i++) { \r\n        switch (i) { \r\n        case 0: \r\n        case 3: \r\n        case 5: \r\n        case 7: \r\n        case 9: \r\n            for (int j = 0; j < adjL; j++) { \r\n                delete[] s[i][j]; \r\n            } \r\n            break; \r\n        case 1: \r\n        case 2: \r\n        case 4: \r\n        case 6: \r\n        case 8: \r\n            for (int j = 0; j < adjN; j++) { \r\n                delete[] s[i][j]; \r\n            } \r\n            break; \r\n        } \r\n        delete[] s[i]; \r\n    } \r\n    delete[] s; \r\n  \r\n    for (int i = 0; i < 7; i++) { \r\n        for (int j = 0; j < (n >> 1); j++) { \r\n            delete[] p[i][j]; \r\n        } \r\n        delete[] p[i]; \r\n    } \r\n    delete[] p; \r\n  \r\n    return c; \r\n} \r\n  \r\nint main() \r\n{ \r\n    lld** matA; \r\n    int n;\r\n    cin>>n;\r\n    matA = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        matA[i] = new lld[n]; \r\n\r\n    for(int i=0;i<n;i++)\r\n        {\r\n            for(int j=0;j<n;j++)\r\n            {\r\n                cin>>matA[i][j];\r\n            }\r\n        }\r\n   \r\n  \r\n    lld** matB; \r\n    matB = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        matB[i] = new lld[n]; \r\n       \r\n    for(int i=0;i<n;i++)\r\n        {\r\n            for(int j=0;j<n;j++)\r\n            {\r\n                cin>>matB[i][j];\r\n            }\r\n        }\r\n  \r\n    lld** matC = Strassen(matA, matB, n, n, n); \r\n    for (int i = 0; i < n; i++) { \r\n        for (int j = 0; j < n; j++) { \r\n            printf(\"%lld \", matC[i][j]); \r\n        }  \r\n    } \r\n  \r\n    return 0; \r\n} ', 0, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '-17 -4 -7 10 2 11 40 92 107 ', 'void multiply(int A[][N], int B[][N], int C[][N]) \r\n{ \r\n    for (int i = 0; i < N; i++) \r\n    { \r\n        for (int j = 0; j < N; j++) \r\n        { \r\n            C[i][j] = 0; \r\n            for (int k = 0; k < N; k++) \r\n            { \r\n                C[i][j] += A[i][k]*B[k][j]; \r\n            } \r\n        } \r\n    } \r\n} ', '2020-05-25'),
(208, 8, 2401012018, '#include<iostream.h>\r\n#include<conio.h>\r\nvoid main()\r\n{\r\n	clrscr();\r\n	int n,mat1[n][n], mat2[n][n], mat3[n][n], sum=0, i, j, k;\r\n	\r\n	cin>>n;\r\n	\r\n	for(i=0; i<n; i++)\r\n	{\r\n		for(j=0; j<n; j++)\r\n		{\r\n			cin>>mat1[i][j];\r\n		}\r\n	}\r\n	\r\n	for(i=0; i<n; i++)\r\n	{\r\n		for(j=0; j<n; j++)\r\n		{\r\n			cin>>mat2[i][j];\r\n		}\r\n	}\r\n\r\n	for(i=0; i<n; i++)\r\n	{\r\n		for(j=0; j<n; j++)\r\n		{\r\n			sum=0;\r\n			for(k=0; k<n; k++)\r\n			{\r\n				sum = sum + mat1[i][k] * mat2[k][j];\r\n			}\r\n			mat3[i][j] = sum;\r\n		}\r\n	}\r\n\r\n	for(i=0; i<n; i++)\r\n	{\r\n		for(j=0; j<n; j++)\r\n		{\r\n			cout<<mat3[i][j]<<\" \";\r\n		}\r\n		cout<<\" \";\r\n	}\r\n	getch();\r\n}', 10, '', '', '', '0000-00-00'),
(209, 7, 2201012018, '#include <cstdlib> \r\n#include<ctime>\r\n #include <iostream> \r\nusing namespace std; \r\nint partition(int arr[], int low, int high) \r\n{\r\n int pivot = arr[high]; // pivot\r\n int i = (low - 1); // Index of smaller element\r\n for (int j = low; j <= high - 1; j++) \r\n{ \r\n    if (arr[j] <= pivot) \r\n{     i++; \r\n     swap(arr[i], arr[j]); \r\n} \r\n} \r\nswap(arr[i + 1], arr[high]); \r\nreturn (i + 1);\r\n } \r\nint partition_r(int arr[], int low, int high) \r\n{ \r\nsrand(time(NULL));\r\n int random = low + rand() % (high - low); \r\nswap(arr[random], arr[high]);\r\n return partition(arr, low, high); \r\n}  \r\nvoid quickSort(int arr[], int low, int high) \r\n{ \r\nif (low < high)\r\n { \r\nint pi = partition_r(arr, low, high); \r\nquickSort(arr, low, pi - 1);\r\n quickSort(arr, pi + 1, high); \r\n} \r\n}\r\n /* Function to print an array */ \r\nvoid printArray(int arr[], int size) \r\n{ int i; for (i = 0; i < size; i++) cout<<arr[i]<<\" \"; } \r\n// Driver program to test above functions \r\nint main()\r\n { \r\nint n; \r\ncin>>n; \r\nint arr[n]; \r\nfor(int i=0;i<n;i++) { cin>>arr[i]; } \r\nquickSort(arr, 0, n - 1); \r\nprintArray(arr, n);\r\n return 0;\r\n } \r\n', 10, '', '', '', '0000-00-00'),
(210, 3, 2401012018, '//QUICK\r\n#include <iostream>\r\n \r\nusing namespace std;\r\n \r\nvoid quick_sort(int[],int,int);\r\nint partition(int[],int,int);\r\n \r\nint main()\r\n{\r\n    int a[50],n,i;\r\n\r\n    cin>>n;\r\n\r\n    \r\n    for(i=0;i<n;i++)\r\n        cin>>a[i];\r\n        \r\n    quick_sort(a,0,n-1);\r\n    \r\n    \r\n    for(i=0;i<n;i++)\r\n    if(i!= n)\r\n        cout<<a[i]<<\" \";\r\n        //cout<<a[n-1];\r\n    \r\n    return 0;        \r\n}\r\n \r\nvoid quick_sort(int a[],int l,int u)\r\n{\r\n    int j;\r\n    if(l<u)\r\n    {\r\n        j=partition(a,l,u);\r\n        quick_sort(a,l,j-1);\r\n        quick_sort(a,j+1,u);\r\n    }\r\n}\r\n \r\nint partition(int a[],int l,int u)\r\n{\r\n    int v,i,j,temp;\r\n    v=a[l];\r\n    i=l;\r\n    j=u+1;\r\n    \r\n    do\r\n    {\r\n        do\r\n            i++;\r\n            \r\n        while(a[i]<v&&i<=u);\r\n        \r\n        do\r\n            j--;\r\n        while(v<a[j]);\r\n        \r\n        if(i<j)\r\n        {\r\n            temp=a[i];\r\n            a[i]=a[j];\r\n            a[j]=temp;\r\n        }\r\n    }while(i<j);\r\n    \r\n    a[l]=a[j];\r\n    a[j]=v;\r\n    \r\n    return(j);\r\n}', 10, '', '', '', '0000-00-00'),
(211, 2, 2401012018, '#include<stdlib.h> \n#include<stdio.h> \n\nvoid merge(int arr[], int l, int m, int r) \n{ \n    int i, j, k; \n    int n1 = m - l + 1; \n    int n2 =  r - m; \n  \n \n    int L[n1], R[n2]; \n  \n  \n    for (i = 0; i < n1; i++) \n        L[i] = arr[l + i]; \n    for (j = 0; j < n2; j++) \n        R[j] = arr[m + 1+ j]; \n  \n\n    i = 0; // Initial index of first subarray \n    j = 0; // Initial index of second subarray \n    k = l; // Initial index of merged subarray \n    while (i < n1 && j < n2) \n    { \n        if (L[i] <= R[j]) \n        { \n            arr[k] = L[i]; \n            i++; \n        } \n        else\n        { \n            arr[k] = R[j]; \n            j++; \n        } \n        k++; \n    } \n  \n   \n    while (i < n1) \n    { \n        arr[k] = L[i]; \n        i++; \n        k++; \n    } \n  \n    \n    while (j < n2) \n    { \n        arr[k] = R[j]; \n        j++; \n        k++; \n    } \n} \n  \n\nvoid mergeSort(int arr[], int l, int r) \n{ \n    if (l < r) \n    { \n        int m = l+(r-l)/2; \n  \n       \n        mergeSort(arr, l, m); \n        mergeSort(arr, m+1, r); \n  \n        merge(arr, l, m, r); \n    } \n} \n\nvoid printArray(int A[], int size) \n{ \n    int i; \n    for (i=0; i < size; i++) \n        printf(\"%d \", A[i]); \n    printf(\"\n\"); \n} \n  \n\nint main() \n{ \n    int arr[100];\n    int n;\n    cin>>n;\n    for(int i=0;i<n;i++){\n	cin>>arr[i];\n    }\n  \n    mergeSort(arr, 0, arr_size - 1); \n  \n     \n    printArray(arr, arr_size); \n    return 0; \n} \n', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '', 'MergeSort(arr[], l,  r)\r\nIf r > l\r\n     1. Find the middle point to divide the array into two halves:  \r\n             middle m = (l+r)/2\r\n     2. Call mergeSort for first half:   \r\n             Call mergeSort(arr, l, m)\r\n     3. Call mergeSort for second half:\r\n             Call mergeSort(arr, m+1, r)\r\n     4. Merge the two halves sorted in step 2 and 3:\r\n             Call merge(arr, l, m, r)', '2020-05-25'),
(214, 7, 2401012018, '#include <cstdlib> \r\n#include<ctime>\r\n #include <iostream> \r\nusing namespace std; \r\nint partition(int arr[], int low, int high) \r\n{\r\n int pivot = arr[high]; // pivot\r\n int i = (low - 1); // Index of smaller element\r\n for (int j = low; j <= high - 1; j++) \r\n{ \r\n    if (arr[j] <= pivot) \r\n{     i++; \r\n     swap(arr[i], arr[j]); \r\n} \r\n} \r\nswap(arr[i + 1], arr[high]); \r\nreturn (i + 1);\r\n } \r\nint partition_r(int arr[], int low, int high) \r\n{ \r\nsrand(time(NULL));\r\n int random = low + rand() % (high - low); \r\nswap(arr[random], arr[high]);\r\n return partition(arr, low, high); \r\n}  \r\nvoid quickSort(int arr[], int low, int high) \r\n{ \r\nif (low < high)\r\n { \r\nint pi = partition_r(arr, low, high); \r\nquickSort(arr, low, pi - 1);\r\n quickSort(arr, pi + 1, high); \r\n} \r\n}\r\n /* Function to print an array */ \r\nvoid printArray(int arr[], int size) \r\n{ int i; for (i = 0; i < size; i++) cout<<arr[i]<<\" \"; } \r\n// Driver program to test above functions \r\nint main()\r\n { \r\nint n; \r\ncin>>n; \r\nint arr[n]; \r\nfor(int i=0;i<n;i++) { cin>>arr[i]; } \r\nquickSort(arr, 0, n - 1); \r\nprintArray(arr, n);\r\n return 0;\r\n } \r\n\r\n\r\n', 10, '', '', '', '0000-00-00'),
(215, 14, 1001012018, '\r\n#include <bits/stdc++.h> \r\nstruct Edge { \r\n    int src, dest, weight; \r\n}; \r\nstruct Graph { \r\n    \r\n    int V, E; \r\n \r\n    struct Edge* edge; \r\n}; \r\nstruct Graph* createGraph(int V, int E) \r\n{ \r\n    struct Graph* graph = new Graph; \r\n    graph->V = V; \r\n    graph->E = E; \r\n    graph->edge = new Edge[E]; \r\n    return graph; \r\n} \r\nvoid printArr(int dist[], int n) \r\n{ \r\n    printf(\"Vertex   Distance from Source\n\"); \r\n    for (int i = 0; i < n; ++i) \r\n        printf(\"%d 		 %d\n\", i, dist[i]); \r\n} \r\nvoid BellmanFord(struct Graph* graph, int src) \r\n{ \r\n    int V = graph->V; \r\n    int E = graph->E; \r\n    int dist[V]; \r\n  \r\n    for (int i = 0; i < V; i++) \r\n        dist[i] = INT_MAX; \r\n    dist[src] = 0; \r\n  \r\n    for (int i = 1; i <= V - 1; i++) { \r\n        for (int j = 0; j < E; j++) { \r\n            int u = graph->edge[j].src; \r\n            int v = graph->edge[j].dest; \r\n            int weight = graph->edge[j].weight; \r\n            if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) \r\n                dist[v] = dist[u] + weight; \r\n        } \r\n    } \r\n  \r\n    for (int i = 0; i < E; i++) { \r\n        int u = graph->edge[i].src; \r\n        int v = graph->edge[i].dest; \r\n        int weight = graph->edge[i].weight; \r\n        if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) { \r\n            printf(\"Graph contains negative weight cycle\"); \r\n            return; \r\n        } \r\n    } \r\n  \r\n    printArr(dist, V); \r\n  \r\n    return; \r\n} ', 1000, '', '', '', '0000-00-00'),
(216, 10, 3601012018, '#include<bits/stdc++.h>\r\nusing namespace std;\r\nint main(){\r\n   double a[50],aa[50];\r\n   int n,temp,i,j;\r\n    int constraints,u;\r\n   double x[20],profit=0,s[10];\r\n    cin>>n>>constraints;\r\n     for(int i=0; i<n; i++){\r\n        cin>>a[i];\r\n     }\r\n     for(int i=0; i<n; i++){\r\n        cin>>aa[i];\r\n     }\r\n     for(i=0; i<n; i++){\r\n       s[i]=a[i]/aa[i];\r\n     }\r\n    for(i=0; i<n-1; i++){\r\n       for(j=i+1; j<n; j++){\r\n          if(s[i]<s[j])\r\n          temp=s[j];\r\n          s[j]=s[i];\r\n          s[i]=temp;\r\n\r\n          temp=a[j];\r\n          a[j]=a[i];\r\n          a[i]=temp;\r\n\r\n          temp=aa[j];\r\n          aa[j]=aa[i];\r\n          aa[i]=temp;\r\n       }\r\n    }\r\n    u=constraints;\r\n      for(i=0; i<n; i++){\r\n          x[i]=0;\r\n        }\r\n        for(i=0; i<n; i++){\r\n        if(aa[i]>u){\r\n          break;\r\n        }\r\n      else{\r\n            x[i]=1.0;\r\n          profit= profit+a[i];\r\n          u=u-aa[i];\r\n        }\r\n      }\r\n      if(i<n)\r\n        x[i]=u/aa[i];\r\n      profit=profit+a[i]*x[i];\r\n\r\n   cout<<profit;\r\n return 0;\r\n}\r\n', 2, '5 15 4 2 1 2 10 12 2 1 1 4', '17.3333', 'partition(arr[], lo, hi) \r\n    pivot = arr[hi]\r\n    i = lo     // place for swapping\r\n    for j := lo to hi – 1 do\r\n        if arr[j] <= pivot then\r\n            swap arr[i] with arr[j]\r\n            i = i + 1\r\n    swap arr[i] with arr[hi]\r\n    return i\r\n\r\npartition_r(arr[], lo, hi)\r\n    r = Random Number from lo to hi\r\n    Swap arr[r] and arr[hi]\r\n    return partition(arr, lo, hi)\r\n\r\nquicksort(arr[], lo, hi)\r\n    if lo < hi\r\n        p = partition_r(arr, lo, hi)\r\n        quicksort(arr, p-1, hi)\r\n        quicksort(arr, p+1, hi)', '2020-05-25'),
(217, 3, 2101012018, '#include <bits/stdc++.h> \r\nusing namespace std;  \r\n  \r\n\r\nvoid swap(int* a, int* b)  \r\n{  \r\n    int t = *a;  \r\n    *a = *b;  \r\n    *b = t;  \r\n}  \r\n  \r\n\r\nint partition (int arr[], int low, int high)  \r\n{  \r\n    int pivot = arr[high]; \r\n    int i = (low - 1); \r\n  \r\n    for (int j = low; j <= high - 1; j++)  \r\n    {  \r\n        \r\n        if (arr[j] < pivot)  \r\n        {  \r\n            i++;   \r\n            swap(&arr[i], &arr[j]);  \r\n        }  \r\n    }  \r\n    swap(&arr[i + 1], &arr[high]);  \r\n    return (i + 1);  \r\n}  \r\n  \r\n\r\nvoid quickSort(int arr[], int low, int high)  \r\n{  \r\n    if (low < high)  \r\n    {  \r\n        \r\n        int pi = partition(arr, low, high);  \r\n  \r\n        quickSort(arr, low, pi - 1);  \r\n        quickSort(arr, pi + 1, high);  \r\n    }  \r\n}  \r\n\r\nvoid printArray(int arr[], int size)  \r\n{  \r\n    int i;  \r\n    for (i = 0; i < size; i++)  \r\n        cout << arr[i] << \" \";  \r\n   // cout << endl;  \r\n}  \r\n\r\nint main()  \r\n{  \r\n    \r\n    int n, arr[100000];\r\n    cin>>n;\r\n    for (int i = 0; i < n; i++)  \r\n        cin>>arr[i];\r\n    \r\n    quickSort(arr, 0, n - 1);  \r\n    printArray(arr, n);  \r\n    return 0;  \r\n}  ', 10, '', '', '', '0000-00-00'),
(218, 8, 1601012018, '#include<iostream> \r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int n;\r\n    cin >> n;\r\n    int a[n][n], b[n][n];\r\n    for(int i = 0; i < n; i++)\r\n    {\r\n        for(int j = 0; j < n; j++)\r\n        cin >> a[i][j];\r\n    }\r\n    for(int i = 0; i < n; i++)\r\n    {\r\n        for(int j = 0; j < n; j++)\r\n        cin >> b[i][j];\r\n    }\r\n    \r\n    int ans[n][n];\r\n    \r\n    for(int i = 0; i < n; i++)\r\n    {\r\n        for(int j = 0; j < n; j++)\r\n        {\r\n            ans[i][j] = 0;\r\n            for(int k = 0; k < n; k++)\r\n            {\r\n                ans[i][j] += a[i][k] * b[k][j];\r\n            }\r\n            cout << ans[i][j] << \" \";\r\n        }\r\n        cout << endl;\r\n    }\r\n    \r\n    // for(int i = 0; i < n; i++)\r\n    // {\r\n    //     for(int j = 0; j < n; j++)\r\n    //     cout << ans[i][j] << \" \";\r\n    //     cout << endl;\r\n    // }\r\n}', 10, '', '', '', '0000-00-00'),
(220, 7, 3601012018, '#include <cstdlib> \r\n#include<ctime>\r\n #include <iostream> \r\nusing namespace std; \r\nint partition(int arr[], int low, int high) \r\n{\r\n int pivot = arr[high];\r\n int i = (low - 1); \r\n for (int j = low; j <= high - 1; j++) \r\n{ \r\n    if (arr[j] <= pivot) \r\n{     i++; \r\n     swap(arr[i], arr[j]); \r\n} \r\n} \r\nswap(arr[i + 1], arr[high]); \r\nreturn (i + 1);\r\n } \r\nint partition_r(int arr[], int low, int high) \r\n{ \r\nsrand(time(NULL));\r\n int random = low + rand() % (high - low); \r\nswap(arr[random], arr[high]);\r\n return partition(arr, low, high); \r\n}  \r\nvoid quickSort(int arr[], int low, int high) \r\n{ \r\nif (low < high)\r\n { \r\nint pi = partition_r(arr, low, high); \r\nquickSort(arr, low, pi - 1);\r\n quickSort(arr, pi + 1, high); \r\n} \r\n}\r\n\r\nvoid printArray(int arr[], int size) \r\n{ \r\nint i;\r\nfor (i = 0; i < size; i++) \r\ncout<<arr[i]<<\" \";\r\n} \r\nint main()\r\n{ \r\nint n; \r\ncin>>n; \r\nint arr[n]; \r\nfor(int i=0;i<n;i++) { cin>>arr[i]; } \r\nquickSort(arr, 0, n - 1); \r\nprintArray(arr, n);\r\n return 0;\r\n } \r\n', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', '', '0000-00-00');
INSERT INTO `qtos_map` (`ID`, `Q_ID`, `ROLL`, `SUBMISSION`, `SCORE`, `INPUT`, `OP`, `ALGO`, `DATE`) VALUES
(221, 8, 2201012018, '#include < iostream>\r\n#include < vector>\r\n#include < cmath>\r\n#include < algorithm>\r\nusing namespace std;\r\n\r\nint nextpowerof2(int k)\r\n{\r\n    return pow(2, int(ceil(log2(k))));\r\n}\r\nvoid display(vector< vector<int>> &matrix, int m, int n)\r\n{\r\n    for (int i = 0; i < m; i++)\r\n    {\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            if (j != 0)\r\n            {\r\n                cout << \"	\";\r\n            }\r\n            cout << matrix[i][j];\r\n        }\r\n        cout << endl;\r\n    }\r\n}\r\n\r\nvoid add(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\r\n{\r\n    int i, j;\r\n\r\n    for (i = 0; i < size; i++)\r\n    {\r\n        for (j = 0; j < size; j++)\r\n        {\r\n            C[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid sub(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\r\n{\r\n    int i, j;\r\n\r\n    for (i = 0; i < size; i++)\r\n    {\r\n        for (j = 0; j < size; j++)\r\n        {\r\n            C[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid STRASSEN_algorithmA(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\r\n{\r\n   \r\n    if (size == 1)\r\n    {\r\n        C[0][0] = A[0][0] * B[0][0];\r\n        return;\r\n    }\r\n    else\r\n    {\r\n        int new_size = size / 2;\r\n        vector<int> z(new_size);\r\n        vector<vector<int>>\r\n            a11(new_size, z), a12(new_size, z), a21(new_size, z), a22(new_size, z),\r\n            b11(new_size, z), b12(new_size, z), b21(new_size, z), b22(new_size, z),\r\n            c11(new_size, z), c12(new_size, z), c21(new_size, z), c22(new_size, z),\r\n            p1(new_size, z), p2(new_size, z), p3(new_size, z), p4(new_size, z),\r\n            p5(new_size, z), p6(new_size, z), p7(new_size, z),\r\n            aResult(new_size, z), bResult(new_size, z);\r\n\r\nint i, j;\r\n\r\nfor (i = 0; i < new_size; i++)\r\n        {\r\n            for (j = 0; j < new_size; j++)\r\n            {\r\n                a11[i][j] = A[i][j];\r\n                a12[i][j] = A[i][j + new_size];\r\n                a21[i][j] = A[i + new_size][j];\r\n                a22[i][j] = A[i + new_size][j + new_size];\r\n\r\n                b11[i][j] = B[i][j];\r\n                b12[i][j] = B[i][j + new_size];\r\n                b21[i][j] = B[i + new_size][j];\r\n                b22[i][j] = B[i + new_size][j + new_size];\r\n            }\r\n}\r\n\r\n\r\n        add(a11, a22, aResult, new_size);    \r\n        add(b11, b22, bResult, new_size);    \r\n        STRASSEN_algorithmA(aResult, bResult, p1, new_size); \r\n\r\n        add(a21, a22, aResult, new_size); \r\n        STRASSEN_algorithmA(aResult, b11, p2, new_size);\r\n\r\n        sub(b12, b22, bResult, new_size);      \r\n        STRASSEN_algorithmA(a11, bResult, p3, new_size);\r\n\r\n        sub(b21, b11, bResult, new_size);     \r\n        STRASSEN_algorithmA(a22, bResult, p4, new_size); \r\n\r\n        add(a11, a12, aResult, new_size);     \r\n        STRASSEN_algorithmA(aResult, b22, p5, new_size);\r\n\r\n        sub(a21, a11, aResult, new_size);      \r\n        add(b11, b12, bResult, new_size);               \r\n      \r\n        STRASSEN_algorithmA(aResult, bResult, p6, new_size);\r\n\r\n        sub(a12, a22, aResult, new_size);      \r\n        add(b21, b22, bResult, new_size);                \r\n        \r\n        STRASSEN_algorithmA(aResult, bResult, p7, new_size);\r\n        \r\n\r\n        add(p3, p5, c12, new_size); \r\n        add(p2, p4, c21, new_size); \r\n\r\n        add(p1, p4, aResult, new_size);      \r\n        add(aResult, p7, bResult, new_size); \r\n        sub(bResult, p5, c11, new_size); \r\n\r\n        add(p1, p3, aResult, new_size);     \r\n        add(aResult, p6, bResult, new_size);  \r\n        sub(bResult, p2, c22, new_size); \r\n\r\n        for (i = 0; i < new_size; i++)\r\n        {\r\n            for (j = 0; j < new_size; j++)\r\n            {\r\n                C[i][j] = c11[i][j];\r\n                C[i][j + new_size] = c12[i][j];\r\n                C[i + new_size][j] = c21[i][j];\r\n                C[i + new_size][j + new_size] = c22[i][j];\r\n            }\r\n        }\r\n    }\r\n}\r\nvoid STRASSEN_algorithm(vector<vector<int>> &A, vector<vector<int>> &B, int m, int n, int a, int b)\r\n{  \r\n    int k = max({m, n, a, b});\r\n\r\n    int s = nextpowerof2(k);\r\n\r\n    vector<int> z(s);\r\n    vector<vector<int>> Aa(s, z), Bb(s, z), Cc(s, z);\r\n\r\n    for (unsigned int i = 0; i < m; i++)\r\n    {\r\n        for (unsigned int j = 0; j < n; j++)\r\n        {\r\n            Aa[i][j] = A[i][j];\r\n        }\r\n    }\r\n    for (unsigned int i = 0; i < a; i++)\r\n    {\r\n        for (unsigned int j = 0; j < b; j++)\r\n        {\r\n            Bb[i][j] = B[i][j];\r\n        }\r\n    }\r\n    STRASSEN_algorithmA(Aa, Bb, Cc, s);\r\n    vector<int> temp1(b);\r\n    vector<vector<int>> C(m, temp1);\r\n    for (unsigned int i = 0; i < m; i++)\r\n    {\r\n        for (unsigned int j = 0; j < b; j++)\r\n        {\r\n            C[i][j] = Cc[i][j];\r\n        }\r\n    }\r\n    display(C, m, b);\r\n}\r\n\r\nbool check(int n, int a)\r\n{\r\n    if (n == a)\r\n        return true;\r\n    else\r\n        return false;\r\n}\r\n\r\nint main()\r\n{\r\nInt t;\r\ncin>>t;\r\nwhile(t!=0){\r\n    int m, n, a, b;\r\n    cin >> m >> n;\r\n    vector<vector<int>> A;\r\n   \r\n    for (int i = 0; i < m; i++)\r\n    {\r\n        vector<int> temp;\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            int i;\r\n            cin >> i;\r\n            temp.push_back(i);\r\n        }\r\n        A.push_back(temp);\r\n    }\r\n    \r\n    cin >> a >> b;\r\n    \r\n    vector<vector<int>> B;\r\n    for (int i = 0; i < a; i++)\r\n    {\r\n        vector<int> temp;\r\n        for (int j = 0; j < b; j++)\r\n        {\r\n            int i;\r\n            cin >> i;\r\n            temp.push_back(i);\r\n        }\r\n        B.push_back(temp);\r\n    }\r\n\r\n    bool k = check(n, a);\r\n    if (k)\r\n    {\r\n        STRASSEN_algorithm(A, B, m, n, a, b);\r\n    }\r\n    else\r\n    {\r\n        cout << \"-1\";\r\n    }\r\nt--;\r\ncout<<endl;\r\n}\r\n    return 0;\r\n}\r\n', 0, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '', 'MATRIX-CHAIN-ORDER (p)\r\n\r\n\r\n 1. n   length[p]-1\r\n 2. for i ← 1 to n\r\n 3. do m [i, i] ← 0\r\n 4. for l ← 2 to n    // l is the chain length\r\n 5. do for i ← 1 to n-l + 1\r\n 6. do j ← i+ l -1\r\n 7. m[i,j] ←  ∞\r\n 8. for k  ← i to j-1\r\n 9. do q  ← m [i, k] + m [k + 1, j] + pi-1 pk pj	\r\n 10. If q < m [i,j]\r\n 11. then m [i,j] ← q\r\n 12. s [i,j] ← k\r\n 13. return m and s.   ', '2020-05-25'),
(222, 12, 2501012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n\r\nclass Edge \r\n{ \r\n	public: \r\n	int src, dest, weight; \r\n}; \r\nclass Graph \r\n{ \r\n	public: \r\n	int V, E; \r\n\r\n	Edge* edge; \r\n}; \r\n\r\nGraph* createGraph(int V, int E) \r\n{ \r\n	Graph* graph = new Graph; \r\n	graph->V = V; \r\n	graph->E = E; \r\n\r\n	graph->edge = new Edge[E]; \r\n\r\n	return graph; \r\n} \r\n\r\nclass subset \r\n{ \r\n	public: \r\n	int parent; \r\n	int rank; \r\n}; \r\nint find(subset subsets[], int i) \r\n{ \r\n	if (subsets[i].parent != i) \r\n		subsets[i].parent = find(subsets, subsets[i].parent); \r\n\r\n	return subsets[i].parent; \r\n} \r\n\r\nvoid Union(subset subsets[], int x, int y) \r\n{ \r\n	int xroot = find(subsets, x); \r\n	int yroot = find(subsets, y); \r\n\r\n	if (subsets[xroot].rank < subsets[yroot].rank) \r\n		subsets[xroot].parent = yroot; \r\n	else if (subsets[xroot].rank > subsets[yroot].rank) \r\n		subsets[yroot].parent = xroot; \r\n\r\n	else\r\n	{ \r\n		subsets[yroot].parent = xroot; \r\n		subsets[xroot].rank++; \r\n	} \r\n} \r\n\r\nint myComp(const void* a, const void* b) \r\n{ \r\n	Edge* a1 = (Edge*)a; \r\n	Edge* b1 = (Edge*)b; \r\n	return a1->weight > b1->weight; \r\n} \r\n\r\nvoid KruskalMST(Graph* graph) \r\n{ \r\n	int V = graph->V; \r\n	Edge result[V]; \r\n	int e = 0;  \r\n	int i = 0; \r\n\r\n	qsort(graph->edge, graph->E, sizeof(graph->edge[0]), myComp); \r\n\r\n	subset *subsets = new subset[( V * sizeof(subset) )]; \r\n\r\n	for (int v = 0; v < V; ++v) \r\n	{ \r\n		subsets[v].parent = v; \r\n		subsets[v].rank = 0; \r\n	} \r\n\r\n	while (e < V - 1 && i < graph->E) \r\n	{ \r\n		Edge next_edge = graph->edge[i++]; \r\n\r\n		int x = find(subsets, next_edge.src); \r\n		int y = find(subsets, next_edge.dest); \r\n\r\n		if (x != y) \r\n		{ \r\n			result[e++] = next_edge; \r\n			Union(subsets, x, y); \r\n		} \r\n	} \r\n\r\n	for (i = 0; i < e; ++i) \r\n		cout<<result[i].src<<\"--\"<<result[i].dest<<\"==>\"<<result[i].weight<<endl; \r\n	return; \r\n} \r\n\r\nint main() \r\n{ \r\n	int V = 4;\r\n	int E = 5; \r\n	Graph* graph = createGraph(V, E); \r\n\r\n\r\n	graph->edge[0].src = 0; \r\n	graph->edge[0].dest = 1; \r\n	graph->edge[0].weight = 10; \r\n\r\n	graph->edge[1].src = 0; \r\n	graph->edge[1].dest = 2; \r\n	graph->edge[1].weight = 6; \r\n\r\n	graph->edge[2].src = 0; \r\n	graph->edge[2].dest = 3; \r\n	graph->edge[2].weight = 5; \r\n\r\n\r\n	graph->edge[3].src = 1; \r\n	graph->edge[3].dest = 3; \r\n	graph->edge[3].weight = 15; \r\n\r\n \r\n	graph->edge[4].src = 2; \r\n	graph->edge[4].dest = 3; \r\n	graph->edge[4].weight = 4; \r\n\r\n	KruskalMST(graph); \r\n\r\n	return 0; \r\n} \r\n', 0, '', '', '', '0000-00-00'),
(223, 3, 2201012018, '#include <bits/stdc++.h> \r\nusing namespace std;  \r\n   \r\nvoid swap(int* a, int* b)  \r\n{  \r\n    int t = *a;  \r\n    *a = *b;  \r\n    *b = t;  \r\n}  \r\n  \r\nint partition (int arr[], int low, int high)  \r\n{  \r\n    int pivot = arr[high];  \r\n    int i = (low - 1); \r\n  \r\n    for (int j = low; j <= high - 1; j++)  \r\n    {   \r\n        if (arr[j] < pivot)  \r\n        {  \r\n            i++; \r\n            swap(&arr[i], &arr[j]);  \r\n        }  \r\n    }  \r\n    swap(&arr[i + 1], &arr[high]);  \r\n    return (i + 1);  \r\n}  \r\n  \r\nvoid quickSort(int arr[], int low, int high)  \r\n{  \r\n    if (low < high)  \r\n    {  \r\n        int pi = partition(arr, low, high);   \r\n        quickSort(arr, low, pi - 1);  \r\n        quickSort(arr, pi + 1, high);  \r\n    }  \r\n}  \r\n  \r\nvoid printArray(int arr[], int size)  \r\n{  \r\n    int i;  \r\n    for (i = 0; i < size; i++)  \r\n        cout << arr[i] << \" \";  \r\n    cout << endl;  \r\n}  \r\n  \r\nint main()  \r\n{  \r\nint t;\r\ncin>>t;\r\nwhile(t!=0){\r\nint n;\r\ncin>>n;\r\n    int arr[n] ;  \r\n   for(int i=0;i<n;i++){\r\ncin>>arr[i];\r\n}\r\n    quickSort(arr, 0, n - 1);   \r\n    printArray(arr, n);  \r\nt--;\r\n}\r\n    return 0;  \r\n} ', 0, '1 2000', '-1996488312 -1996488312 -1746987490 -1746987490 -1746987394 -1746986910 -1284654964 -1284654964 -1284654260 -1284654260 -1157627717 -1073741807 -995892916 -993392916 -993392416 -993392080 -993391868 -993388776 -993388640 -993388576 -993388488 -993388344 -993388072 -993387936 -993387816 -993387632 -993387592 -993387476 -993387140 -993387028 -993386676 -993378608 -905969462 -905969462 -838860084 -838860084 -838860084 -838860084 -489262906 -285719254 -194488364 -194488364 -167771657 -17974607 -17974607 -65536 -688 -367 -190 -187 -183 -2 -2 -2 -2 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 5 5 8 9 9 9 10 10 10 13 14 16 16 16 16 17 17 17 17 18 18 18 18 20 22 22 24 24 24 24 24 24 24 24 24 25 28 28 31 31 31 31 32 32 32 32 32 32 33 44 44 50 63 64 64 64 66 68 80 80 80 80 115 115 115 115 127 127 127 127 127 127 127 127 127 127 127 127 127 127 127 127 127 127 127 127 127 128 128 128 143 183 183 183 187 196 200 216 224 224 236 236 255 255 255 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 280 389 452 462 512 512 512 512 532 628 664 716 909 909 909 909 996 1252 1252 1252 1395 1905 1905 1905 1952 1952 1952 1952 2000 4096 4100 7956 7968 8016 13084 13084 52428 52428 55297 65568 65568 131072 131097 196610 196610 262144 327684 327684 393743 458758 458758 589832 589832 655360 655360 655596 655596 655612 655612 661336 661336 661336 663128 663208 663216 720906 720906 851980 851980 983054 983054 983054 983054 1114128 1114128 1245202 1245202 1310738 1376276 1376276 1507350 1507350 1638424 1638424 1769498 1769498 1900572 1900572 2031646 2031646 2097152 2162720 2162720 2293794 2293794 2424868 2424868 2555942 2555942 2621442 2687016 2687016 2818090 2818090 2949164 2949164 3080238 3080238 3145776 3211312 3211312 3276848 3342386 3342386 3473460 3473460 3538992 3604534 3604534 3735608 3735608 3866682 3866682 3874816 3874816 3874816 3874816 3887104 3887104 3887104 3887104 3887104 3997756 3997756 4128830 4128830 4199040 4199040 4199040 4199040 4199822 4201088 4259904 4259904 4259936 4295123 4295123 4336627 4336627 4338772 4338873 4338873 4362768 4383243 4390978 4390978 4390978 4391004 4391004 4510886 4510942 4522052 4522052 4522052 4587568 4653126 4653126 4653126 4659728 4665628 4665628 4711456 4711456 4711456 4711456 4711456 4711456 4711456 4712704 4712712 4712712 4712712 4712712 4712712 4712712 4712712 4732986 4733024 4784200 4784200 4784200 4915274 4915274 4915274 5046348 5046348 5046348 5111900 5177422 5177422 5177422 5308496 5308496 5308496 5374044 5439570 5439570 5439570 5439580 5439596 5570644 5570644 5570644 5636188 5701718 5701718 5701718 5832792 5832792 5832792 5963866 5963866 6029413 6029433 6094940 6094940 6226014 6226014 6357069 6357088 6488162 6619236 6619250 6750309 6750310 6750318 6815843 6881329 6881384 6881395 6881396 6939540 6940492 6940564 6940588 6940628 6940636 6940644 6940648 6940673 6940684 6940728 6940728 6940728 6940812 6940812 6940872 6940872 6940876 6940884 6940912 6940924 6940936 6940944 6940944 6940972 6941044 6941100 6941172 6941185 6941212 6941244 6941248 6941256 6941268 6941308 6941316 6941324 6941328 6941352 6941364 6941408 6941408 6941408 6941408 6941492 6941492 6941492 6941552 6941552 6941552 6941564 6941604 6941652 6941724 6941724 6941752 6941752 6941768 6941768 6941768 6941800 6941892 6941908 6941940 6941956 6941976 6941988 6942004 6942004 6942008 6942032 6942032 6942048 6942048 6942084 6942264 6942280 6942280 6942304 6942312 6942312 6942312 6942312 6942312 6942312 6942424 6942432 6942432 6942458 6942624 6942632 6942632 6942684 6942684 6942684 6942688 6942688 6942724 6942724 6942758 6942808 6942824 6942840 6942840 6942840 6942840 6942840 6943180 6943184 6943200 6943204 6943308 6943448 6943448 6943452 6943492 6943508 6943823 6943823 6943823 6943824 6944100 6944100 6944100 6944100 6944257 6944340 6944356 6944376 6944376 6944376 6944376 6944408 6944428 6944436 6944472 6944492 6944512 6944512 6944512 6944512 6944512 6944520 6944584 6944584 6944612 6944612 6944664 6944672 6944720 6944720 6944720 6944720 6944720 6944720 6944752 6944777 6944804 6944872 6944916 6944984 6945072 6945104 6945140 6945216 6945232 6945296 6945312 6945340 6945500 6945536 6945628 6945644 6945648 6945656 6945664 6945680 6945684 6945712 6945716 6945760 6945832 6945840 6945840 6945892 6945904 6945932 6945940 6945956 6945964 6945984 6946024 6946080 6946140 6946216 6946216 6946264 6946264 6946272 6946316 6946316 6946316 6946316 6946316 6946316 6946376 6946376 6946376 6946376 6946376 6946376 6946380 6946380 6946384 6946384 6946408 6946408 6946440 6946444 6946444 6946444 6946444 6946444 6946444 6946444 6946528 6946764 6946764 6946764 7012458 7077999 7143525 7143532 7209065 7209071 7209071 7274563 7274606 7274610 7405680 7471205 7471215 7471220 7471220 7471221 7536745 7536748 7536754 7602277 7602286 7602286 7602291 7667828 7798902 7864320 7864320 7864320 7864320 7864320 7864320 7864320 7864320 7864320 7864320 7864320 7864320 7864320 7864320 7864512 7864512 7864944 7865008 7865008 7876296 7876320 7877064 7877216 7877216 7877216 7877216 7877276 7877536 7877560 7877568 7878600 7878600 7879736 7879736 7879744 7879744 7879744 7880200 7880224 7880224 7886128 7886624 7929939 7929976 8061018 8061050 8192124 8192124 8323198 8323198 8388608 8388618 8462508 8462508 9240914 9372029 9437326 10289490 10551456 10682530 10813604 10944678 11075752 11206826 11337900 11468974 11600048 11731122 11862196 11993270 12124344 12255418 12386492 12517566 12648640 12648640 12779714 12779714 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845056 12845136 12845248 12845248 12845248 12845248 12845248 12845248 12845248 12845427 12845680 12845680 12845680 12845680 12845744 12845772 12845844 12846248 12846248 12846256 12846262 12846264 12846264 12846264 12846272 12846272 12846488 12846520 12847076 12848336 12848336 12848336 12848344 12848344 12848368 12848376 12848480 12848480 12848480 12848480 12848488 12848488 12848488 12848488 12848488 12848488 12848500 12848504 12848536 12848728 12848728 12848728 12849472 12849472 12849480 12849480 12849480 12849480 12849480 12849696 12849840 12849840 12849840 12849868 12852180 12852288 12852296 12854344 12854352 12854352 12854358 12858456 12858456 12858456 12858456 12858456 12858464 12858464 12858464 12858464 12858464 12858464 12866424 12866936 12866936 12867976 12873696 12910788 12910788 13041862 13041862 13041862 13172936 13172936 13303857 13304010 13304010 13435084 13435084 13566158 13566158 13697232 13697232 13828306 13828306 13828306 13959380 13959380 14090454 14090454 14221528 14221528 14352602 14352602 14483676 14483676 14614750 15532268 15663342 15794416 15925490 16056564 16187606 16187638 16318712 16449786 16580860 16711934 16777216 16777244 16777244 16777472 16777504 16777523 16777570 16777596 16777596 16842888 16883776 16907328 16907360 20976256 24641758 24641917 26288154 26353690 29642720 33554434 33554434 33554944 33619971 34603520 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603552 34603592 34603592 34603777 34603777 34603777 34603778 34603778 34603794 34603794 34865190 34865680 34865684 35652096 35652112 35652128 35652128 35652128 35652128 35652128 35652128 35652128 35652128 35652128 35652128 35652128 35652128 35652168 35652353 35652353 35652354 36176424 36176424 36700688 37076676 37076676 37076676 37076676 37076676 40370720 42205828 42205828 42205828 42205828 42205828 50331651 50331651 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397954 50398081 50463248 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463618 51511824 58786320 58786689 58786689 58851856 58852226 58852226 83886085 83886085 83886085 214748364 285212689 285212689 318767123 385941526 469762076 520093727 538189843 538443920 538443920 538714137 538714137 539041824 539041824 539107357 539107357 539369502 539369502 540017350 540017350 540606816 540672352 555877084 754974765 754974765 754974765 822215426 922746935 1912602995 1912602995 1912602995 1912602995 1912602995 1912602995 1912603505 1968875835 1968890764 1968890899 1968925365 1968925664 1968925857 1968925907 1968925988 1968950464 1968992245 1969307768 1969309184 1969309184 1969309184 1969312192 1969319168 1969319296 1969319296 1993301020 1993301020 1993301020 1993301066 1993301068 1993301476 1993301488 1993301608 1993919619 1993919661 1993920276 1993920397 1993949574 1993949574 1993975678 1993975759 1993975929 1993976247 1993977058 1993977082 1994006501 2008940544 2008940544 2008947224 2008948144 2008960560 2008976792 2008976792 2009158987 2009169156 2009170054 2009170348 2009173278 2009173401 2009173941 2009173941 2009174035 2009175178 2009175178 2009176427 2009176427 2009176768 2009176768 2009182415 2009182415 2009186028 2009188048 2009188048 2009188048 2009189696 2009189696 2009189696 2009190943 2009190943 2009190943 2009190943 2009190943 2009190943 2009190943 2009190943 2009190943 2009196576 2009197209 2009202655 2009234055 2009315379 2009315379 2009315379 2009315379 2009315379 2009315379 2009315379 2009334393 2009334393 2009334393 2009346651 2009399296 2009407228 2009407276 2009407276 2009407356 2009407356 2009407548 2009427176 2009427272 2009429472 2009429472 2009440320 2009440320 2009440320 2009447055 2009448660 2009448726 2009492907 2009492907 2009492946 2009492946 2009657029 2009657039 2009657079 2009660698 2009660885 2009662962 2009663760 2009926285 2009926370 2010113412 2010113412 2010113412 2010113412 2147352624 2147483647 \n', 'partition algo\r\n/* low  --> Starting index,  high  --> Ending index */\r\nquickSort(arr[], low, high)\r\n{\r\n    if (low < high)\r\n    {\r\n        /* pi is partitioning index, arr[pi] is now\r\n           at right place */\r\n        pi = partition(arr, low, high);\r\n\r\n        quickSort(arr, low, pi - 1);  // Before pi\r\n        quickSort(arr, pi + 1, high); // After pi\r\n    }\r\n}', '2020-05-25'),
(224, 10, 301012018, '\r\n#include <bits/stdc++.h> \r\nusing namespace std; \r\n  \r\n\r\nint max(int a, int b) { return (a > b)? a : b; }  \r\n \r\nint knapSack(int W, int wt[], int val[], int n)  \r\n{  \r\n      \r\n\r\nif (n == 0 || W == 0)  \r\n    return 0;\r\n    \r\nif (wt[n-1] > W)  \r\n    return knapSack(W, wt, val, n-1);  \r\n  \r\n\r\nelse return max( val[n-1] + knapSack(W-wt[n-1], wt, val, n-1),  \r\n                    knapSack(W, wt, val, n-1) );  \r\n}  \r\n  \r\n\r\nint main()  \r\n{  \r\n    int n, W;\r\n    cin>> n>> W;\r\n    int val[n];  \r\n    for(int i=0; i<n; i++)\r\n    {\r\n        cin>>val[i];\r\n    }\r\n    int wt[n];\r\n    for(int i =0; i<n; i++)\r\n    {\r\n        cin>>wt[i];\r\n    }\r\n    \r\n    \r\n    cout<<knapSack(W, wt, val, n);  \r\n    return 0;  \r\n}  \r\n', 10, '', '', '', '0000-00-00'),
(225, 7, 2101012018, '#include <ctime>\r\n#include <cstdlib>\r\n#include <iostream> \r\nusing namespace std; \r\n  \r\n\r\nint partition(int arr[], int low, int high) \r\n{ \r\n    int pivot = arr[high];  \r\n    int i = (low - 1); \r\n  \r\n    for (int j = low; j <= high - 1; j++) { \r\n  \r\n       \r\n        if (arr[j] <= pivot) { \r\n  \r\n            i++;\r\n            swap(arr[i], arr[j]); \r\n        } \r\n    } \r\n    swap(arr[i + 1], arr[high]); \r\n    return (i + 1); \r\n} \r\n  \r\n\r\nint partition_r(int arr[], int low, int high) \r\n{ \r\n   \r\n    srand(time(NULL)); \r\n    int random = low + rand() % (high - low); \r\n  \r\n   \r\n    swap(arr[random], arr[high]); \r\n  \r\n    return partition(arr, low, high); \r\n} \r\n  \r\n\r\nvoid quickSort(int arr[], int low, int high) \r\n{ \r\n    if (low < high) { \r\n  \r\n        \r\n        int pi = partition_r(arr, low, high); \r\n        quickSort(arr, low, pi - 1); \r\n        quickSort(arr, pi + 1, high); \r\n    } \r\n} \r\n  \r\n\r\nvoid printArray(int arr[], int size) \r\n{ \r\n    for (int i = 0; i < size; i++)\r\n    {\r\n        cout<<arr[i];\r\n        cout<<\" \";\r\n    }\r\n        \r\n} \r\n  \r\n\r\nint main() \r\n{ \r\n    int arr[100]; \r\n    int n; \r\n    cin>>n;\r\n    for(int i = 0; i < n; i++) \r\n        cin>>arr[i]; \r\n    quickSort(arr, 0, n - 1);\r\n    printArray(arr, n); \r\n    return 0; \r\n}', 10, '', '', '', '0000-00-00'),
(226, 8, 1301012018, '#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint main(){\r\n    int n;\r\n    cin>>n;\r\n    int a[n][n],b[n][n];\r\n    for(int i=0;i<n;i++){\r\n        for(int j=0;j<n;j++){\r\n            cin>>a[i][j];\r\n        }\r\n    }\r\n    for(int i=0;i<n;i++){\r\n        for(int j=0;j<n;j++){\r\n            cin>>b[i][j];\r\n        }\r\n    }\r\n    int c[n][n];\r\n    for(int i=0;i<n;i++){\r\n        for(int j=0;j<n;j++){\r\n            c[i][j]=0;\r\n            for(int k=0;k<n;k++){\r\n                c[i][j] += (a[i][k]*b[k][j]);\r\n            }\r\n        }\r\n    }\r\n    \r\n    for(int i=0;i<n;i++){\r\n        for(int j=0;j<n;j++){\r\n            cout<<c[i][j]<<\" \";\r\n        }\r\n        cout<<endl;\r\n    }\r\n    \r\n}', 10, '', '', '', '0000-00-00'),
(229, 10, 601012018, '\r\n#include <bits/stdc++.h> \r\nusing namespace std; \r\n  \r\n\r\nint max(int a, int b) { return (a > b)? a : b; }  \r\n \r\nint knapSack(int W, int wt[], int val[], int n)  \r\n{  \r\n      \r\n\r\nif (n == 0 || W == 0)  \r\n    return 0;\r\n    \r\nif (wt[n-1] > W)  \r\n    return knapSack(W, wt, val, n-1);  \r\n  \r\n\r\nelse return max( val[n-1] + knapSack(W-wt[n-1], wt, val, n-1),  \r\n                    knapSack(W, wt, val, n-1) );  \r\n}  \r\n  \r\n\r\nint main()  \r\n{  \r\n    int n, W;\r\n    cin>> n>> W;\r\n    int val[n];  \r\n    for(int i=0; i<n; i++)\r\n    {\r\n        cin>>val[i];\r\n    }\r\n    int wt[n];\r\n    for(int i =0; i<n; i++)\r\n    {\r\n        cin>>wt[i];\r\n    }\r\n    \r\n    \r\n    cout<<knapSack(W, wt, val, n);  \r\n    return 0;  \r\n}  \r\n', 10, '', '', '', '0000-00-00'),
(230, 9, 701012018, '#include<cstdlib>\r\n#include<iostream>\r\nusing namespace std;\r\n\r\nint partition(int arr[], int low, int high){\r\n    int pivot = arr[high];\r\n    int i = (low-1);\r\n    \r\n    for(int j = low; j<=high-1; j++){\r\n        if(arr[j]<=pivot){\r\n            i++;\r\n            swap(arr[i],arr[j]);\r\n        }\r\n    }\r\n    swap(arr[i+1],arr[high]);\r\n    return (i+1);\r\n}\r\n\r\nint partition_r(int arr[], int low, int high){\r\n    srand(time(NULL));\r\n    int random = low + rand() % (high-low);\r\n    swap(arr[random], arr[high]);\r\n    return partition(arr,low,high);\r\n}\r\n\r\nvoid quicksort(int arr[], int low, int high){\r\n    if(low<high){\r\n        int pi=partition_r(arr,low,high);\r\n        quicksort(arr,low,pi-1);\r\n        quicksort(arr,pi+1,high);\r\n    }\r\n}\r\n\r\nvoid print(int arr[], int size){\r\n    int i;\r\n    for(i=0; i<siz; i++){\r\n        printf(\"%d \",arr[i]);\r\n    }\r\n    printf(\"/n\");\r\n}\r\n\r\nint main(){\r\n    int n;\r\n    cin>>n;\r\n    int arr[n];\r\n    for(int i=0; i<n; i++){\r\n        cin>>arr[i];\r\n    }\r\n    quicksort(arr,0,n-1);\r\n    print(arr,n);\r\n    return 0;\r\n}', 1000, '', '', '', '0000-00-00'),
(231, 7, 701012018, '#include<cstdlib>\r\n#include<iostream>\r\nusing namespace std;\r\n\r\nint partition(int arr[], int low, int high){\r\n    int pivot = arr[high];\r\n    int i = (low-1);\r\n    \r\n    for(int j = low; j<=high-1; j++){\r\n        if(arr[j]<=pivot){\r\n            i++;\r\n            swap(arr[i],arr[j]);\r\n        }\r\n    }\r\n    swap(arr[i+1],arr[high]);\r\n    return (i+1);\r\n}\r\n\r\nint partition_r(int arr[], int low, int high){\r\n    srand(time(NULL));\r\n    int random = low + rand() % (high-low);\r\n    swap(arr[random], arr[high]);\r\n    return partition(arr,low,high);\r\n}\r\n\r\nvoid quicksort(int arr[], int low, int high){\r\n    if(low<high){\r\n        int pi=partition_r(arr,low,high);\r\n        quicksort(arr,low,pi-1);\r\n        quicksort(arr,pi+1,high);\r\n    }\r\n}\r\n\r\nvoid print(int arr[], int size){\r\n    int i;\r\n    for(i=0; i<siz; i++){\r\n        printf(\"%d \",arr[i]);\r\n    }\r\n    printf(\"/n\");\r\n}\r\n\r\nint main(){\r\n    int n;\r\n    cin>>n;\r\n    int arr[n];\r\n    for(int i=0; i<n; i++){\r\n        cin>>arr[i];\r\n    }\r\n    quicksort(arr,0,n-1);\r\n    print(arr,n);\r\n    return 0;\r\n}', 10, '', '', 'partition(arr[], lo, hi) \r\n    pivot = arr[hi]\r\n    i = lo     // place for swapping\r\n    for j := lo to hi – 1 do\r\n        if arr[j] <= pivot then\r\n            swap arr[i] with arr[j]\r\n            i = i + 1\r\n    swap arr[i] with arr[hi]\r\n    return i\r\n\r\npartition_r(arr[], lo, hi)\r\n    r = Random Number from lo to hi\r\n    Swap arr[r] and arr[hi]\r\n    return partition(arr, lo, hi)\r\n\r\nquicksort(arr[], lo, hi)\r\n    if lo < hi\r\n        p = partition_r(arr, lo, hi)\r\n        quicksort(arr, p-1, hi)\r\n        quicksort(arr, p+1, hi)', '0000-00-00'),
(233, 8, 1101012018, '#include<iostream> \r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int n;\r\n    cin >> n;\r\n    int a[n][n], b[n][n];\r\n    for(int i = 0; i < n; i++)\r\n    {\r\n        for(int j = 0; j < n; j++)\r\n        cin >> a[i][j];\r\n    }\r\n    for(int i = 0; i < n; i++)\r\n    {\r\n        for(int j = 0; j < n; j++)\r\n        cin >> b[i][j];\r\n    }\r\n    \r\n    int ans[n][n];\r\n    \r\n    for(int i = 0; i < n; i++)\r\n    {\r\n        for(int j = 0; j < n; j++)\r\n        {\r\n            ans[i][j] = 0;\r\n            for(int k = 0; k < n; k++)\r\n            {\r\n                ans[i][j] += a[i][k] * b[k][j];\r\n            }\r\n            cout << ans[i][j] << \" \";\r\n        }\r\n        cout << endl;\r\n    }\r\n    \r\n    // for(int i = 0; i < n; i++)\r\n    // {\r\n    //     for(int j = 0; j < n; j++)\r\n    //     cout << ans[i][j] << \" \";\r\n    //     cout << endl;\r\n    // }\r\n}', 10, '', '', '', '0000-00-00'),
(234, 3, 2801012018, '#include<iostream>\r\nusing namespace std;\r\nvoid swap (int &a, int&b)\r\n{\r\n	int t = a;\r\n	a = b;\r\n	b = t;\r\n}\r\nint pivotlist( int A[], int first, int last)\r\n{\r\n	int pp = first;\r\n	int pv = A[first];\r\n	for (int i = first + 1; i<= last; i++)\r\n	if(A[i] <pv)\r\n	swap ( A[i] , A[++pp]);\r\n	swap ( A[first] , A[pp]);\r\n	return pp;\r\n}\r\nvoid quicksort(int A[] , int first , int last)\r\n{\r\n	if(first == last)\r\n	return;\r\n	int pivot = pivotlist(A, first, last);\r\n	quicksort(A, first, pivot-1);\r\n	quicksort(A, pivot+1, last);\r\n}\r\nint main()\r\n{\r\n	int n;\r\n	cin>>n;\r\n	int A[n];\r\n	for (int i=0; i<n; i++)\r\n	cin>>A[i];\r\n	quicksort(A, 0, n-1);\r\n	for(int i=0; i<n; i++)\r\n	cout<<A[i]<<\" \";\r\n	return 0;\r\n}', 2, '1 2000', '2000 ', '{\r\n    if (low < high)\r\n    {\r\n        /* pi is partitioning index, arr[pi] is now\r\n           at right place */\r\n        pi = partition(arr, low, high);\r\n\r\n        quickSort(arr, low, pi - 1);  // Before pi\r\n        quickSort(arr, pi + 1, high); // After pi\r\n    }\r\n}\r\n\r\n/* This function takes last element as pivot, places\r\n   the pivot element at its correct position in sorted\r\n    array, and places all smaller (smaller than pivot)\r\n   to left of pivot and all greater elements to right\r\n   of pivot */\r\npartition (arr[], low, high)\r\n{\r\n    // pivot (Element to be placed at right position)\r\n    pivot = arr[high];  \r\n \r\n    i = (low - 1)  // Index of smaller element\r\n\r\n    for (j = low; j <= high- 1; j++)\r\n    {\r\n        // If current element is smaller than the pivot\r\n        if (arr[j] < pivot)\r\n        {\r\n            i++;    // increment index of smaller element\r\n            swap arr[i] and arr[j]\r\n        }\r\n    }\r\n    swap arr[i + 1] and arr[high])\r\n    return (i + 1)\r\n}', '2020-05-25'),
(235, 7, 2801012018, '#include<iostream>\r\n#include<ctime>\r\n#include<cstdlib>\r\nusing namespace std ;\r\nvoid shuffle(int *a,int s,int e)\r\n{\r\n	srand(time(NULL)) ;\r\n	int i,j,temp ;\r\n	for( i=e ; i>0 ; i-- )\r\n	{\r\n		j = rand()%(i+1) ;\r\n		temp = a[i] ;\r\n		a[i] = a[j] ;\r\n		a[j] = temp ;\r\n	}\r\n}\r\nint partition(int *a,int s,int e)\r\n{\r\n	int temp ;\r\n	int i = s-1 ;\r\n	int j = s ;\r\n	int pivot = a[e] ;\r\n	for( ; j<e ; j++ )\r\n	{\r\n		if( a[j]<=pivot )\r\n		{\r\n			i++ ;\r\n			temp = a[i] ;\r\n			a[i] = a[j] ;\r\n			a[j] = temp ;\r\n		}\r\n	}\r\n	temp = a[i+1] ;\r\n	a[i+1] = a[e] ;\r\n	a[e] = temp ;\r\n	return (i+1) ;\r\n}\r\nvoid RQuickSort(int *a,int s,int e)\r\n{\r\n	int p ;\r\n	if( s<e )\r\n	{\r\n		p = partition(a,s,e) ;\r\n		RQuickSort(a,s,p-1) ;\r\n		RQuickSort(a,p+1,e) ;\r\n	}\r\n}\r\nint main()\r\n{\r\n	int i,n ;\r\n	cin>>n ;\r\n	int a[n] ;\r\n	for( i=0 ; i<n ; i++ )\r\n	    cin>>a[i] ;\r\n	shuffle(a,0,n-1) ;\r\n	RQuickSort(a,0,n-1) ;\r\n	for( int i=0 ; i<n ; i++ )\r\n	    cout<<a[i]<<\" \" ;\r\n	return 0 ;\r\n}\r\n', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', '/* This function takes last element as pivot, places\r\n   the pivot element at its correct position in sorted\r\n    array, and places all smaller (smaller than pivot)\r\n   to left of pivot and all greater elements to right\r\n   of pivot */\r\npartition (arr[], low, high)\r\n{\r\n    // pivot (Element to be placed at right position)\r\n    pivot = arr[high];  \r\n \r\n    i = (low - 1)  // Index of smaller element\r\n\r\n    for (j = low; j <= high- 1; j++)\r\n    {\r\n        // If current element is smaller than the pivot\r\n        if (arr[j] < pivot)\r\n        {\r\n            i++;    // increment index of smaller element\r\n            swap arr[i] and arr[j]\r\n        }\r\n    }\r\n    swap arr[i + 1] and arr[high])\r\n    return (i + 1)\r\n}', '2020-05-25'),
(236, 2, 7601012018, 'import java.util.Scanner;\r\nclass Main\r\n{ \r\n	// Merges two subarrays of arr[]. \r\n	// First subarray is arr[l..m] \r\n	// Second subarray is arr[m+1..r] \r\n	void merge(int arr[], int l, int m, int r) \r\n	{ \r\n		// Find sizes of two subarrays to be merged \r\n		int n1 = m - l + 1; \r\n		int n2 = r - m; \r\n\r\n		/* Create temp arrays */\r\n		int L[] = new int [n1]; \r\n		int R[] = new int [n2]; \r\n\r\n		/*Copy data to temp arrays*/\r\n		for (int i=0; i<n1; ++i) \r\n			L[i] = arr[l + i]; \r\n		for (int j=0; j<n2; ++j) \r\n			R[j] = arr[m + 1+ j]; \r\n\r\n\r\n		/* Merge the temp arrays */\r\n\r\n		// Initial indexes of first and second subarrays \r\n		int i = 0, j = 0; \r\n\r\n		// Initial index of merged subarry array \r\n		int k = l; \r\n		while (i < n1 && j < n2) \r\n		{ \r\n			if (L[i] <= R[j]) \r\n			{ \r\n				arr[k] = L[i]; \r\n				i++; \r\n			} \r\n			else\r\n			{ \r\n				arr[k] = R[j]; \r\n				j++; \r\n			} \r\n			k++; \r\n		} \r\n\r\n		/* Copy remaining elements of L[] if any */\r\n		while (i < n1) \r\n		{ \r\n			arr[k] = L[i]; \r\n			i++; \r\n			k++; \r\n		} \r\n\r\n		/* Copy remaining elements of R[] if any */\r\n		while (j < n2) \r\n		{ \r\n			arr[k] = R[j]; \r\n			j++; \r\n			k++; \r\n		} \r\n	} \r\n\r\n	// Main function that sorts arr[l..r] using \r\n	// merge() \r\n	void sort(int arr[], int l, int r) \r\n	{ \r\n		if (l < r) \r\n		{ \r\n			// Find the middle point \r\n			int m = (l+r)/2; \r\n\r\n			// Sort first and second halves \r\n			sort(arr, l, m); \r\n			sort(arr , m+1, r); \r\n\r\n			// Merge the sorted halves \r\n			merge(arr, l, m, r); \r\n		} \r\n	} \r\n\r\n	// Driver method \r\n	public static void main(String args[]) \r\n	{ \r\n		int n;\r\n        Scanner s = new Scanner(System.in);\r\n        n = s.nextInt();\r\n        int arr[] = new int[n];\r\n        for(int i = 0; i < n; i++)\r\n        {\r\n            arr[i] = s.nextInt();\r\n        }\r\n\r\n		Main ob = new Main(); \r\n		ob.sort(arr, 0, arr.length-1); \r\n		for (int i = 0; i < n; i++)\r\n		{\r\n			System.out.print(arr[i]);\r\n			if(i!=n-1)\r\n			{\r\n				System.out.print(\" \");\r\n			}\r\n		}  \r\n	} \r\n}', 10, '', '', 'sdagfsgf', '2020-05-12'),
(237, 3, 7601012018, 'public class Main\r\n{\r\n	public static void main(String[] args) {\r\n		System.out.println(\"Hello World\");\r\n	}\r\n}', 2, '', 'Hello World', 'asdfhng', '2020-03-12'),
(238, 7, 1701012018, '\r\nimport java.util.*; \r\n\r\nclass Solution\r\n{ \r\n	public static int N = 5; \r\n	public static int[] arr = new int[N]; \r\n	\r\n	void random(int low,int high) \r\n	{ \r\n	\r\n		Random rand= new Random(); \r\n		int pivot = rand.nextInt(high-low) + low; \r\n		\r\n		int temp1=arr[pivot]; \r\n		arr[pivot]=arr[high]; \r\n		arr[high]=temp1; \r\n	} \r\n	\r\n	int partition(int arr[], int low, int high) \r\n	{ \r\n		\r\n		int pivot = arr[high]; \r\n	\r\n\r\n		int i = (low-1);\r\n		for (int j = low; j < high; j++) \r\n		{ \r\n		\r\n			if (arr[j] <= pivot) \r\n			{ \r\n				i++; \r\n\r\n				\r\n				int temp = arr[i]; \r\n				arr[i] = arr[j]; \r\n				arr[j] = temp; \r\n			} \r\n		} \r\n\r\n		\r\n		int temp = arr[i+1]; \r\n		arr[i+1] = arr[high]; \r\n		arr[high] = temp; \r\n\r\n		return i+1; \r\n	} \r\n\r\n	void sort(int arr[], int low, int high) \r\n	{ \r\n		if (low < high) \r\n		{ \r\n			\r\n			int pi = partition(arr, low, high); \r\n\r\n		\r\n			sort(arr, low, pi-1); \r\n			sort(arr, pi+1, high); \r\n		} \r\n	} \r\n\r\n\r\n	static void printArray(int arr[]) \r\n	{ \r\n		int n = arr.length; \r\n		for (int i = 0; i < n; ++i) \r\n			System.out.print(arr[i]+\" \"); \r\n		System.out.println(); \r\n	} \r\n\r\n\r\n	public static void main(String args[]) \r\n	{ \r\n		Scanner sc=new Scanner(System.in);\r\n		int arr[] = new int[sc.getInt()]; \r\n	    for(int i=0;i<arr.length;i++)\r\n	    {\r\n	        arr[i]=sc.getInt();\r\n	    }\r\n\r\n		RandomisedQuickSort ob = new RandomisedQuickSort(); \r\n		ob.sort(arr, 0, arr.length-1); \r\n\r\n		System.out.println(); \r\n		printArray(arr); \r\n	} \r\n} \r\n\r\n\r\n', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '', 'partition(arr[], lo, hi) \r\n    pivot = arr[hi]\r\n    i = lo     // place for swapping\r\n    for j := lo to hi – 1 do\r\n        if arr[j] <= pivot then\r\n            swap arr[i] with arr[j]\r\n            i = i + 1\r\n    swap arr[i] with arr[hi]\r\n    return i\r\n\r\npartition_r(arr[], lo, hi)\r\n    r = Random Number from lo to hi\r\n    Swap arr[r] and arr[hi]\r\n    return partition(arr, lo, hi)\r\n\r\nquicksort(arr[], lo, hi)\r\n    if lo < hi\r\n        p = partition_r(arr, lo, hi)\r\n        quicksort(arr, p-1, hi)\r\n        quicksort(arr, p+1, hi)', '0000-00-00'),
(239, 7, 101012018, 'import java.util.*; \r\n\r\nclass Solution\r\n{ \r\n	public static int N = 5; \r\n	public static int[] arr = new int[N]; \r\n	\r\n	void random(int low,int high) \r\n	{ \r\n	\r\n		Random rand= new Random(); \r\n		int pivot = rand.nextInt(high-low) + low; \r\n		\r\n		int temp1=arr[pivot]; \r\n		arr[pivot]=arr[high]; \r\n		arr[high]=temp1; \r\n	} \r\n	\r\n	int partition(int arr[], int low, int high) \r\n	{ \r\n		\r\n		int pivot = arr[high]; \r\n	\r\n\r\n		int i = (low-1);\r\n		for (int j = low; j < high; j++) \r\n		{ \r\n		\r\n			if (arr[j] <= pivot) \r\n			{ \r\n				i++; \r\n\r\n				\r\n				int temp = arr[i]; \r\n				arr[i] = arr[j]; \r\n				arr[j] = temp; \r\n			} \r\n		} \r\n\r\n		\r\n		int temp = arr[i+1]; \r\n		arr[i+1] = arr[high]; \r\n		arr[high] = temp; \r\n\r\n		return i+1; \r\n	} \r\n\r\n	void sort(int arr[], int low, int high) \r\n	{ \r\n		if (low < high) \r\n		{ \r\n			\r\n			int pi = partition(arr, low, high); \r\n\r\n		\r\n			sort(arr, low, pi-1); \r\n			sort(arr, pi+1, high); \r\n		} \r\n	} \r\n\r\n\r\n	static void printArray(int arr[]) \r\n	{ \r\n		int n = arr.length; \r\n		for (int i = 0; i < n; ++i) \r\n			System.out.print(arr[i]+\" \"); \r\n		System.out.println(); \r\n	} \r\n\r\n\r\n	public static void main(String args[]) \r\n	{ \r\n		Scanner sc=new Scanner(System.in);\r\n		int arr[] = new int[sc.getInt()]; \r\n	    for(int i=0;i<arr.length;i++)\r\n	    {\r\n	        arr[i]=sc.getInt();\r\n	    }\r\n\r\n		RandomisedQuickSort ob = new RandomisedQuickSort(); \r\n		ob.sort(arr, 0, arr.length-1); \r\n\r\n		System.out.println(); \r\n		printArray(arr); \r\n	} \r\n} ', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '', 'partition(arr[], lo, hi) \r\n    pivot = arr[hi]\r\n    i = lo     // place for swapping\r\n    for j := lo to hi – 1 do\r\n        if arr[j] <= pivot then\r\n            swap arr[i] with arr[j]\r\n            i = i + 1\r\n    swap arr[i] with arr[hi]\r\n    return i\r\n\r\npartition_r(arr[], lo, hi)\r\n    r = Random Number from lo to hi\r\n    Swap arr[r] and arr[hi]\r\n    return partition(arr, lo, hi)\r\n\r\nquicksort(arr[], lo, hi)\r\n    if lo < hi\r\n        p = partition_r(arr, lo, hi)\r\n        quicksort(arr, p-1, hi)\r\n        quicksort(arr, p+1, hi)\r\n', '0000-00-00'),
(240, 9, 2501012018, '#include <iostream> \r\nusing namespace std; \r\nclass DisjSet { \r\n	int *rank, *parent, n; \r\n\r\npublic:  \r\n	DisjSet(int n) \r\n	{ \r\n		rank = new int[n]; \r\n		parent = new int[n]; \r\n		this->n = n; \r\n		makeSet(); \r\n	} \r\n\r\n	void makeSet() \r\n	{ \r\n		for (int i = 0; i < n; i++) { \r\n			parent[i] = i; \r\n		} \r\n	} \r\n\r\n	\r\n	int find(int x) \r\n	{ \r\n	\r\n		if (parent[x] != x) { \r\n\r\n		\r\n			parent[x] = find(parent[x]); \r\n		} \r\n\r\n		return parent[x]; \r\n	} \r\n\r\n\r\n	void Union(int x, int y) \r\n	{ \r\n	\r\n		int xset = find(x); \r\n		int yset = find(y); \r\n\r\n	\r\n		if (xset == yset) \r\n			return; \r\n\r\n	\r\n		if (rank[xset] < rank[yset]) { \r\n			parent[xset] = yset; \r\n		} \r\n		else if (rank[xset] > rank[yset]) { \r\n			parent[yset] = xset; \r\n		} \r\n\r\n		else { \r\n			parent[yset] = xset; \r\n			rank[xset] = rank[xset] + 1; \r\n		} \r\n	} \r\n}; \r\n\r\nint main() \r\n{ \r\n	DisjSet obj(5); \r\n	obj.Union(0, 2); \r\n	obj.Union(4, 2); \r\n	obj.Union(3, 1); \r\n	if (obj.find(4) == obj.find(0)) \r\n		cout << \"Yes\n\"; \r\n	else\r\n		cout << \"No\n\"; \r\n	if (obj.find(1) == obj.find(0)) \r\n		cout << \"Yes\n\"; \r\n	else\r\n		cout << \"No\n\"; \r\n\r\n	return 0; \r\n} \r\n\r\n', 1000, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '', 'A disjoint-set data structure is a data structure that keeps track of a set of elements partitioned into a number of disjoint (non-overlapping) subsets. A union-find algorithm is an algorithm that performs two useful operations on such a data structure:\r\n\r\nFind: Determine which subset a particular element is in. This can be used for determining if two elements are in the same subset.\r\n\r\nUnion: Join two subsets into a single subset.', '2020-05-25'),
(241, 7, 2601012018, '#include<iostream>\r\n#include<cstdlib>\r\n#include<ctime>\r\n#define MAX 100\r\nusing namespace std;\r\nvoid random_shuffle(int arr[]) {\r\n   \r\n   srand(time(NULL));\r\n   for (int i = MAX - 1; i > 0; i--) {\r\n      int j = rand()%(i + 1);\r\n      int temp = arr[i];\r\n      arr[i] = arr[j];\r\n      arr[j] = temp;\r\n   }\r\n}\r\nint Partition(int a[], int low, int high) {\r\n   int pivot, index, i;\r\n   index = low;\r\n   pivot = high;\r\n   for(i=low; i < high; i++) {\r\n      if(a[i] < a[pivot]) {\r\n         swap(a[i], a[index]);\r\n         index++;\r\n      }\r\n   }\r\n   swap(a[pivot], a[index]);\r\n   return index;\r\n}\r\nint RandomPivotPartition(int a[], int low, int high){\r\n   \r\n   int pvt, n, temp;\r\n   n = rand();\r\n   pvt = low + n%(high-low+1); \r\n   swap(a[high], a[pvt]);\r\n   return Partition(a, low, high);\r\n}\r\nvoid quick_sort(int arr[], int p, int q) {\r\n   int pindex;\r\n   if(p < q) {\r\n      pindex = RandomPivotPartition(arr, p, q); \r\n      \r\n      quick_sort(arr, p, pindex-1);\r\n    quick_sort(arr, pindex+1, q);\r\n}\r\n}\r\nint main()\r\n {\r\n    int i;\r\n    int arr[MAX];\r\n    for (i = 0;i < MAX; i++)\r\n        arr[i] = i + 1;\r\n        random_shuffle(arr); \r\n        quick_sort(arr, 0, MAX - 1); \r\n    for (i = 0; i < MAX; i++)\r\n        cout << arr[i] << \" \";\r\n        cout << endl;\r\n    return 0;\r\n}', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \n', 'partition(arr[], lo, hi) \r\n    pivot = arr[hi]\r\n    i = lo     // place for swapping\r\n    for j := lo to hi – 1 do\r\n        if arr[j] <= pivot then\r\n            swap arr[i] with arr[j]\r\n            i = i + 1\r\n    swap arr[i] with arr[hi]\r\n    return i\r\n\r\npartition_r(arr[], lo, hi)\r\n    r = Random Number from lo to hi\r\n    Swap arr[r] and arr[hi]\r\n    return partition(arr, lo, hi)\r\n\r\nquicksort(arr[], lo, hi)\r\n    if lo < hi\r\n        p = partition_r(arr, lo, hi)\r\n        quicksort(arr, p-1, hi)\r\n        quicksort(arr, p+1, hi)\r\n ', '2020-05-24');
INSERT INTO `qtos_map` (`ID`, `Q_ID`, `ROLL`, `SUBMISSION`, `SCORE`, `INPUT`, `OP`, `ALGO`, `DATE`) VALUES
(242, 8, 2601012018, '// CPP program to implement Strassen’s Matrix  \r\n// Multiplication Algorithm  \r\n#include<iostream>\r\n#include<conio.h>\r\n#include<stdio.h>\r\nusing namespace std; \r\ntypedef long long lld; \r\ninline lld** MatrixMultiply(lld** a, lld** b, int n, \r\n                                      int l, int m) \r\n{ \r\n    lld** c = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        c[i] = new lld[m]; \r\n  \r\n    for (int i = 0; i < n; i++) { \r\n        for (int j = 0; j < m; j++) { \r\n            c[i][j] = 0; \r\n            for (int k = 0; k < l; k++) { \r\n                c[i][j] += a[i][k] * b[k][j]; \r\n            } \r\n        } \r\n    } \r\n    return c; \r\n} \r\n  \r\ninline lld** Strassen(lld** a, lld** b, int n,  \r\n                                int l, int m) \r\n{ \r\n    if (n == 1 || l == 1 || m == 1)  \r\n        return MatrixMultiply(a, b, n, l, m); \r\n  \r\n    lld** c = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        c[i] = new lld[m]; \r\n  \r\n    int adjN = (n >> 1) + (n & 1); \r\n    int adjL = (l >> 1) + (l & 1); \r\n    int adjM = (m >> 1) + (m & 1); \r\n  \r\n    lld**** As = new lld***[2]; \r\n    for (int x = 0; x < 2; x++) { \r\n        As[x] = new lld**[2]; \r\n        for (int y = 0; y < 2; y++) { \r\n            As[x][y] = new lld*[adjN]; \r\n            for (int i = 0; i < adjN; i++) { \r\n                As[x][y][i] = new lld[adjL]; \r\n                for (int j = 0; j < adjL; j++) { \r\n                    int I = i + (x & 1) * adjN; \r\n                    int J = j + (y & 1) * adjL; \r\n                    As[x][y][i][j] = (I < n && J < l) ? a[I][J] : 0; \r\n                } \r\n            } \r\n        } \r\n    } \r\n  \r\n    lld**** Bs = new lld***[2]; \r\n    for (int x = 0; x < 2; x++) { \r\n        Bs[x] = new lld**[2]; \r\n        for (int y = 0; y < 2; y++) { \r\n            Bs[x][y] = new lld*[adjN]; \r\n            for (int i = 0; i < adjL; i++) { \r\n                Bs[x][y][i] = new lld[adjM]; \r\n                for (int j = 0; j < adjM; j++) { \r\n                    int I = i + (x & 1) * adjL; \r\n                    int J = j + (y & 1) * adjM; \r\n                    Bs[x][y][i][j] = (I < l && J < m) ? b[I][J] : 0; \r\n                } \r\n            } \r\n        } \r\n    } \r\n  \r\n    lld*** s = new lld**[10]; \r\n    for (int i = 0; i < 10; i++) { \r\n        switch (i) { \r\n        case 0: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][1][j][k] - Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 1: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] + As[0][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 2: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[1][0][j][k] + As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 3: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[1][0][j][k] - Bs[0][0][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 4: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] + As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 5: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 6: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][1][j][k] - As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 7: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[1][0][j][k] + Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 8: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] - As[1][0][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 9: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[0][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        } \r\n    } \r\n  \r\n    lld*** p = new lld**[7]; \r\n    p[0] = Strassen(As[0][0], s[0], adjN, adjL, adjM); \r\n    p[1] = Strassen(s[1], Bs[1][1], adjN, adjL, adjM); \r\n    p[2] = Strassen(s[2], Bs[0][0], adjN, adjL, adjM); \r\n    p[3] = Strassen(As[1][1], s[3], adjN, adjL, adjM); \r\n    p[4] = Strassen(s[4], s[5], adjN, adjL, adjM); \r\n    p[5] = Strassen(s[6], s[7], adjN, adjL, adjM); \r\n    p[6] = Strassen(s[8], s[9], adjN, adjL, adjM); \r\n  \r\n    for (int i = 0; i < adjN; i++) { \r\n        for (int j = 0; j < adjM; j++) { \r\n            c[i][j] = p[4][i][j] + p[3][i][j] - p[1][i][j] + p[5][i][j]; \r\n            if (j + adjM < m) \r\n                c[i][j + adjM] = p[0][i][j] + p[1][i][j]; \r\n            if (i + adjN < n) \r\n                c[i + adjN][j] = p[2][i][j] + p[3][i][j]; \r\n            if (i + adjN < n && j + adjM < m) \r\n                c[i + adjN][j + adjM] = p[4][i][j] + p[0][i][j] - p[2][i][j] - p[6][i][j]; \r\n        } \r\n    } \r\n  \r\n    for (int x = 0; x < 2; x++) { \r\n        for (int y = 0; y < 2; y++) { \r\n            for (int i = 0; i < adjN; i++) { \r\n                delete[] As[x][y][i]; \r\n            } \r\n            delete[] As[x][y]; \r\n        } \r\n        delete[] As[x]; \r\n    } \r\n    delete[] As; \r\n  \r\n    for (int x = 0; x < 2; x++) { \r\n        for (int y = 0; y < 2; y++) { \r\n            for (int i = 0; i < adjL; i++) { \r\n                delete[] Bs[x][y][i]; \r\n            } \r\n            delete[] Bs[x][y]; \r\n        } \r\n        delete[] Bs[x]; \r\n    } \r\n    delete[] Bs; \r\n  \r\n    for (int i = 0; i < 10; i++) { \r\n        switch (i) { \r\n        case 0: \r\n        case 3: \r\n        case 5: \r\n        case 7: \r\n        case 9: \r\n            for (int j = 0; j < adjL; j++) { \r\n                delete[] s[i][j]; \r\n            } \r\n            break; \r\n        case 1: \r\n        case 2: \r\n        case 4: \r\n        case 6: \r\n        case 8: \r\n            for (int j = 0; j < adjN; j++) { \r\n                delete[] s[i][j]; \r\n            } \r\n            break; \r\n        } \r\n        delete[] s[i]; \r\n    } \r\n    delete[] s; \r\n  \r\n    for (int i = 0; i < 7; i++) { \r\n        for (int j = 0; j < (n >> 1); j++) { \r\n            delete[] p[i][j]; \r\n        } \r\n        delete[] p[i]; \r\n    } \r\n    delete[] p; \r\n  \r\n    return c; \r\n} \r\n  \r\nint main() \r\n{ \r\n    lld** matA; \r\n    matA = new lld*[2]; \r\n    for (int i = 0; i < 2; i++) \r\n        matA[i] = new lld[3]; \r\n    matA[0][0] = 1; \r\n    matA[0][1] = 2; \r\n    matA[0][2] = 3; \r\n    matA[1][0] = 4; \r\n    matA[1][1] = 5; \r\n    matA[1][2] = 6; \r\n  \r\n    lld** matB; \r\n    matB = new lld*[3]; \r\n    for (int i = 0; i < 3; i++) \r\n        matB[i] = new lld[2]; \r\n    matB[0][0] = 7; \r\n    matB[0][1] = 8; \r\n    matB[1][0] = 9; \r\n    matB[1][1] = 10; \r\n    matB[2][0] = 11; \r\n    matB[2][1] = 12; \r\n  \r\n    lld** matC = Strassen(matA, matB, 2, 3, 2); \r\n    for (int i = 0; i < 2; i++) { \r\n        for (int j = 0; j < 2; j++) { \r\n            printf(\"%lld \", matC[i][j]); \r\n        } \r\n        printf(\"\n\"); \r\n    } \r\n  \r\n    return 0; \r\n} ', 0, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '58 64 \n139 154 \n', 'void multiply(int A[][N], int B[][N], int C[][N]) \r\n{ \r\n    for (int i = 0; i < N; i++) \r\n    { \r\n        for (int j = 0; j < N; j++) \r\n        { \r\n            C[i][j] = 0; \r\n            for (int k = 0; k < N; k++) \r\n            { \r\n                C[i][j] += A[i][k]*B[k][j]; \r\n            } \r\n        } \r\n    } \r\n} ', '2020-05-24'),
(243, 10, 3201012018, '#include <iostream>\r\n#include <climits>\r\nusing namespace std;\r\nint knapSack(int v[], int w[], int n, int W) {\r\n   if (W < 0)\r\n      return INT_MIN;\r\n   if (n < 0 || W == 0)\r\n      return 0;\r\n   int in = v[n] + knapSack(v, w, n - 1, W - w[n]);\r\n   int ex = knapSack(v, w, n - 1, W);\r\n   return max (in, ex);\r\n}\r\nint main() {\r\n   int v[] = { 10, 20, 30, 40, 60, 70 };\r\n   int w[] = { 1, 2, 3, 6, 7, 4 };\r\n   int W = 7;\r\n   int n = sizeof(v) / sizeof(v[0]);\r\n   cout << \"Knapsack value is \" << knapSack(v, w, n - 1, W);\r\n   return 0;\r\n}', 0, '5 15 4 2 1 2 10 12 2 1 1 4', 'Knapsack value is 100', 'aaa', '0000-00-00'),
(244, 2, 2601012018, '#include<stdlib.h> \r\n#include<stdio.h> \r\n  \r\nvoid merge(int arr[], int l, int m, int r) \r\n{ \r\n    int i, j, k; \r\n    int n1 = m - l + 1; \r\n    int n2 =  r - m; \r\n  \r\n    \r\n    int L[n1], R[n2]; \r\n  \r\n    \r\n    for (i = 0; i < n1; i++) \r\n        L[i] = arr[l + i]; \r\n    for (j = 0; j < n2; j++) \r\n        R[j] = arr[m + 1+ j]; \r\n    i = 0; \r\n    j = 0; \r\n    k = l; \r\n    while (i < n1 && j < n2) \r\n    { \r\n        if (L[i] <= R[j]) \r\n        { \r\n            arr[k] = L[i]; \r\n            i++; \r\n        } \r\n        else\r\n        { \r\n            arr[k] = R[j]; \r\n            j++; \r\n        } \r\n        k++; \r\n    } \r\n\r\n    while (i < n1) \r\n    { \r\n        arr[k] = L[i]; \r\n        i++; \r\n        k++; \r\n    } \r\n  \r\n   \r\n    while (j < n2) \r\n    { \r\n        arr[k] = R[j]; \r\n        j++; \r\n        k++; \r\n    } \r\n} \r\n  \r\nvoid mergeSort(int arr[], int l, int r) \r\n{ \r\n    if (l < r) \r\n    { \r\n        // Same as (l+r)/2, but avoids overflow for \r\n        // large l and h \r\n        int m = l+(r-l)/2; \r\n  \r\n        // Sort first and second halves \r\n        mergeSort(arr, l, m); \r\n        mergeSort(arr, m+1, r); \r\n  \r\n        merge(arr, l, m, r); \r\n    } \r\n} \r\nvoid printArray(int A[], int size) \r\n{ \r\n    int i; \r\n    for (i=0; i < size; i++) \r\n        printf(\"%d \", A[i]); \r\n    printf(\"\n\"); \r\n} \r\n  \r\nint main() \r\n{ \r\n  \r\nint t;\r\ncin>>t;\r\nwhile(t!=0){\r\nint n;\r\ncin>>n;\r\nint a[n];\r\nfor(int i=0;i<n;i++){\r\ncin>>a[i];\r\n}\r\n    printf(\"Given array is \n\"); \r\n    printArray(arr, arr_size); \r\n  \r\n    mergeSort(a, 0, n - 1); \r\n  \r\n    printf(\"\nSorted array is \n\"); \r\n    printArray(a, n); \r\n    return 0; \r\n\r\nt--;\r\ncout<<endl;\r\n}\r\n} ', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '', 'MergeSort(arr[], l,  r)\r\nIf r > l\r\n     1. Find the middle point to divide the array into two halves:  \r\n             middle m = (l+r)/2\r\n     2. Call mergeSort for first half:   \r\n             Call mergeSort(arr, l, m)\r\n     3. Call mergeSort for second half:\r\n             Call mergeSort(arr, m+1, r)\r\n     4. Merge the two halves sorted in step 2 and 3:\r\n             Call merge(arr, l, m, r)', '2020-05-25'),
(245, 11, 101012018, '0', 10, '8 a b c d e f g h 1 1 2 3 5 8 13 21', '', 'aaa', '0000-00-00'),
(246, 3, 2601012018, '/* C implementation QuickSort */\r\n#include<iostream>\r\nusing namespace std;\r\n  \r\n// A utility function to swap two elements \r\nvoid swap(int* a, int* b) \r\n{ \r\n    int t = *a; \r\n    *a = *b; \r\n    *b = t; \r\n} \r\n  \r\n/* This function takes last element as pivot, places \r\n   the pivot element at its correct position in sorted \r\n    array, and places all smaller (smaller than pivot) \r\n   to left of pivot and all greater elements to right \r\n   of pivot */\r\nint partition (int arr[], int low, int high) \r\n{ \r\n    int pivot = arr[high];    // pivot \r\n    int i = (low - 1);  // Index of smaller element \r\n  \r\n    for (int j = low; j <= high- 1; j++) \r\n    { \r\n        // If current element is smaller than the pivot \r\n        if (arr[j] < pivot) \r\n        { \r\n            i++;    // increment index of smaller element \r\n            swap(&arr[i], &arr[j]); \r\n        } \r\n    } \r\n    swap(&arr[i + 1], &arr[high]); \r\n    return (i + 1); \r\n} \r\n  \r\n/* The main function that implements QuickSort \r\n arr[] --> Array to be sorted, \r\n  low  --> Starting index, \r\n  high  --> Ending index */\r\nvoid quickSort(int arr[], int low, int high) \r\n{ \r\n    if (low < high) \r\n    { \r\n        /* pi is partitioning index, arr[p] is now \r\n           at right place */\r\n        int pi = partition(arr, low, high); \r\n  \r\n        // Separately sort elements before \r\n        // partition and after partition \r\n        quickSort(arr, low, pi - 1); \r\n        quickSort(arr, pi + 1, high); \r\n    } \r\n} \r\n  \r\n/* Function to print an array */\r\nvoid printArray(int arr[], int size) \r\n{ \r\n    int i; \r\n    for (i=0; i < size; i++) \r\n    cout<<arr[i]<<\" \";\r\n} \r\n  \r\n// Driver program to test above functions \r\nint main() \r\n{ \r\n    int n;\r\n    cin>>n;\r\n    int arr[n];\r\n    for(int i=0;i<n;i++)\r\n    cin>>arr[i];\r\n    quickSort(arr, 0, n-1); \r\n    printArray(arr, n); \r\n    return 0; \r\n} ', 10, '1 2000', '2000 ', 'quickSort(arr[], low, high)\r\n{\r\n    if (low < high)\r\n    {\r\n        /* pi is partitioning index, arr[pi] is now\r\n           at right place */\r\n        pi = partition(arr, low, high);\r\n\r\n        quickSort(arr, low, pi - 1);  // Before pi\r\n        quickSort(arr, pi + 1, high); // After pi\r\n    }\r\n}', '0000-00-00'),
(247, 3, 1701012018, 'import java.util.Scanner;\r\n\r\npublic class Main {\r\n\r\npublic static Scanner s = new Scanner(System.in);\r\n\r\n	public static void quickSort(int[] arr, int start, int end) {\r\n		if (start >= end)\r\n			return;\r\n		int partitionIndex = partitionQuickSort(arr, start, end);\r\n		quickSort(arr, start, partitionIndex - 1);\r\n		quickSort(arr, partitionIndex + 1, end);\r\n	}\r\n\r\n	public static int partitionQuickSort(int[] arr, int start, int end) {\r\n		int pivotElement = arr[start];\r\n		int count = 0;\r\n		for (int i = start; i <= end; i++) {\r\n			if (arr[i] < pivotElement) {\r\n				count++;\r\n			}\r\n		}\r\n		int pivotPosition = start + count;\r\n		int temp = arr[start];\r\n		arr[start] = arr[pivotPosition];\r\n		arr[pivotPosition] = temp;\r\n		int i = start, j = end;\r\n		while (i < pivotPosition && j > pivotPosition) {\r\n			if (arr[i] < pivotElement)\r\n				i++;\r\n			else if (arr[j] >= pivotElement)\r\n				j--;\r\n			else {\r\n				int tempVar = arr[i];\r\n				arr[i] = arr[j];\r\n				arr[j] = tempVar;\r\n				i++;\r\n				j--;\r\n			}\r\n\r\n		}\r\n		return pivotPosition;\r\n	}\r\n\r\n	public static int[] takeInput() {\r\n		int n = s.nextInt();\r\n		int[] arr = new int[n];\r\n		for (int i = 0; i < n; i++) {\r\n			arr[i] = s.nextInt();\r\n		}\r\n		return arr;\r\n	}\r\n\r\n	public static void printArray(int[] arr) {\r\n		for (int i = 0; i < arr.length; i++) {\r\n			System.out.print(arr[i] + \" \");\r\n		}\r\n	}\r\n\r\n	public static void main(String[] args) {\r\n		int[] arr = takeInput();\r\n		quickSort(arr, 0, arr.length - 1);\r\n		printArray(arr);\r\n	}\r\n}\r\n\r\n', 10, '1 2000', '', 'quickSort(arr[], low, high)\r\n{\r\n    if (low < high)\r\n    {\r\n       \r\n        pi = partition(arr, low, high);\r\n\r\n        quickSort(arr, low, pi - 1);  \r\n        quickSort(arr, pi + 1, high); \r\n    }\r\n}\r\npartition (arr[], low, high)\r\n{\r\n   \r\n    pivot = arr[high];  \r\n \r\n    i = (low - 1)  // Index of smaller element\r\n\r\n    for (j = low; j <= high- 1; j++)\r\n    {\r\n       \r\n        if (arr[j] < pivot)\r\n        {\r\n            i++;    // increment index of smaller element\r\n            swap arr[i] and arr[j]\r\n        }\r\n    }\r\n    swap arr[i + 1] and arr[high])\r\n    return (i + 1)\r\n}', '0000-00-00'),
(248, 8, 3601012018, '#include<iostream.h>\r\n#include<conio.h>\r\nvoid main()\r\n{\r\n	clrscr();\r\n	int n,mat1[n][n], mat2[n][n], mat3[n][n], sum=0, i, j, k;\r\n	\r\n	cin>>n;\r\n	\r\n	for(i=0; i<n; i++)\r\n	{\r\n		for(j=0; j<n; j++)\r\n		{\r\n			cin>>mat1[i][j];\r\n		}\r\n	}\r\n	\r\n	for(i=0; i<n; i++)\r\n	{\r\n		for(j=0; j<n; j++)\r\n		{\r\n			cin>>mat2[i][j];\r\n		}\r\n	}\r\n\r\n	for(i=0; i<n; i++)\r\n	{\r\n		for(j=0; j<n; j++)\r\n		{\r\n			sum=0;\r\n			for(k=0; k<n; k++)\r\n			{\r\n				sum = sum + mat1[i][k] * mat2[k][j];\r\n			}\r\n			mat3[i][j] = sum;\r\n		}\r\n	}\r\n\r\n	for(i=0; i<n; i++)\r\n	{\r\n		for(j=0; j<n; j++)\r\n		{\r\n			cout<<mat3[i][j]<<\" \";\r\n		}\r\n		cout<<\" \";\r\n	}\r\n	getch();\r\n}', 10, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '', 'aaa', '0000-00-00'),
(249, 10, 1701012018, 'class Knapsack \r\n{ \r\n\r\n	static int max(int a, int b) { return (a > b)? a : b; } \r\n	\r\n	static int knapSack(int W, int wt[], int val[], int n) \r\n	{ \r\n		\r\n	if (n == 0 || W == 0) \r\n		return 0; \r\n	\r\n	\r\n	if (wt[n-1] > W) \r\n	return knapSack(W, wt, val, n-1); \r\n	\r\n	\r\n	else return max( val[n-1] + knapSack(W-wt[n-1], wt, val, n-1), \r\n					knapSack(W, wt, val, n-1) \r\n					); \r\n	} \r\n\r\n	\r\n\r\npublic static void main(String args[]) \r\n{ \r\n	Scanner sc=new Scanner(System.in);\r\n	int n = sc.getInt(); \r\n	int W = sc.getInt();\r\n	int val[] = new int[3]; \r\n	for(int i=0;i<val.length;i++)\r\n	    val[i]=sc.getInt();\r\n	int wt[] = new int[3]; \r\n	for(int i=0;i<wt.length;i++)\r\n	    wt[i]=sc.getInt();\r\n	\r\n	System.out.println(knapSack(W, wt, val, n)); \r\n	} \r\n} \r\n\r\n', 10, '5 15 4 2 1 2 10 12 2 1 1 4', '', 'aaa', '0000-00-00'),
(250, 10, 2601012018, '/* A Naive recursive implementation of 0-1 Knapsack problem */\r\n#include<stdio.h> \r\n  \r\n// A utility function that returns maximum of two integers \r\nint max(int a, int b) { return (a > b)? a : b; } \r\n  \r\n// Returns the maximum value that can be put in a knapsack of capacity W \r\nint knapSack(int W, int wt[], int val[], int n) \r\n{ \r\n   // Base Case \r\n   if (n == 0 || W == 0) \r\n       return 0; \r\n  \r\n   // If weight of the nth item is more than Knapsack capacity W, then \r\n   // this item cannot be included in the optimal solution \r\n   if (wt[n-1] > W) \r\n       return knapSack(W, wt, val, n-1); \r\n  \r\n   // Return the maximum of two cases:  \r\n   // (1) nth item included  \r\n   // (2) not included \r\n   else return max( val[n-1] + knapSack(W-wt[n-1], wt, val, n-1), \r\n                    knapSack(W, wt, val, n-1) \r\n                  ); \r\n} \r\n  \r\n// Driver program to test above function \r\nint main() \r\n{ \r\n    int val[] = {60, 100, 120}; \r\n    int wt[] = {10, 20, 30}; \r\n    int  W = 50; \r\n    int n = sizeof(val)/sizeof(val[0]); \r\n    printf(\"%d\", knapSack(W, wt, val, n)); \r\n    return 0; \r\n} ', 2, '5 15 4 2 1 2 10 12 2 1 1 4', '220', 'Fractional Knapsack (Array W, Array V, int M)\r\n1. for i <- 1 to size (V)\r\n2. 	calculate cost[i] <- V[i] / W[i]\r\n3. Sort-Descending (cost)\r\n4. i ← 1\r\n5. while (i <= size(V))\r\n6. 	if  W[i] <= M \r\n7.		M ← M – W[i]\r\n8.		total ← total + V[i];\r\n9. 	if  W[i] > M\r\n10. 		i ← i+1', '0000-00-00'),
(251, 11, 1701012018, '0', 10, '8 a b c d e f g h 1 1 2 3 5 8 13 21', '', 'aaa', '0000-00-00'),
(252, 3, 3501012018, '#include<stdio.h> \r\n  \r\nvoid swap(int* a, int* b) \r\n{ \r\n    int t = *a; \r\n    *a = *b; \r\n    *b = t; \r\n} \r\n  \r\nint partition (int arr[], int low, int high) \r\n{ \r\n    int pivot = arr[high];     \r\n    int i = (low - 1);  \r\n  \r\n    for (int j = low; j <= high- 1; j++) \r\n    { \r\n        if (arr[j] < pivot) \r\n        { \r\n            i++;    \r\n            swap(&arr[i], &arr[j]); \r\n        } \r\n    } \r\n    swap(&arr[i + 1], &arr[high]); \r\n    return (i + 1); \r\n} \r\n  \r\nvoid quickSort(int arr[], int low, int high) \r\n{ \r\n    if (low < high) \r\n    { \r\n        int pi = partition(arr, low, high); \r\n  \r\n        quickSort(arr, low, pi - 1); \r\n        quickSort(arr, pi + 1, high); \r\n    } \r\n} \r\n  \r\nvoid printArray(int arr[], int size) \r\n{ \r\n    int i; \r\n    for (i=0; i < size; i++) \r\n        printf(\"%d \", arr[i]); \r\n} \r\n  \r\nint main() \r\n{  \r\n    int n;\r\n    scanf(\"%d\",&n);\r\n    int i,arr[n];\r\n    for(i=0;i<n;i++)\r\n        scanf(\"%d\",&arr[i]); \r\n    quickSort(arr, 0, n-1);  \r\n    printArray(arr, n); \r\n    return 0; \r\n}', 10, '1 2000', '2000 ', 'quickSort(array, leftmostIndex, rightmostIndex)\r\n  if (leftmostIndex < rightmostIndex)\r\n    pivotIndex <- partition(array,leftmostIndex, rightmostIndex)\r\n    quickSort(array, leftmostIndex, pivotIndex)\r\n    quickSort(array, pivotIndex + 1, rightmostIndex)\r\n\r\npartition(array, leftmostIndex, rightmostIndex)\r\n  set rightmostIndex as pivotIndex\r\n  storeIndex <- leftmostIndex - 1\r\n  for i <- leftmostIndex + 1 to rightmostIndex\r\n  if element[i] < pivotElement\r\n    swap element[i] and element[storeIndex]\r\n    storeIndex++\r\n  swap pivotElement and element[storeIndex+1]\r\nreturn storeIndex + 1', '2020-05-25'),
(253, 7, 3501012018, '#include <cstdlib> \r\n#include <stdio.h>\r\n#include <iostream> \r\nusing namespace std; \r\n  \r\nint partition(int arr[], int start, int end) \r\n{ \r\n    int pivot = arr[end]; \r\n    int i = (start - 1); \r\n  \r\n    for (int j = start; j <= end - 1; j++) { \r\n  \r\n        if (arr[j] <= pivot) { \r\n  \r\n            i++; \r\n            swap(arr[i], arr[j]); \r\n        } \r\n    } \r\n    swap(arr[i + 1], arr[end]); \r\n    return (i + 1); \r\n} \r\n  \r\nint random_partition(int arr[], int start, int end) \r\n{ \r\n   \r\n    int random = start + rand() % (end - start); \r\n  \r\n    swap(arr[random], arr[end]); \r\n  \r\n    return partition(arr, start, end); \r\n} \r\n  \r\nvoid quickSort(int arr[], int start, int end) \r\n{ \r\n    if (start < end) { \r\n  \r\n        int pi = random_partition(arr, start, end); \r\n  \r\n        quickSort(arr, start, pi - 1); \r\n        quickSort(arr, pi + 1, end); \r\n    } \r\n} \r\n  \r\nvoid printArray(int arr[], int size) \r\n{ \r\n    for (int i = 0; i < size; i++){ \r\n 	 cout<<arr[i]<<endl; \r\n    }\r\n   \r\n} \r\n  \r\nint main() \r\n{ \r\n    \r\n    int n;\r\n    cin >> n; \r\n    int arr[n];\r\n    for (int i = 0; i < n; ++i){\r\n	 cin >> arr[i];\r\n    }\r\n    quickSort(arr, 0, n - 1); \r\n    printArray(arr, n);   \r\n} ', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0\n1\n4\n5\n6\n6\n8\n8\n8\n9\n9\n1000\n14000\n', 'partition(arr[], lo, hi) \r\n    pivot = arr[hi]\r\n    i = lo     // place for swapping\r\n    for j := lo to hi – 1 do\r\n        if arr[j] <= pivot then\r\n            swap arr[i] with arr[j]\r\n            i = i + 1\r\n    swap arr[i] with arr[hi]\r\n    return i\r\n\r\npartition_r(arr[], lo, hi)\r\n    r = Random Number from lo to hi\r\n    Swap arr[r] and arr[hi]\r\n    return partition(arr, lo, hi)\r\n\r\nquicksort(arr[], lo, hi)\r\n    if lo < hi\r\n        p = partition_r(arr, lo, hi)\r\n        quicksort(arr, p-1, hi)\r\n        quicksort(arr, p+1, hi)\r\n ', '2020-05-25'),
(254, 10, 2501012018, '#include <bits/stdc++.h> \r\n  \r\nusing namespace std; \r\n  \r\nstruct Item \r\n{ \r\n    int value, weight; \r\n    Item(int value, int weight) : value(value), weight(weight) \r\n    {} \r\n}; \r\n  \r\n\r\nbool cmp(struct Item a, struct Item b) \r\n{ \r\n    double r1 = (double)a.value / a.weight; \r\n    double r2 = (double)b.value / b.weight; \r\n    return r1 > r2; \r\n} \r\n\r\ndouble fractionalKnapsack(int W, struct Item arr[], int n) \r\n{ \r\n    sort(arr, arr + n, cmp); \r\n    for (int i = 0; i < n; i++) \r\n    { \r\n        cout << arr[i].value << \"  \" << arr[i].weight << \" : \" \r\n             << ((double)arr[i].value / arr[i].weight) << endl; \r\n    } \r\n    \r\n  \r\n    int curWeight = 0;  \r\n    double finalvalue = 0.0; \r\n\r\n    for (int i = 0; i < n; i++) \r\n    { \r\n        if (curWeight + arr[i].weight <= W) \r\n        { \r\n            curWeight += arr[i].weight; \r\n            finalvalue += arr[i].value; \r\n        } \r\n        else\r\n        { \r\n            int remain = W - curWeight; \r\n            finalvalue += arr[i].value * ((double) remain / arr[i].weight); \r\n            break; \r\n        } \r\n    } \r\n    return finalvalue; \r\n} \r\nint main() \r\n{ \r\n   int t;\r\ncin>>t;\r\nwhile(t!=0){\r\nint w,n;\r\ncin>>w>>n;\r\nItem arr[n];\r\nfor(int i=0;i<n;i++){\r\ncin>>arr[i].value;\r\ncin>>arr[i].weight;\r\n}\r\n\r\n    cout << fractionalKnapsack(w, arr, n)<<endl; \r\nt--;\r\n}\r\n    return 0; \r\n} ', 0, '5 15 4 2 1 2 10 12 2 1 1 4', '', 'Approach: A simple solution is to consider all subsets of items and calculate the total weight and value of all subsets. Consider the only subsets whose total weight is smaller than W. From all such subsets, pick the maximum value subset.\r\nOptimal Sub-structure: To consider all subsets of items, there can be two cases for every item.\r\n\r\nCase 1: The item is included in the optimal subset.\r\nCase 2: The item is not included in the optimal set.\r\nTherefore, the maximum value that can be obtained from ‘n’ items is the max of the following two values.\r\n\r\n1.Maximum value obtained by n-1 items and W weight (excluding nth item).\r\n2.Value of nth item plus maximum value obtained by n-1 items and W minus the weight of the nth item (including nth item).\r\nIf the weight of ‘nth’ item is greater than ‘W’, then the nth item cannot be included and Case 1 is the only possibility.', '2020-05-25'),
(255, 2, 801012018, '#include<stdlib.h> \r\n#include<stdio.h> \r\n#include<iostream>\r\nusing namespace std;\r\n\r\nvoid merge(int arr[], int l, int m, int r) \r\n{ \r\n    int i, j, k; \r\n    int n1 = m - l + 1; \r\n    int n2 =  r - m; \r\n  \r\n    int L[n1], R[n2]; \r\n  \r\n    for (i = 0; i < n1; i++) \r\n        L[i] = arr[l + i]; \r\n    for (j = 0; j < n2; j++) \r\n        R[j] = arr[m + 1+ j]; \r\n  \r\n    \r\n    i = 0; \r\n    j = 0;\r\n    k = l; \r\n    while (i < n1 && j < n2) \r\n    { \r\n        if (L[i] <= R[j]) \r\n        { \r\n            arr[k] = L[i]; \r\n            i++; \r\n        } \r\n        else\r\n        { \r\n            arr[k] = R[j]; \r\n            j++; \r\n        } \r\n        k++; \r\n    } \r\n  \r\n    while (i < n1) \r\n    { \r\n        arr[k] = L[i]; \r\n        i++; \r\n        k++; \r\n    } \r\n    while (j < n2) \r\n    { \r\n        arr[k] = R[j]; \r\n        j++; \r\n        k++; \r\n    } \r\n} \r\n  \r\nvoid mergeSort(int arr[], int l, int r) \r\n{ \r\n    if (l < r) \r\n    { \r\n        int m = l+(r-l)/2; \r\n  \r\n        mergeSort(arr, l, m); \r\n        mergeSort(arr, m+1, r); \r\n  \r\n        merge(arr, l, m, r); \r\n    } \r\n} \r\n\r\nvoid printArray(int A[], int size) \r\n{ \r\n    int i; \r\n    for (i=0; i < size; i++) \r\n        printf(\"%d \", A[i]); \r\n    printf(\"\r\n\"); \r\n} \r\n\r\nint main() \r\n{ \r\n    int n;\r\n    cin>>n;\r\n    int arr[n]; \r\n    for(int i =0; i<n; i++){\r\n        cin>>arr[i];\r\n    }\r\n  \r\n    mergeSort(arr, 0, n - 1); \r\n  \r\n    printArray(arr, n); \r\n    return 0; \r\n} ', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '', 'procedure mergesort( var a as array )\r\n   if ( n == 1 ) return a\r\n\r\n   var l1 as array = a[0] ... a[n/2]\r\n   var l2 as array = a[n/2+1] ... a[n]\r\n\r\n   l1 = mergesort( l1 )\r\n   l2 = mergesort( l2 )\r\n\r\n   return merge( l1, l2 )\r\nend procedure\r\n\r\nprocedure merge( var a as array, var b as array )\r\n\r\n   var c as array\r\n   while ( a and b have elements )\r\n      if ( a[0] > b[0] )\r\n         add b[0] to the end of c\r\n         remove b[0] from b\r\n      else\r\n         add a[0] to the end of c\r\n         remove a[0] from a\r\n      end if\r\n   end while\r\n   \r\n   while ( a has elements )\r\n      add a[0] to the end of c\r\n      remove a[0] from a\r\n   end while\r\n   \r\n   while ( b has elements )\r\n      add b[0] to the end of c\r\n      remove b[0] from b\r\n   end while\r\n   \r\n   return c\r\n	\r\nend procedure', '0000-00-00'),
(256, 3, 801012018, '#include <bits/stdc++.h> \r\nusing namespace std;  \r\n  \r\nvoid swap(int* a, int* b)  \r\n{  \r\n    int t = *a;  \r\n    *a = *b;  \r\n    *b = t;  \r\n}  \r\n\r\nint partition (int arr[], int low, int high)  \r\n{  \r\n    int pivot = arr[high];  \r\n    int i = (low - 1);  \r\n  \r\n    for (int j = low; j <= high - 1; j++)  \r\n    {  \r\n        if (arr[j] < pivot)  \r\n        {  \r\n            i++; \r\n            swap(&arr[i], &arr[j]);  \r\n        }  \r\n    }  \r\n    swap(&arr[i + 1], &arr[high]);  \r\n    return (i + 1);  \r\n}  \r\n  \r\nvoid quickSort(int arr[], int low, int high)  \r\n{  \r\n    if (low < high)  \r\n    {  \r\n        int pi = partition(arr, low, high);  \r\n  \r\n        quickSort(arr, low, pi - 1);  \r\n        quickSort(arr, pi + 1, high);  \r\n    }  \r\n}  \r\n  \r\nvoid printArray(int arr[], int size)  \r\n{  \r\n    int i;  \r\n    for (i = 0; i < size; i++)  \r\n        cout << arr[i] << \" \";  \r\n    cout << endl;  \r\n}  \r\n  \r\nint main()  \r\n{  int n;\r\ncin>>n;\r\n    int arr[n];  \r\n    for(int i=0;i<n;i++){\r\n        cin>>arr[i];\r\n    }\r\n    quickSort(arr, 0, n - 1);\r\n    printArray(arr, n);  \r\n    return 0;  \r\n}  ', 10, '1 2000', '', 'aaa', '0000-00-00'),
(257, 10, 1401012018, '#include <iostream.h>\r\nusing namespace std;\r\nint max(int x, int y) {\r\n   return (x > y) ? x : y;\r\n}\r\nint knapSack(int W, int w[], int v[], int n) {\r\n   int i, wt;\r\n   int K[n + 1][W + 1];\r\n   for (i = 0; i <= n; i++) {\r\n      for (wt = 0; wt <= W; wt++) {\r\n         if (i == 0 || wt == 0)\r\n         K[i][wt] = 0;\r\n         else if (w[i - 1] <= wt)\r\n            K[i][wt] = max(v[i - 1] + K[i - 1][wt - w[i - 1]], K[i - 1][wt]);\r\n         else\r\n        K[i][wt] = K[i - 1][wt];\r\n      }\r\n   }\r\n   return K[n][W];\r\n}\r\nint main() {\r\n   cout << \"Enter the number of items in a Knapsack:\";\r\n   int n, W;\r\n   cin >> n;\r\n   int v[n], w[n];\r\n   for (int i = 0; i < n; i++) {\r\n      cout << \"Enter value and weight for item \" << i << \":\";\r\n      cin >> v[i];\r\n      cin >> w[i];\r\n   }\r\n   cout << \"Enter the capacity of knapsack\";\r\n   cin >> W;\r\n   cout << knapSack(W, w, v, n);\r\n   return 0;\r\n}', 10, '5 15 4 2 1 2 10 12 2 1 1 4', '', 'aaa', '0000-00-00'),
(258, 10, 2401012018, '#include<iostream>\r\n\n#include<stdio.h>\r\n \n\n// function that returns maximum of two integers\r\n \nint max(int a, int b)\r\n {\r\n    return (a > b)? a : b;\r\n }\r\n \n\n// Returns the maximum value that can be put in a knapsack of capacity W\r\n \nint knapSack(int W, int wt[], int val[], int n)\r\n \n{ \nint i, w; \nint K[n+1][W+1];\r\n   \n\n// Build table K[][] in bottom up manner \r\n   \nfor (i = 0; i <= n; i++)\r\n   \n{ \n	for (w = 0; w <= W; w++)\r\n \n	{\r\n \n		if (i==0 || w==0)\r\n \n			K[i][w] = 0;\r\n \n		else if (wt[i-1] <= w)\r\n \n			K[i][w] = max(val[i-1] + K[i-1][w-wt[i-1]], K[i-1][w]);\r\n \n		else\r\n\n			K[i][w] = K[i-1][w];\r\n \n	}\r\n    \n}\r\n   \n\nreturn K[n][W];\r\n \n}\r\n \n\nint main()\r\n \n{\r\n \n	int val[100],wt[100];\r\n \n	int n,W;\r\n\n	cin>>n>>W;\r\n        \\ no. of elements and capacity of knapsack\r\n \n	for(int i=0;i<n;i++){\r\n\n		cin>>val[i];\r\n        }\r\n\n	for(int i=0;i<n;i++){\n\r\n		cin>>wt[i];\r\n        }\r\n\n	printf(\"%d\", knapSack(W, wt, val, n));\r\n \n	return 0; \r\n\n} \n\n', 0, '5 15 4 2 1 2 10 12 2 1 1 4', '', 'Algorithm: Greedy-Fractional-Knapsack (w[1..n], p[1..n], W) \r\nfor i = 1 to n \r\n   do x[i] = 0 \r\nweight = 0 \r\nfor i = 1 to n \r\n   if weight + w[i] ≤ W then  \r\n      x[i] = 1 \r\n      weight = weight + w[i] \r\n   else \r\n      x[i] = (W - weight) / w[i] \r\n      weight = W \r\n      break \r\nreturn x', '2020-05-25'),
(259, 2, 6901012018, '#include<iostream.h>\r\n#include<conio.h>\r\nvoid main()\r\n{\r\n	clrscr();\r\n	int n,mat1[n][n], mat2[n][n], mat3[n][n], sum=0, i, j, k;\r\n	\r\n	cin>>n;\r\n	\r\n	for(i=0; i<n; i++)\r\n	{\r\n		for(j=0; j<n; j++)\r\n		{\r\n			cin>>mat1[i][j];\r\n		}\r\n	}\r\n	\r\n	for(i=0; i<n; i++)\r\n	{\r\n		for(j=0; j<n; j++)\r\n		{\r\n			cin>>mat2[i][j];\r\n		}\r\n	}\r\n\r\n	for(i=0; i<n; i++)\r\n	{\r\n		for(j=0; j<n; j++)\r\n		{\r\n			sum=0;\r\n			for(k=0; k<n; k++)\r\n			{\r\n				sum = sum + mat1[i][k] * mat2[k][j];\r\n			}\r\n			mat3[i][j] = sum;\r\n		}\r\n	}\r\n\r\n	for(i=0; i<n; i++)\r\n	{\r\n		for(j=0; j<n; j++)\r\n		{\r\n			cout<<mat3[i][j]<<\" \";\r\n		}\r\n		cout<<\" \";\r\n	}\r\n	getch();\r\n}', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '', 'aaa', '0000-00-00'),
(260, 3, 6901012018, '#include <cstdlib> \r\n#include<ctime>\r\n #include <iostream> \r\nusing namespace std; \r\nint partition(int arr[], int low, int high) \r\n{\r\n int pivot = arr[high]; // pivot\r\n int i = (low - 1); // Index of smaller element\r\n for (int j = low; j <= high - 1; j++) \r\n{ \r\n    if (arr[j] <= pivot) \r\n{     i++; \r\n     swap(arr[i], arr[j]); \r\n} \r\n} \r\nswap(arr[i + 1], arr[high]); \r\nreturn (i + 1);\r\n } \r\nint partition_r(int arr[], int low, int high) \r\n{ \r\nsrand(time(NULL));\r\n int random = low + rand() % (high - low); \r\nswap(arr[random], arr[high]);\r\n return partition(arr, low, high); \r\n}  \r\nvoid quickSort(int arr[], int low, int high) \r\n{ \r\nif (low < high)\r\n { \r\nint pi = partition_r(arr, low, high); \r\nquickSort(arr, low, pi - 1);\r\n quickSort(arr, pi + 1, high); \r\n} \r\n}\r\n /* Function to print an array */ \r\nvoid printArray(int arr[], int size) \r\n{ int i; for (i = 0; i < size; i++) cout<<arr[i]<<\" \"; } \r\n// Driver program to test above functions \r\nint main()\r\n { \r\nint n; \r\ncin>>n; \r\nint arr[n]; \r\nfor(int i=0;i<n;i++) { cin>>arr[i]; } \r\nquickSort(arr, 0, n - 1); \r\nprintArray(arr, n);\r\n return 0;\r\n } ', 10, '1 2000', '2000 ', 'aaa', '0000-00-00'),
(261, 2, 6401012018, '﻿#include<iostream>\r\nusing namespace std;\r\nvoid merge(int arr[], int l, int m, int r)\r\n{\r\n    int i, j, k;\r\n    int n1 = m - l + 1;\r\n    int n2 =  r - m;\r\n\r\n\r\n    int L[n1], R[n2];\r\n\r\n\r\n    for (i = 0; i < n1; i++)\r\n        L[i] = arr[l + i];\r\n    for (j = 0; j < n2; j++)\r\n        R[j] = arr[m + 1+ j];\r\n\r\n\r\n    i = 0;\r\n    j = 0;\r\n    k = l;\r\n    while (i < n1 && j < n2)\r\n    {\r\n        if (L[i] <= R[j])\r\n        {\r\n            arr[k] = L[i];\r\n            i++;\r\n        }\r\n        else\r\n        {\r\n            arr[k] = R[j];\r\n            j++;\r\n        }\r\n        k++;\r\n    }\r\n\r\n\r\n    while (i < n1)\r\n    {\r\n        arr[k] = L[i];\r\n        i++;\r\n        k++;\r\n    }\r\n\r\n\r\n    while (j < n2)\r\n    {\r\n        arr[k] = R[j];\r\n        j++;\r\n        k++;\r\n    }\r\n}\r\n\r\n\r\nvoid mergeSort(int arr[], int l, int r)\r\n{\r\n    if (l < r)\r\n    {\r\n\r\n\r\n        int m = l+(r-l)/2;\r\n        mergeSort(arr, l, m);\r\n        mergeSort(arr, m+1, r);\r\n\r\n\r\n        merge(arr, l, m, r);\r\n    }\r\n}\r\nvoid printArray(int A[], int size)\r\n{\r\n    int i;\r\n    for (i=0; i < size; i++)\r\n        cout<<A[i]<<\" \";\r\n}\r\n\r\n\r\n\r\n\r\nint main()\r\n{\r\n    int n; cin >> n;\r\n\r\n\r\n    int* arr = new int[n];\r\n\r\n\r\n    for(int i = 0; i < n; i++)\r\n        cin >> arr[i];\r\n\r\n\r\n    int arr_size = sizeof(arr)/sizeof(arr[0]);\r\n\r\n\r\n    mergeSort(arr, 0, n - 1);\r\n    printArray(arr, n);\r\n    return 0;\r\n}', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', '﻿MergeSort(arr[], l,  r)\r\nIf r > l\r\n     1. Find the middle point to divide the array into two halves:  \r\n             middle m = (l+r)/2\r\n    2. Call mergeSort for first half:   \r\n             Call mergeSort(arr, l, m)\r\n     3. Call mergeSort for second half:\r\n             Call mergeSort(arr, m+1, r)\r\n     4. Merge the two halves sorted in step 2 and 3:\r\n             Call merge(arr, l, m, r)', '2020-05-25'),
(262, 7, 4701012018, '#include <cstdlib> \n#include <iostream> \nusing namespace std; \nint partition(int arr[], int low, int high) \n{ \n    int pivot = arr[high];  \n    int i = (low - 1); \n    for (int j = low; j <= high - 1; j++) \n    { \n        if (arr[j] <= pivot) \n        { \n            i++; \n            swap(arr[i], arr[j]); \n        } \n    } \n    swap(arr[i + 1], arr[high]); \n    return (i + 1); \n} \nint partition_r(int arr[], int low, int high) \n{ \n    srand(time(NULL)); \n    int random = low + rand() % (high - low); \n    swap(arr[random], arr[high]); \n    return partition(arr, low, high); \n} \nvoid quickSort(int arr[], int low, int high) \n{ \n    if (low < high) \n    { \n        int pi = partition_r(arr, low, high); \n        quickSort(arr, low, pi - 1); \n        quickSort(arr, pi + 1, high); \n    } \n} \nvoid printArray(int arr[], int size) \n{ \n    int i; \n    for (i = 0; i < size; i++) \n        printf(\"%d \", arr[i]); \n} \nint main() \n{ \n    int n,i;\n    cin>>n;\n    int arr[n];\n    for(i=0;i<n;i++)\n        cin>>arr[i];\n    quickSort(arr, 0, n - 1);  \n    printArray(arr, n); \n    return 0; \n} \n', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '', 'partition(arr[], lo, hi) \r\n    pivot = arr[hi]\r\n    i = lo    \r\n    for j := lo to hi – 1 do\r\n        if arr[j] <= pivot then\r\n            swap arr[i] with arr[j]\r\n            i = i + 1\r\n    swap arr[i] with arr[hi]\r\n    return i\r\n\r\npartition_r(arr[], lo, hi)\r\n    r = Random Number from lo to hi\r\n    Swap arr[r] and arr[hi]\r\n    return partition(arr, lo, hi)\r\n\r\nquicksort(arr[], lo, hi)\r\n    if lo < hi\r\n        p = partition_r(arr, lo, hi)\r\n        quicksort(arr, p-1, hi)\r\n        quicksort(arr, p+1, hi)\r\n ', '2020-05-25'),
(263, 10, 7501012018, '﻿#include<iostream>\r\n#include<vector>\r\nusing namespace std;\r\nint knapsack(vector<int>& weight,vector<int>& v,int t)\r\n{\r\n    vector<vector<int>> dp(v.size()+1,vector<int>(t+1,0));\r\n    for(int i=0;i<dp.size();i++)\r\n    {\r\n        for(int j=1;j<dp[0].size();j++)\r\n        {\r\n            if(i==0)\r\n            {\r\n                dp[i][j] = j - weight[i] >= 0 ? v[i] : 0;\r\n            }\r\n            else\r\n            {\r\n                if(j-weight[i]>=0)\r\n                {\r\n                    dp[i][j]+=max(dp[i-1][j],dp[i-1][j-weight[i]]+v[i]);\r\n                }\r\n                else\r\n                {\r\n                    dp[i][j]=dp[i-1][j];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return dp[v.size()][t];\r\n}\r\nint main()\r\n{\r\n    int n,x;\r\n    cin>>n>>x;\r\n    vector<int>w(n,0);\r\n    vector<int>v(n,0);\r\n    for(int i=0;i<n;i++)\r\n    {\r\n        cin>>v[i];\r\n    }\r\n    for(int i=0;i<n;i++)\r\n    {\r\n        cin>>w[i];\r\n    }\r\n   cout<< knapsack(w,v,x);\r\n}', 0, '5 15 4 2 1 2 10 12 2 1 1 4', '', '﻿An efficient solution is to use the Greedy approach. The basic idea of the greedy approach is to calculate the ratio value/weight for each item and sort the item on the basis of this ratio. Then take the item with the highest ratio and add them until we can’t add the next item as a whole and at the end add the next item as much as we can. Which will always be the optimal solution to this problem.\r\n\r\n\r\nAlgorithm: Greedy-Fractional-Knapsack (w[1..n], p[1..n], W) \r\nfor i = 1 to n \r\n   do x[i] = 0 \r\nweight = 0 \r\nfor i = 1 to n \r\n   if weight + w[i] ≤ W then  \r\n      x[i] = 1 \r\n      weight = weight + w[i] \r\n   else \r\n      x[i] = (W - weight) / w[i] \r\n      weight = W \r\n      break \r\nreturn x', '2020-05-25'),
(264, 2, 4101012018, '#include<iostream>\r\nusing namespace std;\r\nvoid swap(int &a, int &b) {     \r\n   int temp;\r\n   temp = a;\r\n   a = b;\r\n   b = temp;\r\n}\r\nvoid display(int *arr, int size) {\r\n   for(int i = 0; i<size; i++)\r\n      cout << arr[i] << \" \";\r\n   cout << endl;\r\n}\r\nvoid merge(int *arr, int l, int m, int r) {\r\n   int i, j, k, nl, nr;\r\n   \r\n   nl = m-l+1; nr = r-m;\r\n   int larr[nl], rarr[nr];\r\n   \r\n   for(i = 0; i<nl; i++)\r\n      larr[i] = arr[l+i];\r\n   for(j = 0; j<nr; j++)\r\n      rarr[j] = arr[m+1+j];\r\n   i = 0; j = 0; k = l;\r\n   \r\n   while(i < nl && j<nr) {\r\n      if(larr[i] <= rarr[j]) {\r\n         arr[k] = larr[i];\r\n         i++;\r\n      }else{\r\n         arr[k] = rarr[j];\r\n         j++;\r\n      }\r\n      k++;\r\n   }\r\n   while(i<nl) {     \r\n      arr[k] = larr[i];\r\n      i++; k++;\r\n   }\r\n   while(j<nr) {     \r\n      arr[k] = rarr[j];\r\n      j++; k++;\r\n   }\r\n}\r\nvoid mergeSort(int *arr, int l, int r) {\r\n   int m;\r\n   if(l < r) {\r\n      int m = l+(r-l)/2;\r\n      \r\n      mergeSort(arr, l, m);\r\n      mergeSort(arr, m+1, r);\r\n      merge(arr, l, m, r);\r\n   }\r\n}\r\nint main() {\r\n   int n;\r\n   \r\n   cin >> n;\r\n   int arr[n];     \r\n   \r\n   for(int i = 0; i<n; i++) {\r\n      cin >> arr[i];\r\n   }\r\n   \r\n   mergeSort(arr, 0, n-1);     \r\n   \r\n   display(arr, n);\r\n}', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 \n', 'aaa', '0000-00-00'),
(265, 8, 6801012018, '\r\n#include <cstdlib> \r\n#include<ctime>\r\n #include <iostream> \r\nusing namespace std; \r\nint partition(int arr[], int low, int high) \r\n{\r\n int pivot = arr[high]; // pivot\r\n int i = (low - 1); // Index of smaller element\r\n for (int j = low; j <= high - 1; j++) \r\n{ \r\n    if (arr[j] <= pivot) \r\n{     i++; \r\n     swap(arr[i], arr[j]); \r\n} \r\n} \r\nswap(arr[i + 1], arr[high]); \r\nreturn (i + 1);\r\n } \r\nint partition_r(int arr[], int low, int high) \r\n{ \r\nsrand(time(NULL));\r\n int random = low + rand() % (high - low); \r\nswap(arr[random], arr[high]);\r\n return partition(arr, low, high); \r\n}  \r\nvoid quickSort(int arr[], int low, int high) \r\n{ \r\nif (low < high)\r\n { \r\nint pi = partition_r(arr, low, high); \r\nquickSort(arr, low, pi - 1);\r\n quickSort(arr, pi + 1, high); \r\n} \r\n}\r\n /* Function to print an array */ \r\nvoid printArray(int arr[], int size) \r\n{ int i; for (i = 0; i < size; i++) cout<<arr[i]<<\" \"; } \r\n// Driver program to test above functions \r\nint main()\r\n { \r\nint n; \r\ncin>>n; \r\nint arr[n]; \r\nfor(int i=0;i<n;i++) { cin>>arr[i]; } \r\nquickSort(arr, 0, n - 1); \r\nprintArray(arr, n);\r\n return 0;\r\n } \r\n\r\n\r\n\r\n#include<iostream.h>\r\n#include<conio.h>\r\nvoid main()\r\n{\r\n	clrscr();\r\n	int n,mat1[n][n], mat2[n][n], mat3[n][n], sum=0, i, j, k;\r\n	\r\n	cin>>n;\r\n	\r\n	for(i=0; i<n; i++)\r\n	{\r\n		for(j=0; j<n; j++)\r\n		{\r\n			cin>>mat1[i][j];\r\n		}\r\n	}\r\n	\r\n	for(i=0; i<n; i++)\r\n	{\r\n		for(j=0; j<n; j++)\r\n		{\r\n			cin>>mat2[i][j];\r\n		}\r\n	}\r\n\r\n	for(i=0; i<n; i++)\r\n	{\r\n		for(j=0; j<n; j++)\r\n		{\r\n			sum=0;\r\n			for(k=0; k<n; k++)\r\n			{\r\n				sum = sum + mat1[i][k] * mat2[k][j];\r\n			}\r\n			mat3[i][j] = sum;\r\n		}\r\n	}\r\n\r\n	for(i=0; i<n; i++)\r\n	{\r\n		for(j=0; j<n; j++)\r\n		{\r\n			cout<<mat3[i][j]<<\" \";\r\n		}\r\n		cout<<\" \";\r\n	}\r\n	getch();\r\n', 10, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '', 'aaa', '0000-00-00'),
(266, 2, 7301012018, '﻿#include<stdlib.h>\r\n#include<stdio.h>\r\n#include<iostream>\r\n#include<conio.h>\r\nusing namespace std;\r\nvoid merge(int arr[], int l, int m, int r)\r\n{\r\n    int i, j, k;\r\n    int n1 = m - l + 1;\r\n    int n2 =  r - m;\r\n\r\n\r\n    int L[n1], R[n2];\r\n\r\n\r\n    for (i = 0; i < n1; i++)\r\n        L[i] = arr[l + i];\r\n    for (j = 0; j < n2; j++)\r\n        R[j] = arr[m + 1+ j];\r\n\r\n\r\n    i = 0;\r\n    j = 0;\r\n    k = l;\r\n    while (i < n1 && j < n2)\r\n    {\r\n        if (L[i] <= R[j])\r\n        {\r\n            arr[k] = L[i];\r\n            i++;\r\n        }\r\n        else\r\n        {\r\n            arr[k] = R[j];\r\n            j++;\r\n        }\r\n        k++;\r\n    }\r\n\r\n\r\n    while (i < n1)\r\n    {\r\n        arr[k] = L[i];\r\n        i++;\r\n        k++;\r\n    }\r\n\r\n\r\n    while (j < n2)\r\n    {\r\n        arr[k] = R[j];\r\n        j++;\r\n        k++;\r\n    }\r\n}\r\n\r\n\r\nvoid mergeSort(int arr[], int l, int r)\r\n{\r\n    if (l < r)\r\n    {\r\n\r\n\r\n        int m = l+(r-l)/2;\r\n        mergeSort(arr, l, m);\r\n        mergeSort(arr, m+1, r);\r\n\r\n\r\n        merge(arr, l, m, r);\r\n    }\r\n}\r\nvoid printArray(int A[], int size)\r\n{\r\n    int i;\r\n    for (i=0; i < size; i++)\r\n        printf(\"%d \", A[i]);\r\n}\r\n\r\n\r\n\r\n\r\nint main()\r\n{\r\n    int n; cin >> n;\r\n\r\n\r\n    int* arr = new int[n];\r\n\r\n\r\n    for(int i = 0; i < n; i++)\r\n        cin >> arr[i];\r\n\r\n\r\n    int arr_size = sizeof(arr)/sizeof(arr[0]);\r\n\r\n\r\n    mergeSort(arr, 0, n - 1);\r\n    printArray(arr, n);\r\n    return 0;\r\n}', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '', '﻿MergeSort(arr[], l,  r)\r\nIf r > l\r\n     1. Find the middle point to divide the array into two halves:  \r\n             middle m = (l+r)/2\r\n    2. Call mergeSort for first half:   \r\n             Call mergeSort(arr, l, m)\r\n     3. Call mergeSort for second half:\r\n             Call mergeSort(arr, m+1, r)\r\n     4. Merge the two halves sorted in step 2 and 3:\r\n             Call merge(arr, l, m, r)', '2020-05-25'),
(267, 3, 4901012018, '#include<iostream>\r\nusing namespace std;\r\n\r\nvoid swap( int &a, int &b)\r\n{\r\n    int t=a;\r\n    a=b;\r\n    b=t;\r\n}\r\n\r\nint pivot(int arr[], int sPos, int ePos)\r\n{\r\n    \r\n   int p= arr[ePos];\r\n   int i=sPos-1;\r\n   for(int j=sPos;j<=ePos-1;j++)\r\n   {\r\n       if(arr[j]<p)\r\n       {\r\n           i++;\r\n           swap(arr[i], arr[j]);\r\n       }\r\n   }\r\n    \r\n    swap(arr[i+1], arr[ePos]);\r\n    return i+1;\r\n    \r\n}\r\n\r\nvoid quickSort(int arr[], int sPos, int ePos)\r\n{\r\n    \r\n   if(sPos>=ePos)  return;\r\n   int pi= pivot(arr, sPos, ePos);\r\n   quickSort(arr, sPos, pi-1);\r\n   quickSort(arr, pi+1, ePos);\r\n    \r\n}\r\n\r\nint main()\r\n{\r\n    \r\n    int n; cin>>n;\r\n    int arr[n];\r\n    for(int i=0;i<n;i++)\r\n    cin>>arr[i];\r\n    quickSort(arr,0,n-1);\r\n    for(int i=0;i<n;i++) cout<<arr[i]<<\" \";\r\n     \r\n}', 10, '5 99 88 77 66 55', '55 66 77 88 99 ', 'aaa', '2020-03-11'),
(268, 10, 5701012018, '#include <iostream>\r\nusing namespace std;\r\nint max(int a, int b)\r\n{\r\n    return (a > b) ? a : b;\r\n}\r\n\r\nint knapSack(int W, int wt[], int val[], int n)\r\n{\r\n    int i, w;\r\n    int K[n + 1][W + 1];\r\n    for (i = 0; i <= n; i++)\r\n    {\r\n        for (w = 0; w <= W; w++)\r\n        {\r\n            if (i == 0 || w == 0)\r\n                K[i][w] = 0;\r\n            else if (wt[i - 1] <= w)\r\n                K[i][w]\r\n                        = max(val[i - 1] + K[i - 1][w - wt[i - 1]], K[i - 1][w]);\r\n            else\r\n                K[i][w] = K[i - 1][w];\r\n        }\r\n    }\r\n\r\n    return K[n][W];\r\n}\r\n\r\nint main()\r\n{\r\n    int n, W;\r\n    cin >> n;\r\n    int val[n], wt[n];\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        cout << i << \":\";\r\n        cin >> val[i];\r\n        cin >> wt[i];\r\n    }\r\n    cin >> W;\r\n    cout << knapSack(W, wt, val, n);\r\n\r\n    return 0;\r\n}\r\n', 0, '5 15 4 2 1 2 10 12 2 1 1 4', '0:1:2:3:4:15', 'The basic idea of the greedy approach is to calculate the ratio value/weight for each item and sort the item on basis of this ratio. Then take the item with the highest ratio and add them until we can’t add the next item as a whole and at the end add the next item as much as we can. Which will always be the optimal solution to this problem.\r\n\r\nA simple code with our own comparison function can be written as follows, please see sort function more closely, the third argument to sort function is our comparison function which sorts the item according to value/weight ratio in non-decreasing order.\r\nAfter sorting we need to loop over these items and add them in our knapsack satisfying above-mentioned criteria.', '2020-05-25');
INSERT INTO `qtos_map` (`ID`, `Q_ID`, `ROLL`, `SUBMISSION`, `SCORE`, `INPUT`, `OP`, `ALGO`, `DATE`) VALUES
(269, 12, 6601012018, '﻿#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n\r\nclass Edge\r\n{\r\n    public:\r\n    int src, dest, weight;\r\n};\r\n\r\n\r\nclass Graph\r\n{\r\n    public:\r\n\r\n\r\n    int V, E;\r\n\r\n\r\n    Edge* edge;\r\n};\r\n\r\n\r\n\r\n\r\nGraph* createGraph(int V, int E)\r\n{\r\n    Graph* graph = new Graph;\r\n    graph->V = V;\r\n    graph->E = E;\r\n\r\n\r\n    graph->edge = new Edge[E];\r\n\r\n\r\n    return graph;\r\n}\r\n\r\n\r\nclass subset\r\n{\r\n    public:\r\n    int parent;\r\n    int rank;\r\n};\r\n\r\n\r\n\r\n\r\nint find(subset subsets[], int i)\r\n{\r\n    if (subsets[i].parent != i)\r\n        subsets[i].parent = find(subsets, subsets[i].parent);\r\n\r\n\r\n    return subsets[i].parent;\r\n}\r\n\r\n\r\n\r\n\r\nvoid Union(subset subsets[], int x, int y)\r\n{\r\n    int xroot = find(subsets, x);\r\n    int yroot = find(subsets, y);\r\n\r\n\r\n\r\n\r\n    if (subsets[xroot].rank < subsets[yroot].rank)\r\n        subsets[xroot].parent = yroot;\r\n    else if (subsets[xroot].rank > subsets[yroot].rank)\r\n        subsets[yroot].parent = xroot;\r\n\r\n\r\n    else\r\n    {\r\n        subsets[yroot].parent = xroot;\r\n        subsets[xroot].rank++;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\nint myComp(const void* a, const void* b)\r\n{\r\n    Edge* a1 = (Edge*)a;\r\n    Edge* b1 = (Edge*)b;\r\n    return a1->weight > b1->weight;\r\n}\r\n\r\n\r\n\r\n\r\nvoid KruskalMST(Graph* graph)\r\n{\r\n    int V = graph->V;\r\n    Edge result[V];\r\n    int e = 0;\r\n    int i = 0;\r\n\r\n\r\n    qsort(graph->edge, graph->E, sizeof(graph->edge[0]), myComp);\r\n\r\n\r\n\r\n\r\n    subset *subsets = new subset[( V * sizeof(subset) )];\r\n\r\n\r\n    for (int v = 0; v < V; ++v)\r\n    {\r\n        subsets[v].parent = v;\r\n        subsets[v].rank = 0;\r\n    }\r\n\r\n\r\n\r\n\r\n    while (e < V - 1 && i < graph->E)\r\n    {\r\n        Edge next_edge = graph->edge[i++];\r\n\r\n\r\n        int x = find(subsets, next_edge.src);\r\n        int y = find(subsets, next_edge.dest);\r\n\r\n\r\n        if (x != y)\r\n        {\r\n            result[e++] = next_edge;\r\n            Union(subsets, x, y);\r\n        }\r\n\r\n\r\n    }\r\n\r\n\r\n    cout<<\"Following are the edges in the constructed MST\n\";\r\n    for (i = 0; i < e; ++i)\r\n        cout<<result[i].src<<\" -- \"<<result[i].dest<<\" == \"<<result[i].weight<<endl;\r\n    return;\r\n}\r\n\r\n\r\n\r\n\r\nint main()\r\n{\r\n    int V = 4;\r\n    int E = 5;\r\n    Graph* graph = createGraph(V, E);\r\n\r\n\r\n    graph->edge[0].src = 0;\r\n    graph->edge[0].dest = 1;\r\n    graph->edge[0].weight = 10;\r\n\r\n\r\n    graph->edge[1].src = 0;\r\n    graph->edge[1].dest = 2;\r\n    graph->edge[1].weight = 6;\r\n\r\n\r\n\r\n\r\n    graph->edge[2].src = 0;\r\n    graph->edge[2].dest = 3;\r\n    graph->edge[2].weight = 5;\r\n\r\n\r\n\r\n\r\n    graph->edge[3].src = 1;\r\n    graph->edge[3].dest = 3;\r\n    graph->edge[3].weight = 15;\r\n\r\n\r\n\r\n\r\n    graph->edge[4].src = 2;\r\n    graph->edge[4].dest = 3;\r\n    graph->edge[4].weight = 4;\r\n\r\n\r\n    KruskalMST(graph);\r\n\r\n\r\n    return 0;\r\n}', 1000, '8 a b c d e f g h 1 1 2 3 5 8 13 21', '\nh: 0\ng: 10\nf: 110\ne: 1110\nd: 11110\nc: 111110\na: 1111110\nb: 1111111', '﻿1. Sort all the edges in non-decreasing order of their weight.\r\n2. Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If a cycle is not formed, include this edge. Else, discard it.\r\n3. Repeat step#2 until there are (V-1) edges in the spanning tree.', '2020-05-25'),
(270, 12, 7501012018, '﻿#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n\r\nclass Edge\r\n{\r\n    public:\r\n    int src, dest, weight;\r\n};\r\n\r\n\r\nclass Graph\r\n{\r\n    public:\r\n\r\n\r\n    int V, E;\r\n\r\n\r\n    Edge* edge;\r\n};\r\n\r\n\r\n\r\n\r\nGraph* createGraph(int V, int E)\r\n{\r\n    Graph* graph = new Graph;\r\n    graph->V = V;\r\n    graph->E = E;\r\n\r\n\r\n    graph->edge = new Edge[E];\r\n\r\n\r\n    return graph;\r\n}\r\n\r\n\r\nclass subset\r\n{\r\n    public:\r\n    int parent;\r\n    int rank;\r\n};\r\n\r\n\r\n\r\n\r\nint find(subset subsets[], int i)\r\n{\r\n    if (subsets[i].parent != i)\r\n        subsets[i].parent = find(subsets, subsets[i].parent);\r\n\r\n\r\n    return subsets[i].parent;\r\n}\r\n\r\n\r\n\r\n\r\nvoid Union(subset subsets[], int x, int y)\r\n{\r\n    int xroot = find(subsets, x);\r\n    int yroot = find(subsets, y);\r\n\r\n\r\n\r\n\r\n    if (subsets[xroot].rank < subsets[yroot].rank)\r\n        subsets[xroot].parent = yroot;\r\n    else if (subsets[xroot].rank > subsets[yroot].rank)\r\n        subsets[yroot].parent = xroot;\r\n\r\n\r\n    else\r\n    {\r\n        subsets[yroot].parent = xroot;\r\n        subsets[xroot].rank++;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\nint myComp(const void* a, const void* b)\r\n{\r\n    Edge* a1 = (Edge*)a;\r\n    Edge* b1 = (Edge*)b;\r\n    return a1->weight > b1->weight;\r\n}\r\n\r\n\r\n\r\n\r\nvoid KruskalMST(Graph* graph)\r\n{\r\n    int V = graph->V;\r\n    Edge result[V];\r\n    int e = 0;\r\n    int i = 0;\r\n\r\n\r\n    qsort(graph->edge, graph->E, sizeof(graph->edge[0]), myComp);\r\n\r\n\r\n\r\n\r\n    subset *subsets = new subset[( V * sizeof(subset) )];\r\n\r\n\r\n    for (int v = 0; v < V; ++v)\r\n    {\r\n        subsets[v].parent = v;\r\n        subsets[v].rank = 0;\r\n    }\r\n\r\n\r\n\r\n\r\n    while (e < V - 1 && i < graph->E)\r\n    {\r\n        Edge next_edge = graph->edge[i++];\r\n\r\n\r\n        int x = find(subsets, next_edge.src);\r\n        int y = find(subsets, next_edge.dest);\r\n\r\n\r\n        if (x != y)\r\n        {\r\n            result[e++] = next_edge;\r\n            Union(subsets, x, y);\r\n        }\r\n\r\n\r\n    }\r\n\r\n\r\n    cout<<\"Following are the edges in the constructed MST\n\";\r\n    for (i = 0; i < e; ++i)\r\n        cout<<result[i].src<<\" -- \"<<result[i].dest<<\" == \"<<result[i].weight<<endl;\r\n    return;\r\n}\r\n\r\n\r\n\r\n\r\nint main()\r\n{\r\n    int V = 4;\r\n    int E = 5;\r\n    Graph* graph = createGraph(V, E);\r\n\r\n\r\n    graph->edge[0].src = 0;\r\n    graph->edge[0].dest = 1;\r\n    graph->edge[0].weight = 10;\r\n\r\n\r\n    graph->edge[1].src = 0;\r\n    graph->edge[1].dest = 2;\r\n    graph->edge[1].weight = 6;\r\n\r\n\r\n\r\n\r\n    graph->edge[2].src = 0;\r\n    graph->edge[2].dest = 3;\r\n    graph->edge[2].weight = 5;\r\n\r\n\r\n\r\n\r\n    graph->edge[3].src = 1;\r\n    graph->edge[3].dest = 3;\r\n    graph->edge[3].weight = 15;\r\n\r\n\r\n\r\n\r\n    graph->edge[4].src = 2;\r\n    graph->edge[4].dest = 3;\r\n    graph->edge[4].weight = 4;\r\n\r\n\r\n    KruskalMST(graph);\r\n\r\n\r\n    return 0;\r\n}', 1000, '8 a b c d e f g h 1 1 2 3 5 8 13 21', '\nh: 0\ng: 10\nf: 110\ne: 1110\nd: 11110\nc: 111110\na: 1111110\nb: 1111111', '﻿1. Sort all the edges in non-decreasing order of their weight.\r\n2. Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If a cycle is not formed, include this edge. Else, discard it.\r\n3. Repeat step#2 until there are (V-1) edges in the spanning tree.', '2020-05-25'),
(271, 10, 6901012018, '#include<iostream>\r\n#include<vector>\r\nusing namespace std;\r\nint knapsack(vector<int>& weight,vector<int>& v,int t)\r\n{\r\n    vector<vector<int>> dp(v.size()+1,vector<int>(t+1,0));\r\n    for(int i=0;i<dp.size();i++)\r\n    {\r\n        for(int j=1;j<dp[0].size();j++)\r\n        {\r\n            if(i==0)\r\n            {\r\n                dp[i][j] = j - weight[i] >= 0 ? v[i] : 0;\r\n            }\r\n            else\r\n            {\r\n                if(j-weight[i]>=0)\r\n                {\r\n                    dp[i][j]+=max(dp[i-1][j],dp[i-1][j-weight[i]]+v[i]);\r\n                }\r\n                else\r\n                {\r\n                    dp[i][j]=dp[i-1][j];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return dp[v.size()][t];\r\n}\r\nint main()\r\n{\r\n    int n,x;\r\n    cin>>n>>x;\r\n    vector<int>w(n,0);\r\n    vector<int>v(n,0);\r\n    for(int i=0;i<n;i++)\r\n    {\r\n        cin>>v[i];\r\n    }\r\n    for(int i=0;i<n;i++)\r\n    {\r\n        cin>>w[i];\r\n    }\r\n   cout<< knapsack(w,v,x);\r\n}\r\n', 10, '5 15 4 2 1 2 10 12 2 1 1 4', '', 'aaa', '0000-00-00'),
(272, 14, 4701012018, '#include<iostream>\nusing namespace std;\nstruct Edge \n{ \n    int src, dest, weight; \n}; \nstruct Graph \n{ \n    int V, E; \n    struct Edge* edge; \n}; \nstruct Graph* createGraph(int V, int E) \n{ \n    struct Graph* graph = new Graph; \n    graph->V = V; \n    graph->E = E; \n    graph->edge = new Edge[E]; \n    return graph; \n} \nvoid printArr(int dist[], int n) \n{ \n    printf(\"Vertex   Distance from Source\n\"); \n    for (int i = 0; i < n; ++i) \n        printf(\"%d 		 %d\n\", i, dist[i]); \n} \nvoid BellmanFord(struct Graph* graph, int src) \n{ \n    int V = graph->V; \n    int E = graph->E; \n    int dist[V]; \n    for (int i = 0; i < V; i++) \n        dist[i] = INT_MAX; \n    dist[src] = 0; \n    for (int i = 1; i <= V - 1; i++) { \n        for (int j = 0; j < E; j++) { \n            int u = graph->edge[j].src; \n            int v = graph->edge[j].dest; \n            int weight = graph->edge[j].weight; \n            if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) \n                dist[v] = dist[u] + weight; \n        } \n    } \n    for (int i = 0; i < E; i++) { \n        int u = graph->edge[i].src; \n        int v = graph->edge[i].dest; \n        int weight = graph->edge[i].weight; \n        if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) { \n            printf(\"Graph contains negative weight cycle\"); \n            return; \n        } \n    } \n    printArr(dist, V); \n    return; \n} \nint main() \n{ \n    int V = 5; \n    int E = 8; \n    struct Graph* graph = createGraph(V, E); \n    graph->edge[0].src = 0; \n    graph->edge[0].dest = 1; \n    graph->edge[0].weight = -1; \n    graph->edge[1].src = 0; \n    graph->edge[1].dest = 2; \n    graph->edge[1].weight = 4; \n    graph->edge[2].src = 1; \n    graph->edge[2].dest = 2; \n    graph->edge[2].weight = 3;  \n    graph->edge[3].src = 1; \n    graph->edge[3].dest = 3; \n    graph->edge[3].weight = 2;  \n    graph->edge[4].src = 1; \n    graph->edge[4].dest = 4; \n    graph->edge[4].weight = 2;  \n    graph->edge[5].src = 3; \n    graph->edge[5].dest = 2; \n    graph->edge[5].weight = 5; \n    graph->edge[6].src = 3; \n    graph->edge[6].dest = 1; \n    graph->edge[6].weight = 1; \n    graph->edge[7].src = 4; \n    graph->edge[7].dest = 3; \n    graph->edge[7].weight = -3; \n    BellmanFord(graph, 0); \n    return 0; \n} \n', 1000, '8 a b c d e f g h 1 1 2 3 5 8 13 21', 'h: 0\ng: 10\nf: 110\ne: 1110\nd: 11110\nc: 111110\na: 1111110\nb: 1111111\n', 'Following are the detailed steps.\r\nInput: Graph and a source vertex src\r\nOutput: Shortest distance to all vertices from src. If there is a negative weight cycle, then shortest distances are not calculated, negative weight cycle is reported.\r\n1) This step initializes distances from source to all vertices as infinite and distance to source itself as 0. Create an array dist[] of size |V| with all values as infinite except dist[src] where src is source vertex.2) This step calculates shortest distances. Do following |V|-1 times where |V| is the number of vertices in given graph.\r\n…..a) Do following for each edge u-v\r\n………………If dist[v] > dist[u] + weight of edge uv, then update dist[v]\r\n………………….dist[v] = dist[u] + weight of edge uv\r\n3) This step reports if there is a negative weight cycle in graph. Do following for each edge u-v\r\n……If dist[v] > dist[u] + weight of edge uv, then “Graph contains negative weight cycle”\r\nThe idea of step 3 is, step 2 guarantees shortest distances if graph doesn’t contain negative weight cycle. If we iterate through all edges one more time and get a shorter path for any vertex, then there is a negative weight cycle', '2020-05-25'),
(273, 7, 4601012018, '#include <cstdlib> \n#include <iostream> \nusing namespace std; \nint partition(int arr[], int low, int high) \n{ \n    int pivot = arr[high];  \n    int i = (low - 1); \n    for (int j = low; j <= high - 1; j++) \n    { \n        if (arr[j] <= pivot) \n        { \n            i++; \n            swap(arr[i], arr[j]); \n        } \n    } \n    swap(arr[i + 1], arr[high]); \n    return (i + 1); \n} \nint partition_r(int arr[], int low, int high) \n{ \n    srand(time(NULL)); \n    int random = low + rand() % (high - low); \n    swap(arr[random], arr[high]); \n    return partition(arr, low, high); \n} \nvoid quickSort(int arr[], int low, int high) \n{ \n    if (low < high) \n    { \n        int pi = partition_r(arr, low, high); \n        quickSort(arr, low, pi - 1); \n        quickSort(arr, pi + 1, high); \n    } \n} \nvoid printArray(int arr[], int size) \n{ \n    int i; \n    for (i = 0; i < size; i++) \n        printf(\"%d \", arr[i]); \n} \nint main() \n{ \n    int n,i;\n    cin>>n;\n    int arr[n];\n    for(i=0;i<n;i++)\n        cin>>arr[i];\n    quickSort(arr, 0, n - 1);  \n    printArray(arr, n); \n    return 0; \n} \n', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '', 'partition(arr[], lo, hi) \r\n    pivot = arr[hi]\r\n    i = lo    \r\n    for j := lo to hi – 1 do\r\n        if arr[j] <= pivot then\r\n            swap arr[i] with arr[j]\r\n            i = i + 1\r\n    swap arr[i] with arr[hi]\r\n    return i\r\n\r\npartition_r(arr[], lo, hi)\r\n    r = Random Number from lo to hi\r\n    Swap arr[r] and arr[hi]\r\n    return partition(arr, lo, hi)\r\n\r\nquicksort(arr[], lo, hi)\r\n    if lo < hi\r\n        p = partition_r(arr, lo, hi)\r\n        quicksort(arr, p-1, hi)\r\n        quicksort(arr, p+1, hi)\r\n ', '2020-05-25'),
(274, 3, 4101012018, '#include<iostream>\r\nusing namespace std;\r\nvoid swap(int* a, int* b)\r\n{\r\n    int t = *a;\r\n    *a = *b;\r\n    *b = t;\r\n}\r\n\r\nint partition (int arr[], int low, int high)\r\n{\r\n    int pivot = arr[high];\r\n    int i = (low - 1);\r\n\r\n    for (int j = low; j <= high- 1; j++)\r\n    {\r\n\r\n        if (arr[j] <= pivot)\r\n        {\r\n            i++;\r\n            swap(&arr[i], &arr[j]);\r\n        }\r\n    }\r\n    swap(&arr[i + 1], &arr[high]);\r\n    return (i + 1);\r\n}\r\n\r\nvoid quickSort(int arr[], int low, int high)\r\n{\r\n    if (low < high)\r\n    {\r\n\r\n        int pi = partition(arr, low, high);\r\n\r\n        quickSort(arr, low, pi - 1);\r\n        quickSort(arr, pi + 1, high);\r\n    }\r\n}\r\n\r\n\r\nvoid printArray(int arr[], int size)\r\n{\r\n    int i;\r\n    for (i=0; i < size; i++)\r\n        cout<<arr[i]<<\" \";\r\n\r\n}\r\nint main()\r\n{\r\n    int n;\r\n   cin >> n;\r\n   int arr[n];\r\n   for(int i = 0; i<n; i++) {\r\n      cin >> arr[i];\r\n   }\r\n    quickSort(arr, 0, n-1);\r\n    printArray(arr, n);\r\n    return 0;\r\n}\r\n', 10, '1 2000', '2000 ', 'aaa', '0000-00-00'),
(275, 10, 6301012018, '﻿\r\n#include<iostream>\r\nusing namespace std;\r\n  \r\n \r\nint max(int a, int b) { return (a > b)? a : b; } \r\n  \r\n \r\nint knapSack(int W, int wt[], int val[], int n) \r\n{ \r\n   int i, w; \r\n   int K[n+1][W+1]; \r\n  \r\n \r\n   for (i = 0; i <= n; i++) \r\n   { \r\n       for (w = 0; w <= W; w++) \r\n       { \r\n           if (i==0 || w==0) \r\n               K[i][w] = 0; \r\n           else if (wt[i-1] <= w) \r\n                 K[i][w] = max(val[i-1] + K[i-1][w-wt[i-1]],  K[i-1][w]); \r\n           else\r\n                 K[i][w] = K[i-1][w]; \r\n       } \r\n   } \r\n  \r\n   return K[n][W]; \r\n} \r\n  \r\nint main() \r\n{ \r\n    int n,w;\r\n    cin>>n>>w;\r\n    int val[n];\r\n    int wt[n];\r\n    for(int i=0;i<n;i++)\r\n    {\r\n        cin>>val[i];\r\n    } \r\n    for(int i=0;i<n;i++)\r\n    {\r\n        cin>>wt[i];\r\n    } \r\n\r\n    cout<<knapSack(w, wt, val, n); \r\n    return 0; \r\n} ', 10, '5 15 4 2 1 2 10 12 2 1 1 4', '15', '﻿An efficient solution is to use the Greedy approach. The basic idea of the greedy approach is to calculate the ratio value/weight for each item and sort the item on the basis of this ratio. Then take the item with the highest ratio and add them until we can’t add the next item as a whole and at the end add the next item as much as we can. Which will always be the optimal solution to this problem.\r\n\r\n\r\nAlgorithm: Greedy-Fractional-Knapsack (w[1..n], p[1..n], W) \r\nfor i = 1 to n \r\n   do x[i] = 0 \r\nweight = 0 \r\nfor i = 1 to n \r\n   if weight + w[i] ≤ W then  \r\n      x[i] = 1 \r\n      weight = weight + w[i] \r\n   else \r\n      x[i] = (W - weight) / w[i] \r\n      weight = W \r\n      break \r\nreturn x', '2020-05-25'),
(276, 3, 7301012018, '// Java program for implementation of QuickSort \r\nimport java.util.*;\r\nimport java.io.*;\r\n\r\nclass QuickSort \r\n{ \r\n	/* This function takes last element as pivot, \r\n	places the pivot element at its correct \r\n	position in sorted array, and places all \r\n	smaller (smaller than pivot) to left of \r\n	pivot and all greater elements to right \r\n	of pivot */\r\n	int partition(int arr[], int low, int high) \r\n	{ \r\n		int pivot = arr[high]; \r\n		int i = (low-1); // index of smaller element \r\n		for (int j=low; j<high; j++) \r\n		{ \r\n			// If current element is smaller than the pivot \r\n			if (arr[j] < pivot) \r\n			{ \r\n				i++; \r\n\r\n				// swap arr[i] and arr[j] \r\n				int temp = arr[i]; \r\n				arr[i] = arr[j]; \r\n				arr[j] = temp; \r\n			} \r\n		} \r\n\r\n		// swap arr[i+1] and arr[high] (or pivot) \r\n		int temp = arr[i+1]; \r\n		arr[i+1] = arr[high]; \r\n		arr[high] = temp; \r\n\r\n		return i+1; \r\n	} \r\n\r\n\r\n	/* The main function that implements QuickSort() \r\n	arr[] --> Array to be sorted, \r\n	low --> Starting index, \r\n	high --> Ending index */\r\n	void sort(int arr[], int low, int high) \r\n	{ \r\n		if (low < high) \r\n		{ \r\n			/* pi is partitioning index, arr[pi] is \r\n			now at right place */\r\n			int pi = partition(arr, low, high); \r\n\r\n			// Recursively sort elements before \r\n			// partition and after partition \r\n			sort(arr, low, pi-1); \r\n			sort(arr, pi+1, high); \r\n		} \r\n	} \r\n\r\n	/* A utility function to print array of size n */\r\n	static void printArray(int arr[]) \r\n	{ \r\n		int n = arr.length; \r\n		for (int i=0; i<n; ++i) \r\n			System.out.print(arr[i]+\" \"); \r\n		System.out.println(); \r\n	} \r\n\r\n	// Driver program \r\n	public static void main(String args[]) \r\n	{ \r\n	  Scanner s=new Scanner(System.in);\r\n	  int N=s.nextInt();\r\n	  int ar[]=new int[N];\r\n	  \r\n	  for(int i=0;i<N;i++){\r\n	      ar[i]=s.nextInt();\r\n	  }\r\n\r\n		QuickSort ob = new QuickSort(); \r\n		ob.sort(arr, 0, n-1); \r\n\r\n	//	System.out.println(\"sorted array\"); \r\n		printArray(arr); \r\n	} \r\n} \r\n\r\n', 10, '1 2000', '', 'aaa', '0000-00-00'),
(278, 7, 4901012018, '#include<iostream>\r\nusing namespace std;\r\n\r\nvoid swap( int &a, int &b)\r\n{\r\n    int t=a;\r\n    a=b;\r\n    b=t;\r\n}\r\n\r\nint pivot(int arr[], int sPos, int ePos)\r\n{\r\n    \r\n   int p= arr[ePos];\r\n   int i=sPos-1;\r\n   for(int j=sPos;j<=ePos-1;j++)\r\n   {\r\n       if(arr[j]<p)\r\n       {\r\n           i++;\r\n           swap(arr[i], arr[j]);\r\n       }\r\n   }\r\n    \r\n    swap(arr[i+1], arr[ePos]);\r\n    return i+1;\r\n    \r\n}\r\n\r\nvoid quickSort(int arr[], int sPos, int ePos)\r\n{\r\n    \r\n   if(sPos>=ePos)  return;\r\n   int pi= pivot(arr, sPos, ePos);\r\n   quickSort(arr, sPos, pi-1);\r\n   quickSort(arr, pi+1, ePos);\r\n    \r\n}\r\n\r\nint main()\r\n{\r\n    \r\n    int n; cin>>n;\r\n    int arr[n];\r\n    for(int i=0;i<n;i++)\r\n    cin>>arr[i];\r\n    quickSort(arr,0,n-1);\r\n    for(int i=0;i<n;i++) cout<<arr[i]<<\" \";\r\n     \r\n}', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', 'aaa', '2020-03-11'),
(279, 7, 7301012018, '// Java program for implementation of QuickSort \r\nimport java.util.*;\r\nimport java.io.*;\r\n\r\nclass QuickSort \r\n{ \r\n	/* This function takes last element as pivot, \r\n	places the pivot element at its correct \r\n	position in sorted array, and places all \r\n	smaller (smaller than pivot) to left of \r\n	pivot and all greater elements to right \r\n	of pivot */\r\n	int partition(int arr[], int low, int high) \r\n	{ \r\n		int pivot = arr[high]; \r\n		int i = (low-1); // index of smaller element \r\n		for (int j=low; j<high; j++) \r\n		{ \r\n			// If current element is smaller than the pivot \r\n			if (arr[j] < pivot) \r\n			{ \r\n				i++; \r\n\r\n				// swap arr[i] and arr[j] \r\n				int temp = arr[i]; \r\n				arr[i] = arr[j]; \r\n				arr[j] = temp; \r\n			} \r\n		} \r\n\r\n		// swap arr[i+1] and arr[high] (or pivot) \r\n		int temp = arr[i+1]; \r\n		arr[i+1] = arr[high]; \r\n		arr[high] = temp; \r\n\r\n		return i+1; \r\n	} \r\n\r\n\r\n	/* The main function that implements QuickSort() \r\n	arr[] --> Array to be sorted, \r\n	low --> Starting index, \r\n	high --> Ending index */\r\n	void sort(int arr[], int low, int high) \r\n	{ \r\n		if (low < high) \r\n		{ \r\n			/* pi is partitioning index, arr[pi] is \r\n			now at right place */\r\n			int pi = partition(arr, low, high); \r\n\r\n			// Recursively sort elements before \r\n			// partition and after partition \r\n			sort(arr, low, pi-1); \r\n			sort(arr, pi+1, high); \r\n		} \r\n	} \r\n\r\n	/* A utility function to print array of size n */\r\n	static void printArray(int arr[]) \r\n	{ \r\n		int n = arr.length; \r\n		for (int i=0; i<n; ++i) \r\n			System.out.print(arr[i]+\" \"); \r\n		System.out.println(); \r\n	} \r\n\r\n	// Driver program \r\n	public static void main(String args[]) \r\n	{ \r\n	  Scanner s=new Scanner(System.in);\r\n	  int N=s.nextInt();\r\n	  int ar[]=new int[N];\r\n	  \r\n	  for(int i=0;i<N;i++){\r\n	      ar[i]=s.nextInt();\r\n	  }\r\n\r\n		QuickSort ob = new QuickSort(); \r\n		ob.sort(arr, 0, n-1); \r\n\r\n	//	System.out.println(\"sorted array\"); \r\n		printArray(arr); \r\n	} \r\n} \r\n\r\n\r\n', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '', 'aaa', '0000-00-00'),
(280, 8, 4301012018, '\r\nimport java.util.Scanner;\r\n\r\npublic class Main\r\n{\r\n   \r\n   public int[][] multiply(int[][] A, int[][] B)\r\n   {        \r\n       int n = A.length;\r\n       int[][] R = new int[n][n];\r\n       \r\n       if (n == 1)\r\n           R[0][0] = A[0][0] * B[0][0];\r\n       else\r\n       {\r\n           int[][] A11 = new int[n/2][n/2];\r\n           int[][] A12 = new int[n/2][n/2];\r\n           int[][] A21 = new int[n/2][n/2];\r\n           int[][] A22 = new int[n/2][n/2];\r\n           int[][] B11 = new int[n/2][n/2];\r\n           int[][] B12 = new int[n/2][n/2];\r\n           int[][] B21 = new int[n/2][n/2];\r\n           int[][] B22 = new int[n/2][n/2];\r\n\r\n          \r\n           split(A, A11, 0 , 0);\r\n           split(A, A12, 0 , n/2);\r\n           split(A, A21, n/2, 0);\r\n           split(A, A22, n/2, n/2);\r\n           \r\n           split(B, B11, 0 , 0);\r\n           split(B, B12, 0 , n/2);\r\n           split(B, B21, n/2, 0);\r\n           split(B, B22, n/2, n/2);\r\n\r\n           \r\n           int [][] M1 = multiply(add(A11, A22), add(B11, B22));\r\n           int [][] M2 = multiply(add(A21, A22), B11);\r\n           int [][] M3 = multiply(A11, sub(B12, B22));\r\n           int [][] M4 = multiply(A22, sub(B21, B11));\r\n           int [][] M5 = multiply(add(A11, A12), B22);\r\n           int [][] M6 = multiply(sub(A21, A11), add(B11, B12));\r\n           int [][] M7 = multiply(sub(A12, A22), add(B21, B22));\r\n\r\n          \r\n           int [][] C11 = add(sub(add(M1, M4), M5), M7);\r\n           int [][] C12 = add(M3, M5);\r\n           int [][] C21 = add(M2, M4);\r\n           int [][] C22 = add(sub(add(M1, M3), M2), M6);\r\n\r\n           join(C11, R, 0 , 0);\r\n           join(C12, R, 0 , n/2);\r\n           join(C21, R, n/2, 0);\r\n           join(C22, R, n/2, n/2);\r\n       }\r\n          \r\n       return R;\r\n   }\r\n   \r\n   public int[][] sub(int[][] A, int[][] B)\r\n   {\r\n       int n = A.length;\r\n       int[][] C = new int[n][n];\r\n       for (int i = 0; i < n; i++)\r\n           for (int j = 0; j < n; j++)\r\n               C[i][j] = A[i][j] - B[i][j];\r\n       return C;\r\n   }\r\n   \r\n   public int[][] add(int[][] A, int[][] B)\r\n   {\r\n       int n = A.length;\r\n       int[][] C = new int[n][n];\r\n       for (int i = 0; i < n; i++)\r\n           for (int j = 0; j < n; j++)\r\n               C[i][j] = A[i][j] + B[i][j];\r\n       return C;\r\n   }\r\n   \r\n   public void split(int[][] P, int[][] C, int iB, int jB) \r\n   {\r\n       for(int i1 = 0, i2 = iB; i1 < C.length; i1++, i2++)\r\n           for(int j1 = 0, j2 = jB; j1 < C.length; j1++, j2++)\r\n               C[i1][j1] = P[i2][j2];\r\n   }\r\n   \r\n   public void join(int[][] C, int[][] P, int iB, int jB) \r\n   {\r\n       for(int i1 = 0, i2 = iB; i1 < C.length; i1++, i2++)\r\n           for(int j1 = 0, j2 = jB; j1 < C.length; j1++, j2++)\r\n               P[i2][j2] = C[i1][j1];\r\n   }    \r\n\r\n   public static void main (String[] args) \r\n   {\r\n       Scanner scan = new Scanner(System.in);\r\n      \r\n       StrassenMatrixMultiplication s = new StrassenMatrixMultiplication();\r\n      \r\n       int N = scan.nextInt();\r\n      \r\n       int[][] A = new int[N][N];\r\n       for (int i = 0; i < N; i++)\r\n           for (int j = 0; j < N; j++)\r\n               A[i][j] = scan.nextInt();\r\n\r\n       int[][] B = new int[N][N];\r\n       for (int i = 0; i < N; i++)\r\n           for (int j = 0; j < N; j++)\r\n               B[i][j] = scan.nextInt();\r\n\r\n       int[][] C = s.multiply(A, B);\r\n\r\n     \r\n       for (int i = 0; i < N; i++)\r\n       {\r\n           for (int j = 0; j < N; j++)\r\n               System.out.print(C[i][j] +\" \");\r\n	    System.out.println();\r\n           \r\n       }\r\n       System.out.println();\r\n\r\n   }\r\n}', 0, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '', 'Procedure of Strassen matrix multiplication\r\nThere are some procedures:\r\n\r\nDivide a matrix of order of 2*2 recursively till we get the matrix of 2*2.\r\nUse the previous set of formulas to carry out 2*2 matrix multiplication.\r\nIn this eight multiplication and four additions, subtraction are performed.\r\nCombine the result of two matrixes to find the final product or final matrix.\r\nFormulas for Stassen’s matrix multiplication\r\nIn Strassen’s matrix multiplication there are seven multiplication and four addition, subtraction in total.\r\n\r\n    1.	D1 =  (a11 + a22) (b11 + b22)\r\n    2.	D2 =  (a21 + a22).b11\r\n    3.	D3 =  (b12 – b22).a11\r\n    4.	D4 =  (b21 – b11).a22\r\n    5.	D5 =  (a11 + a12).b22\r\n    6.	D6 =  (a21 – a11) . (b11 + b12)\r\n    7.	D7 =  (a12 – a22) . (b21 + b22)\r\n\r\n    C11 = d1 + d4 – d5 + d7\r\n    C12 = d3 + d5\r\n    C21 = d2 + d4\r\n    C22 = d1 + d3 – d2 – d6\r\nAlgorithm for Strassen’s matrix multiplication\r\nAlgorithm Strassen(n, a, b, d)\r\n\r\nbegin \r\n	If n = threshold then compute\r\n		C = a * b is a conventional matrix.\r\n	Else\r\n		Partition a into four sub matrices  a11, a12, a21, a22.\r\n		Partition b into four sub matrices b11, b12, b21, b22.\r\n		Strassen ( n/2, a11 + a22, b11 + b22, d1)\r\n		Strassen ( n/2, a21 + a22, b11, d2)\r\n		Strassen ( n/2, a11, b12 – b22, d3)\r\n		Strassen ( n/2, a22, b21 – b11, d4)\r\n		Strassen ( n/2, a11 + a12, b22, d5)\r\n		Strassen (n/2, a21 – a11, b11 + b22, d6)\r\n		Strassen (n/2, a12 – a22, b21 + b22, d7)\r\n\r\n		C = d1+d4-d5+d7     d3+d5\r\n		d2+d4           d1+d3-d2-d6  \r\n		\r\n	end if\r\n	\r\n	return (C)\r\nend.', '2020-05-25'),
(281, 8, 6501012018, '\r\n#include <iostream>\r\n#include <vector>\r\n#include <cmath>\r\n#include <algorithm>\r\nusing namespace std;\r\n\r\nint nextpowerof2(int k)\r\n{\r\n    return pow(2, int(ceil(log2(k))));\r\n}\r\nvoid display(vector< vector<int>> &matrix, int m, int n)\r\n{\r\n    for (int i = 0; i < m; i++)\r\n    {\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            if (j != 0)\r\n            {\r\n                cout << \"	\";\r\n            }\r\n            cout << matrix[i][j];\r\n        }\r\n        cout << endl;\r\n    }\r\n}\r\n\r\nvoid add(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\r\n{\r\n    int i, j;\r\n\r\n    for (i = 0; i < size; i++)\r\n    {\r\n        for (j = 0; j < size; j++)\r\n        {\r\n            C[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid sub(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\r\n{\r\n    int i, j;\r\n\r\n    for (i = 0; i < size; i++)\r\n    {\r\n        for (j = 0; j < size; j++)\r\n        {\r\n            C[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid STRASSEN_algorithmA(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\r\n{\r\n    //base case\r\n    if (size == 1)\r\n    {\r\n        C[0][0] = A[0][0] * B[0][0];\r\n        return;\r\n    }\r\n    else\r\n    {\r\n        int new_size = size / 2;\r\n        vector<int> z(new_size);\r\n        vector<vector<int>>\r\n            a11(new_size, z), a12(new_size, z), a21(new_size, z), a22(new_size, z),\r\n            b11(new_size, z), b12(new_size, z), b21(new_size, z), b22(new_size, z),\r\n            c11(new_size, z), c12(new_size, z), c21(new_size, z), c22(new_size, z),\r\n            p1(new_size, z), p2(new_size, z), p3(new_size, z), p4(new_size, z),\r\n            p5(new_size, z), p6(new_size, z), p7(new_size, z),\r\n            aResult(new_size, z), bResult(new_size, z);\r\n\r\nint i, j;\r\n\r\n//dividing the matrices into sub-matrices:\r\nfor (i = 0; i < new_size; i++)\r\n        {\r\n            for (j = 0; j < new_size; j++)\r\n            {\r\n                a11[i][j] = A[i][j];\r\n                a12[i][j] = A[i][j + new_size];\r\n                a21[i][j] = A[i + new_size][j];\r\n                a22[i][j] = A[i + new_size][j + new_size];\r\n\r\n                b11[i][j] = B[i][j];\r\n                b12[i][j] = B[i][j + new_size];\r\n                b21[i][j] = B[i + new_size][j];\r\n                b22[i][j] = B[i + new_size][j + new_size];\r\n            }\r\n}\r\n\r\n// Calculating p1 to p7:\r\n\r\n        add(a11, a22, aResult, new_size);     // a11 + a22\r\n        add(b11, b22, bResult, new_size);    // b11 + b22\r\n        STRASSEN_algorithmA(aResult, bResult, p1, new_size); \r\n        // p1 = (a11+a22) * (b11+b22)\r\n\r\n        add(a21, a22, aResult, new_size); // a21 + a22\r\n        STRASSEN_algorithmA(aResult, b11, p2, new_size);\r\n        // p2 = (a21+a22) * (b11)\r\n\r\n        sub(b12, b22, bResult, new_size);      // b12 - b22\r\n        STRASSEN_algorithmA(a11, bResult, p3, new_size);\r\n        // p3 = (a11) * (b12 - b22)\r\n\r\n        sub(b21, b11, bResult, new_size);       // b21 - b11\r\n        STRASSEN_algorithmA(a22, bResult, p4, new_size); \r\n        // p4 = (a22) * (b21 - b11)\r\n\r\n        add(a11, a12, aResult, new_size);      // a11 + a12\r\n        STRASSEN_algorithmA(aResult, b22, p5, new_size);\r\n        // p5 = (a11+a12) * (b22)\r\n\r\n        sub(a21, a11, aResult, new_size);      // a21 - a11\r\n        add(b11, b12, bResult, new_size);               \r\n        // b11 + b12\r\n        STRASSEN_algorithmA(aResult, bResult, p6, new_size);\r\n        // p6 = (a21-a11) * (b11+b12)\r\n\r\n        sub(a12, a22, aResult, new_size);      // a12 - a22\r\n        add(b21, b22, bResult, new_size);                \r\n        // b21 + b22\r\n        STRASSEN_algorithmA(aResult, bResult, p7, new_size);\r\n        // p7 = (a12-a22) * (b21+b22)\r\n\r\n        // calculating c21, c21, c11 e c22:\r\n\r\n        add(p3, p5, c12, new_size); // c12 = p3 + p5\r\n        add(p2, p4, c21, new_size); // c21 = p2 + p4\r\n\r\n        add(p1, p4, aResult, new_size);       // p1 + p4\r\n        add(aResult, p7, bResult, new_size);  // p1 + p4 + p7\r\n        sub(bResult, p5, c11, new_size); // c11 = p1 + p4 - p5 + p7\r\n\r\n        add(p1, p3, aResult, new_size);       // p1 + p3\r\n        add(aResult, p6, bResult, new_size);  // p1 + p3 + p6\r\n        sub(bResult, p2, c22, new_size); // c22 = p1 + p3 - p2 + p6\r\n\r\n        // Grouping the results obtained in a single matrix:\r\n        for (i = 0; i < new_size; i++)\r\n        {\r\n            for (j = 0; j < new_size; j++)\r\n            {\r\n                C[i][j] = c11[i][j];\r\n                C[i][j + new_size] = c12[i][j];\r\n                C[i + new_size][j] = c21[i][j];\r\n                C[i + new_size][j + new_size] = c22[i][j];\r\n            }\r\n        }\r\n    }\r\n}\r\nvoid STRASSEN_algorithm(vector<vector<int>> &A, vector<vector<int>> &B, int m, int n, int a, int b)\r\n{  \r\n/* Check to see if these matrices are already square and have dimensions of a power of 2. If not,\r\n * the matrices must be resized and padded with zeroes to meet this criteria. */\r\n    int k = max({m, n, a, b});\r\n\r\n    int s = nextpowerof2(k);\r\n\r\n    vector<int> z(s);\r\n    vector<vector<int>> Aa(s, z), Bb(s, z), Cc(s, z);\r\n\r\n    for (unsigned int i = 0; i < m; i++)\r\n    {\r\n        for (unsigned int j = 0; j < n; j++)\r\n        {\r\n            Aa[i][j] = A[i][j];\r\n        }\r\n    }\r\n    for (unsigned int i = 0; i < a; i++)\r\n    {\r\n        for (unsigned int j = 0; j < b; j++)\r\n        {\r\n            Bb[i][j] = B[i][j];\r\n        }\r\n    }\r\n    STRASSEN_algorithmA(Aa, Bb, Cc, s);\r\n    vector<int> temp1(b);\r\n    vector<vector<int>> C(m, temp1);\r\n    for (unsigned int i = 0; i < m; i++)\r\n    {\r\n        for (unsigned int j = 0; j < b; j++)\r\n        {\r\n            C[i][j] = Cc[i][j];\r\n        }\r\n    }\r\n    display(C, m, b);\r\n}\r\n\r\nbool check(int n, int a)\r\n{\r\n    if (n == a)\r\n        return true;\r\n    else\r\n        return false;\r\n}\r\n\r\nint main()\r\n{\r\n     int m, n, a, b;\r\n   // cout << \"Matrix Multiplication using Strassen algorithm\" << endl;\r\n//    cout << \"Enter rows and columns of first matrix\" << endl;\r\n    cin >> m;\r\n    n=m;\r\n    //cout << \"enter values into first matrix\" << endl;\r\n    vector<vector<int>> A;\r\n    //first matrix input\r\n    for (int i = 0; i < m; i++)\r\n    {\r\n        vector<int> temp;\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            int i;\r\n            cin >> i;\r\n            temp.push_back(i);\r\n        }\r\n        A.push_back(temp);\r\n    }\r\n    //cout << \"Enter rows and columns of second matrix\" << endl;\r\n     a=m;\r\n    b=a;\r\n    // cout << \"enter values into second matrix\" << endl;\r\n    vector<vector<int>> B;\r\n    //second matrix input\r\n    for (int i = 0; i < a; i++)\r\n    {\r\n        vector<int> temp;\r\n        for (int j = 0; j < b; j++)\r\n        {\r\n            int i;\r\n            cin >> i;\r\n            temp.push_back(i);\r\n        }\r\n        B.push_back(temp);\r\n    }\r\n    bool k = check(n, a);\r\n    if (k)\r\n    {\r\n        STRASSEN_algorithm(A, B, m, n, a, b);\r\n    }\r\n    else\r\n    {\r\n        cout << \"martrix multiplication not possible\";\r\n    }\r\n    return 0;\r\n}\r\n\r\n', 0, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '', '1.	Divide a matrix of order of 2*2 recursively till we get the matrix of 2*2.\r\n2.	Use the previous set of formulas to carry out 2*2 matrix multiplication.\r\n3.	In this eight multiplication and four additions, subtraction are performed.\r\n4.	Combine the result of two matrixes to find the final product or final matrix.\r\nFormulas:\r\nIn Strassen’s matrix multiplication there are seven multiplication and four addition, subtraction in total.\r\n    1.	D1 =  (a11 + a22) (b11 + b22)\r\n    2.	D2 =  (a21 + a22).b11\r\n    3.	D3 =  (b12 – b22).a11\r\n    4.	D4 =  (b21 – b11).a22\r\n    5.	D5 =  (a11 + a12).b22\r\n    6.	D6 =  (a21 – a11) . (b11 + b12)\r\n    7.	D7 =  (a12 – a22) . (b21 + b22)\r\n\r\n    C11 = d1 + d4 – d5 + d7\r\n    C12 = d3 + d5\r\n    C21 = d2 + d4\r\n    C22 = d1 + d3 – d2 – d6\r\nAlgorithm Strassen(n, a, b, d)\r\nbegin \r\n	If n = threshold then compute\r\n		C = a * b is a conventional matrix.\r\n	Else\r\n		Partition a into four sub matrices  a11, a12, a21, a22.\r\n		Partition b into four sub matrices b11, b12, b21, b22.\r\n		Strassen ( n/2, a11 + a22, b11 + b22, d1)\r\n		Strassen ( n/2, a21 + a22, b11, d2)\r\n		Strassen ( n/2, a11, b12 – b22, d3)\r\n		Strassen ( n/2, a22, b21 – b11, d4)\r\n		Strassen ( n/2, a11 + a12, b22, d5)\r\n		Strassen (n/2, a21 – a11, b11 + b22, d6)\r\n		Strassen (n/2, a12 – a22, b21 + b22, d7)\r\n\r\n		C = d1+d4-d5+d7     d3+d5\r\n		d2+d4           d1+d3-d2-d6  \r\n		\r\n	end if\r\n	\r\n	return (C)\r\nend.\r\n\r\n', '2020-05-25'),
(282, 10, 7301012018, '﻿#include <bits/stdc++.h>\r\nusing namespace std;\r\nstruct Item\r\n{\r\n    int value, weight;\r\n};\r\n\r\n\r\nbool cmp(struct Item a, struct Item b)\r\n{\r\n    double r1 = (double)a.value / a.weight;\r\n    double r2 = (double)b.value / b.weight;\r\n    return r1 > r2;\r\n}\r\n\r\n\r\ndouble fractionalKnapsack(int W, struct Item arr[], int n)\r\n{\r\n    sort(arr, arr + n, cmp);\r\n    int curWeight = 0;\r\n    double finalvalue = 0.0;\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        if (curWeight + arr[i].weight <= W)\r\n        {\r\n            curWeight += arr[i].weight;\r\n            finalvalue += arr[i].value;\r\n        }\r\n        else\r\n        {\r\n            int remain = W - curWeight;\r\n            finalvalue += arr[i].value * ((double) remain / arr[i].weight);\r\n            break;\r\n        }\r\n    }\r\n    return finalvalue;\r\n}\r\n\r\n\r\nint main()\r\n{\r\n    int n; cin >> n;\r\n    int W; cin>>W;\r\n    Item* arr = new Item[n];\r\n    for(int i = 0; i < n; i++)\r\n        cin >> arr[i].value;\r\n\r\n\r\n    for(int i = 0; i < n; i++)\r\n        cin >> arr[i].weight;\r\n\r\n\r\n    cout<< fractionalKnapsack(W, arr, n);\r\n    return 0;\r\n}', 2, '5 15 4 2 1 2 10 12 2 1 1 4', '17.3333', '﻿An efficient solution is to use the Greedy approach. The basic idea of the greedy approach is to calculate the ratio value/weight for each item and sort the item on the basis of this ratio. Then take the item with the highest ratio and add them until we can’t add the next item as a whole and at the end add the next item as much as we can. Which will always be the optimal solution to this problem.\r\n\r\n\r\nAlgorithm: Greedy-Fractional-Knapsack (w[1..n], p[1..n], W) \r\nfor i = 1 to n \r\n   do x[i] = 0 \r\nweight = 0 \r\nfor i = 1 to n \r\n   if weight + w[i] ≤ W then  \r\n      x[i] = 1 \r\n      weight = weight + w[i] \r\n   else \r\n      x[i] = (W - weight) / w[i] \r\n      weight = W \r\n      break \r\nreturn x', '2020-05-25'),
(283, 10, 4301012018, '\r\nimport java.util.Scanner;\r\nimport java.util.Arrays; \r\nimport java.util.Comparator; \r\n\r\npublic class Main\r\n{ \r\n	\r\n	public static void main(String[] args) \r\n	{ \r\n	    Scanner sc = new Scanner(System.in);\r\n	    int n = sc.nextInt();\r\n	    int capacity = sc.nextInt();\r\n	    \r\n	    int val[] = new int[n];\r\n        int wt[] = new int[n];\r\n        for(int i = 0; i<= n-1;i++)\r\n        {\r\n            val[i] = sc.nextInt();\r\n        }\r\n        for(int i = 0; i<= n-1;i++)\r\n        {\r\n            wt[i] = sc.nextInt();\r\n        }\r\n		\r\n\r\n		double maxValue = getMaxValue(wt, val, capacity); \r\n		System.out.println(maxValue);\r\n\r\n	} \r\n\r\n\r\n	private static double getMaxValue(int[] wt, int[] val, int capacity) \r\n	{ \r\n		ItemValue[] iVal = new ItemValue[wt.length]; \r\n\r\n		for(int i = 0; i < wt.length; i++) \r\n		{ \r\n			iVal[i] = new ItemValue(wt[i], val[i], i); \r\n		} \r\n\r\n		\r\n		Arrays.sort(iVal, new Comparator<ItemValue>() \r\n		{ \r\n			@Override\r\n			public int compare(ItemValue o1, ItemValue o2) \r\n			{ \r\n				return o2.cost.compareTo(o1.cost) ; \r\n			} \r\n		}); \r\n\r\n\r\n		double totalValue = 0d; \r\n\r\n		for(ItemValue i: iVal) \r\n		{ \r\n\r\n			int curWt = (int) i.wt; \r\n			int curVal = (int) i.val; \r\n\r\n			if (capacity - curWt >= 0) \r\n			{ \r\n				\r\n				capacity = capacity-curWt; \r\n				totalValue += curVal; \r\n\r\n			} \r\n			else\r\n			{ \r\n				\r\n				double fraction = ((double)capacity/(double)curWt); \r\n				totalValue += (curVal*fraction); \r\n				capacity = (int)(capacity - (curWt*fraction)); \r\n				break; \r\n			} \r\n\r\n\r\n		} \r\n\r\n		return totalValue; \r\n	} \r\n\r\n	 \r\n	static class ItemValue \r\n	{ \r\n		Double cost; \r\n		double wt, val, ind; \r\n		\r\n		public ItemValue(int wt, int val, int ind) \r\n		{ \r\n			this.wt = wt; \r\n			this.val = val; \r\n			this.ind = ind; \r\n			cost = new Double(val/wt ); \r\n		} \r\n	} \r\n} \r\n', 0, '5 15 4 2 1 2 10 12 2 1 1 4', '17.333333333333332\n', 'A brute-force solution would be to try all possible subset with all different fraction but that will be too much time taking.\r\n\r\nAn efficient solution is to use Greedy approach. The basic idea of the greedy approach is to calculate the ratio value/weight for each item and sort the item on basis of this ratio. Then take the item with the highest ratio and add them until we can’t add the next item as a whole and at the end add the next item as much as we can. Which will always be the optimal solution to this problem.', '2020-05-25'),
(284, 7, 6801012018, '#include<iostream>\r\n#include<cstdlib>\r\n#include<ctime>\r\n#define MAX 100\r\nusing namespace std;\r\nvoid random_shuffle(int arr[]) {\r\n   //function to shuffle the array elements into random positions\r\n   srand(time(NULL));\r\n   for (int i = MAX - 1; i > 0; i--) {\r\n      int j = rand()%(i + 1);\r\n      int temp = arr[i];\r\n      arr[i] = arr[j];\r\n      arr[j] = temp;\r\n   }\r\n}\r\n// Partitioning the array on the basis of values at high as pivot value.\r\nint Partition(int a[], int low, int high) {\r\n   int pivot, index, i;\r\n   index = low;\r\n   pivot = high;\r\n   for(i=low; i < high; i++) {\r\n      // finding index of pivot.\r\n      if(a[i] < a[pivot]) {\r\n         swap(a[i], a[index]);\r\n         index++;\r\n      }\r\n   }\r\n   swap(a[pivot], a[index]);\r\n   return index;\r\n}\r\nint RandomPivotPartition(int a[], int low, int high){\r\n   // Random selection of pivot.\r\n   int pvt, n, temp;\r\n   n = rand();\r\n   pvt = low + n%(high-low+1); // Randomizing the pivot value from sub-array.\r\n   swap(a[high], a[pvt]);\r\n   return Partition(a, low, high);\r\n}\r\nvoid quick_sort(int arr[], int p, int q) {\r\n   //recursively sort the list\r\n   int pindex;\r\n   if(p < q) {\r\n      pindex = RandomPivotPartition(arr, p, q); //randomly choose pivot\r\n      // Recursively implementing QuickSort.\r\n      quick_sort(arr, p, pindex-1);\r\n    quick_sort(arr, pindex+1, q);\r\n}\r\n}\r\nint main() {\r\nint i;\r\nint arr[MAX];\r\nfor (i = 0;i < MAX; i++)\r\narr[i] = i + 1;\r\nrandom_shuffle(arr); //To randomize the array\r\nquick_sort(arr, 0, MAX - 1); //sort the elements of array\r\nfor (i = 0; i < MAX; i++)\r\ncout << arr[i] << \" \";\r\ncout << endl;\r\nreturn 0;\r\n', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '', 'empty algorithm!', '0000-00-00'),
(285, 8, 6901012018, '#include<iostream.h>\r\n#include<conio.h>\r\nvoid main()\r\n{\r\n	clrscr();\r\n	int n,mat1[n][n], mat2[n][n], mat3[n][n], sum=0, i, j, k;\r\n	\r\n	cin>>n;\r\n	\r\n	for(i=0; i<n; i++)\r\n	{\r\n		for(j=0; j<n; j++)\r\n		{\r\n			cin>>mat1[i][j];\r\n		}\r\n	}\r\n	\r\n	for(i=0; i<n; i++)\r\n	{\r\n		for(j=0; j<n; j++)\r\n		{\r\n			cin>>mat2[i][j];\r\n		}\r\n	}\r\n\r\n	for(i=0; i<n; i++)\r\n	{\r\n		for(j=0; j<n; j++)\r\n		{\r\n			sum=0;\r\n			for(k=0; k<n; k++)\r\n			{\r\n				sum = sum + mat1[i][k] * mat2[k][j];\r\n			}\r\n			mat3[i][j] = sum;\r\n		}\r\n	}\r\n\r\n	for(i=0; i<n; i++)\r\n	{\r\n		for(j=0; j<n; j++)\r\n		{\r\n			cout<<mat3[i][j]<<\" \";\r\n		}\r\n		cout<<\" \";\r\n	}\r\n	getch();\r\n}', 10, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '', 'empty algorithm!', '0000-00-00'),
(286, 14, 6901012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n   \r\nvoid BellmanFord(int graph[][3], int V, int E, \r\n                 int src) \r\n{ \r\n    \r\n    int dis[V]; \r\n    for (int i = 0; i < V; i++) \r\n        dis[i] = INT_MAX; \r\n  \r\n    // initialize distance of source as 0 \r\n    dis[src] = 0; \r\n  \r\n \r\n    for (int i = 0; i < V - 1; i++) { \r\n  \r\n        for (int j = 0; j < E; j++) { \r\n            if (dis[graph[j][0]] + graph[j][2] < \r\n                               dis[graph[j][1]]) \r\n                dis[graph[j][1]] =  \r\n                  dis[graph[j][0]] + graph[j][2]; \r\n        } \r\n    } \r\n \r\n    for (int i = 0; i < E; i++) { \r\n        int x = graph[i][0]; \r\n        int y = graph[i][1]; \r\n        int weight = graph[i][2]; \r\n        if (dis[x] != INT_MAX && \r\n                   dis[x] + weight < dis[y]) \r\n            cout << \"Graph contains negative\"\r\n                    \" weight cycle\"\r\n                 << endl; \r\n    } \r\n  \r\n    cout << \"Vertex Distance from Source\" << endl; \r\n    for (int i = 0; i < V; i++) \r\n        cout << i << \"		\" << dis[i] << endl; \r\n} \r\n  \r\nint main() \r\n{ \r\n    int V = 5; // Number of vertices in graph \r\n    int E = 8; // Number of edges in graph \r\n  \r\n    // Every edge has three values (u, v, w) where \r\n    // the edge is from vertex u to v. And weight \r\n    // of the edge is w. \r\n    int graph[][3] = { { 0, 1, -1 }, { 0, 2, 4 }, \r\n                       { 1, 2, 3 }, { 1, 3, 2 },  \r\n                       { 1, 4, 2 }, { 3, 2, 5 },  \r\n                       { 3, 1, 1 }, { 4, 3, -3 } }; \r\n  \r\n    BellmanFord(graph, V, E, 0); \r\n    return 0; \r\n} ', 0, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '', 'empty algorithm!', '0000-00-00');
INSERT INTO `qtos_map` (`ID`, `Q_ID`, `ROLL`, `SUBMISSION`, `SCORE`, `INPUT`, `OP`, `ALGO`, `DATE`) VALUES
(287, 10, 4001012018, '#include <bits/stdc++.h> \r\n  \r\nusing namespace std; \r\n  \r\nstruct Item \r\n{ \r\n    int value, weight; \r\n    Item(int value, int weight) : value(value), weight(weight) \r\n    {} \r\n}; \r\n  \r\n\r\nbool cmp(struct Item a, struct Item b) \r\n{ \r\n    double r1 = (double)a.value / a.weight; \r\n    double r2 = (double)b.value / b.weight; \r\n    return r1 > r2; \r\n} \r\n\r\ndouble fractionalKnapsack(int W, struct Item arr[], int n) \r\n{ \r\n    sort(arr, arr + n, cmp); \r\n    for (int i = 0; i < n; i++) \r\n    { \r\n        cout << arr[i].value << \"  \" << arr[i].weight << \" : \" \r\n             << ((double)arr[i].value / arr[i].weight) << endl; \r\n    } \r\n    \r\n  \r\n    int curWeight = 0;  \r\n    double finalvalue = 0.0; \r\n\r\n    for (int i = 0; i < n; i++) \r\n    { \r\n        if (curWeight + arr[i].weight <= W) \r\n        { \r\n            curWeight += arr[i].weight; \r\n            finalvalue += arr[i].value; \r\n        } \r\n        else\r\n        { \r\n            int remain = W - curWeight; \r\n            finalvalue += arr[i].value * ((double) remain / arr[i].weight); \r\n            break; \r\n        } \r\n    } \r\n    return finalvalue; \r\n} \r\nint main() \r\n{ \r\n   int t;\r\ncin>>t;\r\nwhile(t!=0){\r\nint w,n;\r\ncin>>w>>n;\r\nItem arr[n];\r\nfor(int i=0;i<n;i++){\r\ncin>>arr[i].value;\r\ncin>>arr[i].weight;\r\n}\r\n\r\n    cout << fractionalKnapsack(w, arr, n)<<endl; \r\nt--;\r\n}\r\n    return 0; \r\n} ', 0, '5 15 4 2 1 2 10 12 2 1 1 4', '-1962933878 -1962933878 -1175125013 -1157627717 -1073741807 -905969462 -905969462 -838860084 -838860084 -838860084 -838860084 -194488364 -194488364 -134217223 -17974607 -17974607 -65536 -688 -367 -190 -187 -183 -2 -2 -2 -2 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 4 5 5 8 9 9 9 10 10 10 13 14 16 16 16 16 17 17 17 17 18 18 18 18 20 22 22 24 24 24 24 24 24 24 24 24 25 28 28 31 31 31 31 32 32 32 32 32 32 33 44 44 50 63 64 64 64 66 70 80 80 100 100 115 115 115 115 127 127 127 127 127 127 127 127 127 127 127 127 127 127 127 127 127 127 127 127 127 128 128 128 143 160 164 183 183 183 187 216 224 224 236 236 255 255 255 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 280 391 452 462 512 512 512 512 532 628 716 736 909 909 909 909 996 1252 1252 1252 1395 1905 1905 1905 1952 1952 1952 1952 2000 4096 4100 7956 7968 8016 13084 13084 52428 52428 55297 65568 65568 131072 131097 196610 196610 262144 327684 327684 393743 458758 458758 589832 589832 655360 655360 655596 655596 655612 655612 661336 661336 661336 663128 663208 663216 720906 720906 851980 851980 983054 983054 983054 983054 1114128 1114128 1245202 1245202 1310738 1376276 1376276 1507350 1507350 1638424 1638424 1769498 1769498 1900572 1900572 2031646 2031646 2097152 2162720 2162720 2293794 2293794 2424868 2424868 2555942 2555942 2621442 2687016 2687016 2818090 2818090 2949164 2949164 3006464 3006464 3006464 3006464 3018752 3018752 3018752 3018752 3018752 3080238 3080238 3145776 3211312 3211312 3276848 3342386 3342386 3473460 3473460 3538992 3604534 3604534 3735608 3735608 3866682 3866682 3997756 3997756 4128830 4128830 4199040 4199040 4199040 4199040 4199822 4201088 4259904 4259904 4259936 4295123 4295123 4336627 4336627 4338772 4338873 4338873 4362768 4383243 4390978 4390978 4390978 4391004 4391004 4510886 4510942 4522052 4522052 4522052 4587568 4653126 4653126 4653126 4659728 4665628 4665628 4711456 4711456 4711456 4711456 4711456 4711456 4711456 4712704 4712712 4712712 4712712 4712712 4712712 4712712 4712712 4732986 4733024 4784200 4784200 4784200 4915274 4915274 4915274 5046348 5046348 5046348 5111900 5177422 5177422 5177422 5308496 5308496 5308496 5374044 5439570 5439570 5439570 5439580 5439596 5570644 5570644 5570644 5636188 5701718 5701718 5701718 5832792 5832792 5832792 5963866 5963866 6029413 6029433 6094940 6094940 6226014 6226014 6357069 6357088 6488162 6619236 6619250 6750309 6750310 6750318 6815843 6881329 6881384 6881395 6881396 6939540 6940492 6940564 6940588 6940628 6940636 6940644 6940648 6940673 6940684 6940728 6940728 6940728 6940812 6940812 6940872 6940872 6940876 6940884 6940912 6940924 6940936 6940944 6940944 6940972 6941044 6941100 6941172 6941185 6941212 6941244 6941248 6941256 6941268 6941308 6941316 6941324 6941328 6941352 6941364 6941408 6941408 6941408 6941408 6941492 6941492 6941492 6941552 6941552 6941552 6941564 6941604 6941652 6941724 6941724 6941752 6941752 6941768 6941768 6941768 6941800 6941892 6941908 6941940 6941956 6941976 6941988 6942004 6942004 6942008 6942032 6942032 6942048 6942048 6942084 6942264 6942280 6942280 6942304 6942312 6942312 6942312 6942312 6942312 6942312 6942424 6942432 6942432 6942458 6942624 6942632 6942632 6942684 6942684 6942684 6942688 6942688 6942724 6942724 6942758 6942808 6942824 6942840 6942840 6942840 6942840 6942840 6943180 6943184 6943200 6943204 6943308 6943448 6943448 6943452 6943492 6943508 6943823 6943823 6943823 6943824 6944100 6944100 6944100 6944100 6944257 6944340 6944356 6944376 6944376 6944376 6944376 6944408 6944428 6944436 6944472 6944492 6944512 6944512 6944512 6944512 6944512 6944520 6944584 6944584 6944612 6944612 6944664 6944672 6944720 6944720 6944720 6944720 6944720 6944720 6944752 6944777 6944804 6944872 6944916 6944984 6945072 6945104 6945140 6945216 6945232 6945296 6945312 6945340 6945500 6945536 6945628 6945644 6945648 6945656 6945664 6945680 6945684 6945712 6945716 6945760 6945832 6945840 6945840 6945892 6945904 6945932 6945940 6945956 6945964 6945984 6946024 6946080 6946140 6946216 6946216 6946264 6946264 6946272 6946316 6946316 6946316 6946316 6946316 6946316 6946376 6946376 6946376 6946376 6946376 6946376 6946380 6946380 6946384 6946384 6946408 6946408 6946440 6946444 6946444 6946444 6946444 6946444 6946444 6946444 6946528 6946764 6946764 6946764 7012458 7077999 7143525 7143532 7209065 7209071 7209071 7274563 7274606 7274610 7405680 7471205 7471215 7471220 7471220 7471221 7536745 7536748 7536754 7602277 7602286 7602286 7602291 7667712 7667712 7667712 7667712 7667712 7667712 7667712 7667712 7667712 7667712 7667712 7667712 7667712 7667712 7667828 7667904 7667904 7668336 7668400 7668400 7679680 7679704 7680440 7680592 7680592 7680592 7680592 7680652 7680912 7680936 7680944 7681976 7681976 7683112 7683112 7683120 7683120 7683120 7683576 7683600 7683600 7689504 7690000 7798902 7929939 7929976 8061018 8061050 8192124 8192124 8323198 8323198 8388608 8388618 8462508 8462508 9240914 9372029 9437326 10289490 10551456 10682530 10813604 10944678 11075752 11206826 11337900 11468974 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534336 11534416 11534528 11534528 11534528 11534528 11534528 11534528 11534528 11534707 11534960 11534960 11534960 11534960 11535024 11535052 11535124 11535528 11535528 11535536 11535542 11535544 11535544 11535544 11535552 11535552 11535768 11535800 11536356 11537616 11537616 11537616 11537624 11537624 11537648 11537656 11537760 11537760 11537760 11537760 11537768 11537768 11537768 11537768 11537768 11537768 11537780 11537784 11537816 11538008 11538008 11538008 11538752 11538752 11538760 11538760 11538760 11538760 11538760 11538976 11539120 11539120 11539120 11539148 11541460 11541568 11541576 11543624 11543632 11543632 11543638 11547736 11547736 11547736 11547736 11547736 11547744 11547744 11547744 11547744 11547744 11547744 11555704 11555928 11555928 11557256 11562976 11600048 11731122 11862196 11993270 12124344 12255418 12386492 12517566 12648640 12648640 12779714 12779714 12910788 12910788 13041862 13041862 13041862 13172936 13172936 13303857 13304010 13304010 13435084 13435084 13566158 13566158 13697232 13697232 13828306 13828306 13828306 13959380 13959380 14090454 14090454 14221528 14221528 14352602 14352602 14483676 14483676 14614750 15532268 15663342 15794416 15925490 16056564 16187606 16187638 16318712 16449786 16580860 16711934 16777216 16777244 16777244 16777472 16777504 16777523 16777570 16777596 16777596 16842888 16883776 16907328 16907360 20976256 24641758 24641917 26288154 26353690 28332000 33554434 33554434 33554944 33619971 34603520 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603552 34603592 34603592 34603777 34603777 34603777 34603778 34603778 34603794 34603794 34865190 34865680 34865684 35652096 35652112 35652128 35652128 35652128 35652128 35652128 35652128 35652128 35652128 35652128 35652128 35652128 35652128 35652168 35652353 35652353 35652354 36176424 36176424 36700688 37076676 37076676 37076676 37076676 37076676 40370720 42205828 42205828 42205828 42205828 42205828 50331651 50331651 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397954 50398081 50463248 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463618 51511824 58786320 58786689 58786689 58851856 58852226 58852226 83886085 83886085 83886085 178619701 178619701 178620149 178620149 214748364 285212689 285212689 318767123 385941526 469762076 520093727 538189843 538443920 538443920 538714137 538714137 539041824 539041824 539107357 539107357 539369502 539369502 540017350 540017350 540606816 540672352 555877084 589431474 754974765 754974765 754974765 822215426 956301369 1423598602 1423598698 1423598698 1423600150 1912602995 1912602995 1912602995 1912602995 1912602995 1912602995 1912603505 1999264796 1999264796 1999264796 1999264842 1999264844 1999265252 1999265264 1999265384 1999883395 1999883437 1999884052 1999884173 1999913350 1999913350 1999939454 1999939535 1999939705 1999940023 1999940834 1999940858 1999970277 2005641531 2005656460 2005656595 2005691061 2005691360 2005691553 2005691603 2005691684 2005716160 2005757941 2006073464 2006074880 2006074880 2006074880 2006077888 2006084864 2006084992 2006084992 2007433216 2007433216 2007439896 2007440816 2007453232 2007469464 2007469464 2007651659 2007661828 2007662726 2007663020 2007665950 2007666073 2007666613 2007666613 2007666707 2007667850 2007667850 2007669099 2007669099 2007669440 2007669440 2007675087 2007675087 2007678700 2007680720 2007680720 2007680720 2007682368 2007682368 2007682368 2007683615 2007683615 2007683615 2007683615 2007683615 2007683615 2007683615 2007683615 2007683615 2007689248 2007689881 2007695327 2007726727 2007808051 2007808051 2007808051 2007808051 2007808051 2007808051 2007808051 2007827065 2007827065 2007827065 2007839323 2007891968 2007899900 2007899948 2007899948 2007900028 2007900028 2007900220 2007919848 2007919944 2007922144 2007922144 2007932992 2007932992 2007932992 2007939727 2007941332 2007941398 2007985579 2007985579 2007985618 2007985618 2008149701 2008149711 2008149751 2008153370 2008153557 2008155634 2008156432 2008418957 2008419042 2008606084 2008606084 2008606084 2008606084 2098388789 2105213097 2105221429 2105221717 2105221893 2105222037 2105222169 2105222305 2105222593 2105222633 2105222721 2105222833 2105223073 2105223521 2105223577 2105223641 2105226313 2105226621 2105226905 2105227413 2147352624 2147483647 \n', 'A disjoint-set data structure is a data structure that keeps track of a set of elements partitioned into a number of disjoint (non-overlapping) subsets. A union-find algorithm is an algorithm that performs two useful operations on such a data structure:\r\n\r\nFind: Determine which subset a particular element is in. This can be used for determining if two elements are in the same subset.\r\n\r\nUnion: Join two subsets into a single subset.', '2020-05-25'),
(288, 7, 6901012018, '#include<iostream>\r\n#include<cstdlib>\r\n#include<ctime>\r\n#define MAX 100\r\nusing namespace std;\r\nvoid random_shuffle(int arr[]) {\r\n   //function to shuffle the array elements into random positions\r\n   srand(time(NULL));\r\n   for (int i = MAX - 1; i > 0; i--) {\r\n      int j = rand()%(i + 1);\r\n      int temp = arr[i];\r\n      arr[i] = arr[j];\r\n      arr[j] = temp;\r\n   }\r\n}\r\n// Partitioning the array on the basis of values at high as pivot value.\r\nint Partition(int a[], int low, int high) {\r\n   int pivot, index, i;\r\n   index = low;\r\n   pivot = high;\r\n   for(i=low; i < high; i++) {\r\n      // finding index of pivot.\r\n      if(a[i] < a[pivot]) {\r\n         swap(a[i], a[index]);\r\n         index++;\r\n      }\r\n   }\r\n   swap(a[pivot], a[index]);\r\n   return index;\r\n}\r\nint RandomPivotPartition(int a[], int low, int high){\r\n   // Random selection of pivot.\r\n   int pvt, n, temp;\r\n   n = rand();\r\n   pvt = low + n%(high-low+1); // Randomizing the pivot value from sub-array.\r\n   swap(a[high], a[pvt]);\r\n   return Partition(a, low, high);\r\n}\r\nvoid quick_sort(int arr[], int p, int q) {\r\n   //recursively sort the list\r\n   int pindex;\r\n   if(p < q) {\r\n      pindex = RandomPivotPartition(arr, p, q); //randomly choose pivot\r\n      // Recursively implementing QuickSort.\r\n      quick_sort(arr, p, pindex-1);\r\n    quick_sort(arr, pindex+1, q);\r\n}\r\n}\r\nint main() {\r\nint i;\r\nint arr[MAX];\r\nfor (i = 0;i < MAX; i++)\r\narr[i] = i + 1;\r\nrandom_shuffle(arr); //To randomize the array\r\nquick_sort(arr, 0, MAX - 1); //sort the elements of array\r\nfor (i = 0; i < MAX; i++)\r\ncout << arr[i] << \" \";\r\ncout << endl;\r\nreturn 0;\r\n}', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 \n', 'empty algorithm!', '0000-00-00'),
(289, 14, 6801012018, '#include <bits/stdc++.h> \r\nusing namespace std;  \r\n\r\nstruct Edge { \r\n    int src, dest, weight; \r\n}; \r\n  \r\nstruct Graph { \r\n    int V, E; \r\n    struct Edge* edge; \r\n}; \r\n  \r\nstruct Graph* createGraph(int V, int E) \r\n{ \r\n    struct Graph* graph = new Graph; \r\n    graph->V = V; \r\n    graph->E = E; \r\n    graph->edge = new Edge[E]; \r\n    return graph; \r\n} \r\n  \r\nvoid printArr(int dist[], int n) \r\n{ \r\n    printf(\"Vertex   Distance from Source\n\"); \r\n    for (int i = 0; i < n; ++i) \r\n        printf(\"%d 		 %d\n\", i, dist[i]); \r\n} \r\n  \r\nvoid BellmanFord(struct Graph* graph, int src) \r\n{ \r\n    int V = graph->V; \r\n    int E = graph->E; \r\n    int dist[V]; \r\n \r\n    for (int i = 0; i < V; i++) \r\n        dist[i] = INT_MAX; \r\n    dist[src] = 0; \r\n \r\n    for (int i = 1; i <= V - 1; i++) { \r\n        for (int j = 0; j < E; j++) { \r\n            int u = graph->edge[j].src; \r\n            int v = graph->edge[j].dest; \r\n            int weight = graph->edge[j].weight; \r\n            if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) \r\n                dist[v] = dist[u] + weight; \r\n        } \r\n    } \r\n  \r\n   \r\n    for (int i = 0; i < E; i++) { \r\n        int u = graph->edge[i].src; \r\n        int v = graph->edge[i].dest; \r\n        int weight = graph->edge[i].weight; \r\n        if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) { \r\n            printf(\"Graph contains negative weight cycle\"); \r\n            return; \r\n        } \r\n    } \r\n  \r\n    printArr(dist, V); \r\n  \r\n    return; \r\n} \r\n\r\nint main() \r\n{ \r\n    int V = 5;\r\n    int E=8;\r\n    struct Graph* graph = createGraph(V, E); \r\n  \r\n    graph->edge[0].src = 0; \r\n    graph->edge[0].dest = 1; \r\n    graph->edge[0].weight = -1; \r\n  \r\n \r\n    graph->edge[1].src = 0; \r\n    graph->edge[1].dest = 2; \r\n    graph->edge[1].weight = 4; \r\n  \r\n    graph->edge[2].src = 1; \r\n    graph->edge[2].dest = 2; \r\n    graph->edge[2].weight = 3; \r\n  \r\n    graph->edge[3].src = 1; \r\n    graph->edge[3].dest = 3; \r\n    graph->edge[3].weight = 2; \r\n  \r\n    graph->edge[4].src = 1; \r\n    graph->edge[4].dest = 4; \r\n    graph->edge[4].weight = 2; \r\n  \r\n    graph->edge[5].src = 3; \r\n    graph->edge[5].dest = 2; \r\n    graph->edge[5].weight = 5; \r\n  \r\n    graph->edge[6].src = 3; \r\n    graph->edge[6].dest = 1; \r\n    graph->edge[6].weight = 1; \r\n  \r\n    graph->edge[7].src = 4; \r\n    graph->edge[7].dest = 3; \r\n    graph->edge[7].weight = -3; \r\n  \r\n    BellmanFord(graph, 0); \r\n  \r\n    return 0; \r\n} ', 1000, '8 a b c d e f g h 1 1 2 3 5 8 13 21', '', 'This algorithm detects the negative cycle in a graph and reports their existence.\r\n\r\nBased on the \"Principle of Relaxation\" in which more accurate values gradually recovered an approximation to the proper distance by until eventually reaching the optimum solution.\r\n\r\nGiven a weighted directed graph G = (V, E) with source s and weight function w: E → R, the Bellman-Ford algorithm returns a Boolean value indicating whether or not there is a negative weight cycle that is attainable from the source. If there is such a cycle, the algorithm produces the shortest paths and their weights. The algorithm returns TRUE if and only if a graph contains no negative - weight cycles that are reachable from the source.', '2020-05-25'),
(290, 10, 6801012018, '#include <bits/stdc++.h> \r\n  \r\nusing namespace std; \r\n  \r\nstruct Item \r\n{ \r\n    int value, weight; \r\n    Item(int value, int weight) : value(value), weight(weight) \r\n    {} \r\n}; \r\n  \r\n\r\nbool cmp(struct Item a, struct Item b) \r\n{ \r\n    double r1 = (double)a.value / a.weight; \r\n    double r2 = (double)b.value / b.weight; \r\n    return r1 > r2; \r\n} \r\n\r\ndouble fractionalKnapsack(int W, struct Item arr[], int n) \r\n{ \r\n    sort(arr, arr + n, cmp); \r\n    for (int i = 0; i < n; i++) \r\n    { \r\n        cout << arr[i].value << \"  \" << arr[i].weight << \" : \" \r\n             << ((double)arr[i].value / arr[i].weight) << endl; \r\n    } \r\n    \r\n  \r\n    int curWeight = 0;  \r\n    double finalvalue = 0.0; \r\n\r\n    for (int i = 0; i < n; i++) \r\n    { \r\n        if (curWeight + arr[i].weight <= W) \r\n        { \r\n            curWeight += arr[i].weight; \r\n            finalvalue += arr[i].value; \r\n        } \r\n        else\r\n        { \r\n            int remain = W - curWeight; \r\n            finalvalue += arr[i].value * ((double) remain / arr[i].weight); \r\n            break; \r\n        } \r\n    } \r\n    return finalvalue; \r\n} \r\nint main() \r\n{ \r\n   int t;\r\ncin>>t;\r\nwhile(t!=0){\r\nint w,n;\r\ncin>>w>>n;\r\nItem arr[n];\r\nfor(int i=0;i<n;i++){\r\ncin>>arr[i].value;\r\ncin>>arr[i].weight;\r\n}\r\n\r\n    cout << fractionalKnapsack(w, arr, n)<<endl; \r\nt--;\r\n}\r\n    return 0; \r\n} ', 0, '5 15 4 2 1 2 10 12 2 1 1 4', '', 'Approach: A simple solution is to consider all subsets of items and calculate the total weight and value of all subsets. Consider the only subsets whose total weight is smaller than W. From all such subsets, pick the maximum value subset.\r\nOptimal Sub-structure: To consider all subsets of items, there can be two cases for every item.\r\n\r\nCase 1: The item is included in the optimal subset.\r\nCase 2: The item is not included in the optimal set.\r\nTherefore, the maximum value that can be obtained from ‘n’ items is the max of the following two values.\r\n\r\n1.Maximum value obtained by n-1 items and W weight (excluding nth item).\r\n2.Value of nth item plus maximum value obtained by n-1 items and W minus the weight of the nth item (including nth item).\r\nIf the weight of ‘nth’ item is greater than ‘W’, then the nth item cannot be included and Case 1 is the only possibility.', '2020-05-25'),
(291, 7, 6601012018, '#include<iostream>\r\nusing namespace std;\r\nvoid swap(int* a, int* b)  \r\n{  \r\n    int t = *a;  \r\n    *a = *b;  \r\n    *b = t;  \r\n}  \r\nint partition (int arr[], int low, int high)  \r\n{  \r\n    int pivot = arr[high]; \r\n    int i = (low - 1); \r\n    for (int j=low;j<=high-1;j++)  \r\n    {  \r\n        if (arr[j]<=pivot)  \r\n        {  \r\n            i++;   \r\n            swap(&arr[i], &arr[j]);  \r\n        }  \r\n    }  \r\n    swap(&arr[i+1],&arr[high]);  \r\n    return (i+1);  \r\n}  \r\nvoid quickSort(int arr[], int low, int high)  \r\n{  \r\n    if (low < high)  \r\n    {  \r\n    \r\n        int pi = partition(arr, low, high);  \r\n        quickSort(arr, low, pi - 1);  \r\n        quickSort(arr, pi, high);  \r\n    }  \r\n}  \r\nvoid printArray(int arr[], int size)  \r\n{  \r\n    for (int i=0;i<size;i++)\r\n    {\r\n        cout<<arr[i]<<\" \";\r\n    }\r\n}  \r\nint main()\r\n{\r\n   int n;\r\n   cin>>n;\r\n   int a[n];\r\n   for(int i=0;i<n;i++)\r\n   {\r\n       cin>>a[i];\r\n   }\r\n   quickSort(a,0,n-1);\r\n   printArray(a,n);\r\n}', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', 'empty algorithm!', '0000-00-00'),
(292, 13, 4401012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n  \r\n#define V 5  \r\n  \r\nint minKey(int key[], bool mstSet[])  \r\n{  \r\n    int min = INT_MAX, min_index;  \r\n  \r\n    for (int v = 0; v < V; v++)  \r\n        if (mstSet[v] == false && key[v] < min)  \r\n            min = key[v], min_index = v;  \r\n  \r\n    return min_index;  \r\n}  \r\n   \r\nvoid printMST(int parent[], int graph[V][V])  \r\n{  \r\n    cout<<\"Edge 	Weight\n\";  \r\n    for (int i = 1; i < V; i++)  \r\n        cout<<parent[i]<<\" - \"<<i<<\" 	\"<<graph[i][parent[i]]<<\" \n\";  \r\n}  \r\nvoid primMST(int graph[V][V])  \r\n{  \r\n    int parent[V];  \r\n    \r\n    int key[V];  \r\n    bool mstSet[V];  \r\n    for (int i = 0; i < V; i++)  \r\n        key[i] = INT_MAX, mstSet[i] = false;  \r\n   \r\n    key[0] = 0;  \r\n    parent[0] = -1; \r\n  \r\n    for (int count = 0; count < V - 1; count++) \r\n    {   \r\n        int u = minKey(key, mstSet); \r\n        mstSet[u] = true;  \r\n        for (int v = 0; v < V; v++)   \r\n            if (graph[u][v] && mstSet[v] == false && graph[u][v] < key[v])  \r\n                parent[v] = u, key[v] = graph[u][v];  \r\n    }   \r\n    printMST(parent, graph);  \r\n}  \r\nint main()  \r\n{  \r\n    int graph[V][V] = { { 0, 2, 0, 6, 0 },  \r\n                        { 2, 0, 3, 8, 5 },  \r\n                        { 0, 3, 0, 0, 7 },  \r\n                        { 6, 8, 0, 0, 9 },  \r\n                        { 0, 5, 7, 9, 0 } };  \r\n \r\n    primMST(graph);  \r\n  \r\n    return 0;  \r\n}  ', 1000, '8 a b c d e f g h 1 1 2 3 5 8 13 21', '', 'Algorithm\r\n1) Create a set mstSet that keeps track of vertices already included in MST.\r\n2) Assign a key value to all vertices in the input graph. Initialize all key values as INFINITE. Assign key value as 0 for the first vertex so that it is picked first.\r\n3) While mstSet doesn’t include all vertices\r\n….a) Pick a vertex u which is not there in mstSet and has minimum key value.\r\n….b) Include u to mstSet.\r\n….c) Update key value of all adjacent vertices of u. To update the key values, iterate through all adjacent vertices. For every adjacent vertex v, if weight of edge u-v is less than the previous key value of v, update the key value as weight of u-v\r\n', '2020-05-25'),
(293, 10, 6501012018, 'import java.util.Arrays; \r\nimport java.util.Comparator; \r\n  \r\npublic class Main\r\n{ \r\n    public static void main(String[] args) \r\n    { \r\n  Scanner s=new Scanner(System.in);\r\nint n=s.nextInt();\r\nint W=s.nextInt();\r\nint[] val = new int[n];\r\nfor(int i=0;i<n;i++)val[i]=s.nextInt();\r\nint[] wt = new int[n]; \r\n\r\nfor(int i=0;i<n;i++)wt[i]=s.nextInt();        \r\n\r\n         \r\n       \r\n  \r\n        double maxValue = getMaxValue(wt, val,W); \r\n        System.out.print(maxValue); \r\n  \r\n    } \r\n    public static double getMaxValue(int[] wt, \r\n                        int[] val, int capacity) \r\n    { \r\n        ItemValue[] iVal = new ItemValue[wt.length]; \r\n  \r\n        for(int i = 0; i < wt.length; i++) \r\n        { \r\n            iVal[i] = new ItemValue(wt[i], val[i], i); \r\n        } \r\n        Arrays.sort(iVal, new Comparator<ItemValue>()  \r\n        { \r\n            @Override\r\n            public int compare(ItemValue o1, ItemValue o2)  \r\n            { \r\n                return o2.cost.compareTo(o1.cost) ; \r\n            } \r\n        }); \r\n  \r\n  \r\n        double totalValue = 0d; \r\n  \r\n        for(ItemValue i: iVal) \r\n        { \r\n  \r\n            int curWt = (int) i.wt; \r\n            int curVal = (int) i.val; \r\n  \r\n            if (capacity - curWt >= 0) \r\n            { \r\n                capacity = capacity-curWt; \r\n                totalValue += curVal; \r\n  \r\n            } \r\n            else\r\n            { \r\n                double fraction = ((double)capacity/(double)curWt); \r\n                totalValue += (curVal*fraction); \r\n                capacity = (int)(capacity - (curWt*fraction)); \r\n                break; \r\n            } \r\n  \r\n  \r\n        } \r\n  \r\n        return totalValue; \r\n    } \r\n  \r\n    public static class ItemValue  \r\n    { \r\n        Double cost; \r\n        double wt, val, ind; \r\n          \r\n        public ItemValue(int wt, int val, int ind) \r\n        { \r\n            this.wt = wt; \r\n            this.val = val; \r\n            this.ind = ind; \r\n            cost = new Double(val/wt ); \r\n        } \r\n    } \r\n} ', 0, '5 15 4 2 1 2 10 12 2 1 1 4', '', 'Algo:\r\n\r\nThe basic idea of the greedy approach is to calculate the ratio value/weight for each item and sort the item on basis of this ratio. Then take the item with the highest ratio and add them until we can’t add the next item as a whole and at the end add the next item as much as we can. Which will always be the optimal solution to this problem.', '2020-05-25'),
(294, 12, 4001012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n  \r\nclass Edge  \r\n{  \r\n    public: \r\n    int src, dest, weight;  \r\n};  \r\nclass Graph  \r\n{  \r\n    public: \r\n    int V, E;  \r\n    Edge* edge;  \r\n};  \r\nGraph* createGraph(int V, int E)  \r\n{  \r\n    Graph* graph = new Graph;  \r\n    graph->V = V;  \r\n    graph->E = E;  \r\n  \r\n    graph->edge = new Edge[E];  \r\n  \r\n    return graph;  \r\n}   \r\nclass subset  \r\n{  \r\n    public: \r\n    int parent;  \r\n    int rank;  \r\n};  \r\nint find(subset subsets[], int i)  \r\n{  \r\n    if (subsets[i].parent != i)  \r\n        subsets[i].parent = find(subsets, subsets[i].parent);  \r\n  \r\n    return subsets[i].parent;  \r\n}    \r\nvoid Union(subset subsets[], int x, int y)  \r\n{  \r\n    int xroot = find(subsets, x);  \r\n    int yroot = find(subsets, y);    \r\n    if (subsets[xroot].rank < subsets[yroot].rank)  \r\n        subsets[xroot].parent = yroot;  \r\n    else if (subsets[xroot].rank > subsets[yroot].rank)  \r\n        subsets[yroot].parent = xroot;  \r\n    else\r\n    {  \r\n        subsets[yroot].parent = xroot;  \r\n        subsets[xroot].rank++;  \r\n    }  \r\n}   \r\nint myComp(const void* a, const void* b)  \r\n{  \r\n    Edge* a1 = (Edge*)a;  \r\n    Edge* b1 = (Edge*)b;  \r\n    return a1->weight > b1->weight;  \r\n}  \r\nvoid KruskalMST(Graph* graph)  \r\n{  \r\n    int V = graph->V;  \r\n    Edge result[V];  \r\n    int e = 0; \r\n    int i = 0;  \r\n \r\n    qsort(graph->edge, graph->E, sizeof(graph->edge[0]), myComp);  \r\n    subset *subsets = new subset[( V * sizeof(subset) )];    \r\n    for (int v = 0; v < V; ++v)  \r\n    {  \r\n        subsets[v].parent = v;  \r\n        subsets[v].rank = 0;  \r\n    }  \r\n\r\n    while (e < V - 1 && i < graph->E)  \r\n    {  \r\n        Edge next_edge = graph->edge[i++];  \r\n  \r\n        int x = find(subsets, next_edge.src);  \r\n        int y = find(subsets, next_edge.dest);  \r\n  \r\n        if (x != y)  \r\n        {  \r\n            result[e++] = next_edge;  \r\n            Union(subsets, x, y);  \r\n        }  \r\n   \r\n    }   \r\n    cout<<\"Following are the edges in the constructed MST\n\";  \r\n    for (i = 0; i < e; ++i)  \r\n        cout<<result[i].src<<\" -- \"<<result[i].dest<<\" == \"<<result[i].weight<<endl;  \r\n    return;  \r\n}  \r\n  \r\nint main()  \r\n{  \r\nint V=4;\r\nint E=5;\r\n\r\n    Graph* graph = createGraph(V, E);   \r\n    graph->edge[0].src = 0;  \r\n    graph->edge[0].dest = 1;  \r\n    graph->edge[0].weight = 10;   \r\n    graph->edge[1].src = 0;  \r\n    graph->edge[1].dest = 2;  \r\n    graph->edge[1].weight = 6;  \r\n\r\n    graph->edge[2].src = 0;  \r\n    graph->edge[2].dest = 3;  \r\n    graph->edge[2].weight = 5;   \r\n    graph->edge[3].src = 1;  \r\n    graph->edge[3].dest = 3;  \r\n    graph->edge[3].weight = 15;  \r\n  \r\n    graph->edge[4].src = 2;  \r\n    graph->edge[4].dest = 3;  \r\n    graph->edge[4].weight = 4;  \r\n  \r\n    KruskalMST(graph);  \r\n    return 0;  \r\n}  ', 1000, '8 a b c d e f g h 1 1 2 3 5 8 13 21', '', 'Prefix Codes, means the codes (bit sequences) are assigned in such a way that the code assigned to one character is not the prefix of code assigned to any other character. This is how Huffman Coding makes sure that there is no ambiguity when decoding the generated bitstream.\r\n Let there be four characters a, b, c and d, and their corresponding variable length codes be 00, 01, 0 and 1. This coding leads to ambiguity because code assigned to c is the prefix of codes assigned to a and b. If the compressed bit stream is 0001, the de-compressed output may be “cccd” or “ccb” or “acd” or “ab”.\r\n\r\n\r\nThere are mainly two major parts in Huffman Coding\r\n1) Build a Huffman Tree from input characters.\r\n2) Traverse the Huffman Tree and assign codes to characters.\r\n\r\n', '2020-05-25'),
(295, 15, 6801012018, '#include<bits/stdc++.h> \r\nusing namespace std; \r\n  \r\n\r\nint MatrixChainOrder(int p[], int i, int j) \r\n{ \r\n    if(i == j) \r\n        return 0; \r\n    int k; \r\n    int min = INT_MAX; \r\n    int count; \r\n  \r\n    for (k = i; k < j; k++) \r\n    { \r\n        count = MatrixChainOrder(p, i, k) + \r\n                MatrixChainOrder(p, k + 1, j) + \r\n                p[i - 1] * p[k] * p[j]; \r\n  \r\n        if (count < min) \r\n            min = count; \r\n    } \r\n  \r\n    return min; \r\n} \r\nint main() \r\n{ \r\nint t;\r\ncin>>t;\r\nwhile(t!=0){\r\nint n;\r\ncin>>n;\r\nint arr[n];\r\n    cout << MatrixChainOrder(arr, 1, n - 1); \r\ncout<<endl;\r\nt--;\r\n}\r\n} ', 1000, '8 a b c d e f g h 1 1 2 3 5 8 13 21', '', 'MATRIX-CHAIN-ORDER (p)\r\n\r\n\r\n 1. n   length[p]-1\r\n 2. for i ← 1 to n\r\n 3. do m [i, i] ← 0\r\n 4. for l ← 2 to n    // l is the chain length\r\n 5. do for i ← 1 to n-l + 1\r\n 6. do j ← i+ l -1\r\n 7. m[i,j] ←  ∞\r\n 8. for k  ← i to j-1\r\n 9. do q  ← m [i, k] + m [k + 1, j] + pi-1 pk pj	\r\n 10. If q < m [i,j]\r\n 11. then m [i,j] ← q\r\n 12. s [i,j] ← k\r\n 13. return m and s.   ', '2020-05-25'),
(296, 8, 4001012018, '#include < iostream>\r\n#include < vector>\r\n#include < cmath>\r\n#include < algorithm>\r\nusing namespace std;\r\n\r\nint nextpowerof2(int k)\r\n{\r\n    return pow(2, int(ceil(log2(k))));\r\n}\r\nvoid display(vector< vector<int>> &matrix, int m, int n)\r\n{\r\n    for (int i = 0; i < m; i++)\r\n    {\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            if (j != 0)\r\n            {\r\n                cout << \"	\";\r\n            }\r\n            cout << matrix[i][j];\r\n        }\r\n        cout << endl;\r\n    }\r\n}\r\n\r\nvoid add(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\r\n{\r\n    int i, j;\r\n\r\n    for (i = 0; i < size; i++)\r\n    {\r\n        for (j = 0; j < size; j++)\r\n        {\r\n            C[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid sub(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\r\n{\r\n    int i, j;\r\n\r\n    for (i = 0; i < size; i++)\r\n    {\r\n        for (j = 0; j < size; j++)\r\n        {\r\n            C[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid STRASSEN_algorithmA(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\r\n{\r\n   \r\n    if (size == 1)\r\n    {\r\n        C[0][0] = A[0][0] * B[0][0];\r\n        return;\r\n    }\r\n    else\r\n    {\r\n        int new_size = size / 2;\r\n        vector<int> z(new_size);\r\n        vector<vector<int>>\r\n            a11(new_size, z), a12(new_size, z), a21(new_size, z), a22(new_size, z),\r\n            b11(new_size, z), b12(new_size, z), b21(new_size, z), b22(new_size, z),\r\n            c11(new_size, z), c12(new_size, z), c21(new_size, z), c22(new_size, z),\r\n            p1(new_size, z), p2(new_size, z), p3(new_size, z), p4(new_size, z),\r\n            p5(new_size, z), p6(new_size, z), p7(new_size, z),\r\n            aResult(new_size, z), bResult(new_size, z);\r\n\r\nint i, j;\r\n\r\nfor (i = 0; i < new_size; i++)\r\n        {\r\n            for (j = 0; j < new_size; j++)\r\n            {\r\n                a11[i][j] = A[i][j];\r\n                a12[i][j] = A[i][j + new_size];\r\n                a21[i][j] = A[i + new_size][j];\r\n                a22[i][j] = A[i + new_size][j + new_size];\r\n\r\n                b11[i][j] = B[i][j];\r\n                b12[i][j] = B[i][j + new_size];\r\n                b21[i][j] = B[i + new_size][j];\r\n                b22[i][j] = B[i + new_size][j + new_size];\r\n            }\r\n}\r\n\r\n\r\n        add(a11, a22, aResult, new_size);    \r\n        add(b11, b22, bResult, new_size);    \r\n        STRASSEN_algorithmA(aResult, bResult, p1, new_size); \r\n\r\n        add(a21, a22, aResult, new_size); \r\n        STRASSEN_algorithmA(aResult, b11, p2, new_size);\r\n\r\n        sub(b12, b22, bResult, new_size);      \r\n        STRASSEN_algorithmA(a11, bResult, p3, new_size);\r\n\r\n        sub(b21, b11, bResult, new_size);     \r\n        STRASSEN_algorithmA(a22, bResult, p4, new_size); \r\n\r\n        add(a11, a12, aResult, new_size);     \r\n        STRASSEN_algorithmA(aResult, b22, p5, new_size);\r\n\r\n        sub(a21, a11, aResult, new_size);      \r\n        add(b11, b12, bResult, new_size);               \r\n      \r\n        STRASSEN_algorithmA(aResult, bResult, p6, new_size);\r\n\r\n        sub(a12, a22, aResult, new_size);      \r\n        add(b21, b22, bResult, new_size);                \r\n        \r\n        STRASSEN_algorithmA(aResult, bResult, p7, new_size);\r\n        \r\n\r\n        add(p3, p5, c12, new_size); \r\n        add(p2, p4, c21, new_size); \r\n\r\n        add(p1, p4, aResult, new_size);      \r\n        add(aResult, p7, bResult, new_size); \r\n        sub(bResult, p5, c11, new_size); \r\n\r\n        add(p1, p3, aResult, new_size);     \r\n        add(aResult, p6, bResult, new_size);  \r\n        sub(bResult, p2, c22, new_size); \r\n\r\n        for (i = 0; i < new_size; i++)\r\n        {\r\n            for (j = 0; j < new_size; j++)\r\n            {\r\n                C[i][j] = c11[i][j];\r\n                C[i][j + new_size] = c12[i][j];\r\n                C[i + new_size][j] = c21[i][j];\r\n                C[i + new_size][j + new_size] = c22[i][j];\r\n            }\r\n        }\r\n    }\r\n}\r\nvoid STRASSEN_algorithm(vector<vector<int>> &A, vector<vector<int>> &B, int m, int n, int a, int b)\r\n{  \r\n    int k = max({m, n, a, b});\r\n\r\n    int s = nextpowerof2(k);\r\n\r\n    vector<int> z(s);\r\n    vector<vector<int>> Aa(s, z), Bb(s, z), Cc(s, z);\r\n\r\n    for (unsigned int i = 0; i < m; i++)\r\n    {\r\n        for (unsigned int j = 0; j < n; j++)\r\n        {\r\n            Aa[i][j] = A[i][j];\r\n        }\r\n    }\r\n    for (unsigned int i = 0; i < a; i++)\r\n    {\r\n        for (unsigned int j = 0; j < b; j++)\r\n        {\r\n            Bb[i][j] = B[i][j];\r\n        }\r\n    }\r\n    STRASSEN_algorithmA(Aa, Bb, Cc, s);\r\n    vector<int> temp1(b);\r\n    vector<vector<int>> C(m, temp1);\r\n    for (unsigned int i = 0; i < m; i++)\r\n    {\r\n        for (unsigned int j = 0; j < b; j++)\r\n        {\r\n            C[i][j] = Cc[i][j];\r\n        }\r\n    }\r\n    display(C, m, b);\r\n}\r\n\r\nbool check(int n, int a)\r\n{\r\n    if (n == a)\r\n        return true;\r\n    else\r\n        return false;\r\n}\r\n\r\nint main()\r\n{\r\nInt t;\r\ncin>>t;\r\nwhile(t!=0){\r\n    int m, n, a, b;\r\n    cin >> m >> n;\r\n    vector<vector<int>> A;\r\n   \r\n    for (int i = 0; i < m; i++)\r\n    {\r\n        vector<int> temp;\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            int i;\r\n            cin >> i;\r\n            temp.push_back(i);\r\n        }\r\n        A.push_back(temp);\r\n    }\r\n    \r\n    cin >> a >> b;\r\n    \r\n    vector<vector<int>> B;\r\n    for (int i = 0; i < a; i++)\r\n    {\r\n        vector<int> temp;\r\n        for (int j = 0; j < b; j++)\r\n        {\r\n            int i;\r\n            cin >> i;\r\n            temp.push_back(i);\r\n        }\r\n        B.push_back(temp);\r\n    }\r\n\r\n    bool k = check(n, a);\r\n    if (k)\r\n    {\r\n        STRASSEN_algorithm(A, B, m, n, a, b);\r\n    }\r\n    else\r\n    {\r\n        cout << \"-1\";\r\n    }\r\nt--;\r\ncout<<endl;\r\n}\r\n    return 0;\r\n}\r\n', 0, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '', 'MATRIX-CHAIN-ORDER (p)\r\n\r\n\r\n 1. n   length[p]-1\r\n 2. for i ← 1 to n\r\n 3. do m [i, i] ← 0\r\n 4. for l ← 2 to n    // l is the chain length\r\n 5. do for i ← 1 to n-l + 1\r\n 6. do j ← i+ l -1\r\n 7. m[i,j] ←  ∞\r\n 8. for k  ← i to j-1\r\n 9. do q  ← m [i, k] + m [k + 1, j] + pi-1 pk pj	\r\n 10. If q < m [i,j]\r\n 11. then m [i,j] ← q\r\n 12. s [i,j] ← k\r\n 13. return m and s.   ', '2020-05-25'),
(297, 7, 4001012018, '#include <cstdlib> \r\n#include<ctime>\r\n #include <iostream> \r\nusing namespace std; \r\nint partition(int arr[], int low, int high) \r\n{\r\n int pivot = arr[high]; // pivot\r\n int i = (low - 1); // Index of smaller element\r\n for (int j = low; j <= high - 1; j++) \r\n{ \r\n    if (arr[j] <= pivot) \r\n{     i++; \r\n     swap(arr[i], arr[j]); \r\n} \r\n} \r\nswap(arr[i + 1], arr[high]); \r\nreturn (i + 1);\r\n } \r\nint partition_r(int arr[], int low, int high) \r\n{ \r\nsrand(time(NULL));\r\n int random = low + rand() % (high - low); \r\nswap(arr[random], arr[high]);\r\n return partition(arr, low, high); \r\n}  \r\nvoid quickSort(int arr[], int low, int high) \r\n{ \r\nif (low < high)\r\n { \r\nint pi = partition_r(arr, low, high); \r\nquickSort(arr, low, pi - 1);\r\n quickSort(arr, pi + 1, high); \r\n} \r\n}\r\n /* Function to print an array */ \r\nvoid printArray(int arr[], int size) \r\n{ int i; for (i = 0; i < size; i++) cout<<arr[i]<<\" \"; } \r\n// Driver program to test above functions \r\nint main()\r\n { \r\nint n; \r\ncin>>n; \r\nint arr[n]; \r\nfor(int i=0;i<n;i++) { cin>>arr[i]; } \r\nquickSort(arr, 0, n - 1); \r\nprintArray(arr, n);\r\n return 0;\r\n } ', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '', 'empty algorithm!', '0000-00-00'),
(298, 15, 4401012018, '#include<bits/stdc++.h> \r\nusing namespace std; \r\n  \r\n\r\nint MatrixChainOrder(int p[], int i, int j) \r\n{ \r\n    if(i == j) \r\n        return 0; \r\n    int k; \r\n    int min = INT_MAX; \r\n    int count; \r\n  \r\n    for (k = i; k < j; k++) \r\n    { \r\n        count = MatrixChainOrder(p, i, k) + \r\n                MatrixChainOrder(p, k + 1, j) + \r\n                p[i - 1] * p[k] * p[j]; \r\n  \r\n        if (count < min) \r\n            min = count; \r\n    } \r\n  \r\n    return min; \r\n} \r\nint main() \r\n{ \r\nint t;\r\ncin>>t;\r\nwhile(t!=0){\r\nint n;\r\ncin>>n;\r\nint arr[n];\r\nfor(int i=0;i<n;i++){\r\ncin>>arr[i];\r\n}\r\n    cout << MatrixChainOrder(arr, 1, n - 1); \r\ncout<<endl;\r\nt--;\r\n}\r\n} ', 1000, '8 a b c d e f g h 1 1 2 3 5 8 13 21', '', 'MATRIX-CHAIN-ORDER (p)\r\n\r\n\r\n 1. n   length[p]-1\r\n 2. for i ← 1 to n\r\n 3. do m [i, i] ← 0\r\n 4. for l ← 2 to n    // l is the chain length\r\n 5. do for i ← 1 to n-l + 1\r\n 6. do j ← i+ l -1\r\n 7. m[i,j] ←  ∞\r\n 8. for k  ← i to j-1\r\n 9. do q  ← m [i, k] + m [k + 1, j] + pi-1 pk pj	\r\n 10. If q < m [i,j]\r\n 11. then m [i,j] ← q\r\n 12. s [i,j] ← k\r\n 13. return m and s.   ', '2020-05-25'),
(299, 10, 4601012018, '#include<stdio.h>\r\n#include<limits.h>\r\nint max(int a, int b) { return (a > b)? a : b; }\r\nint knapSack(int W, int wt[], int val[], int n)\r\n{\r\n   if (n == 0 || W == 0)\r\n       return 0;\r\n   if (wt[n-1] > W)\r\n       return knapSack(W, wt, val, n-1);\r\n\r\n   else return max( val[n-1] + knapSack(W-wt[n-1], wt, val, n-1),\r\n                    knapSack(W, wt, val, n-1) );\r\n}\r\n\r\nint main()\r\n{\r\n    int n;\r\n    int  W ,i;\r\n    scanf(\"%d\",&n);\r\n    scanf(\"%d\",&W);\r\n    int wt[n],val[n];\r\n    for(i=0;i<n;i++)\r\n    scanf(\"%d\",&val[i]);\r\n    for(i=0;i<n;i++)\r\n    scanf(\"%d\",&wt[i]);\r\n    printf(\"%d\", knapSack(W, wt, val, n));\r\n    return 0;\r\n}\r\n', 10, '5 15 4 2 1 2 10 12 2 1 1 4', '15', '??D\0y\0n\0a\0m\0i\0c\0-\00\0-\01\0-\0k\0n\0a\0p\0s\0a\0c\0k\0 \0(\0v\0,\0 \0w\0,\0 \0n\0,\0 \0W\0)\0\r\0\n\0f\0o\0r\0 \0w\0 \0=\0 \00\0 \0t\0o\0 \0W\0 \0d\0o\0\r\0\n\0 \0 \0 \0c\0[\00\0,\0 \0w\0]\0 \0=\0 \00\0\r\0\n\0f\0o\0r\0 \0i\0 \0=\0 \01\0 \0t\0o\0 \0n\0 \0d\0o\0 \0 \0\r\0\n\0 \0 \0 \0c\0[\0i\0,\0 \00\0]\0 \0=\0 \00\0\r\0\n\0 \0 \0 \0f\0o\0r\0 \0w\0 \0=\0 \01\0 \0t\0o\0 \0W\0 \0d\0o\0\r\0\n\0 \0 \0	\0i\0f\0 \0w\0i\0 \0d\" \0w\0 \0t\0h\0e\0n\0\r\0\n\0 \0 \0 \0 \0 \0	\0i\0f\0 \0v\0i\0 \0+\0 \0c\0[\0i\0-\01\0,\0 \0w\0-\0w\0i\0]\0 \0t\0h\0e\0n\0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0	\0c\0[\0i\0,\0 \0w\0]\0 \0=\0 \0v\0i\0 \0+\0 \0c\0[\0i\0-\01\0,\0 \0w\0-\0w\0i\0]\0\r\0\n\0 \0 \0 \0 \0 \0	\0e\0l\0s\0e\0 \0c\0[\0i\0,\0 \0w\0]\0 \0=\0 \0c\0[\0i\0-\01\0,\0 \0w\0]\0\r\0\n\0 \0 \0	\0e\0l\0s\0e\0\r\0\n\0 \0 \0 \0 \0 \0	\0c\0[\0i\0,\0 \0w\0]\0 \0=\0 \0c\0[\0i\0-\01\0,\0 \0w\0]\0', '2020-05-25'),
(300, 14, 4601012018, '#include<iostream>\nusing namespace std;\nstruct Edge \n{ \n    int src, dest, weight; \n}; \nstruct Graph \n{ \n    int V, E; \n    struct Edge* edge; \n}; \nstruct Graph* createGraph(int V, int E) \n{ \n    struct Graph* graph = new Graph; \n    graph->V = V; \n    graph->E = E; \n    graph->edge = new Edge[E]; \n    return graph; \n} \nvoid printArr(int dist[], int n) \n{ \n    printf(\"Vertex   Distance from Source\n\"); \n    for (int i = 0; i < n; ++i) \n        printf(\"%d 		 %d\n\", i, dist[i]); \n} \nvoid BellmanFord(struct Graph* graph, int src) \n{ \n    int V = graph->V; \n    int E = graph->E; \n    int dist[V]; \n    for (int i = 0; i < V; i++) \n        dist[i] = INT_MAX; \n    dist[src] = 0; \n    for (int i = 1; i <= V - 1; i++) { \n        for (int j = 0; j < E; j++) { \n            int u = graph->edge[j].src; \n            int v = graph->edge[j].dest; \n            int weight = graph->edge[j].weight; \n            if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) \n                dist[v] = dist[u] + weight; \n        } \n    } \n    for (int i = 0; i < E; i++) { \n        int u = graph->edge[i].src; \n        int v = graph->edge[i].dest; \n        int weight = graph->edge[i].weight; \n        if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) { \n            printf(\"Graph contains negative weight cycle\"); \n            return; \n        } \n    } \n    printArr(dist, V); \n    return; \n} \nint main() \n{ \n    int V = 5; \n    int E = 8; \n    struct Graph* graph = createGraph(V, E); \n    graph->edge[0].src = 0; \n    graph->edge[0].dest = 1; \n    graph->edge[0].weight = -1; \n    graph->edge[1].src = 0; \n    graph->edge[1].dest = 2; \n    graph->edge[1].weight = 4; \n    graph->edge[2].src = 1; \n    graph->edge[2].dest = 2; \n    graph->edge[2].weight = 3;  \n    graph->edge[3].src = 1; \n    graph->edge[3].dest = 3; \n    graph->edge[3].weight = 2;  \n    graph->edge[4].src = 1; \n    graph->edge[4].dest = 4; \n    graph->edge[4].weight = 2;  \n    graph->edge[5].src = 3; \n    graph->edge[5].dest = 2; \n    graph->edge[5].weight = 5; \n    graph->edge[6].src = 3; \n    graph->edge[6].dest = 1; \n    graph->edge[6].weight = 1; \n    graph->edge[7].src = 4; \n    graph->edge[7].dest = 3; \n    graph->edge[7].weight = -3; \n    BellmanFord(graph, 0); \n    return 0; \n} \n', 1000, '8 a b c d e f g h 1 1 2 3 5 8 13 21', 'h: 0\ng: 10\nf: 110\ne: 1110\nd: 11110\nc: 111110\na: 1111110\nb: 1111111\n', 'Following are the detailed steps.\r\nInput: Graph and a source vertex src\r\nOutput: Shortest distance to all vertices from src. If there is a negative weight cycle, then shortest distances are not calculated, negative weight cycle is reported.\r\n1) This step initializes distances from source to all vertices as infinite and distance to source itself as 0. Create an array dist[] of size |V| with all values as infinite except dist[src] where src is source vertex.2) This step calculates shortest distances. Do following |V|-1 times where |V| is the number of vertices in given graph.\r\n…..a) Do following for each edge u-v\r\n………………If dist[v] > dist[u] + weight of edge uv, then update dist[v]\r\n………………….dist[v] = dist[u] + weight of edge uv\r\n3) This step reports if there is a negative weight cycle in graph. Do following for each edge u-v\r\n……If dist[v] > dist[u] + weight of edge uv, then “Graph contains negative weight cycle”\r\nThe idea of step 3 is, step 2 guarantees shortest distances if graph doesn’t contain negative weight cycle. If we iterate through all edges one more time and get a shorter path for any vertex, then there is a negative weight cycle', '2020-05-25'),
(301, 10, 6101012018, '#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint knapSack(int W, int wt[], int val[], int n)\r\n{\r\nif (n == 0 || W == 0)\r\n    return 0;\r\nif (wt[n-1] > W)\r\n    return knapSack(W, wt, val, n-1);\r\nelse return max( val[n-1] + knapSack(W-wt[n-1], wt, val, n-1),\r\n                    knapSack(W, wt, val, n-1) );\r\n}\r\n\r\n\r\nint main()\r\n{\r\n    int n;\r\n    cin>>n;\r\n    int val[n];\r\n    int wt[n];\r\n    int W ;\r\n    cin>>W;\r\n    for(int i=0;i<n;i++){\r\n        cin>>val[i];\r\n    }\r\n    for(int i=0;i<n;i++){\r\n        cin>>wt[i];\r\n    }\r\n    cout<<knapSack(W, wt, val, n);\r\n    return 0;\r\n}\r\n\r\n', 10, '5 15 4 2 1 2 10 12 2 1 1 4', '15', 'Define a function knapsack which takes as argument (`W->Weight left to be filled, ‘N’->number of left items)\r\nBase case will be if we have ‘left weight=0’ or ‘number of items left=0’ , then return 0\r\nIf the current item’s weight is greater than left weight so that item cannot be included therefore return(n-1,W)\r\nElse return max(val+knapsack(W-val,n-1),knapsack(W,n-1)) which means returning the maximum of the two cases when the current item is included or not included\r\n', '2020-05-25');
INSERT INTO `qtos_map` (`ID`, `Q_ID`, `ROLL`, `SUBMISSION`, `SCORE`, `INPUT`, `OP`, `ALGO`, `DATE`) VALUES
(302, 10, 4901012018, '﻿#include <bits/stdc++.h>\r\nusing namespace std;\r\nstruct Item\r\n{\r\n    int value, weight;\r\n};\r\n\r\n\r\nbool cmp(struct Item a, struct Item b)\r\n{\r\n    double r1 = (double)a.value / a.weight;\r\n    double r2 = (double)b.value / b.weight;\r\n    return r1 > r2;\r\n}\r\n\r\n\r\ndouble fractionalKnapsack(int W, struct Item arr[], int n)\r\n{\r\n    sort(arr, arr + n, cmp);\r\n    int curWeight = 0;\r\n    double finalvalue = 0.0;\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        if (curWeight + arr[i].weight <= W)\r\n        {\r\n            curWeight += arr[i].weight;\r\n            finalvalue += arr[i].value;\r\n        }\r\n        else\r\n        {\r\n            int remain = W - curWeight;\r\n            finalvalue += arr[i].value * ((double) remain / arr[i].weight);\r\n            break;\r\n        }\r\n    }\r\n    return finalvalue;\r\n}\r\n\r\n\r\nint main()\r\n{\r\n    int n; cin >> n;\r\n    int W; cin>>W;\r\n    Item* arr = new Item[n];\r\n    for(int i = 0; i < n; i++)\r\n        cin >> arr[i].value;\r\n\r\n\r\n    for(int i = 0; i < n; i++)\r\n        cin >> arr[i].weight;\r\n\r\n\r\n    cout<< fractionalKnapsack(W, arr, n);\r\n    return 0;\r\n}', 2, '5 15 4 2 1 2 10 12 2 1 1 4', '17.3333', '﻿#include <bits/stdc++.h>\r\nusing namespace std;\r\nstruct Item\r\n{\r\n    int value, weight;\r\n};\r\n\r\n\r\nbool cmp(struct Item a, struct Item b)\r\n{\r\n    double r1 = (double)a.value / a.weight;\r\n    double r2 = (double)b.value / b.weight;\r\n    return r1 > r2;\r\n}\r\n\r\n\r\ndouble fractionalKnapsack(int W, struct Item arr[], int n)\r\n{\r\n    sort(arr, arr + n, cmp);\r\n    int curWeight = 0;\r\n    double finalvalue = 0.0;\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        if (curWeight + arr[i].weight <= W)\r\n        {\r\n            curWeight += arr[i].weight;\r\n            finalvalue += arr[i].value;\r\n        }\r\n        else\r\n        {\r\n            int remain = W - curWeight;\r\n            finalvalue += arr[i].value * ((double) remain / arr[i].weight);\r\n            break;\r\n        }\r\n    }\r\n    return finalvalue;\r\n}\r\n\r\n\r\nint main()\r\n{\r\n    int n; cin >> n;\r\n    int W; cin>>W;\r\n    Item* arr = new Item[n];\r\n    for(int i = 0; i < n; i++)\r\n        cin >> arr[i].value;\r\n\r\n\r\n    for(int i = 0; i < n; i++)\r\n        cin >> arr[i].weight;\r\n\r\n\r\n    cout<< fractionalKnapsack(W, arr, n);\r\n    return 0;\r\n}', '2020-05-25'),
(303, 10, 5901012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n  \r\n// A utility function that returns maximum of two integers  \r\nint max(int a, int b) { return (a > b)? a : b; }  \r\n  \r\n// Returns the maximum value that  \r\n// can be put in a knapsack of capacity W  \r\nint knapSack(int W, int wt[], int val[], int n)  \r\n{  \r\n      \r\n// Base Case  \r\nif (n == 0 || W == 0)  \r\n    return 0;  \r\n  \r\n// If weight of the nth item is more  \r\n// than Knapsack capacity W, then  \r\n// this item cannot be included \r\n// in the optimal solution  \r\nif (wt[n-1] > W)  \r\n    return knapSack(W, wt, val, n-1);  \r\n  \r\n// Return the maximum of two cases:  \r\n// (1) nth item included  \r\n// (2) not included  \r\nelse return max( val[n-1] + knapSack(W-wt[n-1], wt, val, n-1),  \r\n                    knapSack(W, wt, val, n-1) );  \r\n}  \r\n  \r\n// Driver code  \r\nint main()  \r\n{  \r\n    int n; cin>>n;\r\n    int W; cin>>W;\r\n    int wt[n], val[n];\r\n    for(int i=0;i<n;i++) cin>>val[i];\r\n    for(int i=0;i<n;i++) cin>>wt[i];\r\n    cout<<knapSack(W, wt, val, n);  \r\n    return 0;  \r\n}  \r\n  ', 10, '5 15 4 2 1 2 10 12 2 1 1 4', '', 'empty algorithm!', '0000-00-00'),
(304, 3, 5901012018, '#include<iostream>\r\nusing namespace std;\r\n\r\nvoid swap( int &a, int &b)\r\n{\r\n    int t=a;\r\n    a=b;\r\n    b=t;\r\n}\r\n\r\nint pivot(int arr[], int sPos, int ePos)\r\n{\r\n    \r\n   int p= arr[ePos];\r\n   int i=sPos-1;\r\n   for(int j=sPos;j<=ePos-1;j++)\r\n   {\r\n       if(arr[j]<p)\r\n       {\r\n           i++;\r\n           swap(arr[i], arr[j]);\r\n       }\r\n   }\r\n    \r\n    swap(arr[i+1], arr[ePos]);\r\n    return i+1;\r\n    \r\n}\r\n\r\nvoid quickSort(int arr[], int sPos, int ePos)\r\n{\r\n    \r\n   if(sPos>=ePos)  return;\r\n   int pi= pivot(arr, sPos, ePos);\r\n   quickSort(arr, sPos, pi-1);\r\n   quickSort(arr, pi+1, ePos);\r\n    \r\n}\r\n\r\nint main()\r\n{\r\n    \r\n    int n; cin>>n;\r\n    int arr[n];\r\n    for(int i=0;i<n;i++)\r\n    cin>>arr[i];\r\n    quickSort(arr,0,n-1);\r\n    for(int i=0;i<n;i++) cout<<arr[i]<<\" \";\r\n     \r\n}', 10, '1 2000', '', 'empty algorithm!', '0000-00-00'),
(305, 7, 5901012018, '#include <bits.stdc++.h>\r\nusing namespace std;\r\n\r\n/* This function takes last element as pivot, places\r\n  the pivot element at its correct position in sorted\r\n  array, and places all smaller (smaller than pivot)\r\n  to left of pivot and all greater elements to right\r\n  of pivot */\r\nint partition(int arr[], int low, int high)\r\n{\r\n    int pivot = arr[high]; // pivot\r\n    int i = (low - 1); // Index of smaller element\r\n\r\n    for (int j = low; j <= high - 1; j++) {\r\n\r\n        // If current element is smaller than or\r\n        // equal to pivot\r\n        if (arr[j] <= pivot) {\r\n\r\n            i++; // increment index of smaller element\r\n            swap(arr[i], arr[j]);\r\n        }\r\n    }\r\n    swap(arr[i + 1], arr[high]);\r\n    return (i + 1);\r\n}\r\n\r\n// Generates Random Pivot, swaps pivot with\r\n// end element and calls the partition function\r\nint partition_r(int arr[], int low, int high)\r\n{\r\n    // Generate a random number in between\r\n    // low .. high\r\n    srand(time(NULL));\r\n    int random = low + rand() % (high - low);\r\n\r\n    // Swap A[random] with A[high]\r\n    swap(arr[random], arr[high]);\r\n\r\n    return partition(arr, low, high);\r\n}\r\n\r\n/* The main function that implements QuickSort\r\narr[] --> Array to be sorted,\r\nlow --> Starting index,\r\nhigh --> Ending index */\r\nvoid quickSort(int arr[], int low, int high)\r\n{\r\n    if (low < high) {\r\n\r\n        /* pi is partitioning index, arr[p] is now\r\n        at right place */\r\n        int pi = partition_r(arr, low, high);\r\n\r\n        // Separately sort elements before\r\n        // partition and after partition\r\n        quickSort(arr, low, pi - 1);\r\n        quickSort(arr, pi + 1, high);\r\n    }\r\n}\r\n\r\n/* Function to print an array */\r\nvoid printArray(int arr[], int size)\r\n{\r\n    int i;\r\n    for (i = 0; i < size; i++)\r\n         { cout<<arr[i]<<\" \";\r\n            }\r\n}\r\n\r\n// Driver program to test above functions\r\nint main()\r\n{   int n;\r\n    cin>>n;\r\n    int arr[n];\r\n for(int i=0;i<n;i++){cin>>arr[i];}\r\n\r\n    quickSort(arr, 0, n - 1);\r\n   \r\n    printArray(arr, n);\r\n    return 0;\r\n}\r\n', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '', '﻿procedure mergesort( var a as array )\r\n   if ( n == 1 ) return a\r\n\r\n\r\n   var l1 as array = a[0] ... a[n/2]\r\n   var l2 as array = a[n/2+1] ... a[n]\r\n\r\n\r\n   l1 = mergesort( l1 )\r\n   l2 = mergesort( l2 )\r\n\r\n\r\n   return merge( l1, l2 )\r\nend procedure\r\n\r\n\r\nprocedure merge( var a as array, var b as array )\r\n\r\n\r\n   var c as array\r\n   while ( a and b have elements )\r\n      if ( a[0] > b[0] )\r\n         add b[0] to the end of c\r\n         remove b[0] from b\r\n      else\r\n         add a[0] to the end of c\r\n         remove a[0] from a\r\n      end if\r\n   end while\r\n   \r\n   while ( a has elements )\r\n      add a[0] to the end of c\r\n      remove a[0] from a\r\n   end while\r\n   \r\n   while ( b has elements )\r\n      add b[0] to the end of c\r\n      remove b[0] from b\r\n   end while\r\n   \r\n   return c\r\n        \r\nend procedure', '2020-05-25'),
(306, 8, 7601012018, '/******************************************************************************\r\n\r\n                              Online C++ Compiler.\r\n               Code, Compile, Run and Debug C++ program online.\r\nWrite your code in this editor and press \"Run\" button to compile and execute it.\r\n\r\n*******************************************************************************/\r\n\r\n// C++ program to multiply \r\n// two square matrices. \r\n#include <iostream> \r\n\r\nusing namespace std; \r\n#define N 3\r\n\r\n// This function multiplies \r\n// mat1[][] and mat2[][], and \r\n// stores the result in res[][] \r\nvoid multiply(int mat1[][N], \r\n			int mat2[][N], \r\n			int res[][N]) \r\n{ \r\n	int i, j, k; \r\n	for (i = 0; i < N; i++) \r\n	{ \r\n		for (j = 0; j < N; j++) \r\n		{ \r\n			res[i][j] = 0; \r\n			for (k = 0; k < N; k++) \r\n				res[i][j] += mat1[i][k] * \r\n							mat2[k][j]; \r\n		} \r\n	} \r\n} \r\n\r\n// Driver Code \r\nint main() \r\n{ \r\n	int i, j;\r\n	int res[N][N], mat1[N][N]; \r\n\r\n	int mat2[N][N]; \r\nfor(i=0;i<N;i++)\r\nfor(j=0;j<N;j++)\r\ncin>>mat1[i][j];\r\nfor(i=0;i<N;i++)\r\nfor(j=0;j<N;j++)\r\ncin>>mat2[i][j];\r\n	multiply(mat1, mat2, res); \r\n\r\n	for (i = 0; i < N; i++) \r\n	{ \r\n		for (j = 0; j < N; j++) \r\n		cout << res[i][j] << \" \"; \r\n		cout <<\"\n\"; \r\n	} \r\n\r\n	return 0; \r\n} \r\n\r\n// This code is contributed \r\n// by Soumik Mondal \r\n\r\n', 0, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '-14 -4 -28 \n39 36 42 \n58 11 44 \n', 'matrix mult strassen', '0000-00-00'),
(307, 15, 4301012018, '\r\nimport java.util.*;\r\nclass Main \r\n{ \r\n	\r\n	static int MatrixChainOrder(int p[], int i, int j) \r\n	{ \r\n		if (i == j) \r\n			return 0; \r\n\r\n		int min = Integer.MAX_VALUE; \r\n\r\n		for (int k=i; k<j; k++) \r\n		{ \r\n			int count = MatrixChainOrder(p, i, k) + \r\n						MatrixChainOrder(p, k+1, j) + \r\n						p[i-1]*p[k]*p[j]; \r\n\r\n			if (count < min) \r\n				min = count; \r\n		} \r\n\r\n		return min; \r\n	} \r\n\r\n	public static void main(String args[]) \r\n	{ \r\n	    Scanner sc = new Scanner(System.in);\r\n	    int n = sc.nextInt();\r\n		int arr[] = new int[n]; \r\n		\r\n		for(int i = 0; i<= n-1; i++)\r\n		{\r\n		    arr[i] = sc.nextInt();\r\n		}\r\n\r\n		System.out.println(MatrixChainOrder(arr, 1, n-1)); \r\n\r\n	} \r\n} \r\n', 1000, '', '', 'Recursive Solution\r\n\r\nLet M[i,j] represent the number of multiplications required for matrix product Ai×⋯×Aj\r\nFor 1≤i≤j<n\r\n\r\nM[i,i]=0 since no product is required\r\n\r\nThe optimal solution of Ai×Aj must break at some point, k, with i≤k<j\r\nThus, M[i,j]=M[i,k]+M[k+1,j]+di−1dkdj\r\n\r\nThus, M[i,j]={0mini≤k<j{M[i,k]+M[k+1,j]+di−1dkdj}if i=jif i<j\r\n\r\nThis is easily expressed as a recursive function (with exponential complexity)\r\nWhat would this look like?\r\n\r\nComplexity:\r\nP(1) = 1\r\nP(n) = Sum (k=1, n-1) P(k)P(n-k)\r\nP(n) = Ω(fn/n32)\r\n\r\n\r\nEfficient Computation\r\n\r\nWe must find a way to calculate this bottom up\r\n\r\nWhich values does M[i,j] depend on?\r\nConsider a n×n matrix of values M[i,j]\r\nDiagonal is 0\r\n1≤i≤j≤n is the upper right triangle\r\n\r\nConsider some element M[i,j]\r\n\r\nWhere are M[i,k] (for i≤k≤j):\r\n\r\nWhere are M[k+1,j] (for i≤k≤j):\r\n\r\nThis tells us the order in which to build the table: By diagonals\r\nBy diagonal\r\nMoving up and right from the diagonal that goes top-left to bottom-right\r\n\r\nDiagonal indices:\r\nOn diagonal 0,j=i\r\nOn diagonal 1,j=i+1\r\nOn diagonal q,j=i+q\r\nOn diagonal n−1,j=i+n−1', '2020-05-25'),
(309, 10, 2801012018, '#include<iostream>\r\nusing namespace std;\r\nvoid Fractional_Knapsack( float V[] , float W[] , float c, int n , float &value)\r\n{\r\n	float R[100];\r\n	for(int i =0; i<n; i++)\r\n	 R[i] = V[i] / W[i];\r\n	for(int i =0; i<n-1; i++)\r\n	{\r\n		for(int j=0; j<n-i-1; j++)\r\n		{\r\n			if (R[j]<R[j+1])\r\n			{\r\n				swap(R[j] , R[j+1]);\r\n				swap(V[j] , V[j+1]);\r\n				swap(W[j] , W[j+1]);\r\n			}\r\n		}\r\n	}\r\n	float weight = 0, f = 0;\r\n	value = 0;\r\n	for(int i = 0; i<n; i++)\r\n	{\r\n		if(c!=0)\r\n		{\r\n			f = c/W[i];\r\n			if(f>=1)\r\n			 f=1;\r\n			weight += f*W[i];\r\n			value += f*V[i];\r\n			c -= f*W[i];\r\n		}\r\n	}\r\n}\r\nint main()\r\n{\r\n	int n, W;\r\n        cin>>n>>W;\r\n        float val[n], w[n];\r\n	for( int i=0; i<n; i++)\r\n	cin>>val[i];\r\n	for( int i=0; i<n; i++)\r\n	cin>>w[i];\r\n        float value = 0;\r\n	Fractional_Knapsack(val, w, W, n, value);\r\n	cout<<value;\r\n	return 0;\r\n}', 2, '5 15 4 2 1 2 10 12 2 1 1 4', '17.3333', 'Fractional Knapsack (Array W, Array V, int M)\r\n1. for i <- 1 to size (V)\r\n2. 	calculate cost[i] <- V[i] / W[i]\r\n3. Sort-Descending (cost)\r\n4. i ← 1\r\n5. while (i <= size(V))\r\n6. 	if  W[i] <= M \r\n7.		M ← M – W[i]\r\n8.		total ← total + V[i];\r\n9. 	if  W[i] > M\r\n10. 		i ← i+1\r\n', '2020-05-25'),
(310, 10, 2901012018, '#include<iostream>\r\nusing namespace std;\r\nvoid Fractional_Knapsack( float V[] , float W[] , float c, int n , float &value)\r\n{\r\n	float R[100];\r\n	for(int i =0; i<n; i++)\r\n	 R[i] = V[i] / W[i];\r\n	for(int i =0; i<n-1; i++)\r\n	{\r\n		for(int j=0; j<n-i-1; j++)\r\n		{\r\n			if (R[j]<R[j+1])\r\n			{\r\n				swap(R[j] , R[j+1]);\r\n				swap(V[j] , V[j+1]);\r\n				swap(W[j] , W[j+1]);\r\n			}\r\n		}\r\n	}\r\n	float weight = 0, f = 0;\r\n	value = 0;\r\n	for(int i = 0; i<n; i++)\r\n	{\r\n		if(c!=0)\r\n		{\r\n			f = c/W[i];\r\n			if(f>=1)\r\n			 f=1;\r\n			weight += f*W[i];\r\n			value += f*V[i];\r\n			c -= f*W[i];\r\n		}\r\n	}\r\n}\r\nint main()\r\n{\r\n	int n, W;\r\n        cin>>n>>W;\r\n        float val[n], w[n];\r\n	for( int i=0; i<n; i++)\r\n	cin>>val[i];\r\n	for( int i=0; i<n; i++)\r\n	cin>>w[i];\r\n        float value = 0;\r\n	Fractional_Knapsack(val, w, W, n, value);\r\n	cout<<value;\r\n	return 0;\r\n}', 2, '5 15 4 2 1 2 10 12 2 1 1 4', '17.3333', 'Fractional Knapsack (Array W, Array V, int M)\r\n1. for i <- 1 to size (V)\r\n2. 	calculate cost[i] <- V[i] / W[i]\r\n3. Sort-Descending (cost)\r\n4. i ← 1\r\n5. while (i <= size(V))\r\n6. 	if  W[i] <= M \r\n7.		M ← M – W[i]\r\n8.		total ← total + V[i];\r\n9. 	if  W[i] > M\r\n10. 		i ← i+1\r\n', '2020-05-25'),
(311, 12, 1901012018, '#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nclass Edge\r\n{\r\n    public:\r\n    int src, dest, weight;\r\n};\r\nclass Graph\r\n{\r\n    public:\r\n    int V, E;\r\n    Edge* edge;\r\n};\r\n\r\nGraph* createGraph(int V, int E)\r\n{\r\n    Graph* graph = new Graph;\r\n    graph->V = V;\r\n    graph->E = E;\r\n\r\n    graph->edge = new Edge[E];\r\n\r\n    return graph;\r\n}\r\nclass subset\r\n{\r\n    public:\r\n    int parent;\r\n    int rank;\r\n};\r\n\r\n\r\nint find(subset subsets[], int i)\r\n{\r\n    if (subsets[i].parent != i)\r\n        subsets[i].parent = find(subsets, subsets[i].parent);\r\n\r\n    return subsets[i].parent;\r\n}\r\nvoid Union(subset subsets[], int x, int y)\r\n{\r\n    int xroot = find(subsets, x);\r\n    int yroot = find(subsets, y);\r\n    if (subsets[xroot].rank < subsets[yroot].rank)\r\n        subsets[xroot].parent = yroot;\r\n    else if (subsets[xroot].rank > subsets[yroot].rank)\r\n        subsets[yroot].parent = xroot;\r\n\r\n    else\r\n    {\r\n        subsets[yroot].parent = xroot;\r\n        subsets[xroot].rank++;\r\n    }\r\n}\r\nint myComp(const void* a, const void* b)\r\n{\r\n    Edge* a1 = (Edge*)a;\r\n    Edge* b1 = (Edge*)b;\r\n    return a1->weight > b1->weight;\r\n}\r\nvoid KruskalMST(Graph* graph)\r\n{\r\n    int V = graph->V;\r\n    Edge result[V];\r\n    int e = 0;\r\n    int i = 0;\r\n    qsort(graph->edge, graph->E, sizeof(graph->edge[0]), myComp);\r\n\r\n    subset *subsets = new subset[( V * sizeof(subset) )];\r\n\r\n    for (int v = 0; v < V; ++v)\r\n    {\r\n        subsets[v].parent = v;\r\n        subsets[v].rank = 0;\r\n    }\r\n    while (e < V - 1 && i < graph->E)\r\n    {\r\n\r\n        Edge next_edge = graph->edge[i++];\r\n\r\n        int x = find(subsets, next_edge.src);\r\n        int y = find(subsets, next_edge.dest);\r\n\r\n        if (x != y)\r\n        {\r\n            result[e++] = next_edge;\r\n            Union(subsets, x, y);\r\n        }\r\n    }\r\n    for (i = 0; i < e; ++i)\r\n        cout<<result[i].src<<\" -- \"<<result[i].dest<<\" ==> \"<<result[i].weight<<endl;\r\n    return;\r\n}\r\nint main()\r\n{\r\n    int V = 4;\r\n    int E = 5;\r\n    Graph* graph = createGraph(V, E);\r\n    graph->edge[0].src = 0;\r\n    graph->edge[0].dest = 1;\r\n    graph->edge[0].weight = 10;\r\n\r\n    graph->edge[1].src = 0;\r\n    graph->edge[1].dest = 2;\r\n    graph->edge[1].weight = 6;\r\n\r\n    graph->edge[2].src = 0;\r\n    graph->edge[2].dest = 3;\r\n    graph->edge[2].weight = 5;\r\n\r\n    graph->edge[3].src = 1;\r\n    graph->edge[3].dest = 3;\r\n    graph->edge[3].weight = 15;\r\n\r\n    graph->edge[4].src = 2;\r\n    graph->edge[4].dest = 3;\r\n    graph->edge[4].weight = 4;\r\n    cout<<\"(Edge ==> Wt)\n\";\r\n    KruskalMST(graph);\r\n\r\n    return 1;\r\n}\r\n\r\n', 1000, '8 a b c d e f g h 1 1 2 3 5 8 13 21', 'a :1111110\nb :1111111\nc :111110\nd :11110\ne :1110\nf :110\ng :10\nh :0\n', 'Input is an array of unique characters along with their frequency of occurrences and output is Huffman Tree.\r\n \r\n1. Create a leaf node for each unique character and build a min heap of all leaf nodes (Min Heap is used as a priority queue. \r\n   The value of frequency field is used to compare two nodes in min heap. Initially, the least frequent character is at root)\r\n \r\n2. Extract two nodes with the minimum frequency from the min heap.\r\n \r\n3. Create a new internal node with a frequency equal to the sum of the two nodes frequencies.\r\n   Make the first extracted node as its left child and the other extracted node as its right child. Add this node to the min heap.\r\n \r\n4. Repeat steps2 and 3 until the heap contains only one node. The remaining node is the root node and the tree is complete.', '2020-05-25'),
(312, 10, 1301012018, '#include<iostream>\r\n#include<climits>\r\nusing namespace std;\r\nint knapSack(int W, int wt[], int val[], int n) \r\n{\r\n    int K[n+1][W+1];\r\n    for(int i = 0; i <= n; ++i)\r\n    {\r\n        for(int w = 0; w <= W; ++w)\r\n        {\r\n            if(i == 0 || w == 0) K[i][w] = 0;\r\n            else if(wt[i-1] <= w) K[i][w] = max(val[i-1] +  K[i-1][w-wt[i-1]], K[i-1][w]);\r\n            else K[i][w] = K[i-1][w];\r\n        }\r\n    }\r\n    return K[n][W]; \r\n} \r\n\r\nint main() \r\n{ \r\n    int n, W;\r\n    cin>>n>>W;\r\n    int *val = new int[n];\r\n    int *wt = new int[n];\r\n    for(int i = 0; i < n; ++i) cin>>val[i];\r\n    for(int i = 0; i < n; ++i) cin>>wt[i];\r\n    int ans = knapSack(W, wt, val, n);\r\n    cout<<ans;\r\n    delete []val;\r\n    delete []wt;\r\n	 \r\n	return 0; \r\n}', 10, '5 15 4 2 1 2 10 12 2 1 1 4', '15', 'empty algorithm!', '0000-00-00'),
(313, 10, 1801012018, '#include<iostream>\r\n#include<climits>\r\nusing namespace std;\r\nint knapSack(int W, int wt[], int val[], int n)\r\n{\r\n    int K[n+1][W+1];\r\n    for(int i = 0; i <= n; ++i)\r\n    {\r\n        for(int w = 0; w <= W; ++w)\r\n        {\r\n            if(i == 0 || w == 0) K[i][w] = 0;\r\n            else if(wt[i-1] <= w) K[i][w] = max(val[i-1] +  K[i-1][w-wt[i-1]], K[i-1][w]);\r\n            else K[i][w] = K[i-1][w];\r\n        }\r\n    }\r\n    return K[n][W];\r\n}\r\n\r\nint main()\r\n{\r\n    int n, W;\r\n    cin>>n>>W;\r\n    int *val = new int[n];\r\n    int *wt = new int[n];\r\n    for(int i = 0; i < n; ++i) cin>>val[i];\r\n    for(int i = 0; i < n; ++i) cin>>wt[i];\r\n    int ans = knapSack(W, wt, val, n);\r\n    cout<<ans;\r\n    delete []val;\r\n    delete []wt;\r\n\r\nreturn 0;\r\n}\r\n', 10, '5 15 4 2 1 2 10 12 2 1 1 4', '15', 'empty algorithm!', '0000-00-00'),
(314, 15, 3601012018, '#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint MatrixChainOrder(int p[], int n)\r\n{\r\n\r\n	int m[n][n];\r\n\r\n	int i, j, k, L, q;\r\n\r\n	for (i = 1; i < n; i++)\r\n		m[i][i] = 0;\r\n\r\n	for (L = 2; L < n; L++)\r\n	{\r\n		for (i = 1; i < n - L + 1; i++)\r\n		{\r\n			j = i + L - 1;\r\n			m[i][j] = INT_MAX;\r\n			for (k = i; k <= j - 1; k++)\r\n			{\r\n				q = m[i][k] + m[k + 1][j] +\r\n					p[i - 1] * p[k] * p[j];\r\n				if (q < m[i][j])\r\n					m[i][j] = q;\r\n			}\r\n		}\r\n	}\r\n\r\n	return m[1][n - 1];\r\n}\r\n\r\nint main()\r\n{\r\n    int n;\r\n    cin>>n;\r\n	int arr[n];\r\n	for(int i=0;i<n;i++)\r\n        cin>>arr[i];\r\n\r\n	cout<< MatrixChainOrder(arr, n);\r\n	return 0;\r\n}\r\n', 1000, '8 a b c d e f g h 1 1 2 3 5 8 13 21', 'h : 0\ng : 10\nf : 110\ne : 1110\nd : 11110\nc : 111110\na : 1111110\nb : 1111111\n', 'Algorithm\r\n1) Create a set mstSet that keeps track of vertices already included in MST.\r\n2) Assign a key value to all vertices in the input graph. Initialize all key values as INFINITE. Assign key value as 0 for the first vertex so that it is picked first.\r\n3) While mstSet doesn’t include all vertices\r\n….a) Pick a vertex u which is not there in mstSet and has minimum key value.\r\n….b) Include u to mstSet.\r\n….c) Update key value of all adjacent vertices of u. To update the key values, iterate through all adjacent vertices. For every adjacent vertex v, if weight of edge u-v is less than the previous key value of v, update the key value as weight of u-v\r\nMST-PRIM (G, w, r)\r\n 1. for each u ∈ V [G]\r\n 2. do key [u] ← ∞\r\n 3. π [u] ← NIL\r\n 4. key [r] ← 0\r\n 5. Q ← V [G]\r\n 6. While Q ? ∅\r\n 7. do u ← EXTRACT - MIN (Q)\r\n 8. for each v ∈ Adj [u]\r\n 9. do if v ∈ Q and w (u, v) < key [v]\r\n 10. then π [v] ← u\r\n 11. key [v] ← w (u, v)', '2020-05-25'),
(315, 10, 1101012018, '#include<iostream>\r\n#include<climits>\r\nusing namespace std;\r\nint knapSack(int W, int wt[], int val[], int n) \r\n{\r\n    int K[n+1][W+1];\r\n    for(int i = 0; i <= n; ++i)\r\n    {\r\n        for(int w = 0; w <= W; ++w)\r\n        {\r\n            if(i == 0 || w == 0) K[i][w] = 0;\r\n            else if(wt[i-1] <= w) K[i][w] = max(val[i-1] +  K[i-1][w-wt[i-1]], K[i-1][w]);\r\n            else K[i][w] = K[i-1][w];\r\n        }\r\n    }\r\n    return K[n][W]; \r\n} \r\n\r\nint main() \r\n{ \r\n    int n, W;\r\n    cin>>n>>W;\r\n    int *val = new int[n];\r\n    int *wt = new int[n];\r\n    for(int i = 0; i < n; ++i) cin>>val[i];\r\n    for(int i = 0; i < n; ++i) cin>>wt[i];\r\n    int ans = knapSack(W, wt, val, n);\r\n    cout<<ans;\r\n    delete []val;\r\n    delete []wt;\r\n	 \r\n	return 0; \r\n}', 10, '5 15 4 2 1 2 10 12 2 1 1 4', '15', 'empty algorithm!', '0000-00-00'),
(316, 10, 1601012018, '#include<iostream>\r\n#include<climits>\r\nusing namespace std;\r\nint knapSack(int W, int wt[], int val[], int n) \r\n{\r\n    int K[n+1][W+1];\r\n    for(int i = 0; i <= n; ++i)\r\n    {\r\n        for(int w = 0; w <= W; ++w)\r\n        {\r\n            if(i == 0 || w == 0) K[i][w] = 0;\r\n            else if(wt[i-1] <= w) K[i][w] = max(val[i-1] +  K[i-1][w-wt[i-1]], K[i-1][w]);\r\n            else K[i][w] = K[i-1][w];\r\n        }\r\n    }\r\n    return K[n][W]; \r\n} \r\n\r\nint main() \r\n{ \r\n    int n, W;\r\n    cin>>n>>W;\r\n    int *val = new int[n];\r\n    int *wt = new int[n];\r\n    for(int i = 0; i < n; ++i) cin>>val[i];\r\n    for(int i = 0; i < n; ++i) cin>>wt[i];\r\n    int ans = knapSack(W, wt, val, n);\r\n    cout<<ans;\r\n    delete []val;\r\n    delete []wt;\r\n	 \r\n	return 0; \r\n}', 10, '5 15 4 2 1 2 10 12 2 1 1 4', '15', 'empty algorithm!', '0000-00-00'),
(318, 10, 501012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n\r\nint max(int a, int b) { return (a > b)? a : b; }  \r\n\r\nint knapSack(int W, int wt[], int val[], int n)  \r\n{  \r\n      \r\n\r\nif (n == 0 || W == 0)  \r\n    return 0;  \r\n\r\nif (wt[n-1] > W)  \r\n    return knapSack(W, wt, val, n-1);  \r\n\r\nelse return max( val[n-1] + knapSack(W-wt[n-1], wt, val, n-1),  \r\n                    knapSack(W, wt, val, n-1) );  \r\n}  \r\n \r\nint main()  \r\n{   \r\n    int n,W;\r\n    cin>>n >>W;\r\n    int val[n];  \r\n    int wt[n];  \r\n   \r\n    for(int i=0;i<n;i++)\r\n    {\r\n        cin>>val[i];\r\n    }\r\n    \r\n    for(int i=0;i<n;i++)\r\n    {\r\n        cin>>wt[i];\r\n    }\r\n    cout<<knapSack(W, wt, val, n);  \r\n    return 0;  \r\n}  ', 10, '5 15 4 2 1 2 10 12 2 1 1 4', '15', 'empty algorithm!', '0000-00-00'),
(319, 3, 1301012018, '', 0, '', '', 'partition (arr[], low, high)\r\n{\r\n    // pivot (Element to be placed at right position)\r\n    pivot = arr[high];  \r\n \r\n    i = (low - 1)  // Index of smaller element\r\n\r\n    for (j = low; j <= high- 1; j++)\r\n    {\r\n        // If current element is smaller than the pivot\r\n        if (arr[j] < pivot)\r\n        {\r\n            i++;    // increment index of smaller element\r\n            swap arr[i] and arr[j]\r\n        }\r\n    }\r\n    swap arr[i + 1] and arr[high])\r\n    return (i + 1)\r\n}', '0000-00-00'),
(320, 10, 2101012018, '#include <iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n    int array[2][100], n, w, i, curw, used[100], maxi = -1, totalprofit = 0;\r\n    cin >> n;\r\n    cin >> w;\r\n    for (i = 0; i < n; i++)\r\n    {\r\n        cin >> array[1][i];\r\n    }\r\n    for (i = 0; i < n; i++)\r\n    {\r\n        cin>>array[0][i];\r\n        used[i] = 0;\r\n    }\r\n    curw = w;\r\n    while (curw >= 0)\r\n    {\r\n        maxi = -1;\r\n        for (i = 0; i < n; i++)\r\n        {\r\n            if ((used[i] == 0) && ((maxi == -1) || (((float) array[1][i]\r\n                    / (float) array[0][i]) > ((float) array[1][maxi]\r\n                    / (float) array[0][maxi]))))\r\n            {\r\n                maxi = i;\r\n            }\r\n        }\r\n        used[maxi] = 1;\r\n        curw -= array[0][maxi];\r\n        totalprofit += array[1][maxi];\r\n        if (curw >= 0)\r\n        {\r\n\r\n        }\r\n        else\r\n        {\r\n\r\n            totalprofit -= array[1][maxi];\r\n            totalprofit += ((array[1][maxi] / array[0][maxi]) * (array[0][maxi]\r\n                    + curw));\r\n        }\r\n    }\r\n    cout <<totalprofit;\r\n    return 0;\r\n}', 6, '5 15 4 2 1 2 10 12 2 1 1 4', '15', '1 Choose the lowest/highest index value has pivot\r\n2 Take two variables to point left and right of the list excluding pivot\r\n3 left points to the low index\r\n4 right points to the high\r\n5 while value at left is less than pivot move right\r\n6 while value at right is greater than pivot move left\r\n7 if both step 5 and step 6 does not match swap left and right\r\n8 if left ≥ right, the point where they met is new pivot', '2020-05-25'),
(322, 4, 7601012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\nclass Pair{ public: int min; int max; }; Pair maxMin(int arr[], int beg, int end){ Pair mxMn; if (end == beg){ mxMn.min = arr[beg]; mxMn.max = arr[beg]; return mxMn; } if (end - beg == 1){ if (arr[beg] < arr[end]){ mxMn.min = arr[beg]; mxMn.max = arr[end]; } else { mxMn.min = arr[end]; mxMn.max = arr[beg]; } return mxMn; } int mid = (beg + end) / 2; Pair ml = maxMin(arr, beg, mid); Pair mr = maxMin(arr, mid + 1, end); if (ml.min > mr.min) mxMn.min = mr.min; else mxMn.min = ml.min; if (ml.max > mr.max) mxMn.max = ml.max; else mxMn.max = mr.max; return mxMn; } \r\nint main(){ cout <<\"Enter the number of elements :\"; int n; cin >> n; int arr[n]; cout <<\"Enter the array : \"; for (int i = 0; i < n; ++i) cin >> arr[i]; Pair mxMn = maxMin(arr, 0, n - 1); cout << mxMn.min << \" \" << mxMn.max; }\r\n', 4, '6 1000 11 445 1 330 3000', 'Enter the number of elements :Enter the array : 1 3000', 'empty algorithm!', '2020-05-20'),
(323, 10, 7601012018, '#include<iostream>\r\nusing namespace std;\r\nint main(){\r\n    cout<<\"hello world\";\r\n    return 0;\r\n}', 0, '8 a b c d e f g h 1 1 2 3 5 8 13 21', '', 'empty algorithm!', '0000-00-00'),
(324, 11, 7601012018, '#include<iostream>\r\nusing namespace std;\r\nint main(){\r\n    cout<<\"hello world\";\r\n    return 0;\r\n}', -50, '8 a b c d e f g h 1 1 2 3 5 8 13 21', 'hello world', 'empty algorithm!', '0000-00-00'),
(330, 4, 4201012018, '#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nclass Pair{\r\npublic:\r\n	int min;\r\n	int max;\r\n};\r\n\r\nPair maxMin(int arr[], int beg, int end){\r\n	Pair mxMn;\r\n	if (end == beg){\r\n		mxMn.min = arr[beg];\r\n		mxMn.max = arr[beg];\r\n		return mxMn;\r\n	}\r\n\r\n	if (end - beg == 1){\r\n		if (arr[beg] < arr[end]){\r\n			mxMn.min = arr[beg];\r\n			mxMn.max = arr[end];\r\n		}\r\n		else {\r\n			mxMn.min = arr[end];\r\n			mxMn.max = arr[beg];\r\n		}\r\n		return mxMn;\r\n	}\r\n\r\n	int mid = (beg + end) / 2;\r\n\r\n	Pair ml = maxMin(arr, beg, mid);\r\n	Pair mr = maxMin(arr, mid + 1, end);\r\n\r\n	if (ml.min > mr.min) mxMn.min = mr.min;\r\n	else mxMn.min = ml.min;\r\n\r\n	if (ml.max > mr.max) mxMn.max = ml.max;\r\n	else mxMn.max = mr.max;\r\n	return mxMn;\r\n}\r\n\r\nint main(){\r\n	int n; cin >> n;\r\n	int arr[n];\r\n	for (int i = 0; i < n; ++i) cin >> arr[i];\r\n\r\n	Pair mxMn = maxMin(arr, 0, n - 1);\r\n	cout << mxMn.min << \" \" << mxMn.max;\r\n}', 10, '6 1000 11 445 1 330 3000', '1 3000', 'maxmin(arr,beg,end)\r\n	if end=beg\r\n		max=min=arr[beg]\r\n	if end=beg+1\r\n		if arr[beg]>arr[end]\r\n			max=arr[beg]\r\n			min=arr[end]\r\n		else\r\n			max=arr[end]\r\n			min=arr[beg]\r\n\r\n	mid = (beg+end)/2\r\n	min,max = maxmin(arr,beg,mid)\r\n	min1,max1 = maxmin(arr,mid+1,end)\r\n	if (min>min1)min=min1\r\n	if (max<max1)max=max1\r\n', '2020-05-25'),
(331, 0, 0, '', 1000, '', '', '', '2020-05-24'),
(332, 2, 4201012018, '#include<stdlib.h> \r\n#include<stdio.h> \r\n#include <bits/stdc++.h>\r\nusing namespace std;  \r\nvoid merge(int arr[], int l, int m, int r) { \r\n    int i, j, k; \r\n    int n1 = m - l + 1; \r\n    int n2 =  r - m; \r\n  \r\n    int L[n1], R[n2]; \r\n  \r\n    for (i = 0; i < n1; i++) \r\n        L[i] = arr[l + i]; \r\n    for (j = 0; j < n2; j++) \r\n        R[j] = arr[m + 1+ j]; \r\n  \r\n    i = 0; \r\n    j = 0;  \r\n    k = l;  \r\n    while (i < n1 && j < n2) { \r\n        if (L[i] <= R[j]) { \r\n            arr[k] = L[i]; \r\n            i++; \r\n        } \r\n        else{ \r\n            arr[k] = R[j]; \r\n            j++; \r\n        } \r\n        k++; \r\n    } \r\n  \r\n    while (i < n1){ \r\n        arr[k] = L[i]; \r\n        i++; \r\n        k++; \r\n    } \r\n  \r\n    while (j < n2){ \r\n        arr[k] = R[j]; \r\n        j++; \r\n        k++; \r\n    } \r\n} \r\n  \r\nvoid mergeSort(int arr[], int l, int r){ \r\n    if (l < r){ \r\n        int m = l+(r-l)/2; \r\n  \r\n        mergeSort(arr, l, m); \r\n        mergeSort(arr, m+1, r); \r\n  \r\n        merge(arr, l, m, r); \r\n    } \r\n} \r\n  \r\nvoid printArray(int A[], int size){ \r\n    int i; \r\n    for (i=0; i < size; i++) \r\n        printf(\"%d \", A[i]); \r\n    printf(\"\n\"); \r\n} \r\n  \r\nint main(){ \r\n    int arr_size; cin >> arr_size;\r\n    int arr[arr_size];\r\n\r\n    for (int i = 0; i < arr_size; ++i) cin >> arr[i]; \r\n  \r\n  \r\n    mergeSort(arr, 0, arr_size - 1); \r\n  \r\n    printArray(arr, arr_size); \r\n} ', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '', 'merge(arr[],l,r)\r\n   initiate i=k=l, j=(l+r)/2\r\n   mid = (l+r)/2\r\n   while i<mid AND j<r\r\n	if arr[i]<arr[j]\r\n	    temp[k]=arr[i]\r\n	    i=i+1\r\n	else \r\n            temp[k]=arr[j]\r\n	    j=j+1\r\n	k=k+1\r\n   while i<mid\r\n	temp[k]=arr[i]\r\n	k=k+1, i=i+1\r\n   while j<r\r\n	temp[k]=arr[j]\r\n	k=k+1, j=j+1\r\n\r\nmergeSort(arr,l,r)\r\n   if r>1\r\n	mid=(l+r)/2\r\n	mergeSort(arr,l,mid)\r\n	mergeSort(arr,mid+1,r)\r\n	merge(arr,l,r)\r\n   ', '2020-05-25'),
(333, 3, 4201012018, '#include <iostream>\r\n#include <stdio.h>\r\nusing namespace std;\r\n\r\nvoid swap(int* a, int* b){ \r\n    int t = *a; \r\n    *a = *b; \r\n    *b = t; \r\n} \r\n  \r\nint partition (int arr[], int low, int high){ \r\n    int pivot = arr[high];    \r\n    int i = (low - 1); \r\n  \r\n    for (int j = low; j <= high- 1; j++){ \r\n        if (arr[j] < pivot){ \r\n            i++;    \r\n            swap(&arr[i], &arr[j]); \r\n        } \r\n    } \r\n    swap(&arr[i + 1], &arr[high]); \r\n    return (i + 1); \r\n} \r\n  \r\nvoid quickSort(int arr[], int low, int high){ \r\n    if (low < high){ \r\n        int pi = partition(arr, low, high); \r\n  \r\n        quickSort(arr, low, pi - 1); \r\n        quickSort(arr, pi + 1, high); \r\n    } \r\n} \r\n  \r\nvoid printArray(int arr[], int size){ \r\n    int i; \r\n    for (i = 0; i < size; i++) \r\n        printf(\"%d \", arr[i]); \r\n    printf(\"\n\"); \r\n} \r\n  \r\nint main(){ \r\n    int n;\r\n    cin >> n;\r\n    int arr[n];\r\n    for (int i = 0; i < n; ++i) cin >> arr[i]; \r\n    quickSort(arr, 0, n-1); \r\n    printArray(arr, n); \r\n} ', 0, '1 2000', '', 'partition(left, right, pivot)\r\n   l = left\r\n   r = right - 1\r\n\r\n   while True\r\n      while A[++l] < pivot            \r\n      end while\r\n		\r\n      while r > 0 && A[--r] > pivot         \r\n      end while\r\n		\r\n      if l >= r\r\n         break\r\n      else                \r\n         swap l,r\r\n      end if\r\n		\r\n   end while \r\n	\r\n   swap l,right\r\n   return l', '2020-05-25'),
(334, 7, 4201012018, '#include <cstdlib> \r\n#include <stdio.h>\r\n#include <iostream> \r\nusing namespace std; \r\n  \r\nint partition(int arr[], int low, int high) \r\n{ \r\n    int pivot = arr[high]; \r\n    int i = (low - 1); \r\n  \r\n    for (int j = low; j <= high - 1; j++) { \r\n  \r\n        if (arr[j] <= pivot) { \r\n  \r\n            i++; \r\n            swap(arr[i], arr[j]); \r\n        } \r\n    } \r\n    swap(arr[i + 1], arr[high]); \r\n    return (i + 1); \r\n} \r\n  \r\nint partition_r(int arr[], int low, int high) \r\n{ \r\n    // srand(time(NULL)); \r\n    int random = low + rand() % (high - low); \r\n  \r\n    swap(arr[random], arr[high]); \r\n  \r\n    return partition(arr, low, high); \r\n} \r\n  \r\nvoid quickSort(int arr[], int low, int high) \r\n{ \r\n    if (low < high) { \r\n  \r\n        int pi = partition_r(arr, low, high); \r\n  \r\n        quickSort(arr, low, pi - 1); \r\n        quickSort(arr, pi + 1, high); \r\n    } \r\n} \r\n  \r\nvoid printArray(int arr[], int size) \r\n{ \r\n    int i; \r\n    for (i = 0; i < size; i++) \r\n        printf(\"%d \", arr[i]); \r\n    printf(\"\n\"); \r\n} \r\n  \r\nint main() \r\n{ \r\n    \r\n    int n; cin >> n; \r\n    int arr[n];\r\n    for (int i = 0; i < n; ++i) cin >> arr[i];\r\n    quickSort(arr, 0, n - 1); \r\n    printArray(arr, n); \r\n    return 0; \r\n} ', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '', 'partition(arr[], lo, hi) \r\n    pivot = arr[hi]\r\n    i = lo     // place for swapping\r\n    for j := lo to hi – 1 do\r\n        if arr[j] <= pivot then\r\n            swap arr[i] with arr[j]\r\n            i = i + 1\r\n    swap arr[i] with arr[hi]\r\n    return i\r\n\r\npartition_r(arr[], lo, hi)\r\n    r = Random Number from lo to hi\r\n    Swap arr[r] and arr[hi]\r\n    return partition(arr, lo, hi)\r\n\r\nquicksort(arr[], lo, hi)\r\n    if lo < hi\r\n        p = partition_r(arr, lo, hi)\r\n        quicksort(arr, p-1, hi)\r\n        quicksort(arr, p+1, hi)', '2020-05-25'),
(335, 8, 4201012018, '#include<bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nconst int N = 10000 + 5;\r\n\r\nint A[N][N];\r\nint B[N][N];\r\nint D[N][N];\r\n\r\nvoid matrix_multiply(int n){\r\n	for(int i=0;i<n;i++){\r\n		for(int j=0;j<n;j++){\r\n			D[i][j] = 0;\r\n			for(int k=0;k<n;k++)\r\n				D[i][j] += A[i][k]*B[k][j];\r\n				cout << D[i][j] << \" \";\r\n		}\r\n		cout << endl;\r\n	}\r\n}\r\n\r\nstruct matrix{\r\n	int k;\r\n	vector<vector<int> > mat;\r\n\r\n	matrix(int sz){\r\n		k=sz;\r\n		mat.resize(sz);\r\n		for(int i=0;i<sz;i++)\r\n			mat[i].resize(sz);\r\n	}\r\n\r\n	matrix operator + (const matrix &o){\r\n        matrix res(k);\r\n        for(int i=0;i<k;i++){\r\n        	for(int j=0;j<k;j++)\r\n	        	res.mat[i][j]=o.mat[i][j] + mat[i][j];\r\n	    }\r\n        return res;\r\n    }\r\n\r\n    matrix operator - (const matrix &o){\r\n        matrix res(k);\r\n        for(int i=0;i<k;i++){\r\n        	for(int j=0;j<k;j++)\r\n	        	res.mat[i][j]= mat[i][j] - o.mat[i][j];\r\n	    }\r\n        return res;\r\n    }\r\n\r\n	void print(){\r\n		for(int i=0;i<k;i++){\r\n			for(int j=0;j<k;j++){\r\n				cout<<mat[i][j]<<\" \";\r\n			}\r\n			cout<<endl;\r\n		}\r\n	}\r\n};\r\n\r\nmatrix multiply(matrix A, matrix B, int n){\r\n	if(n==2){\r\n		matrix res(2);\r\n		res.mat[0][0] = A.mat[0][0]*B.mat[0][0] + A.mat[0][1]*B.mat[1][0];\r\n		res.mat[0][1] = A.mat[0][0]*B.mat[0][1] + A.mat[0][1]*B.mat[1][1];\r\n		res.mat[1][0] = A.mat[1][0]*B.mat[0][0] + A.mat[1][1]*B.mat[1][0];\r\n		res.mat[1][1] = A.mat[1][0]*B.mat[0][1] + A.mat[1][1]*B.mat[1][1];\r\n		return res;\r\n	}\r\n	if(n==1){\r\n		matrix res(1);\r\n		res.mat[0][0] = A.mat[0][0]*B.mat[0][0];\r\n		return res;\r\n	}\r\n	int h = n/2;\r\n	matrix A00(h), A01(h), A10(h), A11(h);\r\n	matrix B00(h), B01(h), B10(h), B11(h);\r\n	matrix C00(h), C01(h), C10(h), C11(h);\r\n	for(int i=0;i<h;i++){\r\n		for(int j=0;j<h;j++)\r\n		{\r\n			A00.mat[i][j] = A.mat[i][j];\r\n			B00.mat[i][j] = B.mat[i][j];\r\n			A01.mat[i][j] = A.mat[i][j+h];\r\n			B01.mat[i][j] = B.mat[i][j+h];\r\n			A10.mat[i][j] = A.mat[i+h][j];\r\n			B10.mat[i][j] = B.mat[i+h][j];\r\n			A11.mat[i][j] = A.mat[i+h][j+h];\r\n			B11.mat[i][j] = B.mat[i+h][j+h];\r\n		}\r\n	}\r\n	matrix M1(h), M2(h), M3(h), M4(h), M5(h), M6(h), M7(h);\r\n	M1 = multiply(A00 + A11, (B00 + B11), h);\r\n	M2 = multiply(A10 +  A11, B00, h);\r\n	M3 = multiply(A00, B01 - B11, h);\r\n	M4 = multiply(A11, B10 - B00, h);\r\n	M5 = multiply(A00 + A01, B11, h);\r\n	M6 = multiply(A10 - A00, B00 + B01, h);\r\n	M7 = multiply(A01 - A11, B10 + B11, h);\r\n	C00 = M1 + M4 - M5 + M7;\r\n	C01 = M3 + M5;	\r\n	C10 = M2 + M4;\r\n	C11 = M1 - M2 + M3 + M6;\r\n	matrix C(n);\r\n	for(int i=0;i<h;i++){\r\n		for(int j=0;j<h;j++){\r\n			C.mat[i][j] = C00.mat[i][j];\r\n			C.mat[i][j+h] = C01.mat[i][j];\r\n			C.mat[i+h][j] = C10.mat[i][j];\r\n			C.mat[i+h][j+h] = C11.mat[i][j];\r\n		}\r\n	}\r\n	return C;\r\n}	\r\n\r\nint main(){\r\n		int n;\r\n		cin>>n;\r\n		matrix E(n), F(n);\r\n		for(int i=0;i<n;i++){\r\n			for(int j=0;j<n;j++){\r\n				cin>>A[i][j];\r\n				E.mat[i][j] = A[i][j];\r\n			}\r\n		}\r\n		cout<<endl;\r\n		for(int i=0;i<n;i++){\r\n			for(int j=0;j<n;j++){\r\n				cin>>B[i][j];\r\n				F.mat[i][j] = B[i][j];\r\n			}\r\n		}\r\n\r\n\r\n		matrix_multiply(n);\r\n		cout<<endl;\r\n		\r\n}', 0, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '\n-17 -4 -7 \n10 2 11 \n40 92 107 \n\n', 'strassens(a,b,c)\r\n	\r\n	m1 = a[0][0] * (b[0][1] - b[1][1]);\r\n	m2 = b[1][1] * (a[0][0] + a[0][1]);\r\n	m3 = b[0][0] * (a[1][0] + a[1][1]);\r\n	m4 = a[1][1] * (b[1][0] - b[0][0]);\r\n	m5 = (a[0][0] + a[1][1]) * (b[0][0] + b[1][1]);\r\n	m6 = (a[0][1] - a[1][1]) * (b[1][0] + b[1][1]);\r\n	m7 = (a[0][0] - a[1][0]) * (b[0][0] + b[0][1]);\r\n\r\n	c[0][0] = m5 + m4 - m2 + m6;\r\n	c[0][1] = m1 + m2;\r\n	c[1][0] = m3 + m4;\r\n	c[1][1] = m1 + m5 - m3 - m7;\r\n\r\nmain()\r\n	divide matrix into many 2x2 matrices\r\n	apply strassens to them', '2020-05-25'),
(336, 2, 0, '#include<iostream>\r\n#include<climits>\r\nusing namespace std;\r\n\r\nint findMinVertex(int* weights, bool* visited, int n){\r\n\r\n	int minVertex = -1;\r\n	for(int i = 0; i < n; i++){\r\n		if(!visited[i] && (minVertex == - 1 || weights[i] < weights[minVertex])){\r\n			minVertex = i;\r\n		}\r\n	}\r\n	return minVertex;\r\n}\r\n\r\n\r\nvoid prims(int** edges, int n){\r\n\r\n	int* parent = new int[n];\r\n	int* weights = new int[n];\r\n	bool* visited = new bool[n];\r\n\r\n	for(int i = 0; i < n; i++){\r\n		visited[i] = false;\r\n		weights[i] = INT_MAX;\r\n	}\r\n	parent[0] = -1;\r\n	weights[0] = 0;\r\n\r\n	for(int i = 0; i < n - 1; i++){\r\n		// Find Min Vertex\r\n		int minVertex = findMinVertex(weights, visited, n);\r\n		visited[minVertex] = true;\r\n		// Explore un visted neighbours\r\n		for(int j = 0; j < n; j++){\r\n			if(edges[minVertex][j] != 0 && !visited[j]){\r\n				if(edges[minVertex][j] < weights[j]){\r\n					weights[j] = edges[minVertex][j];\r\n					parent[j] = minVertex;\r\n				}\r\n			}\r\n		}\r\n	}\r\n\r\n	for(int i = 1; i < n; i++){\r\n		if(parent[i] < i){\r\n			cout << parent[i] << \" “ << i << \" \" << weights[i] << endl;\r\n		}else{\r\n			cout << i << \" \" << parent[i] << \" \" << weights[i] << endl;\r\n		}\r\n	}\r\n}\r\n\r\nint main() {\r\n	int n;\r\n	int e;\r\n	cin >> n >> e;\r\n	int** edges = new int*[n];\r\n	for (int i = 0; i < n; i++) {\r\n		edges[i] = new int[n];\r\n		for (int j = 0; j < n; j++) {\r\n			edges[i][j] = 0;\r\n		}\r\n	}\r\n\r\n	for (int i = 0; i < e; i++) {\r\n		int f, s, weight;\r\n		cin >> f >> s >> weight;\r\n		edges[f][s] = weight;\r\n		edges[s][f] = weight;\r\n	}\r\n	cout << endl;\r\n	prims(edges, n);\r\n\r\n	for (int i = 0; i < n; i++) {\r\n		delete [] edges[i];\r\n	}\r\n	delete [] edges;\r\n}\r\n\r\n\r\n\r\n\r\n', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '', 'prims(InputGraph, vertices, startVertex, MST)\r\n    initialise visited array to false\r\n    count = 0   // counts vertices visited\r\n \r\n    while count < vertices // there are vertices to visit\r\n        if current node not visited\r\n            mark it visited\r\n            push all its edges to the PriorityQueue\r\n            extract the minimum edge from PriorityQueue\r\n \r\n            if the minimum edge leads to an unvisited vertex\r\n                add it to MST\r\n \r\n            current = newVertex\r\n            ++count\r\n        else\r\n            extract the minimum edge from PriorityQueue again\r\n \r\n            if the minimum edge leads to an unvisited vertex\r\n                add it to MST\r\n \r\n            current = newVertex\r\n', '2020-05-25'),
(337, 3, 0, '#include <bits/stdc++.h> \r\nstruct Edge { \r\n	int src, dest, weight; \r\n}; \r\n\r\nstruct Graph { \r\n	int V, E; \r\n	struct Edge* edge; \r\n}; \r\n\r\nstruct Graph* createGraph(int V, int E) \r\n{ \r\n	struct Graph* graph = new Graph; \r\n	graph->V = V; \r\n	graph->E = E; \r\n	graph->edge = new Edge[E]; \r\n	return graph; \r\n} \r\n\r\nvoid printArr(int dist[], int n) \r\n{ \r\n	printf(\"Vertex Distance from Source\n\"); \r\n	for (int i = 0; i < n; ++i) \r\n		printf(\"%d 		 %d\n\", i, dist[i]); \r\n} \r\n\r\nvoid BellmanFord(struct Graph* graph, int src) \r\n{ \r\n	int V = graph->V; \r\n	int E = graph->E; \r\n	int dist[V]; \r\n	for (int i = 0; i < V; i++) \r\n		dist[i] = INT_MAX; \r\n	dist[src] = 0; \r\n	for (int i = 1; i <= V - 1; i++) { \r\n		for (int j = 0; j < E; j++) { \r\n			int u = graph->edge[j].src; \r\n			int v = graph->edge[j].dest; \r\n			int weight = graph->edge[j].weight; \r\n			if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) \r\n				dist[v] = dist[u] + weight; \r\n		} \r\n	} \r\n\r\n	for (int i = 0; i < E; i++) { \r\n		int u = graph->edge[i].src; \r\n		int v = graph->edge[i].dest; \r\n		int weight = graph->edge[i].weight; \r\n		if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) { \r\n			printf(\"Graph contains negative weight cycle\"); \r\n			return; // If negative cycle is detected, simply return \r\n		} \r\n	} \r\n\r\n	printArr(dist, V); \r\n\r\n	return; \r\n} \r\n \r\nint main() \r\n{ \r\n	\r\n	int V = 5;\r\n	int E = 8; \r\n	struct Graph* graph = createGraph(V, E); \r\n	graph->edge[0].src = 0; \r\n	graph->edge[0].dest = 1; \r\n	graph->edge[0].weight = -1; \r\n\r\n	\r\n	graph->edge[1].src = 0; \r\n	graph->edge[1].dest = 2; \r\n	graph->edge[1].weight = 4; \r\n\r\n	graph->edge[2].src = 1; \r\n	graph->edge[2].dest = 2; \r\n	graph->edge[2].weight = 3; \r\n \r\n	graph->edge[3].src = 1; \r\n	graph->edge[3].dest = 3; \r\n	graph->edge[3].weight = 2; \r\n \r\n	graph->edge[4].src = 1; \r\n	graph->edge[4].dest = 4; \r\n	graph->edge[4].weight = 2; \r\n\r\n	graph->edge[5].src = 3; \r\n	graph->edge[5].dest = 2; \r\n	graph->edge[5].weight = 5; \r\n\r\n	graph->edge[6].src = 3; \r\n	graph->edge[6].dest = 1; \r\n	graph->edge[6].weight = 1; \r\n \r\n	graph->edge[7].src = 4; \r\n	graph->edge[7].dest = 3; \r\n	graph->edge[7].weight = -3; \r\n\r\n	BellmanFord(graph, 0); \r\n\r\n	return 0; \r\n}\r\n', 0, '1 2000', 'Vertex Distance from Source\n0 		 0\n1 		 -1\n2 		 2\n3 		 -2\n4 		 1\n', '01. Function Bellman-Ford(G, source)\r\n02.  for i in 1 to |U| do\r\n03.  distance[i] = +inf\r\n04.  predecessors[i] = null.\r\n05.  distance[source] = 0\r\n \r\n06.  for i in 1 to (|U| - 1) do\r\n07.  for each Edge e in Edges(G) do\r\n08.  if distance[e.from] + length(e) < distance[e.to] do\r\n09.  distance[e.to] = distance[e.from] + length(e)\r\n10.  predecessors[e.to] = e.from\r\n \r\n11 . for each Edge e in Edges(G) do\r\n12.  if distance[e.from] + length(e) < distance[e.to] do\r\n13.  error(\"Graph contains cycles of negative length\")\r\n14. return predecessors\r\n', '2020-05-25'),
(338, 7, 0, '#include <cstdlib> \r\n#include <stdio.h>\r\n#include <iostream> \r\nusing namespace std; \r\n  \r\nint partition(int arr[], int low, int high) \r\n{ \r\n    int pivot = arr[high]; \r\n    int i = (low - 1); \r\n  \r\n    for (int j = low; j <= high - 1; j++) { \r\n  \r\n        if (arr[j] <= pivot) { \r\n  \r\n            i++; \r\n            swap(arr[i], arr[j]); \r\n        } \r\n    } \r\n    swap(arr[i + 1], arr[high]); \r\n    return (i + 1); \r\n} \r\n  \r\nint partition_r(int arr[], int low, int high) \r\n{ \r\n    // srand(time(NULL)); \r\n    int random = low + rand() % (high - low); \r\n  \r\n    swap(arr[random], arr[high]); \r\n  \r\n    return partition(arr, low, high); \r\n} \r\n  \r\nvoid quickSort(int arr[], int low, int high) \r\n{ \r\n    if (low < high) { \r\n  \r\n        int pi = partition_r(arr, low, high); \r\n  \r\n        quickSort(arr, low, pi - 1); \r\n        quickSort(arr, pi + 1, high); \r\n    } \r\n} \r\n  \r\nvoid printArray(int arr[], int size) \r\n{ \r\n    int i; \r\n    for (i = 0; i < size; i++) \r\n        printf(\"%d \", arr[i]); \r\n    printf(\"\n\"); \r\n} \r\n  \r\nint main() \r\n{ \r\n    cout << \"Enter the number of elements :\";\r\n    int n; cin >> n; \r\n    int arr[n];\r\n    cout << \"Enter the array :\n\";\r\n    for (int i = 0; i < n; ++i) cin >> arr[i];\r\n    quickSort(arr, 0, n - 1); \r\n    printf(\"Sorted array: \n\"); \r\n    printArray(arr, n); \r\n    return 0; \r\n} ', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', 'Enter the number of elements :Enter the array :\nSorted array: \n0 1 4 5 6 6 8 8 8 9 9 1000 14000 \n', 'partition(arr[], lo, hi) \r\n    pivot = arr[hi]\r\n    i = lo     // place for swapping\r\n    for j := lo to hi – 1 do\r\n        if arr[j] <= pivot then\r\n            swap arr[i] with arr[j]\r\n            i = i + 1\r\n    swap arr[i] with arr[hi]\r\n    return i\r\n\r\npartition_r(arr[], lo, hi)\r\n    r = Random Number from lo to hi\r\n    Swap arr[r] and arr[hi]\r\n    return partition(arr, lo, hi)\r\n\r\nquicksort(arr[], lo, hi)\r\n    if lo < hi\r\n        p = partition_r(arr, lo, hi)\r\n        quicksort(arr, p-1, hi)\r\n        quicksort(arr, p+1, hi)', '2020-05-23'),
(339, 4, 0, '#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nclass Pair{\r\npublic:\r\n	int min;\r\n	int max;\r\n};\r\n\r\nPair maxMin(int arr[], int beg, int end){\r\n	Pair mxMn;\r\n	if (end == beg){\r\n		mxMn.min = arr[beg];\r\n		mxMn.max = arr[beg];\r\n		return mxMn;\r\n	}\r\n\r\n	if (end - beg == 1){\r\n		if (arr[beg] < arr[end]){\r\n			mxMn.min = arr[beg];\r\n			mxMn.max = arr[end];\r\n		}\r\n		else {\r\n			mxMn.min = arr[end];\r\n			mxMn.max = arr[beg];\r\n		}\r\n		return mxMn;\r\n	}\r\n\r\n	int mid = (beg + end) / 2;\r\n\r\n	Pair ml = maxMin(arr, beg, mid);\r\n	Pair mr = maxMin(arr, mid + 1, end);\r\n\r\n	if (ml.min > mr.min) mxMn.min = mr.min;\r\n	else mxMn.min = ml.min;\r\n\r\n	if (ml.max > mr.max) mxMn.max = ml.max;\r\n	else mxMn.max = mr.max;\r\n	return mxMn;\r\n}\r\n\r\nint main(){\r\n	cout << \"\nEnter the number of elements :\";\r\n	int n; cin >> n;\r\n	int arr[n];\r\n	cout << \"\nEnter the array : \n\";\r\n	for (int i = 0; i < n; ++i) cin >> arr[i];\r\n\r\n	Pair mxMn = maxMin(arr, 0, n - 1);\r\n	cout << mxMn.min << \" \" << mxMn.max;\r\n}', 0, '6 1000 11 445 1 330 3000', '\nEnter the number of elements :\nEnter the array : \n1 3000', 'maxmin(arr,beg,end)\r\n	if end=beg\r\n		max=min=arr[beg]\r\n	if end=beg+1\r\n		if arr[beg]>arr[end]\r\n			max=arr[beg]\r\n			min=arr[end]\r\n		else\r\n			max=arr[end]\r\n			min=arr[beg]\r\n\r\n	mid = (beg+end)/2\r\n	min,max = maxmin(arr,beg,mid)\r\n	min1,max1 = maxmin(arr,mid+1,end)\r\n	if (min>min1)min=min1\r\n	if (max<max1)max=max1\r\n', '2020-05-23');
INSERT INTO `qtos_map` (`ID`, `Q_ID`, `ROLL`, `SUBMISSION`, `SCORE`, `INPUT`, `OP`, `ALGO`, `DATE`) VALUES
(340, 8, 0, '#include<bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nconst int N = 10000 + 5;\r\n\r\nint A[N][N];\r\nint B[N][N];\r\nint D[N][N];\r\n\r\nvoid matrix_multiply(int n){\r\n	for(int i=0;i<n;i++){\r\n		for(int j=0;j<n;j++){\r\n			D[i][j] = 0;\r\n			for(int k=0;k<n;k++)\r\n				D[i][j] += A[i][k]*B[k][j];\r\n				cout << D[i][j] << \" \";\r\n		}\r\n		cout << endl;\r\n	}\r\n}\r\n\r\nstruct matrix{\r\n	int k;\r\n	vector<vector<int> > mat;\r\n\r\n	matrix(int sz){\r\n		k=sz;\r\n		mat.resize(sz);\r\n		for(int i=0;i<sz;i++)\r\n			mat[i].resize(sz);\r\n	}\r\n\r\n	matrix operator + (const matrix &o){\r\n        matrix res(k);\r\n        for(int i=0;i<k;i++){\r\n        	for(int j=0;j<k;j++)\r\n	        	res.mat[i][j]=o.mat[i][j] + mat[i][j];\r\n	    }\r\n        return res;\r\n    }\r\n\r\n    matrix operator - (const matrix &o){\r\n        matrix res(k);\r\n        for(int i=0;i<k;i++){\r\n        	for(int j=0;j<k;j++)\r\n	        	res.mat[i][j]= mat[i][j] - o.mat[i][j];\r\n	    }\r\n        return res;\r\n    }\r\n\r\n	void print(){\r\n		for(int i=0;i<k;i++){\r\n			for(int j=0;j<k;j++){\r\n				cout<<mat[i][j]<<\" \";\r\n			}\r\n			cout<<endl;\r\n		}\r\n	}\r\n};\r\n\r\nmatrix multiply(matrix A, matrix B, int n){\r\n	if(n==2){\r\n		matrix res(2);\r\n		res.mat[0][0] = A.mat[0][0]*B.mat[0][0] + A.mat[0][1]*B.mat[1][0];\r\n		res.mat[0][1] = A.mat[0][0]*B.mat[0][1] + A.mat[0][1]*B.mat[1][1];\r\n		res.mat[1][0] = A.mat[1][0]*B.mat[0][0] + A.mat[1][1]*B.mat[1][0];\r\n		res.mat[1][1] = A.mat[1][0]*B.mat[0][1] + A.mat[1][1]*B.mat[1][1];\r\n		return res;\r\n	}\r\n	if(n==1){\r\n		matrix res(1);\r\n		res.mat[0][0] = A.mat[0][0]*B.mat[0][0];\r\n		return res;\r\n	}\r\n	int h = n/2;\r\n	matrix A00(h), A01(h), A10(h), A11(h);\r\n	matrix B00(h), B01(h), B10(h), B11(h);\r\n	matrix C00(h), C01(h), C10(h), C11(h);\r\n	for(int i=0;i<h;i++){\r\n		for(int j=0;j<h;j++)\r\n		{\r\n			A00.mat[i][j] = A.mat[i][j];\r\n			B00.mat[i][j] = B.mat[i][j];\r\n			A01.mat[i][j] = A.mat[i][j+h];\r\n			B01.mat[i][j] = B.mat[i][j+h];\r\n			A10.mat[i][j] = A.mat[i+h][j];\r\n			B10.mat[i][j] = B.mat[i+h][j];\r\n			A11.mat[i][j] = A.mat[i+h][j+h];\r\n			B11.mat[i][j] = B.mat[i+h][j+h];\r\n		}\r\n	}\r\n	matrix M1(h), M2(h), M3(h), M4(h), M5(h), M6(h), M7(h);\r\n	M1 = multiply(A00 + A11, (B00 + B11), h);\r\n	M2 = multiply(A10 +  A11, B00, h);\r\n	M3 = multiply(A00, B01 - B11, h);\r\n	M4 = multiply(A11, B10 - B00, h);\r\n	M5 = multiply(A00 + A01, B11, h);\r\n	M6 = multiply(A10 - A00, B00 + B01, h);\r\n	M7 = multiply(A01 - A11, B10 + B11, h);\r\n	C00 = M1 + M4 - M5 + M7;\r\n	C01 = M3 + M5;	\r\n	C10 = M2 + M4;\r\n	C11 = M1 - M2 + M3 + M6;\r\n	matrix C(n);\r\n	for(int i=0;i<h;i++){\r\n		for(int j=0;j<h;j++){\r\n			C.mat[i][j] = C00.mat[i][j];\r\n			C.mat[i][j+h] = C01.mat[i][j];\r\n			C.mat[i+h][j] = C10.mat[i][j];\r\n			C.mat[i+h][j+h] = C11.mat[i][j];\r\n		}\r\n	}\r\n	return C;\r\n}	\r\n\r\nint main(){\r\n		cout<<\"Enter number of rows and columns : \";\r\n		int n;\r\n		cin>>n;\r\n		cout<<\"Enter the first matrix : \"<<endl;\r\n		matrix E(n), F(n);\r\n		for(int i=0;i<n;i++){\r\n			for(int j=0;j<n;j++){\r\n				cin>>A[i][j];\r\n				E.mat[i][j] = A[i][j];\r\n			}\r\n		}\r\n		cout<<endl;\r\n		cout<<\"Enter the second matrix : \"<<endl;\r\n		for(int i=0;i<n;i++){\r\n			for(int j=0;j<n;j++){\r\n				cin>>B[i][j];\r\n				F.mat[i][j] = B[i][j];\r\n			}\r\n		}\r\n\r\n\r\n		matrix_multiply(n);\r\n		cout<<endl;\r\n		\r\n}', 0, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', 'Enter number of rows and columns : Enter the first matrix : \n\nEnter the second matrix : \n-17 -4 -7 \n10 2 11 \n40 92 107 \n\n', 'strassens(a,b,c)\r\n	\r\n	m1 = a[0][0] * (b[0][1] - b[1][1]);\r\n	m2 = b[1][1] * (a[0][0] + a[0][1]);\r\n	m3 = b[0][0] * (a[1][0] + a[1][1]);\r\n	m4 = a[1][1] * (b[1][0] - b[0][0]);\r\n	m5 = (a[0][0] + a[1][1]) * (b[0][0] + b[1][1]);\r\n	m6 = (a[0][1] - a[1][1]) * (b[1][0] + b[1][1]);\r\n	m7 = (a[0][0] - a[1][0]) * (b[0][0] + b[0][1]);\r\n\r\n	c[0][0] = m5 + m4 - m2 + m6;\r\n	c[0][1] = m1 + m2;\r\n	c[1][0] = m3 + m4;\r\n	c[1][1] = m1 + m5 - m3 - m7;\r\n\r\nmain()\r\n	divide matrix into many 2x2 matrices\r\n	apply strassens to them', '2020-05-23'),
(341, 11, 0, '#include <stdio.h>\r\n\r\n#define max 10\r\n\r\nint a[11] = { 10, 14, 19, 26, 27, 31, 33, 35, 42, 44, 0 };\r\nint b[10];\r\n\r\nvoid merging(int low, int mid, int high) {\r\n   int l1, l2, i;\r\n\r\n   for(l1 = low, l2 = mid + 1, i = low; l1 <= mid && l2 <= high; i++) {\r\n      if(a[l1] <= a[l2])\r\n         b[i] = a[l1++];\r\n      else\r\n         b[i] = a[l2++];\r\n   }\r\n   \r\n   while(l1 <= mid)    \r\n      b[i++] = a[l1++];\r\n\r\n   while(l2 <= high)   \r\n      b[i++] = a[l2++];\r\n\r\n   for(i = low; i <= high; i++)\r\n      a[i] = b[i];\r\n}\r\n\r\nvoid sort(int low, int high) {\r\n   int mid;\r\n   \r\n   if(low < high) {\r\n      mid = (low + high) / 2;\r\n      sort(low, mid);\r\n      sort(mid+1, high);\r\n      merging(low, mid, high);\r\n   } else { \r\n      return;\r\n   }   \r\n}\r\n\r\nint main() { \r\n   int i;\r\n\r\n   printf(\"List before sorting\n\");\r\n   \r\n   for(i = 0; i <= max; i++)\r\n      printf(\"%d \", a[i]);\r\n\r\n   sort(0, max);\r\n\r\n   printf(\"\nList after sorting\n\");\r\n   \r\n   for(i = 0; i <= max; i++)\r\n      printf(\"%d \", a[i]);\r\n}', 0, '8 a b c d e f g h 1 1 2 3 5 8 13 21', 'List before sorting\n10 14 19 26 27 31 33 35 42 44 0 \nList after sorting\n0 10 14 19 26 27 31 33 35 42 44 ', 'MergeSort(arr[], l,  r)\r\nIf r > l\r\n     1. Find the middle point to divide the array into two halves:  \r\n             middle m = (l+r)/2\r\n     2. Call mergeSort for first half:   \r\n             Call mergeSort(arr, l, m)\r\n     3. Call mergeSort for second half:\r\n             Call mergeSort(arr, m+1, r)\r\n     4. Merge the two halves sorted in step 2 and 3:\r\n             Call merge(arr, l, m, r)', '2020-05-23'),
(342, 13, 0, '#include<iostream>\r\n#include<cstdlib>\r\n#include<ctime>\r\n#define MAX 100\r\nusing namespace std;\r\nvoid random_shuffle(int arr[]) {\r\n   \r\n   srand(time(NULL));\r\n   for (int i = MAX - 1; i > 0; i--) {\r\n      int j = rand()%(i + 1);\r\n      int temp = arr[i];\r\n      arr[i] = arr[j];\r\n      arr[j] = temp;\r\n   }\r\n}\r\nint Partition(int a[], int low, int high) {\r\n   int pivot, index, i;\r\n   index = low;\r\n   pivot = high;\r\n   for(i=low; i < high; i++) {\r\n      if(a[i] < a[pivot]) {\r\n         swap(a[i], a[index]);\r\n         index++;\r\n      }\r\n   }\r\n   swap(a[pivot], a[index]);\r\n   return index;\r\n}\r\nint RandomPivotPartition(int a[], int low, int high){\r\n   \r\n   int pvt, n, temp;\r\n   n = rand();\r\n   pvt = low + n%(high-low+1); \r\n   swap(a[high], a[pvt]);\r\n   return Partition(a, low, high);\r\n}\r\nvoid quick_sort(int arr[], int p, int q) {\r\n   int pindex;\r\n   if(p < q) {\r\n      pindex = RandomPivotPartition(arr, p, q); \r\n      \r\n      quick_sort(arr, p, pindex-1);\r\n    quick_sort(arr, pindex+1, q);\r\n}\r\n}\r\nint main()\r\n {\r\n    int i;\r\n    int arr[MAX];\r\n    for (i = 0;i < MAX; i++)\r\n        arr[i] = i + 1;\r\n        random_shuffle(arr); \r\n        quick_sort(arr, 0, MAX - 1); \r\n    for (i = 0; i < MAX; i++)\r\n        cout << arr[i] << \" \";\r\n        cout << endl;\r\n    return 0;\r\n}', 1000, '', '', 'partition(arr[], lo, hi) \r\n    pivot = arr[hi]\r\n    i = lo     // place for swapping\r\n    for j := lo to hi – 1 do\r\n        if arr[j] <= pivot then\r\n            swap arr[i] with arr[j]\r\n            i = i + 1\r\n    swap arr[i] with arr[hi]\r\n    return i\r\n\r\npartition_r(arr[], lo, hi)\r\n    r = Random Number from lo to hi\r\n    Swap arr[r] and arr[hi]\r\n    return partition(arr, lo, hi)\r\n\r\nquicksort(arr[], lo, hi)\r\n    if lo < hi\r\n        p = partition_r(arr, lo, hi)\r\n        quicksort(arr, p-1, hi)\r\n        quicksort(arr, p+1, hi)\r\n ', '2020-05-23'),
(343, 15, 0, ' \r\n#include <limits.h> \r\n#include <stdbool.h> \r\n#include <stdio.h>  \r\n#define V 5 \r\n\r\nint minKey(int key[], bool mstSet[]) \r\n{ \r\n    \r\n    int min = INT_MAX, min_index; \r\n  \r\n    for (int v = 0; v < V; v++) \r\n        if (mstSet[v] == false && key[v] < min) \r\n            min = key[v], min_index = v; \r\n  \r\n    return min_index; \r\n} \r\n  \r\n\r\nint printMST(int parent[], int graph[V][V]) \r\n{ \r\n    printf(\"Edge 	Weight\n\"); \r\n    for (int i = 1; i < V; i++) \r\n        printf(\"%d - %d 	%d \n\", parent[i], i, graph[i][parent[i]]); \r\n} \r\n  \r\n\r\nvoid primMST(int graph[V][V]) \r\n{ \r\n    \r\n    int parent[V]; \r\n    int key[V]; \r\n    bool mstSet[V];  \r\n    for (int i = 0; i < V; i++) \r\n        key[i] = INT_MAX, mstSet[i] = false; \r\n\r\n    key[0] = 0; \r\n    parent[0] = -1; \r\n    for (int count = 0; count < V - 1; count++) { \r\n        int u = minKey(key, mstSet); \r\n        mstSet[u] = true;  \r\n        for (int v = 0; v < V; v++) \r\n \r\n            if (graph[u][v] && mstSet[v] == false && graph[u][v] < key[v]) \r\n                parent[v] = u, key[v] = graph[u][v]; \r\n    } \r\n  \r\n    \r\n    printMST(parent, graph); \r\n} \r\n \r\nint main() \r\n{ \r\n    int graph[V][V] = { { 0, 2, 0, 6, 0 }, \r\n                        { 2, 0, 3, 8, 5 }, \r\n                        { 0, 3, 0, 0, 7 }, \r\n                        { 6, 8, 0, 0, 9 }, \r\n                        { 0, 5, 7, 9, 0 } };  \r\n    primMST(graph); \r\n  \r\n    return 0; \r\n} ', 1000, '', '', 'Algorithm\r\n1) Create a set mstSet that keeps track of vertices already included in MST.\r\n2) Assign a key value to all vertices in the input graph. Initialize all key values as INFINITE. Assign key value as 0 for the first vertex so that it is picked first.\r\n3) While mstSet doesn’t include all vertices\r\n….a) Pick a vertex u which is not there in mstSet and has minimum key value.\r\n….b) Include u to mstSet.\r\n….c) Update key value of all adjacent vertices of u. To update the key values, iterate through all adjacent vertices. For every adjacent vertex v, if weight of edge u-v is less than the previous key value of v, update the key value as weight of u-v', '2020-05-23'),
(344, 5, 0, '#include<iostream>\r\n#include<conio.h>\r\n#include<stdio.h> \r\nstruct Edge { \r\n    int src, dest, weight; \r\n}; \r\n  \r\nstruct Graph \r\n{  \r\n    int V, E;  \r\n    struct Edge* edge; \r\n};  \r\nstruct Graph* createGraph(int V, int E) \r\n{ \r\n    struct Graph* graph = new Graph; \r\n    graph->V = V; \r\n    graph->E = E; \r\n    graph->edge = new Edge[E]; \r\n    return graph; \r\n}  \r\nvoid printArr(int dist[], int n) \r\n{ \r\n    printf(\"Vertex   Distance from Source\n\"); \r\n    for (int i = 0; i < n; ++i) \r\n        printf(\"%d 		 %d\n\", i, dist[i]); \r\n} \r\n  \r\nvoid BellmanFord(struct Graph* graph, int src) \r\n{ \r\n    int V = graph->V; \r\n    int E = graph->E; \r\n    int dist[V]; \r\n  \r\n    for (int i = 0; i < V; i++) \r\n        dist[i] = INT_MAX; \r\n    dist[src] = 0; \r\n  \r\n    for (int i = 1; i <= V - 1; i++) { \r\n        for (int j = 0; j < E; j++) { \r\n            int u = graph->edge[j].src; \r\n            int v = graph->edge[j].dest; \r\n            int weight = graph->edge[j].weight; \r\n            if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) \r\n                dist[v] = dist[u] + weight; \r\n        } \r\n    } \r\n     for (int i = 0; i < E; i++) { \r\n        int u = graph->edge[i].src; \r\n        int v = graph->edge[i].dest; \r\n        int weight = graph->edge[i].weight; \r\n        if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) { \r\n            printf(\"Graph contains negative weight cycle\"); \r\n            return;  \r\n        } \r\n    } \r\n  \r\n    printArr(dist, V); \r\n  \r\n    return; \r\n} \r\n  \r\nint main() \r\n{ \r\n    int V = 5;  \r\n    int E = 8; \r\n    struct Graph* graph = createGraph(V, E); \r\n  \r\n    \r\n    graph->edge[0].src = 0; \r\n    graph->edge[0].dest = 1; \r\n    graph->edge[0].weight = -1; \r\n  \r\n    \r\n    graph->edge[1].src = 0; \r\n    graph->edge[1].dest = 2; \r\n    graph->edge[1].weight = 4; \r\n  \r\n    \r\n    graph->edge[2].src = 1; \r\n    graph->edge[2].dest = 2; \r\n    graph->edge[2].weight = 3; \r\n  \r\n    \r\n    graph->edge[3].src = 1; \r\n    graph->edge[3].dest = 3; \r\n    graph->edge[3].weight = 2; \r\n  \r\n   \r\n    graph->edge[4].src = 1; \r\n    graph->edge[4].dest = 4; \r\n    graph->edge[4].weight = 2; \r\n  \r\n  \r\n    graph->edge[5].src = 3; \r\n    graph->edge[5].dest = 2; \r\n    graph->edge[5].weight = 5; \r\n  \r\n    \r\n    graph->edge[6].src = 3; \r\n    graph->edge[6].dest = 1; \r\n    graph->edge[6].weight = 1; \r\n  \r\n    \r\n    graph->edge[7].src = 4; \r\n    graph->edge[7].dest = 3; \r\n    graph->edge[7].weight = -3; \r\n  \r\n    BellmanFord(graph, 0); \r\n  \r\n    return 0; \r\n} ', 1000, '', '', 'Algorithm\r\nFollowing are the detailed steps.\r\n\r\nInput: Graph and a source vertex src\r\nOutput: Shortest distance to all vertices from src. If there is a negative weight cycle, then shortest distances are not calculated, negative weight cycle is reported.\r\n\r\n\r\n\r\n\r\n1) This step initializes distances from source to all vertices as infinite and distance to source itself as 0. Create an array dist[] of size |V| with all values as infinite except dist[src] where src is source vertex.\r\n\r\n2) This step calculates shortest distances. Do following |V|-1 times where |V| is the number of vertices in given graph.\r\n…..a) Do following for each edge u-v\r\n………………If dist[v] > dist[u] + weight of edge uv, then update dist[v]\r\n………………….dist[v] = dist[u] + weight of edge uv\r\n\r\n3) This step reports if there is a negative weight cycle in graph. Do following for each edge u-v\r\n……If dist[v] > dist[u] + weight of edge uv, then “Graph contains negative weight cycle”\r\nThe idea of step 3 is, step 2 guarantees shortest distances if graph doesn’t contain negative weight cycle. If we iterate through all edges one more time and get a shorter path for any vertex, then there is a negative weight cycle', '2020-05-23'),
(345, 11, 2601012018, '', 0, 'testing', 'testing', 'Input is an array of unique characters along with their frequency of occurrences and output is Huffman Tree.\r\n\r\n1. Create a leaf node for each unique character and build a min heap of all leaf nodes (Min Heap is used as a priority queue. The value of frequency field is used to compare two nodes in min heap. Initially, the least frequent character is at root)\r\n\r\n2. Extract two nodes with the minimum frequency from the min heap.\r\n\r\n3. Create a new internal node with a frequency equal to the sum of the two nodes frequencies. Make the first extracted node as its left child and the other extracted node as its right child. Add this node to the min heap.\r\n\r\n4. Repeat steps#2 and #3 until the heap contains only one node. The remaining node is the root node and the tree is complete.', '2020-05-24'),
(346, 13, 2601012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n  \r\n#define V 5  \r\n  \r\nint minKey(int key[], bool mstSet[])  \r\n{  \r\n    int min = INT_MAX, min_index;  \r\n  \r\n    for (int v = 0; v < V; v++)  \r\n        if (mstSet[v] == false && key[v] < min)  \r\n            min = key[v], min_index = v;  \r\n  \r\n    return min_index;  \r\n}  \r\n   \r\nvoid printMST(int parent[], int graph[V][V])  \r\n{  \r\n    cout<<\"Edge 	Weight\n\";  \r\n    for (int i = 1; i < V; i++)  \r\n        cout<<parent[i]<<\" - \"<<i<<\" 	\"<<graph[i][parent[i]]<<\" \n\";  \r\n}  \r\nvoid primMST(int graph[V][V])  \r\n{  \r\n    int parent[V];  \r\n    \r\n    int key[V];  \r\n    bool mstSet[V];  \r\n    for (int i = 0; i < V; i++)  \r\n        key[i] = INT_MAX, mstSet[i] = false;  \r\n   \r\n    key[0] = 0;  \r\n    parent[0] = -1; \r\n  \r\n    for (int count = 0; count < V - 1; count++) \r\n    {   \r\n        int u = minKey(key, mstSet); \r\n        mstSet[u] = true;  \r\n        for (int v = 0; v < V; v++)   \r\n            if (graph[u][v] && mstSet[v] == false && graph[u][v] < key[v])  \r\n                parent[v] = u, key[v] = graph[u][v];  \r\n    }   \r\n    printMST(parent, graph);  \r\n}  \r\nint main()  \r\n{  \r\n    int graph[V][V] = { { 0, 2, 0, 6, 0 },  \r\n                        { 2, 0, 3, 8, 5 },  \r\n                        { 0, 3, 0, 0, 7 },  \r\n                        { 6, 8, 0, 0, 9 },  \r\n                        { 0, 5, 7, 9, 0 } };  \r\n \r\n    primMST(graph);  \r\n  \r\n    return 0;  \r\n}  ', 1000, '8 a b c d e f g h 1 1 2 3 5 8 13 21', 'f: 0\nc: 100\nd: 101\na: 1100\nb: 1101\ne: 111\n', 'Algorithm\r\n1) Create a set mstSet that keeps track of vertices already included in MST.\r\n2) Assign a key value to all vertices in the input graph. Initialize all key values as INFINITE. Assign key value as 0 for the first vertex so that it is picked first.\r\n3) While mstSet doesn’t include all vertices\r\n….a) Pick a vertex u which is not there in mstSet and has minimum key value.\r\n….b) Include u to mstSet.\r\n….c) Update key value of all adjacent vertices of u. To update the key values, iterate through all adjacent vertices. For every adjacent vertex v, if weight of edge u-v is less than the previous key value of v, update the key value as weight of u-v', '2020-05-25'),
(347, 14, 2601012018, '#include <bits/stdc++.h> \r\nusing namespace std;  \r\n\r\nstruct Edge { \r\n    int src, dest, weight; \r\n}; \r\n  \r\nstruct Graph { \r\n    int V, E; \r\n    struct Edge* edge; \r\n}; \r\n  \r\nstruct Graph* createGraph(int V, int E) \r\n{ \r\n    struct Graph* graph = new Graph; \r\n    graph->V = V; \r\n    graph->E = E; \r\n    graph->edge = new Edge[E]; \r\n    return graph; \r\n} \r\n  \r\nvoid printArr(int dist[], int n) \r\n{ \r\n    printf(\"Vertex   Distance from Source\n\"); \r\n    for (int i = 0; i < n; ++i) \r\n        printf(\"%d 		 %d\n\", i, dist[i]); \r\n} \r\n  \r\nvoid BellmanFord(struct Graph* graph, int src) \r\n{ \r\n    int V = graph->V; \r\n    int E = graph->E; \r\n    int dist[V]; \r\n \r\n    for (int i = 0; i < V; i++) \r\n        dist[i] = INT_MAX; \r\n    dist[src] = 0; \r\n \r\n    for (int i = 1; i <= V - 1; i++) { \r\n        for (int j = 0; j < E; j++) { \r\n            int u = graph->edge[j].src; \r\n            int v = graph->edge[j].dest; \r\n            int weight = graph->edge[j].weight; \r\n            if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) \r\n                dist[v] = dist[u] + weight; \r\n        } \r\n    } \r\n  \r\n   \r\n    for (int i = 0; i < E; i++) { \r\n        int u = graph->edge[i].src; \r\n        int v = graph->edge[i].dest; \r\n        int weight = graph->edge[i].weight; \r\n        if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) { \r\n            printf(\"Graph contains negative weight cycle\"); \r\n            return; \r\n        } \r\n    } \r\n  \r\n    printArr(dist, V); \r\n  \r\n    return; \r\n} \r\n\r\nint main() \r\n{ \r\n    int V = 5;\r\n    int E=8;\r\n    struct Graph* graph = createGraph(V, E); \r\n  \r\n    graph->edge[0].src = 0; \r\n    graph->edge[0].dest = 1; \r\n    graph->edge[0].weight = -1; \r\n  \r\n \r\n    graph->edge[1].src = 0; \r\n    graph->edge[1].dest = 2; \r\n    graph->edge[1].weight = 4; \r\n  \r\n    graph->edge[2].src = 1; \r\n    graph->edge[2].dest = 2; \r\n    graph->edge[2].weight = 3; \r\n  \r\n    graph->edge[3].src = 1; \r\n    graph->edge[3].dest = 3; \r\n    graph->edge[3].weight = 2; \r\n  \r\n    graph->edge[4].src = 1; \r\n    graph->edge[4].dest = 4; \r\n    graph->edge[4].weight = 2; \r\n  \r\n    graph->edge[5].src = 3; \r\n    graph->edge[5].dest = 2; \r\n    graph->edge[5].weight = 5; \r\n  \r\n    graph->edge[6].src = 3; \r\n    graph->edge[6].dest = 1; \r\n    graph->edge[6].weight = 1; \r\n  \r\n    graph->edge[7].src = 4; \r\n    graph->edge[7].dest = 3; \r\n    graph->edge[7].weight = -3; \r\n  \r\n    BellmanFord(graph, 0); \r\n  \r\n    return 0; \r\n} ', 1000, '8 a b c d e f g h 1 1 2 3 5 8 13 21', 'f: 0\nc: 100\nd: 101\na: 1100\nb: 1101\ne: 111\n', 'This algorithm detects the negative cycle in a graph and reports their existence.\r\n\r\nBased on the \"Principle of Relaxation\" in which more accurate values gradually recovered an approximation to the proper distance by until eventually reaching the optimum solution.\r\n\r\nGiven a weighted directed graph G = (V, E) with source s and weight function w: E → R, the Bellman-Ford algorithm returns a Boolean value indicating whether or not there is a negative weight cycle that is attainable from the source. If there is such a cycle, the algorithm produces the shortest paths and their weights. The algorithm returns TRUE if and only if a graph contains no negative - weight cycles that are reachable from the source.', '2020-05-25'),
(348, 15, 2601012018, '#include<bits/stdc++.h> \r\nusing namespace std; \r\n  \r\n\r\nint MatrixChainOrder(int p[], int i, int j) \r\n{ \r\n    if(i == j) \r\n        return 0; \r\n    int k; \r\n    int min = INT_MAX; \r\n    int count; \r\n  \r\n    for (k = i; k < j; k++) \r\n    { \r\n        count = MatrixChainOrder(p, i, k) + \r\n                MatrixChainOrder(p, k + 1, j) + \r\n                p[i - 1] * p[k] * p[j]; \r\n  \r\n        if (count < min) \r\n            min = count; \r\n    } \r\n  \r\n    return min; \r\n} \r\nint main() \r\n{ \r\nint t;\r\ncin>>t;\r\nwhile(t!=0){\r\nint n;\r\ncin>>n;\r\nint arr[n];\r\n    cout << MatrixChainOrder(arr, 1, n - 1); \r\ncout<<endl;\r\nt--;\r\n}\r\n} ', 1000, '8 a b c d e f g h 1 1 2 3 5 8 13 21', 'f: 0\nc: 100\nd: 101\na: 1100\nb: 1101\ne: 111\n', 'MATRIX-CHAIN-ORDER (p)\r\n\r\n\r\n 1. n   length[p]-1\r\n 2. for i ← 1 to n\r\n 3. do m [i, i] ← 0\r\n 4. for l ← 2 to n    // l is the chain length\r\n 5. do for i ← 1 to n-l + 1\r\n 6. do j ← i+ l -1\r\n 7. m[i,j] ←  ∞\r\n 8. for k  ← i to j-1\r\n 9. do q  ← m [i, k] + m [k + 1, j] + pi-1 pk pj	\r\n 10. If q < m [i,j]\r\n 11. then m [i,j] ← q\r\n 12. s [i,j] ← k\r\n 13. return m and s.   ', '2020-05-25'),
(349, 5, 2601012018, '// CPP program to implement Strassen’s Matrix  \r\n// Multiplication Algorithm  \r\n#include<iostream>\r\n#include<conio.h>\r\n#include<stdio.h>\r\nusing namespace std; \r\ntypedef long long lld; \r\ninline lld** MatrixMultiply(lld** a, lld** b, int n, \r\n                                      int l, int m) \r\n{ \r\n    lld** c = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        c[i] = new lld[m]; \r\n  \r\n    for (int i = 0; i < n; i++) { \r\n        for (int j = 0; j < m; j++) { \r\n            c[i][j] = 0; \r\n            for (int k = 0; k < l; k++) { \r\n                c[i][j] += a[i][k] * b[k][j]; \r\n            } \r\n        } \r\n    } \r\n    return c; \r\n} \r\n  \r\ninline lld** Strassen(lld** a, lld** b, int n,  \r\n                                int l, int m) \r\n{ \r\n    if (n == 1 || l == 1 || m == 1)  \r\n        return MatrixMultiply(a, b, n, l, m); \r\n  \r\n    lld** c = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        c[i] = new lld[m]; \r\n  \r\n    int adjN = (n >> 1) + (n & 1); \r\n    int adjL = (l >> 1) + (l & 1); \r\n    int adjM = (m >> 1) + (m & 1); \r\n  \r\n    lld**** As = new lld***[2]; \r\n    for (int x = 0; x < 2; x++) { \r\n        As[x] = new lld**[2]; \r\n        for (int y = 0; y < 2; y++) { \r\n            As[x][y] = new lld*[adjN]; \r\n            for (int i = 0; i < adjN; i++) { \r\n                As[x][y][i] = new lld[adjL]; \r\n                for (int j = 0; j < adjL; j++) { \r\n                    int I = i + (x & 1) * adjN; \r\n                    int J = j + (y & 1) * adjL; \r\n                    As[x][y][i][j] = (I < n && J < l) ? a[I][J] : 0; \r\n                } \r\n            } \r\n        } \r\n    } \r\n  \r\n    lld**** Bs = new lld***[2]; \r\n    for (int x = 0; x < 2; x++) { \r\n        Bs[x] = new lld**[2]; \r\n        for (int y = 0; y < 2; y++) { \r\n            Bs[x][y] = new lld*[adjN]; \r\n            for (int i = 0; i < adjL; i++) { \r\n                Bs[x][y][i] = new lld[adjM]; \r\n                for (int j = 0; j < adjM; j++) { \r\n                    int I = i + (x & 1) * adjL; \r\n                    int J = j + (y & 1) * adjM; \r\n                    Bs[x][y][i][j] = (I < l && J < m) ? b[I][J] : 0; \r\n                } \r\n            } \r\n        } \r\n    } \r\n  \r\n    lld*** s = new lld**[10]; \r\n    for (int i = 0; i < 10; i++) { \r\n        switch (i) { \r\n        case 0: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][1][j][k] - Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 1: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] + As[0][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 2: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[1][0][j][k] + As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 3: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[1][0][j][k] - Bs[0][0][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 4: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] + As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 5: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 6: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][1][j][k] - As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 7: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[1][0][j][k] + Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 8: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] - As[1][0][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 9: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[0][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        } \r\n    } \r\n  \r\n    lld*** p = new lld**[7]; \r\n    p[0] = Strassen(As[0][0], s[0], adjN, adjL, adjM); \r\n    p[1] = Strassen(s[1], Bs[1][1], adjN, adjL, adjM); \r\n    p[2] = Strassen(s[2], Bs[0][0], adjN, adjL, adjM); \r\n    p[3] = Strassen(As[1][1], s[3], adjN, adjL, adjM); \r\n    p[4] = Strassen(s[4], s[5], adjN, adjL, adjM); \r\n    p[5] = Strassen(s[6], s[7], adjN, adjL, adjM); \r\n    p[6] = Strassen(s[8], s[9], adjN, adjL, adjM); \r\n  \r\n    for (int i = 0; i < adjN; i++) { \r\n        for (int j = 0; j < adjM; j++) { \r\n            c[i][j] = p[4][i][j] + p[3][i][j] - p[1][i][j] + p[5][i][j]; \r\n            if (j + adjM < m) \r\n                c[i][j + adjM] = p[0][i][j] + p[1][i][j]; \r\n            if (i + adjN < n) \r\n                c[i + adjN][j] = p[2][i][j] + p[3][i][j]; \r\n            if (i + adjN < n && j + adjM < m) \r\n                c[i + adjN][j + adjM] = p[4][i][j] + p[0][i][j] - p[2][i][j] - p[6][i][j]; \r\n        } \r\n    } \r\n  \r\n    for (int x = 0; x < 2; x++) { \r\n        for (int y = 0; y < 2; y++) { \r\n            for (int i = 0; i < adjN; i++) { \r\n                delete[] As[x][y][i]; \r\n            } \r\n            delete[] As[x][y]; \r\n        } \r\n        delete[] As[x]; \r\n    } \r\n    delete[] As; \r\n  \r\n    for (int x = 0; x < 2; x++) { \r\n        for (int y = 0; y < 2; y++) { \r\n            for (int i = 0; i < adjL; i++) { \r\n                delete[] Bs[x][y][i]; \r\n            } \r\n            delete[] Bs[x][y]; \r\n        } \r\n        delete[] Bs[x]; \r\n    } \r\n    delete[] Bs; \r\n  \r\n    for (int i = 0; i < 10; i++) { \r\n        switch (i) { \r\n        case 0: \r\n        case 3: \r\n        case 5: \r\n        case 7: \r\n        case 9: \r\n            for (int j = 0; j < adjL; j++) { \r\n                delete[] s[i][j]; \r\n            } \r\n            break; \r\n        case 1: \r\n        case 2: \r\n        case 4: \r\n        case 6: \r\n        case 8: \r\n            for (int j = 0; j < adjN; j++) { \r\n                delete[] s[i][j]; \r\n            } \r\n            break; \r\n        } \r\n        delete[] s[i]; \r\n    } \r\n    delete[] s; \r\n  \r\n    for (int i = 0; i < 7; i++) { \r\n        for (int j = 0; j < (n >> 1); j++) { \r\n            delete[] p[i][j]; \r\n        } \r\n        delete[] p[i]; \r\n    } \r\n    delete[] p; \r\n  \r\n    return c; \r\n} \r\n  \r\nint main() \r\n{ \r\n    lld** matA; \r\n    matA = new lld*[2]; \r\n    for (int i = 0; i < 2; i++) \r\n        matA[i] = new lld[3]; \r\n    matA[0][0] = 1; \r\n    matA[0][1] = 2; \r\n    matA[0][2] = 3; \r\n    matA[1][0] = 4; \r\n    matA[1][1] = 5; \r\n    matA[1][2] = 6; \r\n  \r\n    lld** matB; \r\n    matB = new lld*[3]; \r\n    for (int i = 0; i < 3; i++) \r\n        matB[i] = new lld[2]; \r\n    matB[0][0] = 7; \r\n    matB[0][1] = 8; \r\n    matB[1][0] = 9; \r\n    matB[1][1] = 10; \r\n    matB[2][0] = 11; \r\n    matB[2][1] = 12; \r\n  \r\n    lld** matC = Strassen(matA, matB, 2, 3, 2); \r\n    for (int i = 0; i < 2; i++) { \r\n        for (int j = 0; j < 2; j++) { \r\n            printf(\"%lld \", matC[i][j]); \r\n        } \r\n        printf(\"\n\"); \r\n    } \r\n  \r\n    return 0; \r\n} ', 1000, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', 'f: 0\nc: 100\nd: 101\na: 1100\nb: 1101\ne: 111\n', 'void multiply(int A[][N], int B[][N], int C[][N]) \r\n{ \r\n    for (int i = 0; i < N; i++) \r\n    { \r\n        for (int j = 0; j < N; j++) \r\n        { \r\n            C[i][j] = 0; \r\n            for (int k = 0; k < N; k++) \r\n            { \r\n                C[i][j] += A[i][k]*B[k][j]; \r\n            } \r\n        } \r\n    } \r\n} ', '2020-05-25'),
(350, 7, 4101012018, '#include <cstdlib> \r\n#include <stdio.h>\r\n#include <iostream> \r\nusing namespace std; \r\n  \r\nint partition(int arr[], int start, int end) \r\n{ \r\n    int pivot = arr[end]; \r\n    int i = (start - 1); \r\n  \r\n    for (int j = start; j <= end - 1; j++) { \r\n  \r\n        if (arr[j] <= pivot) { \r\n  \r\n            i++; \r\n            swap(arr[i], arr[j]); \r\n        } \r\n    } \r\n    swap(arr[i + 1], arr[end]); \r\n    return (i + 1); \r\n} \r\n  \r\nint random_partition(int arr[], int start, int end) \r\n{ \r\n   \r\n    int random = start + rand() % (end - start); \r\n  \r\n    swap(arr[random], arr[end]); \r\n  \r\n    return partition(arr, start, end); \r\n} \r\n  \r\nvoid quickSort(int arr[], int start, int end) \r\n{ \r\n    if (start < end) { \r\n  \r\n        int pi = random_partition(arr, start, end); \r\n  \r\n        quickSort(arr, start, pi - 1); \r\n        quickSort(arr, pi + 1, end); \r\n    } \r\n} \r\n  \r\nvoid printArray(int arr[], int size) \r\n{ \r\n    for (int i = 0; i < size; i++){ \r\n 	 cout<<arr[i]<<endl; \r\n    }\r\n   \r\n} \r\n  \r\nint main() \r\n{ \r\n    \r\n    int n;\r\n    cin >> n; \r\n    int arr[n];\r\n    for (int i = 0; i < n; ++i){\r\n	 cin >> arr[i];\r\n    }\r\n    quickSort(arr, 0, n - 1); \r\n    printArray(arr, n);   \r\n} ', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0\n1\n4\n5\n6\n6\n8\n8\n8\n9\n9\n1000\n14000\n', 'Merge_Sort(A,first,last){\r\nif(first<last) then{\r\n   mid=(first+last)/2\r\n   Merge_Sort(A,first,mid)\r\n   Merge_Sort(A,mid+1,last)\r\n   merge(A,first,mid,last)\r\n}', '2020-05-25'),
(351, 9, 4101012018, '#include <iostream>\r\nusing namespace std;\r\nclass DisjSet {\r\n	int *rank, *parent, n;\r\n\r\npublic:\r\n	DisjSet(int n)\r\n	{\r\n		rank = new int[n];\r\n		parent = new int[n];\r\n		this->n = n;\r\n		makeSet();\r\n	}\r\n\r\n	void makeSet()\r\n	{\r\n		for (int i = 0; i < n; i++) {\r\n			parent[i] = i;\r\n		}\r\n	}\r\n\r\n	int find(int x)\r\n	{\r\n		if (parent[x] != x) {\r\n\r\n			parent[x] = find(parent[x]);\r\n		}\r\n\r\n		return parent[x];\r\n	}\r\n\r\n	void Union(int x, int y)\r\n	{\r\n		int xset = find(x);\r\n		int yset = find(y);\r\n\r\n		if (xset == yset)\r\n			return;\r\n\r\n		if (rank[xset] < rank[yset]) {\r\n			parent[xset] = yset;\r\n		}\r\n		else if (rank[xset] > rank[yset]) {\r\n			parent[yset] = xset;\r\n		}\r\n		else {\r\n			parent[yset] = xset;\r\n			rank[xset] = rank[xset] + 1;\r\n		}\r\n	}\r\n};\r\n\r\nint main()\r\n{\r\n	DisjSet obj(5);\r\n    obj.Union(0, 2);\r\n    obj.Union(4, 2);\r\n    obj.Union(3, 1);\r\n    if (obj.find(4) == obj.find(0))\r\n        cout << \"Yes\n\";\r\n    else\r\n        cout << \"No\n\";\r\n    if (obj.find(1) == obj.find(0))\r\n        cout << \"Yes\n\";\r\n    else\r\n        cout << \"No\n\";\r\n\r\n    return 0;\r\n}\r\n', 1000, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0\n1\n4\n5\n6\n6\n8\n8\n8\n9\n9\n1000\n14000\n', 'quick_sort(A,first,last){\r\nif(first<last){\r\n   pivot=pivot_list(A,first,last)\r\n   quick_sort(A,first,pivot-1)\r\n   quick_sort(A,pivot+1,last)\r\n}\r\n}\r\n\r\npivot_list(A,first,last){\r\npivot_value=A[first]\r\npivot_point=first\r\nfor i= first+1 to last do\r\nif(A[i]<pivot_value) then{\r\n  pivot_point++\r\n  swap(A[i],A[pivot_point])\r\n}\r\n}\r\nswap(A[pivot_point],A[first])\r\nreturn pivot_point\r\n}\r\n', '2020-05-25'),
(352, 10, 4101012018, 'import java.io.*;\r\nimport java.util.*;\r\n\r\npublic class Main {\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        Scanner scn = new Scanner(System.in);\r\n        int n = scn.nextInt();\r\n	int cap = scn.nextInt();\r\n        int[] weight = new int[n];\r\n        int[] price = new int[n];\r\n        for (int i = 0; i < n; i++) {\r\n            price[i] = scn.nextInt();\r\n        }\r\n        for (int i = 0; i < n; i++) {\r\n            weight[i] = scn.nextInt();\r\n        }      \r\n        System.out.println(knapsack(weight, price, cap));\r\n    }\r\n\r\n    public static int knapsack(int[] weight, int[] price, int cap) {\r\n        int[][] dp = new int[price.length][cap + 1];\r\n        \r\n        for (int i = 0; i < dp[0].length; i++) {\r\n            if (weight[0] <= cap && i >= weight[0]) {\r\n                dp[0][i] = price[0];\r\n            }\r\n        }\r\n        for (int i = 1; i < dp.length; i++) {\r\n            for (int j = 1; j < dp[0].length; j++) {\r\n                int val = weight[i];\r\n                if (j - val >= 0) {\r\n                    dp[i][j] = Math.max(dp[i - 1][j], price[i] + dp[i - 1][j - val]);\r\n                } else {\r\n                    dp[i][j] = dp[i - 1][j];\r\n                }\r\n            }\r\n        }\r\n        return dp[dp.length-1][dp[0].length-1];\r\n    }\r\n}', 0, '5 15 4 2 1 2 10 12 2 1 1 4', '15\n', '﻿partition(arr[],start,end) \r\n    pivot = arr[end]\r\n    i = start     \r\n    for j = start to end – 1 do\r\n        if arr[j] <= pivot then\r\n            swap arr[i] with arr[j]\r\n            i = i + 1\r\n    swap arr[i] with arr[end]\r\n    return i\r\n\r\nrandom_partition(arr[],start,end)\r\n    r = Random Number from start to end\r\n    Swap arr[r] and arr[end]\r\n    return partition(arr, start, end)\r\n\r\nquicksort(arr[],start,end)\r\n    if start < end\r\n        p = random_partition(arr,start,end)\r\n        quicksort(arr, p-1,end)\r\n        quicksort(arr, p+1,end)', '2020-05-25'),
(353, 12, 4101012018, '#include<iostream>\r\n#include<algorithm>\r\nusing namespace std;\r\n\r\nclass Edge\r\n{\r\n	public:\r\n	int source;\r\n	int dest;\r\n	int weight;\r\n};\r\n\r\nbool compare(Edge e1,Edge e2){\r\n    return e1.weight< e2.weight;\r\n}\r\nint findParent(int v,int *parent){\r\n    if(parent[v]==v){\r\n        return v;\r\n    }\r\n    return findParent(parent[v],parent);\r\n}\r\nvoid Kruskals(Edge *input,int n,int E){\r\n    sort(input,input+E,compare);\r\n    Edge *output=new Edge[n-1];\r\n    int *parent= new int[n];\r\n    for(int i=0;i<n;i++){\r\n        parent[i]=i;\r\n    }\r\n    int count=0;\r\n    int i=0;\r\n    while(count!=n-1){\r\n        Edge currentEdge = input[i];\r\n        int sourceParent = findParent(currentEdge.source,parent);\r\n        int destParent = findParent(currentEdge.dest,parent);\r\n\r\n        if(sourceParent!=destParent){\r\n            output[count]=currentEdge;\r\n            count++;\r\n            parent[sourceParent]=destParent;\r\n        }\r\n        i++;\r\n    }\r\n    for(int i=0;i<n-1;i++){\r\n        if(output[i].source<output[i].dest){\r\n            cout<<output[i].source<<\"---\"<<output[i].dest<<\"==>\"<<output[i].weight<<\" \";\r\n        }else{\r\n            cout<<output[i].dest<<\"---\"<<output[i].source<<\"==>\"<<output[i].weight<<\" \";\r\n        }\r\n    }\r\n}\r\n\r\nint main(){\r\n    int n=4;\r\n    int E=4;\r\n    Edge *input=new Edge[E];\r\n        input[0].source=0;\r\n        input[0].dest=1;\r\n        input[0].weight=3;\r\n        input[1].source=0;\r\n        input[1].dest=3;\r\n        input[1].weight=5;\r\n        input[2].source=1;\r\n        input[2].dest=2;\r\n        input[2].weight=1;\r\n        input[3].source=2;\r\n        input[3].dest=3;\r\n        input[3].weight=8;\r\n    Kruskals(input,n,E);\r\n}\r\n', 1000, '8 a b c d e f g h 1 1 2 3 5 8 13 21', 'h 0\ng 10\nf 110\ne 1110\nd 11110\nc 111110\na 1111110\nb 1111111\n', 'knapsack(v, w, n, W) \r\nfor w = 0 to W do \r\n   c[0, w] = 0 \r\nfor i = 1 to n do \r\n   c[i, 0] = 0 \r\n   for w = 1 to W do \r\n      if wi = w then \r\n         if vi + c[i-1, w-wi] then \r\n            c[i, w] = vi + c[i-1, w-wi] \r\n         else c[i, w] = c[i-1, w] \r\n      else \r\n         c[i, w] = c[i-1, w]', '2020-05-25'),
(354, 14, 4101012018, '#include<iostream>\r\n#include<conio.h>\r\n#include<stdio.h>\r\nstruct Edge {\r\n    int src, dest, weight;\r\n};\r\n\r\nstruct Graph\r\n{\r\n    int V, E;\r\n    struct Edge* edge;\r\n};\r\nstruct Graph* createGraph(int V, int E)\r\n{\r\n    struct Graph* graph = new Graph;\r\n    graph->V = V;\r\n    graph->E = E;\r\n    graph->edge = new Edge[E];\r\n    return graph;\r\n}\r\nvoid printArr(int dist[], int n)\r\n{\r\n    for (int i = 0; i < n; ++i)\r\n        printf(\"%d %d \", i, dist[i]);\r\n}\r\n\r\nvoid BellmanFord(struct Graph* graph, int src)\r\n{\r\n    int V = graph->V;\r\n    int E = graph->E;\r\n    int dist[V];\r\n\r\n    for (int i = 0; i < V; i++)\r\n        dist[i] = INT_MAX;\r\n    dist[src] = 0;\r\n\r\n    for (int i = 1; i <= V - 1; i++) {\r\n        for (int j = 0; j < E; j++) {\r\n            int u = graph->edge[j].src;\r\n            int v = graph->edge[j].dest;\r\n            int weight = graph->edge[j].weight;\r\n            if (dist[u] != INT_MAX && dist[u] + weight < dist[v])\r\n                dist[v] = dist[u] + weight;\r\n        }\r\n    }\r\n     for (int i = 0; i < E; i++) {\r\n        int u = graph->edge[i].src;\r\n        int v = graph->edge[i].dest;\r\n        int weight = graph->edge[i].weight;\r\n        if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {\r\n            printf(\"Graph contains negative weight cycle\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printArr(dist, V);\r\n\r\n    return;\r\n}\r\n\r\nint main()\r\n{\r\n    int V = 5;\r\n    int E = 8;\r\n    struct Graph* graph = createGraph(V, E);\r\n\r\n\r\n    graph->edge[0].src = 0;\r\n    graph->edge[0].dest = 1;\r\n    graph->edge[0].weight = -1;\r\n\r\n\r\n    graph->edge[1].src = 0;\r\n    graph->edge[1].dest = 2;\r\n    graph->edge[1].weight = 4;\r\n\r\n\r\n    graph->edge[2].src = 1;\r\n    graph->edge[2].dest = 2;\r\n    graph->edge[2].weight = 3;\r\n\r\n\r\n    graph->edge[3].src = 1;\r\n    graph->edge[3].dest = 3;\r\n    graph->edge[3].weight = 2;\r\n\r\n\r\n    graph->edge[4].src = 1;\r\n    graph->edge[4].dest = 4;\r\n    graph->edge[4].weight = 2;\r\n\r\n\r\n    graph->edge[5].src = 3;\r\n    graph->edge[5].dest = 2;\r\n    graph->edge[5].weight = 5;\r\n\r\n\r\n    graph->edge[6].src = 3;\r\n    graph->edge[6].dest = 1;\r\n    graph->edge[6].weight = 1;\r\n\r\n\r\n    graph->edge[7].src = 4;\r\n    graph->edge[7].dest = 3;\r\n    graph->edge[7].weight = -3;\r\n\r\n    BellmanFord(graph, 0);\r\n\r\n    return 0;\r\n}\r\n', 1000, '8 a b c d e f g h 1 1 2 3 5 8 13 21', 'h 0\ng 10\nf 110\ne 1110\nd 11110\nc 111110\na 1111110\nb 1111111\n', 'MST_Kruskal(G,w){\r\nA={}\r\nfor each vertex v belongs to V[a] do{\r\n   make_set(u)\r\nsort the edges of E[G} int the increasing order of W\r\nfor each edge (u,v) belongs to E do{\r\n	if(find_set(u)!=find_set(v)) then{\r\n	   A=A U {u,v}\r\n	   UNION(u,v)\r\n	}\r\n}\r\nreturn A\r\n}', '2020-05-25'),
(355, 15, 4101012018, '#include<iostream>\r\nusing namespace std;\r\n\r\nint matrix_chain(int array[], int n) {\r\n   int minMul[n][n];\r\n   for (int i=1; i<n; i++)\r\n      minMul[i][i] = 0;\r\n\r\n   for (int length=2; length<n; length++) {\r\n      for (int i=1; i<n-length+1; i++) {\r\n         int j = i+length-1;\r\n         minMul[i][j] = INT_MAX;\r\n         for (int k=i; k<=j-1; k++) {\r\n            int q = minMul[i][k] + minMul[k+1][j] + array[i- 1]*array[k]*array[j];\r\n            if (q < minMul[i][j])\r\n               minMul[i][j] = q;\r\n         }\r\n        }\r\n   }\r\n   return minMul[1][n-1];\r\n}\r\n\r\nint main() {\r\n    int n;\r\n    cin>>n;\r\n    int arr[n];\r\n    for(int i=0;i<n;i++){\r\n        cin>>arr[i];\r\n    }\r\n   cout <<matrix_chain(arr, n);\r\n}\r\n', 1000, '8 a b c d e f g h 1 1 2 3 5 8 13 21', 'h 0\ng 10\nf 110\ne 1110\nd 11110\nc 111110\na 1111110\nb 1111111\n', 'Prim_MST(G,W,r){\r\nfor each vertex v belongs to V[G] do{\r\n   key(v)=INT_MAX\r\n   P(v)=NULL\r\n}\r\nkey(r)=0\r\nQ=V[G]\r\nwhile(Q!=0) do{\r\nu=extract_min(Q)\r\n  for each vertex v belongs to adj(u) do{\r\n    if((v belongs to Q) and w(u,v)<key(v)){\r\n	P(v)=u\r\n	key(v)=w(u,v)\r\n    }\r\n  }\r\n}\r\n}', '2020-05-25'),
(356, 4, 4101012018, '#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nclass Pair{\r\npublic:\r\n	int min;\r\n	int max;\r\n};\r\n\r\nPair MaxMin(int arr[], int start, int end){\r\n	Pair mxMn;\r\n	if (end == start){\r\n		mxMn.min = arr[start];\r\n		mxMn.max = arr[start];\r\n		return mxMn;\r\n	}\r\n\r\n	if (end - start == 1){\r\n		if (arr[start] < arr[end]){\r\n			mxMn.min = arr[start];\r\n			mxMn.max = arr[end];\r\n		}\r\n		else {\r\n			mxMn.min = arr[end];\r\n			mxMn.max = arr[start];\r\n		}\r\n		return mxMn;\r\n	}\r\n\r\n	int mid = (start + end) / 2;\r\n\r\n	Pair ml = MaxMin(arr, start, mid);\r\n	Pair mr = MaxMin(arr, mid + 1, end);\r\n\r\n	if (ml.min > mr.min) mxMn.min = mr.min;\r\n	else mxMn.min = ml.min;\r\n\r\n	if (ml.max > mr.max) mxMn.max = ml.max;\r\n	else mxMn.max = mr.max;\r\n	return mxMn;\r\n}\r\n\r\nint main(){\r\n	int n=6;\r\n	int arr[] = {10, 37, 194, 365, 82, 55};\r\n	Pair mxMn = MaxMin(arr, 0, n - 1);\r\n	cout << mxMn.min << \" \" << mxMn.max;\r\n}\r\n', 0, '6 1000 11 445 1 330 3000', '10 365', 'Bellman_Ford(G,W,s){\r\nfor each v belongs to V do{\r\n   d[v]=INT_MAX\r\n   parent[v]=NULL\r\n}\r\nd[s]=0\r\nfor i=1 to v[G]-1 do{\r\n   for each edge (u,v) belongs to E[G] do{\r\n	if(d[v]>d[u]+w(u,v)) then{\r\n	   d[v]=d[u]+w(u,v)\r\n	   parent[v]=u\r\n	}\r\n   }\r\n}\r\n\r\nfor each edge(u,v) belongs to E[G]{\r\n   if(d[v]>d[u]+w(u,v)) then{\r\n	return false\r\n   }else{\r\n	return true\r\n   }', '2020-05-25'),
(357, 8, 4101012018, '#include<bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nconst int N = 10000 + 5;\r\n\r\nint A[N][N];\r\nint B[N][N];\r\nint D[N][N];\r\n\r\nvoid matrix_multiply(int n){\r\n	for(int i=0;i<n;i++){\r\n		for(int j=0;j<n;j++){\r\n			D[i][j] = 0;\r\n			for(int k=0;k<n;k++)\r\n				D[i][j] += A[i][k]*B[k][j];\r\n				cout << D[i][j] << \" \";\r\n		}\r\n\r\n	}\r\n}\r\n\r\nstruct matrix{\r\n	int k;\r\n	vector<vector<int> > mat;\r\n\r\n	matrix(int sz){\r\n		k=sz;\r\n		mat.resize(sz);\r\n		for(int i=0;i<sz;i++)\r\n			mat[i].resize(sz);\r\n	}\r\n\r\n	matrix operator + (const matrix &o){\r\n        matrix res(k);\r\n        for(int i=0;i<k;i++){\r\n        	for(int j=0;j<k;j++)\r\n	        	res.mat[i][j]=o.mat[i][j] + mat[i][j];\r\n	    }\r\n        return res;\r\n    }\r\n\r\n    matrix operator - (const matrix &o){\r\n        matrix res(k);\r\n        for(int i=0;i<k;i++){\r\n        	for(int j=0;j<k;j++)\r\n	        	res.mat[i][j]= mat[i][j] - o.mat[i][j];\r\n	    }\r\n        return res;\r\n    }\r\n\r\n	void print(){\r\n		for(int i=0;i<k;i++){\r\n			for(int j=0;j<k;j++){\r\n				cout<<mat[i][j]<<\" \";\r\n			}\r\n\r\n		}\r\n	}\r\n};\r\n\r\nmatrix multiply(matrix A, matrix B, int n){\r\n	if(n==2){\r\n		matrix res(2);\r\n		res.mat[0][0] = A.mat[0][0]*B.mat[0][0] + A.mat[0][1]*B.mat[1][0];\r\n		res.mat[0][1] = A.mat[0][0]*B.mat[0][1] + A.mat[0][1]*B.mat[1][1];\r\n		res.mat[1][0] = A.mat[1][0]*B.mat[0][0] + A.mat[1][1]*B.mat[1][0];\r\n		res.mat[1][1] = A.mat[1][0]*B.mat[0][1] + A.mat[1][1]*B.mat[1][1];\r\n		return res;\r\n	}\r\n	if(n==1){\r\n		matrix res(1);\r\n		res.mat[0][0] = A.mat[0][0]*B.mat[0][0];\r\n		return res;\r\n	}\r\n	int h = n/2;\r\n	matrix A00(h), A01(h), A10(h), A11(h);\r\n	matrix B00(h), B01(h), B10(h), B11(h);\r\n	matrix C00(h), C01(h), C10(h), C11(h);\r\n	for(int i=0;i<h;i++){\r\n		for(int j=0;j<h;j++)\r\n		{\r\n			A00.mat[i][j] = A.mat[i][j];\r\n			B00.mat[i][j] = B.mat[i][j];\r\n			A01.mat[i][j] = A.mat[i][j+h];\r\n			B01.mat[i][j] = B.mat[i][j+h];\r\n			A10.mat[i][j] = A.mat[i+h][j];\r\n			B10.mat[i][j] = B.mat[i+h][j];\r\n			A11.mat[i][j] = A.mat[i+h][j+h];\r\n			B11.mat[i][j] = B.mat[i+h][j+h];\r\n		}\r\n	}\r\n	matrix M1(h), M2(h), M3(h), M4(h), M5(h), M6(h), M7(h);\r\n	M1 = multiply(A00 + A11, (B00 + B11), h);\r\n	M2 = multiply(A10 +  A11, B00, h);\r\n	M3 = multiply(A00, B01 - B11, h);\r\n	M4 = multiply(A11, B10 - B00, h);\r\n	M5 = multiply(A00 + A01, B11, h);\r\n	M6 = multiply(A10 - A00, B00 + B01, h);\r\n	M7 = multiply(A01 - A11, B10 + B11, h);\r\n	C00 = M1 + M4 - M5 + M7;\r\n	C01 = M3 + M5;\r\n	C10 = M2 + M4;\r\n	C11 = M1 - M2 + M3 + M6;\r\n	matrix C(n);\r\n	for(int i=0;i<h;i++){\r\n		for(int j=0;j<h;j++){\r\n			C.mat[i][j] = C00.mat[i][j];\r\n			C.mat[i][j+h] = C01.mat[i][j];\r\n			C.mat[i+h][j] = C10.mat[i][j];\r\n			C.mat[i+h][j+h] = C11.mat[i][j];\r\n		}\r\n	}\r\n	return C;\r\n}\r\n\r\nint main(){\r\n		int n;\r\n		cin>>n;\r\n		matrix E(n), F(n);\r\n		for(int i=0;i<n;i++){\r\n			for(int j=0;j<n;j++){\r\n				cin>>A[i][j];\r\n				E.mat[i][j] = A[i][j];\r\n			}\r\n		}\r\n		cout<<endl;\r\n		for(int i=0;i<n;i++){\r\n			for(int j=0;j<n;j++){\r\n				cin>>B[i][j];\r\n				F.mat[i][j] = B[i][j];\r\n			}\r\n		}\r\n\r\n\r\n		matrix_multiply(n);\r\n		cout<<endl;\r\n\r\n}\r\n', 0, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '\n-17 -4 -7 10 2 11 40 92 107 \n', 'Matrix_Chain_Multiplication(p,n){\r\n	for i=1 to n do m[i,i]=0\r\n	for l=2 to n do{\r\n	   for i=1 to n-l+1 do{\r\n		j=i+l-1\r\n		m[i,j]=INT_MAX\r\n		for k=i to j-1 do{\r\n		   q=m[i,k]+m[k+1,j]+p[i-1]*p[k]*p[j]\r\n		   if(q<m[i,j]) then{\r\n			m[i,j]=q\r\n			s[i,j]=k\r\n		   }\r\n		}\r\n	    }\r\n	}\r\n	return m and s\r\n}\r\n', '2020-05-25');
INSERT INTO `qtos_map` (`ID`, `Q_ID`, `ROLL`, `SUBMISSION`, `SCORE`, `INPUT`, `OP`, `ALGO`, `DATE`) VALUES
(358, 5, 4101012018, '#include<iostream>\r\n#include<conio.h>\r\n#include<stdio.h>\r\nusing namespace std; \r\ntypedef long long lld; \r\ninline lld** MatrixMultiply(lld** a, lld** b, int n, \r\n                                      int l, int m) \r\n{ \r\n    lld** c = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        c[i] = new lld[m]; \r\n  \r\n    for (int i = 0; i < n; i++) { \r\n        for (int j = 0; j < m; j++) { \r\n            c[i][j] = 0; \r\n            for (int k = 0; k < l; k++) { \r\n                c[i][j] += a[i][k] * b[k][j]; \r\n            } \r\n        } \r\n    } \r\n    return c; \r\n} \r\n  \r\ninline lld** Strassen(lld** a, lld** b, int n,  \r\n                                int l, int m) \r\n{ \r\n    if (n == 1 || l == 1 || m == 1)  \r\n        return MatrixMultiply(a, b, n, l, m); \r\n  \r\n    lld** c = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        c[i] = new lld[m]; \r\n  \r\n    int adjN = (n >> 1) + (n & 1); \r\n    int adjL = (l >> 1) + (l & 1); \r\n    int adjM = (m >> 1) + (m & 1); \r\n  \r\n    lld**** As = new lld***[2]; \r\n    for (int x = 0; x < 2; x++) { \r\n        As[x] = new lld**[2]; \r\n        for (int y = 0; y < 2; y++) { \r\n            As[x][y] = new lld*[adjN]; \r\n            for (int i = 0; i < adjN; i++) { \r\n                As[x][y][i] = new lld[adjL]; \r\n                for (int j = 0; j < adjL; j++) { \r\n                    int I = i + (x & 1) * adjN; \r\n                    int J = j + (y & 1) * adjL; \r\n                    As[x][y][i][j] = (I < n && J < l) ? a[I][J] : 0; \r\n                } \r\n            } \r\n        } \r\n    } \r\n  \r\n    lld**** Bs = new lld***[2]; \r\n    for (int x = 0; x < 2; x++) { \r\n        Bs[x] = new lld**[2]; \r\n        for (int y = 0; y < 2; y++) { \r\n            Bs[x][y] = new lld*[adjN]; \r\n            for (int i = 0; i < adjL; i++) { \r\n                Bs[x][y][i] = new lld[adjM]; \r\n                for (int j = 0; j < adjM; j++) { \r\n                    int I = i + (x & 1) * adjL; \r\n                    int J = j + (y & 1) * adjM; \r\n                    Bs[x][y][i][j] = (I < l && J < m) ? b[I][J] : 0; \r\n                } \r\n            } \r\n        } \r\n    } \r\n  \r\n    lld*** s = new lld**[10]; \r\n    for (int i = 0; i < 10; i++) { \r\n        switch (i) { \r\n        case 0: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][1][j][k] - Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 1: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] + As[0][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 2: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[1][0][j][k] + As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 3: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[1][0][j][k] - Bs[0][0][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 4: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] + As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 5: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 6: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][1][j][k] - As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 7: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[1][0][j][k] + Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 8: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] - As[1][0][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 9: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[0][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        } \r\n    } \r\n  \r\n    lld*** p = new lld**[7]; \r\n    p[0] = Strassen(As[0][0], s[0], adjN, adjL, adjM); \r\n    p[1] = Strassen(s[1], Bs[1][1], adjN, adjL, adjM); \r\n    p[2] = Strassen(s[2], Bs[0][0], adjN, adjL, adjM); \r\n    p[3] = Strassen(As[1][1], s[3], adjN, adjL, adjM); \r\n    p[4] = Strassen(s[4], s[5], adjN, adjL, adjM); \r\n    p[5] = Strassen(s[6], s[7], adjN, adjL, adjM); \r\n    p[6] = Strassen(s[8], s[9], adjN, adjL, adjM); \r\n  \r\n    for (int i = 0; i < adjN; i++) { \r\n        for (int j = 0; j < adjM; j++) { \r\n            c[i][j] = p[4][i][j] + p[3][i][j] - p[1][i][j] + p[5][i][j]; \r\n            if (j + adjM < m) \r\n                c[i][j + adjM] = p[0][i][j] + p[1][i][j]; \r\n            if (i + adjN < n) \r\n                c[i + adjN][j] = p[2][i][j] + p[3][i][j]; \r\n            if (i + adjN < n && j + adjM < m) \r\n                c[i + adjN][j + adjM] = p[4][i][j] + p[0][i][j] - p[2][i][j] - p[6][i][j]; \r\n        } \r\n    } \r\n  \r\n    for (int x = 0; x < 2; x++) { \r\n        for (int y = 0; y < 2; y++) { \r\n            for (int i = 0; i < adjN; i++) { \r\n                delete[] As[x][y][i]; \r\n            } \r\n            delete[] As[x][y]; \r\n        } \r\n        delete[] As[x]; \r\n    } \r\n    delete[] As; \r\n  \r\n    for (int x = 0; x < 2; x++) { \r\n        for (int y = 0; y < 2; y++) { \r\n            for (int i = 0; i < adjL; i++) { \r\n                delete[] Bs[x][y][i]; \r\n            } \r\n            delete[] Bs[x][y]; \r\n        } \r\n        delete[] Bs[x]; \r\n    } \r\n    delete[] Bs; \r\n  \r\n    for (int i = 0; i < 10; i++) { \r\n        switch (i) { \r\n        case 0: \r\n        case 3: \r\n        case 5: \r\n        case 7: \r\n        case 9: \r\n            for (int j = 0; j < adjL; j++) { \r\n                delete[] s[i][j]; \r\n            } \r\n            break; \r\n        case 1: \r\n        case 2: \r\n        case 4: \r\n        case 6: \r\n        case 8: \r\n            for (int j = 0; j < adjN; j++) { \r\n                delete[] s[i][j]; \r\n            } \r\n            break; \r\n        } \r\n        delete[] s[i]; \r\n    } \r\n    delete[] s; \r\n  \r\n    for (int i = 0; i < 7; i++) { \r\n        for (int j = 0; j < (n >> 1); j++) { \r\n            delete[] p[i][j]; \r\n        } \r\n        delete[] p[i]; \r\n    } \r\n    delete[] p; \r\n  \r\n    return c; \r\n} \r\n  \r\nint main() \r\n{ \r\n    lld** matA; \r\n    matA = new lld*[2]; \r\n    for (int i = 0; i < 2; i++) \r\n        matA[i] = new lld[3]; \r\n    matA[0][0] = 1; \r\n    matA[0][1] = 2; \r\n    matA[0][2] = 3; \r\n    matA[1][0] = 4; \r\n    matA[1][1] = 5; \r\n    matA[1][2] = 6; \r\n  \r\n    lld** matB; \r\n    matB = new lld*[3]; \r\n    for (int i = 0; i < 3; i++) \r\n        matB[i] = new lld[2]; \r\n    matB[0][0] = 7; \r\n    matB[0][1] = 8; \r\n    matB[1][0] = 9; \r\n    matB[1][1] = 10; \r\n    matB[2][0] = 11; \r\n    matB[2][1] = 12; \r\n  \r\n    lld** matC = Strassen(matA, matB, 2, 3, 2); \r\n    for (int i = 0; i < 2; i++) { \r\n        for (int j = 0; j < 2; j++) { \r\n            printf(\"%lld \", matC[i][j]); \r\n        } \r\n        printf(\"\n\"); \r\n    } \r\n  \r\n    return 0; \r\n', 1000, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '\n-17 -4 -7 10 2 11 40 92 107 \n', 'MaxMin(A,first,last){\r\nif(first=last),then max=min=A[first]\r\nreturn(max,min)\r\nif(first=last-1){\r\n	if(A[first]>A[last]{\r\n		max=A[first]\r\n		min=A[last]\r\n	}else{\r\n	      max=A[last]\r\n	      min=A[first]\r\n	}\r\nreturn(max,min)\r\n}\r\nmid=(first+last)/2\r\n(max1,min1)=MaxMin(A,first,mid)\r\n(max2,min2)=MaxMin(A,mid+1,last)\r\nif(max1>max2)\r\n	max=max1\r\nelse\r\n	max=max2\r\nif(min1>min2)\r\n	min=min2\r\nelse\r\n	min=min1\r\nreturn(max,min)\r\n}\r\n', '2020-05-25'),
(359, 0, 4101012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n\r\n#define d 256 \r\n\r\nvoid search(char pat[], char txt[], int q) \r\n{ \r\n	int M = strlen(pat); \r\n	int N = strlen(txt); \r\n	int i, j; \r\n	int p = 0; \r\n	int t = 0; \r\n	int h = 1; \r\n\r\n	for (i = 0; i < M - 1; i++) \r\n		h = (h * d) % q; \r\n\r\n	for (i = 0; i < M; i++) \r\n	{ \r\n		p = (d * p + pat[i]) % q; \r\n		t = (d * t + txt[i]) % q; \r\n	} \r\n\r\n	for (i = 0; i <= N - M; i++) \r\n	{ \r\n\r\n		if ( p == t ) \r\n		{ \r\n			for (j = 0; j < M; j++) \r\n			{ \r\n				if (txt[i+j] != pat[j]) \r\n					break; \r\n			} \r\n\r\n			if (j == M) \r\n				cout<<\"Pattern found at index\"<<\" \"<<i<<\" \"; \r\n		} \r\n\r\n		if ( i < N-M ) \r\n		{ \r\n			t = (d*(t - txt[i]*h) + txt[i+M])%q; \r\n\r\n			if (t < 0) \r\n			t = (t + q); \r\n		} \r\n	} \r\n} \r\n\r\nint main() \r\n{ \r\n	char txt[101]; \r\n	char pat[101]; \r\n	cin >> txt >> pat;\r\n	int q = 101; \r\n	search(pat, txt, q); \r\n	return 0; \r\n} \r\n\r\n', 1000, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '\n-17 -4 -7 10 2 11 40 92 107 \n', 'strassens(X,Y){\r\n	\r\n	M1 = (X[0][0]+X[1][0])*(Y[0][0]+Y[0][1])\r\n	M2 = (X[0][1]+X[1][1])*(Y[1][0]+Y[1][1])\r\n	M3 = (X[0][0]-X[1][1])*(Y[0][0]+Y[1][1])\r\n	M4 = X[0][0]*(Y[0][1]-Y[1][1])\r\n	M5 = (X[1][0]+X[1][1])*Y[0][0]\r\n	M6 = (X[0][0]+X[0][1])*Y[1][1]\r\n	M7 = X[1][1]*(Y[1][0]-Y[0][0])\r\n\r\n	c[0][0] = M2+M3-M6-M7;\r\n	c[0][1] = M4+M6\r\n	c[1][0] = M5+M7\r\n	c[1][1] = M1-M3-M4-M5\r\n', '2020-05-25'),
(360, 9, 4201012018, '#include <iostream> \r\nusing namespace std; \r\nclass DisjSet { \r\n	int *rank, *parent, n; \r\n\r\npublic: \r\n	DisjSet(int n) \r\n	{ \r\n		rank = new int[n]; \r\n		parent = new int[n]; \r\n		this->n = n; \r\n		makeSet(); \r\n	} \r\n\r\n	void makeSet() \r\n	{ \r\n		for (int i = 0; i < n; i++) { \r\n			parent[i] = i; \r\n		} \r\n	} \r\n\r\n	int find(int x) \r\n	{ \r\n		if (parent[x] != x) { \r\n\r\n			parent[x] = find(parent[x]); \r\n		} \r\n\r\n		return parent[x]; \r\n	} \r\n\r\n	void Union(int x, int y) \r\n	{ \r\n		int xset = find(x); \r\n		int yset = find(y); \r\n\r\n		if (xset == yset) \r\n			return; \r\n\r\n		if (rank[xset] < rank[yset]) { \r\n			parent[xset] = yset; \r\n		} \r\n		else if (rank[xset] > rank[yset]) { \r\n			parent[yset] = xset; \r\n		} \r\n\r\n		// If ranks are same, then increment \r\n		// rank. \r\n		else { \r\n			parent[yset] = xset; \r\n			rank[xset] = rank[xset] + 1; \r\n		} \r\n	} \r\n}; \r\n\r\nint main() \r\n{ \r\n	DisjSet obj(5); \r\n	obj.Union(0, 2); \r\n	obj.Union(4, 2); \r\n	obj.Union(3, 1);\r\n	\r\n	cout << \"\nSet created with disjoint sets : \n 	(0,2,4) 	(3,1)\";\r\n	cout << \"\n\nEnter the element to find : \";\r\n	int y; cin >> y;	 \r\n	int x = obj.find(y);\r\n	if (y >= 0 && y < 5){\r\n		cout << \"\n	\" << x << endl; \r\n	}\r\n	else\r\n		cout << \"\nNo such element\n\"; \r\n	return 0; \r\n} \r\n', 1000, '', '', 'DisjointSet{\r\n	rank, parent, noOfElem\r\n}\r\n\r\nfind(x)\r\n	if parent[x]!=x, then\r\n		parent[x] = find(parent[x])\r\n\r\nunion(x,y)\r\n	xset = find(x)\r\n	yset = find(y)\r\n	if rank[xset] < rank[yset] then,\r\n		parent[xset] = yset\r\n	else if rank[yset] < rank[xset], then\r\n		parent[yset] = xset\r\n	else \r\n		parent[yset] = xset\r\n		rank[xset]++\r\n', '2020-05-25'),
(361, 10, 4201012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n\r\nint max(int a, int b) { return (a > b)? a : b; } \r\n\r\nint knapSack(int W, int wt[], int val[], int n) \r\n{ \r\n    \r\nif (n == 0 || W == 0) \r\n    return 0; \r\n\r\nif (wt[n-1] > W) \r\n    return knapSack(W, wt, val, n-1); \r\n\r\nelse return max( val[n-1] + knapSack(W-wt[n-1], wt, val, n-1), \r\n                    knapSack(W, wt, val, n-1) ); \r\n} \r\n\r\nint main() \r\n{ \r\n    int W, n;\r\n    cin >> n >> W;\r\n    int val[n]; \r\n    int wt[n];\r\n    for (int i = 0; i < n; ++i) cin >> val[i]; \r\n    for (int i = 0; i < n; ++i) cin >> wt[i];\r\n    cout << knapSack(W, wt, val, n); \r\n    return 0; \r\n} \r\n\r\n', 10, '5 15 4 2 1 2 10 12 2 1 1 4', '15', '1. Define a function knapsack which takes as argument (`W->Weight left to be filled, ‘N’->number of left items)\r\n2. Base case will be if we have ‘left weight=0’ or ‘number of items left=0’ , then return 0\r\n3. If the current item’s weight is greater than left weight so that item cannot be included therefore return(n-1,W)\r\n4. Else return max(val+knapsack(W-val,n-1),knapsack(W-val,n-1)) which means returning the maximum of the two cases when the current item is included or not included\r\n', '2020-05-25'),
(362, 12, 4201012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n\r\nclass Edge \r\n{ \r\n	public: \r\n	int src, dest, weight; \r\n}; \r\n\r\nclass Graph \r\n{ \r\n	public: \r\n	int V, E; \r\n\r\n	Edge* edge; \r\n}; \r\n\r\nGraph* createGraph(int V, int E) \r\n{ \r\n	Graph* graph = new Graph; \r\n	graph->V = V; \r\n	graph->E = E; \r\n\r\n	graph->edge = new Edge[E]; \r\n\r\n	return graph; \r\n} \r\n\r\nclass subset \r\n{ \r\n	public: \r\n	int parent; \r\n	int rank; \r\n}; \r\n\r\nint find(subset subsets[], int i) \r\n{ \r\n	if (subsets[i].parent != i) \r\n		subsets[i].parent = find(subsets, subsets[i].parent); \r\n\r\n	return subsets[i].parent; \r\n} \r\n\r\nvoid Union(subset subsets[], int x, int y) \r\n{ \r\n	int xroot = find(subsets, x); \r\n	int yroot = find(subsets, y); \r\n\r\n	if (subsets[xroot].rank < subsets[yroot].rank) \r\n		subsets[xroot].parent = yroot; \r\n	else if (subsets[xroot].rank > subsets[yroot].rank) \r\n		subsets[yroot].parent = xroot; \r\n\r\n	else\r\n	{ \r\n		subsets[yroot].parent = xroot; \r\n		subsets[xroot].rank++; \r\n	} \r\n} \r\n\r\nint myComp(const void* a, const void* b) \r\n{ \r\n	Edge* a1 = (Edge*)a; \r\n	Edge* b1 = (Edge*)b; \r\n	return a1->weight > b1->weight; \r\n} \r\n\r\nvoid KruskalMST(Graph* graph) \r\n{ \r\n	int V = graph->V; \r\n	Edge result[V]; \r\n	int e = 0; \r\n	int i = 0; \r\n\r\n	\r\n	qsort(graph->edge, graph->E, sizeof(graph->edge[0]), myComp); \r\n\r\n	subset *subsets = new subset[( V * sizeof(subset) )]; \r\n\r\n	for (int v = 0; v < V; ++v) \r\n	{ \r\n		subsets[v].parent = v; \r\n		subsets[v].rank = 0; \r\n	} \r\n\r\n	while (e < V - 1 && i < graph->E) \r\n	{ \r\n		Edge next_edge = graph->edge[i++]; \r\n\r\n		int x = find(subsets, next_edge.src); \r\n		int y = find(subsets, next_edge.dest); \r\n\r\n		if (x != y) \r\n		{ \r\n			result[e++] = next_edge; \r\n			Union(subsets, x, y); \r\n		} \r\n	} \r\n\r\n	for (i = 0; i < e; ++i) \r\n		cout<<result[i].src<<\" --- \"<<result[i].dest<<\" ==> \"<<result[i].weight<<endl; \r\n	return; \r\n} \r\n\r\nint main() \r\n{ \r\n	int V; \r\n	int E; \r\n	cin >> V >> E; \r\n	Graph* graph = createGraph(V, E); \r\n	int x, y, z;\r\n	for (int i = 0; i < E; ++i){\r\n		cin >> x >> y >> z;\r\n		graph->edge[i].src = x;\r\n		graph->edge[i].dest = y;\r\n		graph->edge[i].weight = z;\r\n	}\r\n\r\n	KruskalMST(graph); \r\n\r\n	return 0; \r\n} \r\n\r\n', 1000, '', '', '1. Sort all the edges in non-decreasing order of their weight.\r\n2. Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If cycle is not formed, include this edge. Else, discard it.\r\n3. Repeat step#2 until there are (V-1) edges in the spanning tree.', '2020-05-25'),
(363, 13, 4201012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n\r\nint minKey(int key[], bool mstSet[], int V) \r\n{ \r\n  int min = INT_MAX, min_index; \r\n\r\n  for (int v = 0; v < V; v++) \r\n    if (mstSet[v] == false && key[v] < min) \r\n      min = key[v], min_index = v; \r\n\r\n  return min_index; \r\n} \r\n\r\nvoid printMST(int parent[], int graph[][100], int V) \r\n{ \r\n  int sum = 0;\r\n  cout<<\"Edge 	Weight\n\"; \r\n  for (int i = 1; i < V; i++){ \r\n    cout<<parent[i]<<\" - \"<<i<<\" 	\"<<graph[i][parent[i]]<<\" \n\"; \r\n    sum += graph[i][parent[i]];\r\n  }\r\n  cout << \"Cost : \"<< sum;\r\n} \r\n\r\nvoid primMST(int graph[][100], int V) \r\n{ \r\n  int parent[V]; \r\n  \r\n  int key[V]; \r\n  \r\n  bool mstSet[V]; \r\n\r\n  for (int i = 0; i < V; i++) \r\n    key[i] = INT_MAX, mstSet[i] = false; \r\n\r\n  key[0] = 0; \r\n  parent[0] = -1;  \r\n\r\n  for (int count = 0; count < V - 1; count++) \r\n  { \r\n    int u = minKey(key, mstSet, V); \r\n\r\n    mstSet[u] = true; \r\n\r\n    for (int v = 0; v < V; v++) \r\n\r\n      if (graph[u][v] && mstSet[v] == false && graph[u][v] < key[v]) \r\n        parent[v] = u, key[v] = graph[u][v]; \r\n  } \r\n\r\n  printMST(parent, graph, V); \r\n} \r\n\r\nint main() \r\n{ \r\n  int V; cin >> V;\r\n  int graph[100][100];\r\n  for (int i = 0; i < V; ++i){\r\n    for (int j = 0; j < V; ++j) cin >> graph[i][j];\r\n  }\r\n\r\n  primMST(graph, V); \r\n\r\n  return 0; \r\n} \r\n\r\n', 1000, '', '', '1) Create a set mstSet that keeps track of vertices already included in MST.\r\n2) Assign a key value to all vertices in the input graph. Initialize all key values as INFINITE. Assign key value as 0 for the first vertex so that it is picked first.\r\n3) While mstSet doesn’t include all vertices\r\n….a) Pick a vertex u which is not there in mstSet and has minimum key value.\r\n….b) Include u to mstSet.\r\n….c) Update key value of all adjacent vertices of u. To update the key values, iterate through all adjacent vertices. For every adjacent vertex v, if weight of edge u-v is less than the previous key value of v, update the key value as weight of u-v\r\n\r\n', '2020-05-25'),
(364, 14, 4201012018, '#include <bits/stdc++.h> \r\nusing namespace std;\r\nstruct Edge { \r\n	int src, dest, weight; \r\n}; \r\n\r\nstruct Graph { \r\n	int V, E; \r\n\r\n	struct Edge* edge; \r\n}; \r\n\r\nstruct Graph* createGraph(int V, int E) \r\n{ \r\n	struct Graph* graph = new Graph; \r\n	graph->V = V; \r\n	graph->E = E; \r\n	graph->edge = new Edge[E]; \r\n	return graph; \r\n} \r\n\r\nvoid printArr(int dist[], int n) \r\n{ \r\n	for (int i = 0; i < n; ++i) \r\n		printf(\"%d %d \", i, dist[i]); \r\n} \r\n\r\nvoid BellmanFord(struct Graph* graph, int src) \r\n{ \r\n	int V = graph->V; \r\n	int E = graph->E; \r\n	int dist[V]; \r\n\r\n	for (int i = 0; i < V; i++) \r\n		dist[i] = INT_MAX; \r\n	dist[src] = 0; \r\n\r\n	for (int i = 1; i <= V - 1; i++) { \r\n		for (int j = 0; j < E; j++) { \r\n			int u = graph->edge[j].src; \r\n			int v = graph->edge[j].dest; \r\n			int weight = graph->edge[j].weight; \r\n			if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) \r\n				dist[v] = dist[u] + weight; \r\n		} \r\n	} \r\n\r\n	for (int i = 0; i < E; i++) { \r\n		int u = graph->edge[i].src; \r\n		int v = graph->edge[i].dest; \r\n		int weight = graph->edge[i].weight; \r\n		if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) { \r\n			printf(\"Graph contains negative weight cycle\"); \r\n			return;\r\n		} \r\n	} \r\n\r\n	printArr(dist, V); \r\n\r\n	return; \r\n} \r\n\r\nint main() \r\n{ \r\n	int V;  \r\n	int E; \r\n	cin >> V >> E; \r\n	struct Graph* graph = createGraph(V, E); \r\n	int x, y, z;\r\n	for (int i = 0; i < E; ++i){\r\n		cin >> x >> y >> z;\r\n		graph->edge[i].src = x;\r\n		graph->edge[i].dest = y;\r\n		graph->edge[i].weight = z;\r\n	}\r\n\r\n	BellmanFord(graph, 0); \r\n\r\n	return 0; \r\n} \r\n', 1000, '', '', '1) This step initializes distances from the source to all vertices as infinite and distance to the source itself as 0. \r\n   Create an array dist[] of size |V| with all values as infinite except dist[src] where src is source vertex.\r\n\r\n2) This step calculates shortest distances. Do following |V|-1 times where |V| is the number of vertices in given graph.\r\n…..a) Do following for each edge u-v\r\n………………If dist[v] > dist[u] + weight of edge uv, then update dist[v]\r\n………………….dist[v] = dist[u] + weight of edge uv\r\n\r\n3) This step reports if there is a negative weight cycle in graph. Do following for each edge u-v\r\n……If dist[v] > dist[u] + weight of edge uv, then “Graph contains negative weight cycle”', '2020-05-25'),
(365, 15, 4201012018, '#include<bits/stdc++.h> \r\nusing namespace std; \r\n\r\nint MatrixChainOrder(int p[], int n) \r\n{ \r\n\r\n	int m[n][n]; \r\n\r\n	int i, j, k, L, q; \r\n\r\n	for (i = 1; i < n; i++) \r\n		m[i][i] = 0; \r\n\r\n	for (L = 2; L < n; L++) \r\n	{ \r\n		for (i = 1; i < n - L + 1; i++) \r\n		{ \r\n			j = i + L - 1; \r\n			m[i][j] = INT_MAX; \r\n			for (k = i; k <= j - 1; k++) \r\n			{ \r\n				q = m[i][k] + m[k + 1][j] + \r\n					p[i - 1] * p[k] * p[j]; \r\n				if (q < m[i][j]) \r\n					m[i][j] = q; \r\n			} \r\n		} \r\n	} \r\n\r\n	return m[1][n - 1]; \r\n} \r\n\r\nint main() \r\n{ \r\n	int size; cin >> size;\r\n	int arr[size]; \r\n\r\n	for (int i = 0; i < size; ++i) cin >> arr[i];\r\n	cout << \"Minimum number of multiplications is \"\r\n		<< MatrixChainOrder(arr, size); \r\n\r\n	getchar(); \r\n	return 0; \r\n} \r\n\r\n', 1000, '', '', 'Begin\r\n   define table minMul of size n x n, initially fill with all 0s\r\n   for length := 2 to n, do\r\n      fir i:=1 to n-length, do\r\n         j := i + length – 1\r\n         minMul[i, j] := ∞\r\n         for k := i to j-1, do\r\n            q := minMul[i, k] + minMul[k+1, j] + array[i-1]*array[k]*array[j]\r\n            if q < minMul[i, j], then minMul[i, j] := q\r\n         done\r\n      done\r\n   done\r\n   return minMul[1, n-1]\r\nEnd', '2020-05-25'),
(366, 5, 4201012018, '#include<bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nconst int N = 10000 + 5;\r\n\r\nint A[N][N];\r\nint B[N][N];\r\nint D[N][N];\r\n\r\nvoid matrix_multiply(int n){\r\n	for(int i=0;i<n;i++){\r\n		for(int j=0;j<n;j++){\r\n			D[i][j] = 0;\r\n			for(int k=0;k<n;k++)\r\n				D[i][j] += A[i][k]*B[k][j];\r\n				cout << D[i][j] << \" \";\r\n		}\r\n		cout << endl;\r\n	}\r\n}\r\n\r\nstruct matrix{\r\n	int k;\r\n	vector<vector<int> > mat;\r\n\r\n	matrix(int sz){\r\n		k=sz;\r\n		mat.resize(sz);\r\n		for(int i=0;i<sz;i++)\r\n			mat[i].resize(sz);\r\n	}\r\n\r\n	matrix operator + (const matrix &o){\r\n        matrix res(k);\r\n        for(int i=0;i<k;i++){\r\n        	for(int j=0;j<k;j++)\r\n	        	res.mat[i][j]=o.mat[i][j] + mat[i][j];\r\n	    }\r\n        return res;\r\n    }\r\n\r\n    matrix operator - (const matrix &o){\r\n        matrix res(k);\r\n        for(int i=0;i<k;i++){\r\n        	for(int j=0;j<k;j++)\r\n	        	res.mat[i][j]= mat[i][j] - o.mat[i][j];\r\n	    }\r\n        return res;\r\n    }\r\n\r\n	void print(){\r\n		for(int i=0;i<k;i++){\r\n			for(int j=0;j<k;j++){\r\n				cout<<mat[i][j]<<\" \";\r\n			}\r\n			cout<<endl;\r\n		}\r\n	}\r\n};\r\n\r\nmatrix multiply(matrix A, matrix B, int n){\r\n	if(n==2){\r\n		matrix res(2);\r\n		res.mat[0][0] = A.mat[0][0]*B.mat[0][0] + A.mat[0][1]*B.mat[1][0];\r\n		res.mat[0][1] = A.mat[0][0]*B.mat[0][1] + A.mat[0][1]*B.mat[1][1];\r\n		res.mat[1][0] = A.mat[1][0]*B.mat[0][0] + A.mat[1][1]*B.mat[1][0];\r\n		res.mat[1][1] = A.mat[1][0]*B.mat[0][1] + A.mat[1][1]*B.mat[1][1];\r\n		return res;\r\n	}\r\n	if(n==1){\r\n		matrix res(1);\r\n		res.mat[0][0] = A.mat[0][0]*B.mat[0][0];\r\n		return res;\r\n	}\r\n	int h = n/2;\r\n	matrix A00(h), A01(h), A10(h), A11(h);\r\n	matrix B00(h), B01(h), B10(h), B11(h);\r\n	matrix C00(h), C01(h), C10(h), C11(h);\r\n	for(int i=0;i<h;i++){\r\n		for(int j=0;j<h;j++)\r\n		{\r\n			A00.mat[i][j] = A.mat[i][j];\r\n			B00.mat[i][j] = B.mat[i][j];\r\n			A01.mat[i][j] = A.mat[i][j+h];\r\n			B01.mat[i][j] = B.mat[i][j+h];\r\n			A10.mat[i][j] = A.mat[i+h][j];\r\n			B10.mat[i][j] = B.mat[i+h][j];\r\n			A11.mat[i][j] = A.mat[i+h][j+h];\r\n			B11.mat[i][j] = B.mat[i+h][j+h];\r\n		}\r\n	}\r\n	matrix M1(h), M2(h), M3(h), M4(h), M5(h), M6(h), M7(h);\r\n	M1 = multiply(A00 + A11, (B00 + B11), h);\r\n	M2 = multiply(A10 +  A11, B00, h);\r\n	M3 = multiply(A00, B01 - B11, h);\r\n	M4 = multiply(A11, B10 - B00, h);\r\n	M5 = multiply(A00 + A01, B11, h);\r\n	M6 = multiply(A10 - A00, B00 + B01, h);\r\n	M7 = multiply(A01 - A11, B10 + B11, h);\r\n	C00 = M1 + M4 - M5 + M7;\r\n	C01 = M3 + M5;	\r\n	C10 = M2 + M4;\r\n	C11 = M1 - M2 + M3 + M6;\r\n	matrix C(n);\r\n	for(int i=0;i<h;i++){\r\n		for(int j=0;j<h;j++){\r\n			C.mat[i][j] = C00.mat[i][j];\r\n			C.mat[i][j+h] = C01.mat[i][j];\r\n			C.mat[i+h][j] = C10.mat[i][j];\r\n			C.mat[i+h][j+h] = C11.mat[i][j];\r\n		}\r\n	}\r\n	return C;\r\n}	\r\n\r\nint main(){\r\n		int n;\r\n		cin>>n;\r\n		matrix E(n), F(n);\r\n		for(int i=0;i<n;i++){\r\n			for(int j=0;j<n;j++){\r\n				cin>>A[i][j];\r\n				E.mat[i][j] = A[i][j];\r\n			}\r\n		}\r\n		cout<<endl;\r\n		for(int i=0;i<n;i++){\r\n			for(int j=0;j<n;j++){\r\n				cin>>B[i][j];\r\n				F.mat[i][j] = B[i][j];\r\n			}\r\n		}\r\n\r\n\r\n		matrix_multiply(n);\r\n		cout<<endl;\r\n		\r\n}', 1000, '', '', 'strassens(a,b,c)\r\n	\r\n	m1 = a[0][0] * (b[0][1] - b[1][1]);\r\n	m2 = b[1][1] * (a[0][0] + a[0][1]);\r\n	m3 = b[0][0] * (a[1][0] + a[1][1]);\r\n	m4 = a[1][1] * (b[1][0] - b[0][0]);\r\n	m5 = (a[0][0] + a[1][1]) * (b[0][0] + b[1][1]);\r\n	m6 = (a[0][1] - a[1][1]) * (b[1][0] + b[1][1]);\r\n	m7 = (a[0][0] - a[1][0]) * (b[0][0] + b[0][1]);\r\n\r\n	c[0][0] = m5 + m4 - m2 + m6;\r\n	c[0][1] = m1 + m2;\r\n	c[1][0] = m3 + m4;\r\n	c[1][1] = m1 + m5 - m3 - m7;\r\n\r\nmain()\r\n	divide matrix into many 2x2 matrices\r\n	apply strassens to them', '2020-05-25'),
(368, 16, 4201012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n\r\n#define d 256 \r\n\r\nvoid search(char pat[], char txt[], int q) \r\n{ \r\n	int M = strlen(pat); \r\n	int N = strlen(txt); \r\n	int i, j; \r\n	int p = 0; \r\n	int t = 0; \r\n	int h = 1; \r\n\r\n	for (i = 0; i < M - 1; i++) \r\n		h = (h * d) % q; \r\n\r\n	for (i = 0; i < M; i++) \r\n	{ \r\n		p = (d * p + pat[i]) % q; \r\n		t = (d * t + txt[i]) % q; \r\n	} \r\n\r\n	for (i = 0; i <= N - M; i++) \r\n	{ \r\n\r\n		if ( p == t ) \r\n		{ \r\n			for (j = 0; j < M; j++) \r\n			{ \r\n				if (txt[i+j] != pat[j]) \r\n					break; \r\n			} \r\n\r\n			if (j == M) \r\n				cout<<\"Pattern found at index \"<< i<<endl; \r\n		} \r\n\r\n		if ( i < N-M ) \r\n		{ \r\n			t = (d*(t - txt[i]*h) + txt[i+M])%q; \r\n\r\n			if (t < 0) \r\n			t = (t + q); \r\n		} \r\n	} \r\n} \r\n\r\nint main() \r\n{ \r\n	char txt[101]; \r\n	char pat[101]; \r\n	cin >> txt >> pat;\r\n	int q = 101; \r\n	search(pat, txt, q); \r\n	return 0; \r\n} \r\n\r\n', 1000, '', '', 'Begin\r\n   patLen := pattern Length\r\n   strLen := string Length\r\n   patHash := 0 and strHash := 0, h := 1\r\n   maxChar := total number of characters in character set\r\n\r\n   for index i of all character in pattern, do\r\n      h := (h*maxChar) mod prime\r\n   done\r\n\r\n   for all character index i of pattern, do\r\n      patHash := (maxChar*patHash + pattern[i]) mod prime\r\n      strHash := (maxChar*strHash + text[i]) mod prime\r\n   done\r\n\r\n   for i := 0 to (strLen - patLen), do\r\n      if patHash = strHash, then\r\n         for charIndex := 0 to patLen -1, do\r\n            if text[i+charIndex] ≠ pattern[charIndex], then\r\n               break the loop\r\n         done\r\n\r\n         if charIndex = patLen, then\r\n            print the location i as pattern found at i position.\r\n      if i < (strLen - patLen), then\r\n         strHash := (maxChar*(strHash – text[i]*h)+text[i+patLen]) mod prime, then\r\n      if strHash < 0, then\r\n         strHash := strHash + prime\r\n   done\r\nEnd', '2020-05-25'),
(369, 3, 4301012018, '\r\n\r\n	import java.util.Scanner;\r\n\r\n	public class Main\r\n	{\r\n	    public static void main(String args[])\r\n	    {\r\n	        Scanner sc = new Scanner(System.in);\r\n	        int n = sc.nextInt();\r\n	        int arr[] = new int[n];\r\n	        \r\n	        for(int i = 0; i<= n-1; i++)\r\n	        {\r\n	            arr[i] = sc.nextInt();\r\n	        }\r\n	        \r\n	        quickSort(0, n-1, arr);\r\n	        \r\n	        for(int i = 0; i<= n-1; i++)\r\n	        {\r\n	            System.out.print(arr[i]+\" \");\r\n	        }\r\n	        \r\n	        \r\n	    }\r\n	    \r\n	    public static void quickSort(int si, int ei, int[] arr)\r\n	    {\r\n	    	int l = si;\r\n	    	int r = ei;\r\n	    	\r\n	    	if(l>= r)\r\n	    	{\r\n	    		return;\r\n	    	}\r\n	    	\r\n	        int pivotIndex = l;\r\n	        \r\n	        l++;\r\n	        \r\n	        while(l<= r)\r\n	        {\r\n	            while(l<= r && arr[l] < arr[pivotIndex]) \r\n	            {\r\n	                l++;\r\n	            }\r\n	            \r\n	            while(l<= r && arr[r] >= arr[pivotIndex])\r\n	            {\r\n	                r--;\r\n	            }\r\n	            \r\n	            if(l<r)\r\n	            {\r\n	                int temp = arr[l];\r\n	                arr[l] = arr[r];\r\n	                arr[r] = temp;\r\n	            }\r\n	        }\r\n	        \r\n	        int temp = arr[r];\r\n	        arr[r] = arr[pivotIndex];\r\n	        arr[pivotIndex] = temp;\r\n	        \r\n	        pivotIndex = r;\r\n	        \r\n	        \r\n	        quickSort(si, pivotIndex-1, arr);\r\n	        quickSort(pivotIndex+1, ei, arr);\r\n	        \r\n	    }\r\n	}\r\n\r\n', 10, '1 2000', '2000 ', 'QuickSort is a Divide and Conquer algorithm. It picks an element as pivot and partitions the given array around the picked pivot. There are many different versions of quickSort that pick pivot in different ways.\r\n\r\nThe key process in quickSort is partition(). Target of partitions is, given an array and an element x of array as pivot, put x at its correct position in sorted array and put all smaller elements (smaller than x) before x, and put all greater elements (greater than x) after x. All this should be done in linear time.\r\n\r\n/* low  --> Starting index,  high  --> Ending index */\r\nquickSort(arr[], low, high)\r\n{\r\n    if (low < high)\r\n    {\r\n        /* pi is partitioning index, arr[pi] is now\r\n           at right place */\r\n        pi = partition(arr, low, high);\r\n\r\n        quickSort(arr, low, pi - 1);  // Before pi\r\n        quickSort(arr, pi + 1, high); // After pi\r\n    }\r\n}', '2020-05-25'),
(370, 7, 4301012018, 'import java.util.Random;\r\nimport java.util.Scanner;\r\n\r\npublic class Main {\r\n	\r\n	public static void main(String args[])\r\n	{\r\n		Scanner sc = new Scanner(System.in);\r\n		int n = sc.nextInt();\r\n		int arr[] = new int[n];\r\n		\r\n		for(int i = 0; i<= n-1; i++)\r\n		{\r\n			arr[i] = sc.nextInt();\r\n		}\r\n		\r\n		quickSort(0 , n-1, arr);\r\n		\r\n		for(int i = 0; i<= n-1; i++)\r\n		{\r\n			System.out.print(arr[i]+\" \");\r\n		}\r\n	}\r\n	\r\n	public static void quickSort(int si, int ei, int[] arr)\r\n	{\r\n		int l = si;\r\n		int r = ei;\r\n		\r\n		if(l>= r)\r\n		{\r\n			return ;\r\n		}\r\n		\r\n		int len = ei-si+1;\r\n		Random rand = new Random();\r\n		int ran = rand.nextInt(len);\r\n		int pivotIndex = si+ran;\r\n		\r\n		int temp = arr[pivotIndex];\r\n		arr[pivotIndex] = arr[l];\r\n		arr[l] = temp;\r\n		\r\n		pivotIndex = l;\r\n		l++;\r\n		\r\n		while(l<=r)\r\n		{\r\n			while(l<= r && arr[l] < arr[pivotIndex])\r\n			{\r\n				l++;\r\n			}\r\n			\r\n			while(l<= r && arr[r] >= arr[pivotIndex])\r\n			{\r\n				r--;\r\n			}\r\n			\r\n			if(l<r)\r\n			{\r\n				temp = arr[l];\r\n				arr[l] = arr[r];\r\n				arr[r] = temp;\r\n			}\r\n		}\r\n		\r\n		temp = arr[pivotIndex];\r\n		arr[pivotIndex] = arr[r];\r\n		arr[r] = temp;\r\n		\r\n		pivotIndex = r;\r\n		\r\n		quickSort(si, pivotIndex-1, arr);\r\n		quickSort(pivotIndex+1, ei, arr);\r\n		\r\n	}\r\n\r\n}\r\n', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', 'QuickSort is a Divide and Conquer algorithm. It picks an element as pivot and partitions the given array around the picked pivot. There are many different versions of quickSort that pick pivot in different ways.\r\n\r\nAlways pick first element as pivot.\r\nAlways pick last element as pivot \r\nPick a random element as pivot. (Randomized Quick Sort)\r\nPick median as pivot.\r\nThe key process in quickSort is partition(). Target of partitions is, given an array and an element x of array as pivot, put x at its correct position in sorted array and put all smaller elements (smaller than x) before x, and put all greater elements (greater than x) after x. All this should be done in linear time.\r\n\r\n/* low  --> Starting index,  high  --> Ending index */\r\nquickSort(arr[], low, high)\r\n{\r\n    if (low < high)\r\n    {\r\n        /* pi is partitioning index, arr[pi] is now\r\n           at right place */\r\n        pi = partition(arr, low, high);\r\n\r\n        quickSort(arr, low, pi - 1);  // Before pi\r\n        quickSort(arr, pi + 1, high); // After pi\r\n    }\r\n}', '2020-05-25'),
(371, 11, 4301012018, 'import java.util.PriorityQueue; import java.util.Scanner; import java.util.Comparator; import java.util.HashMap; class HuffmanNode { int data; char c; HuffmanNode left; HuffmanNode right; } class MyComparator implements Comparator { public int compare(HuffmanNode x, HuffmanNode y) { return x.data - y.data; } } public class Main { public static void printCode(HuffmanNode root, String s, HashMap map) { if (root.left == null && root.right == null && Character.isLetter(root.c)) { map.put(root.c, s); // System.out.println(root.c + \":\" + s); return; } printCode(root.left, s + \"0\",map); printCode(root.right, s + \"1\",map); } public static void main(String[] args) { Scanner s = new Scanner(System.in); int n = s.nextInt(); char[] charArray = new char[n]; int[] charfreq = new int[n]; for(int i = 0; i<= n-1;i++) { charArray[i] = s.next().charAt(0); } for(int i = 0; i<= n-1;i++) { charfreq[i] = s.nextInt(); } PriorityQueue q = new PriorityQueue(n, new MyComparator()); for (int i = 0; i < n; i++) { HuffmanNode hn = new HuffmanNode(); hn.c = charArray[i]; hn.data = charfreq[i]; hn.left = null; hn.right = null; q.add(hn); } HuffmanNode root = null; while (q.size() > 1) { HuffmanNode x = q.peek(); q.poll(); HuffmanNode y = q.peek(); q.poll(); HuffmanNode f = new HuffmanNode(); f.data = x.data + y.data; f.c = \'-\'; f.left = x; f.right = y; root = f; q.add(f); } HashMap map = new HashMap<>(); printCode(root, \"\", map); for(int i = 0; i<= n-1; i++) { System.out.println(charArray[i]+\": \"+map.get(charArray[i])); } } }', 0, '8 a b c d e f g h 1 1 2 3 5 8 13 21', 'a: 1111110\nb: 1111111\nc: 111110\nd: 11110\ne: 1110\nf: 110\ng: 10\nh: 0\n', 'There are mainly two major parts in Huffman Coding\r\n1) Build a Huffman Tree from input characters.\r\n2) Traverse the Huffman Tree and assign codes to characters.\r\n\r\nSteps to build Huffman Tree\r\nInput is an array of unique characters along with their frequency of occurrences and output is Huffman Tree.\r\n\r\n1. Create a leaf node for each unique character and build a min heap of all leaf nodes (Min Heap is used as a priority queue. The value of frequency field is used to compare two nodes in min heap. Initially, the least frequent character is at root)\r\n\r\n2. Extract two nodes with the minimum frequency from the min heap.\r\n\r\n3. Create a new internal node with a frequency equal to the sum of the two nodes frequencies. Make the first extracted node as its left child and the other extracted node as its right child. Add this node to the min heap.\r\n\r\n4. Repeat steps#2 and #3 until the heap contains only one node. The remaining node is the root node and the tree is complete.\r\n\r\nSteps to print codes from Huffman Tree:\r\nTraverse the tree formed starting from the root. Maintain an auxiliary array. While moving to the left child, write 0 to the array. While moving to the right child, write 1 to the array. Print the array when a leaf node is encountered.', '2020-05-25'),
(372, 12, 4301012018, 'import java.util.*; \r\n\r\nclass Main\r\n{ \r\n	class Edge implements Comparable<Edge> \r\n	{ \r\n		int src, dest, weight; \r\n\r\n		public int compareTo(Edge compareEdge) \r\n		{ \r\n			return this.weight-compareEdge.weight; \r\n		} \r\n	}; \r\n\r\n	class subset \r\n	{ \r\n		int parent, rank; \r\n	}; \r\n\r\n	int V, E; \r\n	Edge edge[]; \r\n\r\n	\r\n	Main(int v, int e) \r\n	{ \r\n		V = v; \r\n		E = e; \r\n		edge = new Edge[E]; \r\n		for (int i=0; i<e; ++i) \r\n			edge[i] = new Edge(); \r\n	} \r\n\r\n \r\n	int find(subset subsets[], int i) \r\n	{ \r\n		\r\n		if (subsets[i].parent != i) \r\n			subsets[i].parent = find(subsets, subsets[i].parent); \r\n\r\n		return subsets[i].parent; \r\n	} \r\n\r\n	void Union(subset subsets[], int x, int y) \r\n	{ \r\n		int xroot = find(subsets, x); \r\n		int yroot = find(subsets, y); \r\n\r\n		 \r\n		if (subsets[xroot].rank < subsets[yroot].rank) \r\n			subsets[xroot].parent = yroot; \r\n		else if (subsets[xroot].rank > subsets[yroot].rank) \r\n			subsets[yroot].parent = xroot; \r\n\r\n	 \r\n		else\r\n		{ \r\n			subsets[yroot].parent = xroot; \r\n			subsets[xroot].rank++; \r\n		} \r\n	} \r\n\r\n\r\n	void KruskalMST() \r\n	{ \r\n		Edge result[] = new Edge[V]; \r\n		int e = 0;  \r\n		int i = 0; \r\n		for (i=0; i<V; ++i) \r\n			result[i] = new Edge(); \r\n\r\n	\r\n		Arrays.sort(edge); \r\n\r\n		subset subsets[] = new subset[V]; \r\n		for(i=0; i<V; ++i) \r\n			subsets[i]=new subset(); \r\n\r\n		\r\n		for (int v = 0; v < V; ++v) \r\n		{ \r\n			subsets[v].parent = v; \r\n			subsets[v].rank = 0; \r\n		} \r\n\r\n		i = 0; \r\n\r\n		while (e < V - 1) \r\n		{ \r\n			 \r\n			Edge next_edge = new Edge(); \r\n			next_edge = edge[i++]; \r\n\r\n			int x = find(subsets, next_edge.src); \r\n			int y = find(subsets, next_edge.dest); \r\n\r\n			\r\n			if (x != y) \r\n			{ \r\n				result[e++] = next_edge; \r\n				Union(subsets, x, y); \r\n			} \r\n			\r\n		} \r\n\r\n		 \r\n		for (i = 0; i < e; ++i) \r\n			System.out.println(result[i].src+\" -- \" + result[i].dest+\" == \" + result[i].weight); \r\n	} \r\n\r\n	public static void main (String[] args) \r\n	{ \r\n\r\n        Scanner sc = new Scanner(System.in);\r\n		\r\n		int V = 4;  // Number of vertices in graph \r\n        int E = 5;  // Number of edges in graph \r\n        Main graph = new Main(V, E); \r\n  \r\n        // add edge 0-1 \r\n        graph.edge[0].src = 0; \r\n        graph.edge[0].dest = 1; \r\n        graph.edge[0].weight = 10; \r\n  \r\n        // add edge 0-2 \r\n        graph.edge[1].src = 0; \r\n        graph.edge[1].dest = 2; \r\n        graph.edge[1].weight = 6; \r\n  \r\n        // add edge 0-3 \r\n        graph.edge[2].src = 0; \r\n        graph.edge[2].dest = 3; \r\n        graph.edge[2].weight = 5; \r\n  \r\n        // add edge 1-3 \r\n        graph.edge[3].src = 1; \r\n        graph.edge[3].dest = 3; \r\n        graph.edge[3].weight = 15; \r\n  \r\n        // add edge 2-3 \r\n        graph.edge[4].src = 2; \r\n        graph.edge[4].dest = 3; \r\n        graph.edge[4].weight = 4; \r\n\r\n		graph.KruskalMST(); \r\n	} \r\n} ', 1000, '', '', 'A minimum spanning tree (MST) or minimum weight spanning tree for a weighted, connected and undirected graph is a spanning tree with weight less than or equal to the weight of every other spanning tree. The weight of a spanning tree is the sum of weights given to each edge of the spanning tree. A minimum spanning tree has (V – 1) edges where V is the number of vertices in the given graph.\r\n\r\nBelow are the steps for finding MST using Kruskal’s algorithm\r\n\r\n1. Sort all the edges in non-decreasing order of their weight.\r\n2. Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If cycle is not formed, include this edge. Else, discard it.\r\n3. Repeat step#2 until there are (V-1) edges in the spanning tree.', '2020-05-25'),
(373, 13, 4301012018, '\r\nimport java.util.*; \r\nimport java.lang.*; \r\nimport java.io.*; \r\n\r\nclass Main { \r\n\r\n	int minKey(int V,int key[], Boolean mstSet[]) \r\n	{ \r\n		\r\n		int min = Integer.MAX_VALUE, min_index = -1; \r\n\r\n		for (int v = 0; v < V; v++) \r\n			if (mstSet[v] == false && key[v] < min) { \r\n				min = key[v]; \r\n				min_index = v; \r\n			} \r\n\r\n		return min_index; \r\n	} \r\n\r\n	\r\n	void printMST(int V, int parent[], int graph[][]) \r\n	{ \r\n		\r\n		for (int i = 1; i < V; i++) \r\n			System.out.println(parent[i] + \"-\" + i + \"	\" + graph[i][parent[i]]); \r\n	} \r\n\r\n\r\n	void primMST(int V,int graph[][]) \r\n	{ \r\n		int parent[] = new int[V]; \r\n\r\n		int key[] = new int[V]; \r\n\r\n		Boolean mstSet[] = new Boolean[V]; \r\n\r\n		for (int i = 0; i < V; i++) { \r\n			key[i] = Integer.MAX_VALUE; \r\n			mstSet[i] = false; \r\n		} \r\n\r\n		key[0] = 0;\r\n		parent[0] = -1; \r\n		\r\n		for (int count = 0; count < V - 1; count++) { \r\n			 \r\n			int u = minKey(V,key, mstSet); \r\n\r\n			mstSet[u] = true; \r\n\r\n			for (int v = 0; v < V; v++) \r\n\r\n				\r\n				if (graph[u][v] != 0 && mstSet[v] == false && graph[u][v] < key[v]) { \r\n					parent[v] = u; \r\n					key[v] = graph[u][v]; \r\n				} \r\n		} \r\n\r\n		printMST(V,parent, graph); \r\n	} \r\n\r\n	public static void main(String[] args) \r\n	{ \r\n		\r\n		Main t = new Main(); \r\n		Scanner sc = new Scanner(System.in);\r\n		int n = sc.nextInt();\r\n		int e = sc.nextInt();\r\n		\r\n		int graph[][] = new int[n][n];\r\n		for(int i = 0; i<= e-1; i++)\r\n		{\r\n		    int u = sc.nextInt();\r\n		    int v = sc.nextInt();\r\n		    int wt = sc.nextInt();\r\n		    graph[u-1][v-1] = wt;\r\n		    graph[v-1][u-1] = wt;\r\n		}\r\n\r\n		\r\n		t.primMST(n,graph); \r\n	} \r\n} \r\n', 1000, '', '', 'Prim’s algorithm is also a Greedy algorithm. It starts with an empty spanning tree. The idea is to maintain two sets of vertices. The first set contains the vertices already included in the MST, the other set contains the vertices not yet included. At every step, it considers all the edges that connect the two sets, and picks the minimum weight edge from these edges. After picking the edge, it moves the other endpoint of the edge to the set containing MST.\r\n\r\nAlgorithm\r\n1) Create a set mstSet that keeps track of vertices already included in MST.\r\n2) Assign a key value to all vertices in the input graph. Initialize all key values as INFINITE. Assign key value as 0 for the first vertex so that it is picked first.\r\n3) While mstSet doesn’t include all vertices\r\n….a) Pick a vertex u which is not there in mstSet and has minimum key value.\r\n….b) Include u to mstSet.\r\n….c) Update key value of all adjacent vertices of u. To update the key values, iterate through all adjacent vertices. For every adjacent vertex v, if weight of edge u-v is less than the previous key value of v, update the key value as weight of u-v', '2020-05-25'),
(374, 14, 4301012018, '\r\nimport java.util.*;\r\nimport java.lang.*;\r\nimport java.io.*;\r\n\r\nclass Main {\r\n	\r\n	class Edge {\r\n		int src, dest, weight;\r\n		Edge()\r\n		{\r\n			src = dest = weight = 0;\r\n		}\r\n	};\r\n	int V, E;\r\n	Edge edge[];\r\n	Main(int v, int e)\r\n	{\r\n		V = v;\r\n		E = e;\r\n		edge = new Edge[e];\r\n		for (int i = 0; i < e; ++i)\r\n			edge[i] = new Edge();\r\n	}\r\n	void BellmanFord(Main graph, int src)\r\n	{\r\n		int V = graph.V, E = graph.E;\r\n		int dist[] = new int[V];\r\n		\r\n		for (int i = 0; i < V; ++i)\r\n			dist[i] = Integer.MAX_VALUE;\r\n		dist[src] = 0;\r\n		\r\n		for (int i = 1; i < V; ++i) {\r\n			for (int j = 0; j < E; ++j) {\r\n				int u = graph.edge[j].src;\r\n				int v = graph.edge[j].dest;\r\n				int weight = graph.edge[j].weight;\r\n				if (dist[u] != Integer.MAX_VALUE && dist[u] + weight < dist[v])\r\n					dist[v] = dist[u] + weight;\r\n			}\r\n		}\r\n\r\n		for (int j = 0; j < E; ++j) {\r\n			int u = graph.edge[j].src;\r\n			int v = graph.edge[j].dest;\r\n			int weight = graph.edge[j].weight;\r\n			if (dist[u] != Integer.MAX_VALUE && dist[u] + weight < dist[v]) {\r\n				System.out.println(\"Graph contains negative weight cycle\");\r\n				return;\r\n			}\r\n		}\r\n		printArr(dist, V);\r\n	}\r\n	void printArr(int dist[], int V)\r\n	{\r\n		\r\n		for (int i = 0; i < V; ++i)\r\n			System.out.println(i + \"		\" + dist[i]);\r\n	}\r\n	public static void main(String[] args)\r\n	{\r\n	\r\n	 int V = 5; // Number of vertices in graph \r\n        int E = 8; // Number of edges in graph \r\n  \r\n        Main graph = new Main(V, E); \r\n  \r\n        // add edge 0-1 (or A-B in above figure) \r\n        graph.edge[0].src = 0; \r\n        graph.edge[0].dest = 1; \r\n        graph.edge[0].weight = -1; \r\n  \r\n        // add edge 0-2 (or A-C in above figure) \r\n        graph.edge[1].src = 0; \r\n        graph.edge[1].dest = 2; \r\n        graph.edge[1].weight = 4; \r\n  \r\n        // add edge 1-2 (or B-C in above figure) \r\n        graph.edge[2].src = 1; \r\n        graph.edge[2].dest = 2; \r\n        graph.edge[2].weight = 3; \r\n  \r\n        // add edge 1-3 (or B-D in above figure) \r\n        graph.edge[3].src = 1; \r\n        graph.edge[3].dest = 3; \r\n        graph.edge[3].weight = 2; \r\n  \r\n        // add edge 1-4 (or A-E in above figure) \r\n        graph.edge[4].src = 1; \r\n        graph.edge[4].dest = 4; \r\n        graph.edge[4].weight = 2; \r\n  \r\n        // add edge 3-2 (or D-C in above figure) \r\n        graph.edge[5].src = 3; \r\n        graph.edge[5].dest = 2; \r\n        graph.edge[5].weight = 5; \r\n  \r\n        // add edge 3-1 (or D-B in above figure) \r\n        graph.edge[6].src = 3; \r\n        graph.edge[6].dest = 1; \r\n        graph.edge[6].weight = 1; \r\n  \r\n        // add edge 4-3 (or E-D in above figure) \r\n        graph.edge[7].src = 4; \r\n        graph.edge[7].dest = 3; \r\n        graph.edge[7].weight = -3; \r\n  \r\n        graph.BellmanFord(graph, 0); \r\n	}\r\n}\r\n', 1000, '', '', 'Dijkstra doesn’t work for Graphs with negative weight edges, Bellman-Ford works for such graphs. Bellman-Ford is also simpler than Dijkstra and suites well for distributed systems. But time complexity of Bellman-Ford is O(VE), which is more than Dijkstra.\r\n\r\nAlgorithm\r\nFollowing are the detailed steps.\r\n\r\nInput: Graph and a source vertex src\r\nOutput: Shortest distance to all vertices from src. If there is a negative weight cycle, then shortest distances are not calculated, negative weight cycle is reported.\r\n\r\n1) This step initializes distances from the source to all vertices as infinite and distance to the source itself as 0. Create an array dist[] of size |V| with all values as infinite except dist[src] where src is source vertex.\r\n\r\n2) This step calculates shortest distances. Do following |V|-1 times where |V| is the number of vertices in given graph.\r\n…..a) Do following for each edge u-v\r\n………………If dist[v] > dist[u] + weight of edge uv, then update dist[v]\r\n………………….dist[v] = dist[u] + weight of edge uv\r\n\r\n3) This step reports if there is a negative weight cycle in graph. Do following for each edge u-v\r\n……If dist[v] > dist[u] + weight of edge uv, then “Graph contains negative weight cycle”\r\nThe idea of step 3 is, step 2 guarantees the shortest distances if the graph doesn’t contain a negative weight cycle. If we iterate through all edges one more time and get a shorter path for any vertex, then there is a negative weight cycle.', '2020-05-25');
INSERT INTO `qtos_map` (`ID`, `Q_ID`, `ROLL`, `SUBMISSION`, `SCORE`, `INPUT`, `OP`, `ALGO`, `DATE`) VALUES
(375, 4, 4301012018, '\r\nimport java.util.Scanner;\r\n\r\nclass Pair { \r\n\r\n	int min; \r\n	int max; \r\n}\r\n\r\npublic class Main { \r\n\r\n	static Pair getMinMax(int arr[], int low, int high) { \r\n	Pair minmax = new Pair(); \r\n	Pair mml = new Pair(); \r\n	Pair mmr = new Pair(); \r\n	int mid; \r\n\r\n	\r\n	if (low == high) { \r\n		minmax.max = arr[low]; \r\n		minmax.min = arr[low]; \r\n		return minmax; \r\n	} \r\n\r\n\r\n	if (high == low + 1) { \r\n		if (arr[low] > arr[high]) { \r\n			minmax.max = arr[low]; \r\n			minmax.min = arr[high]; \r\n		} else { \r\n			minmax.max = arr[high]; \r\n			minmax.min = arr[low]; \r\n		} \r\n		return minmax; \r\n	} \r\n\r\n	\r\n	mid = (low + high) / 2; \r\n	mml = getMinMax(arr, low, mid); \r\n	mmr = getMinMax(arr, mid + 1, high); \r\n\r\n	\r\n	if (mml.min < mmr.min) { \r\n		minmax.min = mml.min; \r\n	} else { \r\n		minmax.min = mmr.min; \r\n	} \r\n\r\n\r\n	if (mml.max > mmr.max) { \r\n		minmax.max = mml.max; \r\n	} else { \r\n		minmax.max = mmr.max; \r\n	} \r\n\r\n	return minmax; \r\n	} \r\n\r\npublic static void main(String args[])\r\n{\r\nint arr[] = {1000, 11, 445, 1, 330, 3000}; \r\n        int arr_size = 6; \r\n        Pair minmax = getMinMax(arr, 0, arr_size - 1); \r\n        System.out.printf(\"\nMinimum element is %d\", minmax.min); \r\n        System.out.printf(\"\nMaximum element is %d\", minmax.max); \r\n}\r\n\r\n\r\n} ', 0, '6 1000 11 445 1 330 3000', '\nMinimum element is 1\nMaximum element is 3000', 'Method 1\r\n(Simple Linear Search)\r\n\r\nInitialize values of min and max as minimum and maximum of the first two elements respectively. Starting from 3rd, compare each element with max and min, and change max and min accordingly (i.e., if the element is smaller than min then change min, else if the element is greater than max then change max, else ignore the element)\r\n\r\nMethod 2\r\n\r\nDivide the array into two parts and compare the maximums and minimums of the two parts to get the maximum and the minimum of the whole array.\r\n\r\nPair MaxMin(array, array_size)\r\n   if array_size = 1\r\n      return element as both max and min\r\n   else if arry_size = 2\r\n      one comparison to determine max and min\r\n      return that pair\r\n   else    /* array_size  > 2 */\r\n      recur for max and min of left half\r\n      recur for max and min of right half\r\n      one comparison determines true max of the two candidates\r\n      one comparison determines true min of the two candidates\r\n      return the pair of max and min', '2020-05-25'),
(376, 5, 4301012018, '\r\nimport java.util.Scanner;\r\n\r\npublic class Main\r\n{\r\n   \r\n   public int[][] multiply(int[][] A, int[][] B)\r\n   {        \r\n       int n = A.length;\r\n       int[][] R = new int[n][n];\r\n       \r\n       if (n == 1)\r\n           R[0][0] = A[0][0] * B[0][0];\r\n       else\r\n       {\r\n           int[][] A11 = new int[n/2][n/2];\r\n           int[][] A12 = new int[n/2][n/2];\r\n           int[][] A21 = new int[n/2][n/2];\r\n           int[][] A22 = new int[n/2][n/2];\r\n           int[][] B11 = new int[n/2][n/2];\r\n           int[][] B12 = new int[n/2][n/2];\r\n           int[][] B21 = new int[n/2][n/2];\r\n           int[][] B22 = new int[n/2][n/2];\r\n\r\n          \r\n           split(A, A11, 0 , 0);\r\n           split(A, A12, 0 , n/2);\r\n           split(A, A21, n/2, 0);\r\n           split(A, A22, n/2, n/2);\r\n           \r\n           split(B, B11, 0 , 0);\r\n           split(B, B12, 0 , n/2);\r\n           split(B, B21, n/2, 0);\r\n           split(B, B22, n/2, n/2);\r\n\r\n           \r\n           int [][] M1 = multiply(add(A11, A22), add(B11, B22));\r\n           int [][] M2 = multiply(add(A21, A22), B11);\r\n           int [][] M3 = multiply(A11, sub(B12, B22));\r\n           int [][] M4 = multiply(A22, sub(B21, B11));\r\n           int [][] M5 = multiply(add(A11, A12), B22);\r\n           int [][] M6 = multiply(sub(A21, A11), add(B11, B12));\r\n           int [][] M7 = multiply(sub(A12, A22), add(B21, B22));\r\n\r\n          \r\n           int [][] C11 = add(sub(add(M1, M4), M5), M7);\r\n           int [][] C12 = add(M3, M5);\r\n           int [][] C21 = add(M2, M4);\r\n           int [][] C22 = add(sub(add(M1, M3), M2), M6);\r\n\r\n           join(C11, R, 0 , 0);\r\n           join(C12, R, 0 , n/2);\r\n           join(C21, R, n/2, 0);\r\n           join(C22, R, n/2, n/2);\r\n       }\r\n          \r\n       return R;\r\n   }\r\n   \r\n   public int[][] sub(int[][] A, int[][] B)\r\n   {\r\n       int n = A.length;\r\n       int[][] C = new int[n][n];\r\n       for (int i = 0; i < n; i++)\r\n           for (int j = 0; j < n; j++)\r\n               C[i][j] = A[i][j] - B[i][j];\r\n       return C;\r\n   }\r\n   \r\n   public int[][] add(int[][] A, int[][] B)\r\n   {\r\n       int n = A.length;\r\n       int[][] C = new int[n][n];\r\n       for (int i = 0; i < n; i++)\r\n           for (int j = 0; j < n; j++)\r\n               C[i][j] = A[i][j] + B[i][j];\r\n       return C;\r\n   }\r\n   \r\n   public void split(int[][] P, int[][] C, int iB, int jB) \r\n   {\r\n       for(int i1 = 0, i2 = iB; i1 < C.length; i1++, i2++)\r\n           for(int j1 = 0, j2 = jB; j1 < C.length; j1++, j2++)\r\n               C[i1][j1] = P[i2][j2];\r\n   }\r\n   \r\n   public void join(int[][] C, int[][] P, int iB, int jB) \r\n   {\r\n       for(int i1 = 0, i2 = iB; i1 < C.length; i1++, i2++)\r\n           for(int j1 = 0, j2 = jB; j1 < C.length; j1++, j2++)\r\n               P[i2][j2] = C[i1][j1];\r\n   }    \r\n\r\n   public static void main (String[] args) \r\n   {\r\n       //Scanner scan = new Scanner(System.in);\r\n      \r\n       StrassenMatrixMultiplication s = new StrassenMatrixMultiplication();\r\n      \r\n       int N = 4;\r\n      \r\n       int[][] A = new int[][]{{1,3,2,4},{5,2,1,4},{0,8,5,3},{5,3,4,2}};\r\n\r\n       int[][] B = new int[][]{{2,6,5,6},{0,8,5,3},{5,3,4,2},{2,1,1,4}};\r\n	\r\n	int[][] C = s.multiply(A, B);\r\n     \r\n       for (int i = 0; i < N; i++)\r\n       {\r\n           for (int j = 0; j < N; j++)\r\n               System.out.print(C[i][j] +\" \");\r\n           System.out.println();\r\n           \r\n       }\r\n       System.out.println();\r\n       \r\n   }\r\n}', 1000, '', '', 'Procedure of Strassen matrix multiplication\r\nThere are some procedures:\r\n\r\nDivide a matrix of order of 2*2 recursively till we get the matrix of 2*2.\r\nUse the previous set of formulas to carry out 2*2 matrix multiplication.\r\nIn this eight multiplication and four additions, subtraction are performed.\r\nCombine the result of two matrixes to find the final product or final matrix.\r\nFormulas for Stassen’s matrix multiplication\r\nIn Strassen’s matrix multiplication there are seven multiplication and four addition, subtraction in total.\r\n\r\n    1.	D1 =  (a11 + a22) (b11 + b22)\r\n    2.	D2 =  (a21 + a22).b11\r\n    3.	D3 =  (b12 – b22).a11\r\n    4.	D4 =  (b21 – b11).a22\r\n    5.	D5 =  (a11 + a12).b22\r\n    6.	D6 =  (a21 – a11) . (b11 + b12)\r\n    7.	D7 =  (a12 – a22) . (b21 + b22)\r\n\r\n    C11 = d1 + d4 – d5 + d7\r\n    C12 = d3 + d5\r\n    C21 = d2 + d4\r\n    C22 = d1 + d3 – d2 – d6\r\nAlgorithm for Strassen’s matrix multiplication\r\nAlgorithm Strassen(n, a, b, d)\r\n\r\nbegin \r\n	If n = threshold then compute\r\n		C = a * b is a conventional matrix.\r\n	Else\r\n		Partition a into four sub matrices  a11, a12, a21, a22.\r\n		Partition b into four sub matrices b11, b12, b21, b22.\r\n		Strassen ( n/2, a11 + a22, b11 + b22, d1)\r\n		Strassen ( n/2, a21 + a22, b11, d2)\r\n		Strassen ( n/2, a11, b12 – b22, d3)\r\n		Strassen ( n/2, a22, b21 – b11, d4)\r\n		Strassen ( n/2, a11 + a12, b22, d5)\r\n		Strassen (n/2, a21 – a11, b11 + b22, d6)\r\n		Strassen (n/2, a12 – a22, b21 + b22, d7)\r\n\r\n		C = d1+d4-d5+d7     d3+d5\r\n		d2+d4           d1+d3-d2-d6  \r\n		\r\n	end if\r\n	\r\n	return (C)\r\nend.', '2020-05-25'),
(377, 16, 4301012018, 'import java.util.Scanner;\r\n\r\npublic class Main  \r\n{ \r\n    public final static int d = 256; \r\n\r\n    static void search(String pat, String txt, int q) \r\n\r\n    { \r\n\r\n        int M = pat.length(); \r\n        int N = txt.length(); \r\n        int i, j; \r\n        int p = 0; // hash value for pattern \r\n        int t = 0; // hash value for txt \r\n        int h = 1; \r\n        for (i = 0; i < M-1; i++) \r\n\r\n            h = (h*d)%q; \r\n\r\n        for (i = 0; i < M; i++) \r\n        { \r\n            p = (d*p + pat.charAt(i))%q; \r\n            t = (d*t + txt.charAt(i))%q; \r\n        } \r\n\r\n    \r\n        for (i = 0; i <= N - M; i++) \r\n        { \r\n            if ( p == t ) \r\n            { \r\n            	for (j = 0; j < M; j++) \r\n                { \r\n                    if (txt.charAt(i+j) != pat.charAt(j)) \r\n\r\n                        break; \r\n\r\n                } \r\n\r\n                if (j == M) \r\n\r\n                    System.out.println(\"Pattern found at index \" + i); \r\n\r\n            } \r\n\r\n            if ( i < N-M ) \r\n\r\n            { \r\n\r\n                t = (d*(t - txt.charAt(i)*h) + txt.charAt(i+M))%q;\r\n\r\n                if (t < 0) \r\n\r\n                t = (t + q); \r\n\r\n            } \r\n        } \r\n    } \r\n\r\n    public static void main(String[] args) \r\n    { \r\n    	Scanner s = new Scanner(System.in);\r\n        String txt = s.nextLine(); \r\n        String pat = s.nextLine();\r\n        int q = 101; // A prime number \r\n        search(pat, txt, q); \r\n\r\n    } \r\n}', 1000, '', '', 'The Rabin-Karp string matching algorithm calculates a hash value for the pattern, as well as for each M-character subsequences of text to be compared. If the hash values are unequal, the algorithm will determine the hash value for next M-character sequence. If the hash values are equal, the algorithm will analyze the pattern and the M-character sequence. In this way, there is only one comparison per text subsequence, and character matching is only required when the hash values match.\r\n\r\nRABIN-KARP-MATCHER (T, P, d, q)\r\n 1. n ← length [T]\r\n 2. m  ← length [P]\r\n 3. h  ←  dm-1 mod q\r\n 4. p ←  0\r\n 5. t0 ←  0\r\n 6. for i ← 1 to m\r\n 7. do p ←  (dp + P[i]) mod q\r\n 8. t0 ← (dt0+T [i]) mod q\r\n 9. for s  ←  0 to n-m\r\n 10. do if p = ts\r\n 11. then if P [1.....m] = T [s+1.....s + m]\r\n 12. then \"Pattern occurs with shift\" s\r\n 13. If s < n-m\r\n 14. then ts+1 ←  (d (ts-T [s+1]h)+T [s+m+1])mod q', '2020-05-25'),
(378, 14, 4401012018, '#include <bits/stdc++.h> \r\nusing namespace std;  \r\n\r\nstruct Edge { \r\n    int src, dest, weight; \r\n}; \r\n  \r\nstruct Graph { \r\n    int V, E; \r\n    struct Edge* edge; \r\n}; \r\n  \r\nstruct Graph* createGraph(int V, int E) \r\n{ \r\n    struct Graph* graph = new Graph; \r\n    graph->V = V; \r\n    graph->E = E; \r\n    graph->edge = new Edge[E]; \r\n    return graph; \r\n} \r\n  \r\nvoid printArr(int dist[], int n) \r\n{ \r\n    printf(\"Vertex   Distance from Source\n\"); \r\n    for (int i = 0; i < n; ++i) \r\n        printf(\"%d 		 %d\n\", i, dist[i]); \r\n} \r\n  \r\nvoid BellmanFord(struct Graph* graph, int src) \r\n{ \r\n    int V = graph->V; \r\n    int E = graph->E; \r\n    int dist[V]; \r\n \r\n    for (int i = 0; i < V; i++) \r\n        dist[i] = INT_MAX; \r\n    dist[src] = 0; \r\n \r\n    for (int i = 1; i <= V - 1; i++) { \r\n        for (int j = 0; j < E; j++) { \r\n            int u = graph->edge[j].src; \r\n            int v = graph->edge[j].dest; \r\n            int weight = graph->edge[j].weight; \r\n            if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) \r\n                dist[v] = dist[u] + weight; \r\n        } \r\n    } \r\n  \r\n   \r\n    for (int i = 0; i < E; i++) { \r\n        int u = graph->edge[i].src; \r\n        int v = graph->edge[i].dest; \r\n        int weight = graph->edge[i].weight; \r\n        if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) { \r\n            printf(\"Graph contains negative weight cycle\"); \r\n            return; \r\n        } \r\n    } \r\n  \r\n    printArr(dist, V); \r\n  \r\n    return; \r\n} \r\n\r\nint main() \r\n{ \r\n    int V = 5;\r\n    int E=8;\r\n    struct Graph* graph = createGraph(V, E); \r\n  \r\n    graph->edge[0].src = 0; \r\n    graph->edge[0].dest = 1; \r\n    graph->edge[0].weight = -1; \r\n  \r\n \r\n    graph->edge[1].src = 0; \r\n    graph->edge[1].dest = 2; \r\n    graph->edge[1].weight = 4; \r\n  \r\n    graph->edge[2].src = 1; \r\n    graph->edge[2].dest = 2; \r\n    graph->edge[2].weight = 3; \r\n  \r\n    graph->edge[3].src = 1; \r\n    graph->edge[3].dest = 3; \r\n    graph->edge[3].weight = 2; \r\n  \r\n    graph->edge[4].src = 1; \r\n    graph->edge[4].dest = 4; \r\n    graph->edge[4].weight = 2; \r\n  \r\n    graph->edge[5].src = 3; \r\n    graph->edge[5].dest = 2; \r\n    graph->edge[5].weight = 5; \r\n  \r\n    graph->edge[6].src = 3; \r\n    graph->edge[6].dest = 1; \r\n    graph->edge[6].weight = 1; \r\n  \r\n    graph->edge[7].src = 4; \r\n    graph->edge[7].dest = 3; \r\n    graph->edge[7].weight = -3; \r\n  \r\n    BellmanFord(graph, 0); \r\n  \r\n    return 0; \r\n} ', 1000, '', '', 'This algorithm detects the negative cycle in a graph and reports their existence.\r\n\r\nBased on the \"Principle of Relaxation\" in which more accurate values gradually recovered an approximation to the proper distance by until eventually reaching the optimum solution.\r\n\r\nGiven a weighted directed graph G = (V, E) with source s and weight function w: E → R, the Bellman-Ford algorithm returns a Boolean value indicating whether or not there is a negative weight cycle that is attainable from the source. If there is such a cycle, the algorithm produces the shortest paths and their weights. The algorithm returns TRUE if and only if a graph contains no negative - weight cycles that are reachable from the source.', '2020-05-25'),
(379, 4, 4401012018, '#include<stdio.h> \nstruct pair  \n{ \n  int min; \n  int max; \n};   \n  \nstruct pair getMinMax(int arr[], int n) \n{ \n  struct pair minmax;      \n  int i; \n    \n  /*If there is only one element then return it as min and max both*/\n  if (n == 1) \n  { \n     minmax.max = arr[0]; \n     minmax.min = arr[0];      \n     return minmax; \n  }     \n  \n  /* If there are more than one elements, then initialize min  \n      and max*/\n  if (arr[0] > arr[1])   \n  { \n      minmax.max = arr[0]; \n      minmax.min = arr[1]; \n  }   \n  else\n  { \n      minmax.max = arr[1]; \n      minmax.min = arr[0]; \n  }     \n  \n  for (i = 2; i<n; i++) \n  { \n    if (arr[i] >  minmax.max)       \n      minmax.max = arr[i]; \n    \n    else if (arr[i] <  minmax.min)       \n      minmax.min = arr[i]; \n  } \n    \n  return minmax; \n} \n  \n/* Driver program to test above function */\nint main() \n{ \nint t;\ncin>>t;\nwhile(t!=0){\nint n;\ncin>>n;\nint arr[n];\n  for(int i=0;i<n;i++){\ncin>>arr[i];\n}\n  struct pair minmax = getMinMax (arr, arr_size); \n  printf(\"nMinimum element is %d\", minmax.min); \n  printf(\"nMaximum element is %d\", minmax.max); \n  getchar(); \nt--;\ncout<<endl;\n}\n} \n', 0, '6 1000 11 445 1 330 3000', '', 'Pair MaxMin(array, array_size)\r\n   if array_size = 1\r\n      return element as both max and min\r\n   else if arry_size = 2\r\n      one comparison to determine max and min\r\n      return that pair\r\n   else    /* array_size  > 2 */\r\n      recur for max and min of left half\r\n      recur for max and min of right half\r\n      one comparison determines true max of the two candidates\r\n      one comparison determines true min of the two candidates\r\n      return the pair of max and min', '2020-05-25'),
(380, 16, 4401012018, '#include <string.h>\n#include <iostream>\nusing namespace std;\n\n#define d 10\n\nvoid rabinKarp(char pattern[], char text[], int q)\n{\n	int m = strlen(pattern);\n	int n = strlen(text);\n	int i, j;\n	int p = 0;\n	int t = 0;\n	int h = 1;\n\n	for (i = 0; i < m - 1; i++)\n		h = (h * d) % q;\n\n	for (i = 0; i < m; i++)\n	{\n		p = (d * p + pattern[i]) % q;\n		t = (d * t + text[i]) % q;\n	}\n\n	for (i = 0; i <= n - m; i++)\n	{\n		if (p == t)\n		{\n			for (j = 0; j < m; j++)\n			{\n				if (text[i + j] != pattern[j])\n					break;\n			}\n\n			if (j == m)\n				cout << \"Pattern found at index \" << i  << endl;\n		}\n\n		if (i < n - m)\n		{\n			t = (d * (t - text[i] * h) + text[i + m]) % q;\n\n			if (t < 0)\n				t = (t + q);\n		}\n	}\n}\n\nint main()\n{\n	char text[100];\n	char pattern[100];\n	int q = 13;\n    cin>>text;\n    cin>>pattern;\n	rabinKarp(pattern, text, q);\n}\n', 1000, '', '', 'Rabin-Karp is another pattern searching algorithm to find the pattern in a more efficient way. It also checks the pattern by moving window one by one, but without checking all characters for all cases, it finds the hash value. When the hash value is matched, then only it tries to check each character. This procedure makes the algorithm more efficient.\r\nThe time complexity is O(m+n), but for the worst case, it is O(mn).\r\n\r\nInput and Output\r\nInput:\r\nMain String: “ABAAABCDBBABCDDEBCABC”, Pattern “ABC”\r\nOutput:\r\nPattern found at position: 4\r\nPattern found at position: 10\r\nPattern found at position: 18\r\n\r\nAlgorithm\r\nrabinKarpSearch(text, pattern, prime) ', '2020-05-25'),
(381, 9, 4501012018, '#include <iostream>\r\nusing namespace std;\r\nclass DisjSet {\r\n    int *rank, *parent, n;\r\n\r\npublic:\r\n        DisjSet(int n)\r\n    {\r\n        rank = new int[n];\r\n        parent = new int[n];\r\n        this->n = n;\r\n        createSet();\r\n    }\r\n\r\n      void createSet()\r\n    {\r\n        for (int i = 0; i < n; i++) {\r\n            parent[i] = i;\r\n        }\r\n        cout<<\"Set with \"<<n<<\" objects created !!\n\";\r\n    }\r\n\r\n      int findSet(int x)\r\n    {\r\n                if (parent[x] != x) {\r\n\r\n                       parent[x] = findSet(parent[x]);\r\n\r\n                }\r\n\r\n        return parent[x];\r\n    }\r\n\r\n       void mergeSets(int x, int y)\r\n    {\r\n               int xset = findSet(x);\r\n        int yset = findSet(y);\r\n\r\n               if (xset == yset)\r\n            return;\r\n\r\n                if (rank[xset] < rank[yset]) {\r\n            parent[xset] = yset;\r\n        }\r\n        else if (rank[xset] > rank[yset]) {\r\n            parent[yset] = xset;\r\n        }\r\n\r\n                else {\r\n            parent[yset] = xset;\r\n            rank[xset] = rank[xset] + 1;\r\n        }\r\n        cout<<\"\nSets \"<<x<<\" and \"<<y<<\" merged !!\n\";\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    DisjSet obj(5);\r\n    obj.mergeSets(0, 2);\r\n    obj.mergeSets(4, 2);\r\n    obj.mergeSets(3, 1);\r\n    cout<<\"\nFindset operation : \n\";\r\n    if (obj.findSet(4) == obj.findSet(0))\r\n        cout << \"Yes\n\";\r\n    else\r\n        cout << \"No\n\";\r\n    if (obj.findSet(1) == obj.findSet(0))\r\n        cout << \"Yes\n\";\r\n    else\r\n        cout << \"No\n\";\r\n\r\n    return 0;\r\n}\r\n', 1000, '', '', 'void create( int Arr[ ], int N)\r\n{\r\n    for(int i = 0;i<N;i++)\r\n    Arr[ i ] = i ;\r\n}\r\n\r\nbool find( int Arr[ ], int A, int B)\r\n{\r\nif(Arr[ A ] == Arr[ B ])\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\n\r\nvoid merge(int Arr[ ], int N, int A, int B)\r\n{\r\n    int TEMP = Arr[ A ];\r\nfor(int i = 0; i < N;i++)\r\n    {\r\n    if(Arr[ i ] == TEMP)\r\n    Arr[ i ] = Arr[ B ];\r\n    }\r\n}\r\n', '2020-05-25'),
(382, 14, 4501012018, '#include <bits/stdc++.h>\r\nusing namespace std;\r\nstruct Edge {\r\n	int src, dest, weight;\r\n};\r\nstruct Graph {\r\n	int V, E;\r\n	struct Edge* edge;\r\n};\r\nstruct Graph* createGraph(int V, int E)\r\n{\r\n	struct Graph* graph = new Graph;\r\n	graph->V = V;\r\n	graph->E = E;\r\n	graph->edge = new Edge[E];\r\n	return graph;\r\n}\r\nvoid printArr(int dist[], int n)\r\n{\r\n	printf(\"Vertex   Distance from Source\n\");\r\n	for (int i = 0; i < n; ++i)\r\n		printf(\"%d 		 %d\n\", i, dist[i]);\r\n}\r\nvoid BellmanFord(struct Graph* graph, int src)\r\n{\r\n	int V = graph->V;\r\n	int E = graph->E;\r\n	int dist[V];\r\n	for (int i = 0; i < V; i++)\r\n		dist[i] = INT_MAX;\r\n	dist[src] = 0;\r\n	for (int i = 1; i <= V - 1; i++) {\r\n		for (int j = 0; j < E; j++) {\r\n			int u = graph->edge[j].src;\r\n			int v = graph->edge[j].dest;\r\n			int weight = graph->edge[j].weight;\r\n			if (dist[u] != INT_MAX &&dist[u] + weight <dist[v])\r\n				dist[v] = dist[u] + weight;\r\n		}\r\n	}\r\n	for (int i = 0; i < E; i++) {\r\n		int u = graph->edge[i].src;\r\n		int v = graph->edge[i].dest;\r\n		int weight = graph->edge[i].weight;\r\n		if (dist[u] != INT_MAX &&dist[u] + weight <dist[v]) {\r\n			printf(\"Graph contains negative weight cycle\");\r\n			return;\r\n		}\r\n	}\r\n	printArr(dist, V);\r\n	return;\r\n}\r\nint main()\r\n{\r\ncout<<\"NUMBER OF VERTICES = 6 AND EDGES = 8 \n\";\r\n	int V=6,E=8;\r\n	struct Graph* graph = createGraph(V, E);\r\n	cout<<\"\nSOURCE DESTINATION WEIGHT : 0 1 -1 0 2 4 1 2 3 1 3 2 1 4 2 3 2 5 3 1 1 4 3 -3\n\n\";\r\n\r\n    graph->edge[0].src = 0;\r\n	graph->edge[0].dest = 1;\r\n	graph->edge[0].weight = -1;\r\n	graph->edge[1].src = 0;\r\n	graph->edge[1].dest = 2;\r\n	graph->edge[1].weight = 4;\r\n	graph->edge[2].src = 1;\r\n	graph->edge[2].dest = 2;\r\n	graph->edge[2].weight = 3;\r\n	graph->edge[3].src = 1;\r\n	graph->edge[3].dest = 3;\r\n	graph->edge[3].weight = 2;\r\n	graph->edge[4].src = 1;\r\n	graph->edge[4].dest = 4;\r\n	graph->edge[4].weight = 2;\r\n	graph->edge[5].src = 3;\r\n	graph->edge[5].dest = 2;\r\n	graph->edge[5].weight = 5;\r\n	graph->edge[6].src = 3;\r\n	graph->edge[6].dest = 1;\r\n	graph->edge[6].weight = 1;\r\n	graph->edge[7].src = 4;\r\n	graph->edge[7].dest = 3;\r\n	graph->edge[7].weight = -3;\r\n	BellmanFord(graph, 0);\r\n	return 0;\r\n}\r\n', 1000, '', '', 'Bellman Ford Algorithm\r\n\r\n1) This step initializes distances from source to all vertices as infinite and distance to source itself as 0. Create an array dist[] of size |V| with all values as infinite except dist[src] where src is source vertex.\r\n\r\n2) This step calculates shortest distances. Do following |V|-1 times where |V| is the number of vertices in given graph.\r\n?..a) Do following for each edge u-v\r\n??????If dist[v] > dist[u] + weight of edge uv, then update dist[v]\r\n???????.dist[v] = dist[u] + weight of edge uv\r\n\r\n3) This step reports if there is a negative weight cycle in graph. Do following for each edge u-v\r\n??If dist[v] > dist[u] + weight of edge uv, then ?Graph contains negative weight cycle?\r\nThe idea of step 3 is, step 2 guarantees shortest distances if graph doesn?t contain negative weight cycle. If we iterate through all edges one more time and get a shorter path for any vertex, then there is a negative weight cycle\r\n\r\n', '2020-05-25'),
(383, 15, 4501012018, '#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint MatrixChainOrder(int p[], int i, int j)\r\n{\r\n    if(i == j)\r\n        return 0;\r\n    int k;\r\n    int min = INT_MAX;\r\n    int count;\r\n\r\n    for (k = i; k < j; k++)\r\n    {\r\n        count = MatrixChainOrder(p, i, k) +\r\n                MatrixChainOrder(p, k + 1, j) +\r\n                p[i - 1] * p[k] * p[j];\r\n\r\n        if (count < min)\r\n            min = count;\r\n    }\r\n\r\n    return min;\r\n}\r\n\r\nint main()\r\n{\r\n    int n=0;\r\n\r\n    cin>>n;\r\n\r\n    int arr[n];\r\n    for(int i=0;i<n;i++){\r\n        cin>>arr[i];\r\n    }\r\n         cout<< MatrixChainOrder(arr, 1, n - 1);\r\n}\r\n', 1000, '', '', 'MCM\r\nAlgorithm..\r\nMatrix-Multiply(A,B)\r\n1.If columns[A]!=rows[B]\r\n2. then error ?incomplete dimensions?\r\n3. else for i = 1 to rows[A]\r\n4.        	do for j = 1 to columns[B]\r\n5.                        	do C[i,j] = 0\r\n6.                                        	for k = 1 to columns[A]\r\n7.                                                        	Do C[i,j]=C[i,j]+A[i,k]*B[k,j]\r\n8. Return C\r\n', '2020-05-25'),
(384, 8, 4501012018, '#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\n\r\ninline ll** MatrixMultiply(ll** a, ll** b, int n, int l, int m)\r\n{\r\n    ll** c = new ll*[n];\r\n    for (int i = 0; i < n; i++)\r\n        c[i] = new ll[m];\r\n\r\n    for (int i = 0; i < n; i++) {\r\n        for (int j = 0; j < m; j++) {\r\n            c[i][j] = 0;\r\n            for (int k = 0; k < l; k++) {\r\n                c[i][j] += a[i][k] * b[k][j];\r\n            }\r\n        }\r\n    }\r\n    return c;\r\n}\r\n\r\ninline ll** Strassen(ll** a, ll** b, int n, int l, int m)\r\n{\r\n    if (n == 1 || l == 1 || m == 1)\r\n        return MatrixMultiply(a, b, n, l, m);\r\n\r\n    ll** c = new ll*[n];\r\n    for (int i = 0; i < n; i++)\r\n        c[i] = new ll[m];\r\n\r\n    int adjN = (n >> 1) + (n & 1);\r\n    int adjL = (l >> 1) + (l & 1);\r\n    int adjM = (m >> 1) + (m & 1);\r\n\r\n    ll**** As = new ll***[2];\r\n    for (int x = 0; x < 2; x++) {\r\n        As[x] = new ll**[2];\r\n        for (int y = 0; y < 2; y++) {\r\n            As[x][y] = new ll*[adjN];\r\n            for (int i = 0; i < adjN; i++) {\r\n                As[x][y][i] = new ll[adjL];\r\n                for (int j = 0; j < adjL; j++) {\r\n                    int I = i + (x & 1) * adjN;\r\n                    int J = j + (y & 1) * adjL;\r\n                    As[x][y][i][j] = (I < n && J < l) ? a[I][J] : 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    ll**** Bs = new ll***[2];\r\n    for (int x = 0; x < 2; x++) {\r\n        Bs[x] = new ll**[2];\r\n        for (int y = 0; y < 2; y++) {\r\n            Bs[x][y] = new ll*[adjN];\r\n            for (int i = 0; i < adjL; i++) {\r\n                Bs[x][y][i] = new ll[adjM];\r\n                for (int j = 0; j < adjM; j++) {\r\n                    int I = i + (x & 1) * adjL;\r\n                    int J = j + (y & 1) * adjM;\r\n                    Bs[x][y][i][j] = (I < l && J < m) ? b[I][J] : 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    ll*** s = new ll**[10];\r\n    for (int i = 0; i < 10; i++) {\r\n        switch (i) {\r\n        case 0:\r\n            s[i] = new ll*[adjL];\r\n            for (int j = 0; j < adjL; j++) {\r\n                s[i][j] = new ll[adjM];\r\n                for (int k = 0; k < adjM; k++) {\r\n                    s[i][j][k] = Bs[0][1][j][k] - Bs[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 1:\r\n            s[i] = new ll*[adjN];\r\n            for (int j = 0; j < adjN; j++) {\r\n                s[i][j] = new ll[adjL];\r\n                for (int k = 0; k < adjL; k++) {\r\n                    s[i][j][k] = As[0][0][j][k] + As[0][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 2:\r\n            s[i] = new ll*[adjN];\r\n            for (int j = 0; j < adjN; j++) {\r\n                s[i][j] = new ll[adjL];\r\n                for (int k = 0; k < adjL; k++) {\r\n                    s[i][j][k] = As[1][0][j][k] + As[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 3:\r\n            s[i] = new ll*[adjL];\r\n            for (int j = 0; j < adjL; j++) {\r\n                s[i][j] = new ll[adjM];\r\n                for (int k = 0; k < adjM; k++) {\r\n                    s[i][j][k] = Bs[1][0][j][k] - Bs[0][0][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 4:\r\n            s[i] = new ll*[adjN];\r\n            for (int j = 0; j < adjN; j++) {\r\n                s[i][j] = new ll[adjL];\r\n                for (int k = 0; k < adjL; k++) {\r\n                    s[i][j][k] = As[0][0][j][k] + As[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 5:\r\n            s[i] = new ll*[adjL];\r\n            for (int j = 0; j < adjL; j++) {\r\n                s[i][j] = new ll[adjM];\r\n                for (int k = 0; k < adjM; k++) {\r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 6:\r\n            s[i] = new ll*[adjN];\r\n            for (int j = 0; j < adjN; j++) {\r\n                s[i][j] = new ll[adjL];\r\n                for (int k = 0; k < adjL; k++) {\r\n                    s[i][j][k] = As[0][1][j][k] - As[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 7:\r\n            s[i] = new ll*[adjL];\r\n            for (int j = 0; j < adjL; j++) {\r\n                s[i][j] = new ll[adjM];\r\n                for (int k = 0; k < adjM; k++) {\r\n                    s[i][j][k] = Bs[1][0][j][k] + Bs[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 8:\r\n            s[i] = new ll*[adjN];\r\n            for (int j = 0; j < adjN; j++) {\r\n                s[i][j] = new ll[adjL];\r\n                for (int k = 0; k < adjL; k++) {\r\n                    s[i][j][k] = As[0][0][j][k] - As[1][0][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 9:\r\n            s[i] = new ll*[adjL];\r\n            for (int j = 0; j < adjL; j++) {\r\n                s[i][j] = new ll[adjM];\r\n                for (int k = 0; k < adjM; k++) {\r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[0][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    }\r\n\r\n    ll*** p = new ll**[7];\r\n    p[0] = Strassen(As[0][0], s[0], adjN, adjL, adjM);\r\n    p[1] = Strassen(s[1], Bs[1][1], adjN, adjL, adjM);\r\n    p[2] = Strassen(s[2], Bs[0][0], adjN, adjL, adjM);\r\n    p[3] = Strassen(As[1][1], s[3], adjN, adjL, adjM);\r\n    p[4] = Strassen(s[4], s[5], adjN, adjL, adjM);\r\n    p[5] = Strassen(s[6], s[7], adjN, adjL, adjM);\r\n    p[6] = Strassen(s[8], s[9], adjN, adjL, adjM);\r\n\r\n    for (int i = 0; i < adjN; i++) {\r\n        for (int j = 0; j < adjM; j++) {\r\n            c[i][j] = p[4][i][j] + p[3][i][j] - p[1][i][j] + p[5][i][j];\r\n            if (j + adjM < m)\r\n                c[i][j + adjM] = p[0][i][j] + p[1][i][j];\r\n            if (i + adjN < n)\r\n                c[i + adjN][j] = p[2][i][j] + p[3][i][j];\r\n            if (i + adjN < n && j + adjM < m)\r\n                c[i + adjN][j + adjM] = p[4][i][j] + p[0][i][j] - p[2][i][j] - p[6][i][j];\r\n        }\r\n    }\r\n\r\n    for (int x = 0; x < 2; x++) {\r\n        for (int y = 0; y < 2; y++) {\r\n            for (int i = 0; i < adjN; i++) {\r\n                delete[] As[x][y][i];\r\n            }\r\n            delete[] As[x][y];\r\n        }\r\n        delete[] As[x];\r\n    }\r\n    delete[] As;\r\n\r\n    for (int x = 0; x < 2; x++) {\r\n        for (int y = 0; y < 2; y++) {\r\n            for (int i = 0; i < adjL; i++) {\r\n                delete[] Bs[x][y][i];\r\n            }\r\n            delete[] Bs[x][y];\r\n        }\r\n        delete[] Bs[x];\r\n    }\r\n    delete[] Bs;\r\n\r\n    for (int i = 0; i < 10; i++) {\r\n        switch (i) {\r\n        case 0:\r\n        case 3:\r\n        case 5:\r\n        case 7:\r\n        case 9:\r\n            for (int j = 0; j < adjL; j++) {\r\n                delete[] s[i][j];\r\n            }\r\n            break;\r\n        case 1:\r\n        case 2:\r\n        case 4:\r\n        case 6:\r\n        case 8:\r\n            for (int j = 0; j < adjN; j++) {\r\n                delete[] s[i][j];\r\n            }\r\n            break;\r\n        }\r\n        delete[] s[i];\r\n    }\r\n    delete[] s;\r\n\r\n    for (int i = 0; i < 7; i++) {\r\n        for (int j = 0; j < (n >> 1); j++) {\r\n            delete[] p[i][j];\r\n        }\r\n        delete[] p[i];\r\n    }\r\n    delete[] p;\r\n\r\n    return c;\r\n}\r\n\r\nint main()\r\n{\r\n    int mat1_m,mat1_n,mat2_m,mat2_n;\r\n\r\n   cin>>mat1_m;\r\n\r\nmat1_n=mat1_m;\r\nmat2_m=mat1_m;\r\nmat2_n=mat1_m;\r\n    ll** mat1 =new ll*[mat1_m];\r\n\r\n    for(int i=0;i<mat1_m;i++)\r\n    {\r\n        mat1[i]=new ll[mat1_n];\r\n        for(int j=0;j<mat1_n;j++)\r\n        {\r\n            cin>>mat1[i][j];\r\n        }\r\n\r\n    }\r\n\r\n    ll**mat2 =new ll*[mat2_m];\r\n    for(int i=0;i<mat2_m;i++)\r\n    {\r\n        mat2[i]=new ll[mat2_n];\r\n        for(int j=0;j<mat2_n;j++)\r\n        {\r\n            cin>>mat2[i][j];\r\n        }\r\n\r\n    }\r\n\r\nif(mat1_n!=mat2_m)\r\n{\r\n    cout<<\"/////////Multipliaction not possible //////// \";\r\n    return 0;\r\n\r\n}\r\n\r\n\r\n    ll** mat3 = Strassen(mat1, mat2, mat1_m, mat1_n, mat2_n);\r\n    for (int i = 0; i < mat1_m; i++)\r\n    {\r\n        for (int j = 0; j < mat2_n; j++)\r\n        {\r\n            cout<<mat3[i][j]<<\" \";\r\n        }\r\n	cout<<endl;\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n', 0, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '-17 -4 -7 \n10 2 11 \n40 92 107 \n', 'Formulas for Stassen?s matrix multiplication\r\nIn Strassen?s matrix multiplication there are seven multiplication and four addition, subtraction in total.\r\n\r\n    1.	D1 =  (a11 + a22) (b11 + b22)\r\n    2.	D2 =  (a21 + a22).b11\r\n    3.	D3 =  (b12 ? b22).a11\r\n    4.	D4 =  (b21 ? b11).a22\r\n    5.	D5 =  (a11 + a12).b22\r\n    6.	D6 =  (a21 ? a11) . (b11 + b12)\r\n    7.	D7 =  (a12 ? a22) . (b21 + b22)\r\n\r\n    C11 = d1 + d4 ? d5 + d7\r\n    C12 = d3 + d5\r\n    C21 = d2 + d4\r\n    C22 = d1 + d3 ? d2 ? d6\r\nAlgorithm for Strassen?s matrix multiplication\r\nAlgorithm Strassen(n, a, b, d)\r\n\r\nbegin\r\n	If n = threshold then compute\r\n		C = a * b is a conventional matrix.\r\n	Else\r\n		Partition a into four sub matrices  a11, a12, a21, a22.\r\n		Partition b into four sub matrices b11, b12, b21, b22.\r\n		Strassen ( n/2, a11 + a22, b11 + b22, d1)\r\n		Strassen ( n/2, a21 + a22, b11, d2)\r\n		Strassen ( n/2, a11, b12 ? b22, d3)\r\n		Strassen ( n/2, a22, b21 ? b11, d4)\r\n		Strassen ( n/2, a11 + a12, b22, d5)\r\n		Strassen (n/2, a21 ? a11, b11 + b22, d6)\r\n		Strassen (n/2, a12 ? a22, b21 + b22, d7)\r\n\r\n		C = d1+d4-d5+d7     d3+d5\r\n		    d2+d4           d1+d3-d2-d6\r\n\r\n	end if\r\n\r\n	return (C)\r\nend.\r\n', '2020-05-25'),
(385, 5, 4501012018, '#include<iostream>\r\n#include<conio.h>\r\n#include<stdio.h>\r\nusing namespace std;\r\ntypedef long long lld;\r\ntypedef long long ll;\r\ninline lld** MatrixMultiply(lld** a, lld** b, int n, int l, int m)\r\n{\r\n    lld** c = new lld*[n];\r\n    for (int i = 0; i < n; i++)\r\n        c[i] = new lld[m];\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        for (int j = 0; j < m; j++)\r\n        {\r\n            c[i][j] = 0;\r\n            for (int k = 0; k < l; k++)\r\n            {\r\n                c[i][j] += a[i][k] * b[k][j];\r\n            }\r\n        }\r\n    }\r\n    return c;\r\n}\r\ninline lld** Strassen(lld** a, lld** b, int n, int l, int m)\r\n{\r\n    if (n == 1 || l == 1 || m == 1)\r\n        return MatrixMultiply(a, b, n, l, m);\r\n    lld** c = new lld*[n];\r\n    for (int i = 0; i < n; i++)\r\n        c[i] = new lld[m];\r\n    int adjN = (n >> 1) + (n & 1);\r\n    int adjL = (l >> 1) + (l & 1);\r\n    int adjM = (m >> 1) + (m & 1);\r\n    lld**** As = new lld***[2];\r\n    for (int x = 0; x < 2; x++)\r\n    {\r\n        As[x] = new lld**[2];\r\n        for (int y = 0; y < 2; y++)\r\n        {\r\n            As[x][y] = new lld*[adjN];\r\n            for (int i = 0; i < adjN; i++)\r\n            {\r\n                As[x][y][i] = new lld[adjL];\r\n                for (int j = 0; j < adjL; j++)\r\n                {\r\n                    int I = i + (x & 1) * adjN;\r\n                    int J = j + (y & 1) * adjL;\r\n                    As[x][y][i][j] = (I < n && J < l) ? a[I][J] : 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    lld**** Bs = new lld***[2];\r\n    for (int x = 0; x < 2; x++)\r\n    {\r\n        Bs[x] = new lld**[2];\r\n        for (int y = 0; y < 2; y++)\r\n        {\r\n            Bs[x][y] = new lld*[adjN];\r\n            for (int i = 0; i < adjL; i++)\r\n            {\r\n                Bs[x][y][i] = new lld[adjM];\r\n                for (int j = 0; j < adjM; j++)\r\n                {\r\n                    int I = i + (x & 1) * adjL;\r\n                    int J = j + (y & 1) * adjM;\r\n                    Bs[x][y][i][j] = (I < l && J < m) ? b[I][J] : 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    lld*** s = new lld**[10];\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        switch (i)\r\n        {\r\n        case 0:\r\n            s[i] = new lld*[adjL];\r\n            for (int j = 0; j < adjL; j++)\r\n	    {\r\n                s[i][j] = new lld[adjM];\r\n                for (int k = 0; k < adjM; k++)\r\n		{\r\n                    s[i][j][k] = Bs[0][1][j][k] - Bs[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 1:\r\n            s[i] = new lld*[adjN];\r\n            for (int j = 0; j < adjN; j++)\r\n	    {\r\n                s[i][j] = new lld[adjL];\r\n                for (int k = 0; k < adjL; k++)\r\n		{\r\n                    s[i][j][k] = As[0][0][j][k] + As[0][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 2:\r\n            s[i] = new lld*[adjN];\r\n            for (int j = 0; j < adjN; j++)\r\n	    {\r\n                s[i][j] = new lld[adjL];\r\n                for (int k = 0; k < adjL; k++)\r\n		{\r\n                    s[i][j][k] = As[1][0][j][k] + As[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 3:\r\n            s[i] = new lld*[adjL];\r\n            for (int j = 0; j < adjL; j++)\r\n	    {\r\n                s[i][j] = new lld[adjM];\r\n                for (int k = 0; k < adjM; k++)\r\n		{\r\n                    s[i][j][k] = Bs[1][0][j][k] - Bs[0][0][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 4:\r\n            s[i] = new lld*[adjN];\r\n            for (int j = 0; j < adjN; j++)\r\n	    {\r\n                s[i][j] = new lld[adjL];\r\n                for (int k = 0; k < adjL; k++)\r\n		{\r\n                    s[i][j][k] = As[0][0][j][k] + As[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 5:\r\n            s[i] = new lld*[adjL];\r\n            for (int j = 0; j < adjL; j++)\r\n	    {\r\n                s[i][j] = new lld[adjM];\r\n                for (int k = 0; k < adjM; k++)\r\n		{\r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 6:\r\n            s[i] = new lld*[adjN];\r\n            for (int j = 0; j < adjN; j++)\r\n	    {\r\n                s[i][j] = new lld[adjL];\r\n                for (int k = 0; k < adjL; k++)\r\n		{\r\n                    s[i][j][k] = As[0][1][j][k] - As[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 7:\r\n            s[i] = new lld*[adjL];\r\n            for (int j = 0; j < adjL; j++)\r\n	    {\r\n                s[i][j] = new lld[adjM];\r\n                for (int k = 0; k < adjM; k++)\r\n		{\r\n                    s[i][j][k] = Bs[1][0][j][k] + Bs[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 8:\r\n            s[i] = new lld*[adjN];\r\n            for (int j = 0; j < adjN; j++)\r\n	    {\r\n                s[i][j] = new lld[adjL];\r\n                for (int k = 0; k < adjL; k++)\r\n		{\r\n                    s[i][j][k] = As[0][0][j][k] - As[1][0][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 9:\r\n            s[i] = new lld*[adjL];\r\n            for (int j = 0; j < adjL; j++)\r\n	    {\r\n                s[i][j] = new lld[adjM];\r\n                for (int k = 0; k < adjM; k++)\r\n		{\r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[0][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    }\r\n    lld*** p = new lld**[7];\r\n    p[0] = Strassen(As[0][0], s[0], adjN, adjL, adjM);\r\n    p[1] = Strassen(s[1], Bs[1][1], adjN, adjL, adjM);\r\n    p[2] = Strassen(s[2], Bs[0][0], adjN, adjL, adjM);\r\n    p[3] = Strassen(As[1][1], s[3], adjN, adjL, adjM);\r\n    p[4] = Strassen(s[4], s[5], adjN, adjL, adjM);\r\n    p[5] = Strassen(s[6], s[7], adjN, adjL, adjM);\r\n    p[6] = Strassen(s[8], s[9], adjN, adjL, adjM);\r\n    for (int i = 0; i < adjN; i++)\r\n    {\r\n        for (int j = 0; j < adjM; j++)\r\n	{\r\n            c[i][j] = p[4][i][j] + p[3][i][j] - p[1][i][j] + p[5][i][j];\r\n            if (j + adjM < m)\r\n                c[i][j + adjM] = p[0][i][j] + p[1][i][j];\r\n            if (i + adjN < n)\r\n                c[i + adjN][j] = p[2][i][j] + p[3][i][j];\r\n            if (i + adjN < n && j + adjM < m)\r\n                c[i + adjN][j + adjM] = p[4][i][j] + p[0][i][j] - p[2][i][j] - p[6][i][j];\r\n        }\r\n    }\r\n    for (int x = 0; x < 2; x++)\r\n    {\r\n        for (int y = 0; y < 2; y++)\r\n	{\r\n            for (int i = 0; i < adjN; i++)\r\n	    {\r\n                delete[] As[x][y][i];\r\n            }\r\n            delete[] As[x][y];\r\n        }\r\n        delete[] As[x];\r\n    }\r\n    delete[] As;\r\n    for (int x = 0; x < 2; x++)\r\n    {\r\n        for (int y = 0; y < 2; y++)\r\n	{\r\n            for (int i = 0; i < adjL; i++)\r\n	    {\r\n                delete[] Bs[x][y][i];\r\n            }\r\n            delete[] Bs[x][y];\r\n        }\r\n        delete[] Bs[x];\r\n    }\r\n    delete[] Bs;\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        switch (i)\r\n       {\r\n        case 0:\r\n        case 3:\r\n        case 5:\r\n        case 7:\r\n        case 9:\r\n            for (int j = 0; j < adjL; j++)\r\n	    {\r\n                delete[] s[i][j];\r\n            }\r\n            break;\r\n        case 1:\r\n        case 2:\r\n        case 4:\r\n        case 6:\r\n        case 8:\r\n            for (int j = 0; j < adjN; j++)\r\n	    {\r\n                delete[] s[i][j];\r\n            }\r\n            break;\r\n        }\r\n        delete[] s[i];\r\n    }\r\n    delete[] s;\r\n    for (int i = 0; i < 7; i++)\r\n    {\r\n        for (int j = 0; j < (n >> 1); j++)\r\n	{\r\n            delete[] p[i][j];\r\n        }\r\n        delete[] p[i];\r\n    }\r\n    delete[] p;\r\n    return c;\r\n}\r\nint main()\r\n{   lld** matA;\r\n    matA = new lld*[2];\r\n    for (int i = 0; i < 3; i++)\r\n        matA[i] = new lld[3];\r\n    matA[0][0] = 1;\r\n    matA[0][1] = 2;\r\n    matA[0][2] = 3;\r\n    matA[1][0] = 4;\r\n    matA[1][1] = 5;\r\n    matA[1][2] = 6;\r\n    matA[2][0] = 7;\r\n    matA[2][1] = 8;\r\n    matA[2][2] = 9;\r\n    lld** matB;\r\n    matB = new lld*[3];\r\n    for (int i = 0; i < 3; i++)\r\n        matB[i] = new lld[3];\r\n    matB[0][0] = 10;\r\n    matB[0][1] = 11;\r\n    matB[0][2] = 12;\r\n    matB[1][0] = 13;\r\n    matB[1][1] = 14;\r\n    matB[1][2] = 15;\r\n    matB[2][0] = 16;\r\n    matB[2][1] = 17;\r\n    matB[2][2] = 18;\r\n      cout<<\"\nThe dimensions of first matrix : 3*3\";\r\n    cout<<\"\nThe first matrix : \n1 2 3\n4 5 6\n7 8 9\n\n\";\r\n    cout<<\"\nThe dimensions of second matrix : 3*3\";\r\n    cout<<\"\nThe second matrix : \n10 11 12\n13 14 15\n16 17 18\n\n\";\r\ncout<<\"The Product matrix is \n\n\";\r\n\r\n    lld** matC = Strassen(matA, matB, 3, 3, 3);\r\n    for (int i = 0; i < 3; i++)\r\n    {\r\n        for (int j = 0; j < 3; j++)\r\n	{\r\n            printf(\"%lld \", matC[i][j]);\r\n        }\r\n        printf(\"\n\");\r\n    }\r\n\r\n    return 0;\r\n}\r\n', 1000, '', '', '\r\n\r\nFormulas for Stassen?s matrix multiplication\r\nIn Strassen?s matrix multiplication there are seven multiplication and four addition, subtraction in total.\r\n\r\n    1.	D1 =  (a11 + a22) (b11 + b22)\r\n    2.	D2 =  (a21 + a22).b11\r\n    3.	D3 =  (b12 ? b22).a11\r\n    4.	D4 =  (b21 ? b11).a22\r\n    5.	D5 =  (a11 + a12).b22\r\n    6.	D6 =  (a21 ? a11) . (b11 + b12)\r\n    7.	D7 =  (a12 ? a22) . (b21 + b22)\r\n\r\n    C11 = d1 + d4 ? d5 + d7\r\n    C12 = d3 + d5\r\n    C21 = d2 + d4\r\n    C22 = d1 + d3 ? d2 ? d6\r\nAlgorithm for Strassen?s matrix multiplication\r\nAlgorithm Strassen(n, a, b, d)\r\n\r\nbegin\r\n	If n = threshold then compute\r\n		C = a * b is a conventional matrix.\r\n	Else\r\n		Partition a into four sub matrices a11, a12, a21, a22.\r\n		Partition b into four sub matrices b11, b12, b21, b22.\r\n		Strassen( n/2, a11 + a22, b11 + b22, d1)\r\n		Strassen( n/2, a21 + a22, b11, d2)\r\n		Strassen( n/2, a11, b12 ? b22, d3)\r\n		Strassen( n/2, a22, b21 ? b11, d4)\r\n		Strassen( n/2, a11 + a12, b22, d5)\r\n		Strassen (n/2, a21 ? a11, b11 + b22, d6)\r\n		Strassen (n/2, a12 ? a22, b21 + b22, d7)\r\n\r\n		C = d1+d4-d5+d7     d3+d5\r\n		    d2+d4           d1+d3-d2-d6\r\n\r\n	end if\r\n\r\n	return (C)\r\nend.\r\n\r\n\r\n\r\n', '2020-05-25'),
(386, 16, 4501012018, '#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define d 256\r\n\r\nvoid search(char pat[], char txt[], int q,int l1,int l2)\r\n{\r\n    int M = l2;\r\n    int N = l1;\r\n    int i, j;\r\n    int p = 0;\r\n    int t = 0;\r\n    int h = 1;\r\n    for (i = 0; i < M - 1; i++)\r\n        h = (h * d) % q;\r\n    for (i = 0; i < M; i++)\r\n    {\r\n        p = (d * p + pat[i]) % q;\r\n        t = (d * t + txt[i]) % q;\r\n    }\r\n    for (i = 0; i <= N - M; i++)\r\n    {\r\n        if ( p == t )\r\n        {\r\n            for (j = 0; j < M; j++)\r\n            {\r\n                if (txt[i+j] != pat[j])\r\n                    break;\r\n            }\r\n            if (j == M)\r\n                cout<<\"Pattern found at index \"<< i<<\" \";\r\n        }\r\n        if ( i < N-M )\r\n        {\r\n            t = (d*(t - txt[i]*h) + txt[i+M])%q;\r\n            if (t < 0)\r\n            t = (t + q);\r\n        }\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n\r\n    string s1;\r\n    getline(cin,s1);\r\n    int l1=s1.length();\r\n    char txt[l1];\r\n    for(int i=0;i<l1;i++){\r\n        txt[i]=s1[i];\r\n    }\r\n\r\n    string s2;\r\n    getline(cin,s2);\r\n    int l2=s2.length();\r\n    char pat[l2];\r\n\r\n    for(int i=0;i<l2;i++){\r\n        pat[i]=s2[i];\r\n    }\r\n\r\n    int q = 101;\r\n    search(pat, txt, q,l1,l2);\r\n    return 0;\r\n}\r\n', 1000, '', '', 'Rabin Karp\r\n\r\nBegin\r\n   patLen := pattern Length\r\n   strLen := string Length\r\n   patHash := 0 and strHash := 0, h := 1\r\n   maxChar := total number of characters in character set\r\n\r\n   for index i of all character in pattern, do\r\n  	h := (h*maxChar) mod prime\r\n   done\r\n\r\n   for all character index i of pattern, do\r\n  	patHash := (maxChar*patHash + pattern[i]) mod prime\r\n  	strHash := (maxChar*strHash + text[i]) mod prime\r\n   done\r\n\r\n   for i := 0 to (strLen - patLen), do\r\n  	if patHash = strHash, then\r\n     	for charIndex := 0 to patLen -1, do\r\n        	if text[i+charIndex] ≠ pattern[charIndex], then\r\n           	break the loop\r\n     	done\r\n\r\n     	if charIndex = patLen, then\r\n        	print the location i as pattern found at i position.\r\n  	if i < (strLen - patLen), then\r\n     	strHash := (maxChar*(strHash – text[i]*h)+text[i+patLen]) mod prime, then\r\n  	if strHash < 0, then\r\n     	strHash := strHash + prime\r\n   done\r\nEnd\r\n', '2020-05-25');
INSERT INTO `qtos_map` (`ID`, `Q_ID`, `ROLL`, `SUBMISSION`, `SCORE`, `INPUT`, `OP`, `ALGO`, `DATE`) VALUES
(387, 9, 4601012018, '??#\0i\0n\0c\0l\0u\0d\0e\0 \0<\0i\0o\0s\0t\0r\0e\0a\0m\0>\0 \0\r\0\n\0u\0s\0i\0n\0g\0 \0n\0a\0m\0e\0s\0p\0a\0c\0e\0 \0s\0t\0d\0;\0 \0\r\0\n\0c\0l\0a\0s\0s\0 \0D\0i\0s\0j\0S\0e\0t\0 \0\r\0\n\0{\0 \0\r\0\n\0 \0 \0 \0 \0i\0n\0t\0 \0*\0r\0a\0n\0k\0,\0 \0*\0p\0a\0r\0e\0n\0t\0,\0 \0n\0;\0 \0 \0 \0\r\0\n\0p\0u\0b\0l\0i\0c\0:\0 \0\r\0\n\0 \0 \0 \0 \0D\0i\0s\0j\0S\0e\0t\0(\0i\0n\0t\0 \0n\0)\0 \0\r\0\n\0 \0 \0 \0 \0{\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0r\0a\0n\0k\0 \0=\0 \0n\0e\0w\0 \0i\0n\0t\0[\0n\0]\0;\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0p\0a\0r\0e\0n\0t\0 \0=\0 \0n\0e\0w\0 \0i\0n\0t\0[\0n\0]\0;\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0t\0h\0i\0s\0-\0>\0n\0 \0=\0 \0n\0;\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0m\0a\0k\0e\0S\0e\0t\0(\0)\0;\0 \0\r\0\n\0 \0 \0 \0 \0}\0 \0\r\0\n\0 \0 \0 \0 \0v\0o\0i\0d\0 \0m\0a\0k\0e\0S\0e\0t\0(\0)\0 \0\r\0\n\0 \0 \0 \0 \0{\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0f\0o\0r\0 \0(\0i\0n\0t\0 \0i\0 \0=\0 \00\0;\0 \0i\0 \0<\0 \0n\0;\0 \0i\0+\0+\0)\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0{\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0p\0a\0r\0e\0n\0t\0[\0i\0]\0 \0=\0 \0i\0;\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0}\0 \0\r\0\n\0 \0 \0 \0 \0}\0 \0\r\0\n\0 \0 \0 \0 \0i\0n\0t\0 \0f\0i\0n\0d\0(\0i\0n\0t\0 \0x\0)\0 \0\r\0\n\0 \0 \0 \0 \0{\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0i\0f\0 \0(\0p\0a\0r\0e\0n\0t\0[\0x\0]\0 \0!\0=\0 \0x\0)\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0{\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0p\0a\0r\0e\0n\0t\0[\0x\0]\0 \0=\0 \0f\0i\0n\0d\0(\0p\0a\0r\0e\0n\0t\0[\0x\0]\0)\0;\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0}\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0r\0e\0t\0u\0r\0n\0 \0p\0a\0r\0e\0n\0t\0[\0x\0]\0;\0 \0\r\0\n\0 \0 \0 \0 \0}\0 \0\r\0\n\0 \0 \0 \0 \0v\0o\0i\0d\0 \0U\0n\0i\0o\0n\0(\0i\0n\0t\0 \0x\0,\0 \0i\0n\0t\0 \0y\0)\0 \0\r\0\n\0 \0 \0 \0 \0{\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0i\0n\0t\0 \0x\0s\0e\0t\0 \0=\0 \0f\0i\0n\0d\0(\0x\0)\0;\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0i\0n\0t\0 \0y\0s\0e\0t\0 \0=\0 \0f\0i\0n\0d\0(\0y\0)\0;\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0i\0f\0 \0(\0x\0s\0e\0t\0 \0=\0=\0 \0y\0s\0e\0t\0)\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0r\0e\0t\0u\0r\0n\0;\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0i\0f\0 \0(\0r\0a\0n\0k\0[\0x\0s\0e\0t\0]\0 \0<\0 \0r\0a\0n\0k\0[\0y\0s\0e\0t\0]\0)\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0{\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0p\0a\0r\0e\0n\0t\0[\0x\0s\0e\0t\0]\0 \0=\0 \0y\0s\0e\0t\0;\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0}\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0e\0l\0s\0e\0 \0i\0f\0 \0(\0r\0a\0n\0k\0[\0x\0s\0e\0t\0]\0 \0>\0 \0r\0a\0n\0k\0[\0y\0s\0e\0t\0]\0)\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0{\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0p\0a\0r\0e\0n\0t\0[\0y\0s\0e\0t\0]\0 \0=\0 \0x\0s\0e\0t\0;\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0}\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0e\0l\0s\0e\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0{\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0p\0a\0r\0e\0n\0t\0[\0y\0s\0e\0t\0]\0 \0=\0 \0x\0s\0e\0t\0;\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0r\0a\0n\0k\0[\0x\0s\0e\0t\0]\0 \0=\0 \0r\0a\0n\0k\0[\0x\0s\0e\0t\0]\0 \0+\0 \01\0;\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0}\0 \0\r\0\n\0 \0 \0 \0 \0}\0 \0\r\0\n\0}\0;\0 \0 \0\r\0\n\0i\0n\0t\0 \0m\0a\0i\0n\0(\0)\0 \0\r\0\n\0{\0 \0\r\0\n\0 \0 \0 \0 \0D\0i\0s\0j\0S\0e\0t\0 \0o\0b\0j\0(\05\0)\0;\0 \0\r\0\n\0 \0 \0 \0 \0o\0b\0j\0.\0U\0n\0i\0o\0n\0(\00\0,\0 \02\0)\0;\0 \0\r\0\n\0 \0 \0 \0 \0o\0b\0j\0.\0U\0n\0i\0o\0n\0(\04\0,\0 \02\0)\0;\0 \0\r\0\n\0 \0 \0 \0 \0o\0b\0j\0.\0U\0n\0i\0o\0n\0(\03\0,\0 \01\0)\0;\0 \0\r\0\n\0 \0 \0 \0 \0i\0f\0 \0(\0o\0b\0j\0.\0f\0i\0n\0d\0(\04\0)\0 \0=\0=\0 \0o\0b\0j\0.\0f\0i\0n\0d\0(\00\0)\0)\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0c\0o\0u\0t\0 \0<\0<\0 \0\"\0Y\0e\0s\0\0n\0\"\0;\0 \0\r\0\n\0 \0 \0 \0 \0e\0l\0s\0e\0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0c\0o\0u\0t\0 \0<\0<\0 \0\"\0N\0o\0\0n\0\"\0;\0 \0\r\0\n\0 \0 \0 \0 \0i\0f\0 \0(\0o\0b\0j\0.\0f\0i\0n\0d\0(\01\0)\0 \0=\0=\0 \0o\0b\0j\0.\0f\0i\0n\0d\0(\00\0)\0)\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0c\0o\0u\0t\0 \0<\0<\0 \0\"\0Y\0e\0s\0\0n\0\"\0;\0 \0\r\0\n\0 \0 \0 \0 \0e\0l\0s\0e\0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0c\0o\0u\0t\0 \0<\0<\0 \0\"\0N\0o\0\0n\0\"\0;\0 \0\r\0\n\0 \0 \0\r\0\n\0 \0 \0 \0 \0r\0e\0t\0u\0r\0n\0 \00\0;\0 \0\r\0\n\0}\0 \0', 1000, '', '', 'Begin\r\n   Assume k is the element\r\n   makeset(k):\r\n      k.parent = k.\r\n   Find(x):\r\n   If k.parent == k\r\n      return k.\r\n   else\r\n   return Find(k.parent)\r\n   Union (a,b):\r\n      Take two set a and b as input.\r\n      aroot = Find(a)\r\n      broot = Find(b)\r\n      aroot.parent = broot\r\nEnd', '2020-05-25'),
(388, 12, 4601012018, '#include <iostream> \nusing namespace std; \nclass Edge \n{ \n    public: \n    int src, dest, weight; \n}; \nclass Graph \n{ \n    public: \n    int V, E; \n    Edge* edge; \n}; \nGraph* createGraph(int V, int E) \n{ \n    Graph* graph = new Graph; \n    graph->V = V; \n    graph->E = E; \n    graph->edge = new Edge[E]; \n    return graph; \n} \nclass subset \n{ \n    public: \n    int parent; \n    int rank; \n}; \nint find(subset subsets[], int i) \n{ \n    if (subsets[i].parent != i) \n        subsets[i].parent = find(subsets, subsets[i].parent); \n    return subsets[i].parent; \n} \nvoid Union(subset subsets[], int x, int y) \n{ \n    int xroot = find(subsets, x); \n    int yroot = find(subsets, y); \n    if (subsets[xroot].rank < subsets[yroot].rank) \n        subsets[xroot].parent = yroot; \n    else if (subsets[xroot].rank > subsets[yroot].rank) \n        subsets[yroot].parent = xroot; \n    else\n    { \n        subsets[yroot].parent = xroot; \n        subsets[xroot].rank++; \n    } \n} \nint myComp(const void* a, const void* b) \n{ \n    Edge* a1 = (Edge*)a; \n    Edge* b1 = (Edge*)b; \n    return a1->weight > b1->weight; \n} \nvoid KruskalMST(Graph* graph) \n{ \n    int V = graph->V; \n    Edge result[V]; \n    int e = 0; \n    int i = 0; \n    qsort(graph->edge, graph->E, sizeof(graph->edge[0]), myComp); \n    subset *subsets = new subset[( V * sizeof(subset) )]; \n    for (int v = 0; v < V; ++v) \n    { \n        subsets[v].parent = v; \n        subsets[v].rank = 0; \n    } \n    while (e < V - 1 && i < graph->E) \n    { \n        Edge next_edge = graph->edge[i++]; \n        int x = find(subsets, next_edge.src); \n        int y = find(subsets, next_edge.dest); \n        if (x != y) \n        { \n            result[e++] = next_edge; \n            Union(subsets, x, y); \n        } \n    } \n    cout<<\"Following are the edges in the constructed MST\n\"; \n    for (i = 0; i < e; ++i) \n        cout<<result[i].src<<\" -- \"<<result[i].dest<<\" ==> \"<<result[i].weight<<endl; \n    return; \n} \nint main() \n{ \n    int V = 4; \n    int E = 5; \n    Graph* graph = createGraph(V, E); \n    graph->edge[0].src = 0; \n    graph->edge[0].dest = 1; \n    graph->edge[0].weight = 10; \n    graph->edge[1].src = 0; \n    graph->edge[1].dest = 2; \n    graph->edge[1].weight = 6; \n    graph->edge[2].src = 0; \n    graph->edge[2].dest = 3; \n    graph->edge[2].weight = 5; \n    graph->edge[3].src = 1; \n    graph->edge[3].dest = 3; \n    graph->edge[3].weight = 15; \n    graph->edge[4].src = 2; \n    graph->edge[4].dest = 3; \n    graph->edge[4].weight = 4; \n    KruskalMST(graph); \n    return 0; \n} \n\n', 1000, '', '', '1. Sort all the edges in non-decreasing order of their weight.\r\n2. Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If cycle is not formed, include this edge. Else, discard it.\r\n3. Repeat step#2 until there are (V-1) edges in the spanning tree.', '2020-05-25'),
(389, 13, 4601012018, '#include <iostream>\r\n#include <vector>\r\n#include <queue>\r\n#include <functional>\r\n#include <utility>\r\nusing namespace std;\r\nconst int MAX = 1e4 + 5;\r\ntypedef pair<long long, int> PII;\r\nbool marked[MAX];\r\nvector <PII> adj[MAX];\r\nlong long prim(int x)\r\n{\r\n    priority_queue<PII, vector<PII>, greater<PII> > Q;\r\n    int y;\r\n    long long minimumCost = 0;\r\n    PII p;\r\n    Q.push(make_pair(0, x));\r\n    while(!Q.empty())\r\n    {\r\n        p = Q.top();\r\n        Q.pop();\r\n        x = p.second;\r\n        if(marked[x] == true)\r\n            continue;\r\n        minimumCost += p.first;\r\n        marked[x] = true;\r\n        for(int i = 0;i < adj[x].size();++i)\r\n        {\r\n            y = adj[x][i].second;\r\n            if(marked[y] == false)\r\n                Q.push(adj[x][i]);\r\n        }\r\n    }\r\n    return minimumCost;\r\n}\r\nint main()\r\n{\r\n    int nodes, edges, x, y;\r\n    long long weight, minimumCost;\r\n    cin >> nodes >> edges;\r\n    for(int i = 0;i < edges;++i)\r\n    {\r\n        cin >> x >> y >> weight;\r\n        adj[x].push_back(make_pair(weight, y));\r\n        adj[y].push_back(make_pair(weight, x));\r\n    }\r\n    minimumCost = prim(1);\r\n    cout << minimumCost << endl;\r\n    return 0;\r\n}', 1000, '', '', '1) Create a set mstSet that keeps track of vertices already included in MST.\r\n2) Assign a key value to all vertices in the input graph. Initialize all key values as INFINITE. Assign key value as 0 for the first vertex so that it is picked first.\r\n3) While mstSet doesn’t include all vertices\r\n….a) Pick a vertex u which is not there in mstSet and has minimum key value.\r\n….b) Include u to mstSet.\r\n….c) Update key value of all adjacent vertices of u. To update the key values, iterate through all adjacent vertices. For every adjacent vertex v, if weight of edge u-v is less than the previous key value of v, update the key value as weight of u-v', '2020-05-25'),
(390, 15, 4601012018, '#include<iostream>\r\nusing namespace std;\r\nint MatrixChainOrder(int p[], int i, int j)\r\n{\r\n    if(i == j)\r\n        return 0;\r\n    int k;\r\n    int min = INT_MAX;\r\n    int count;\r\n\r\n    for (k = i; k < j; k++)\r\n    {\r\n        count = MatrixChainOrder(p, i, k) +\r\n                MatrixChainOrder(p, k + 1, j) +\r\n                p[i - 1] * p[k] * p[j];\r\n\r\n        if (count < min)\r\n            min = count;\r\n    }\r\n    return min;\r\n}\r\nint main()\r\n{\r\n    int n=0;\r\n    cin>>n;\r\n    int arr[n];\r\n    for(int i=0;i<n;i++){\r\n        cin>>arr[i];\r\n    }\r\n         cout<< MatrixChainOrder(arr, 1, n - 1);\r\n}\r\n', 1000, '', '', 'MATRIX-CHAIN-ORDER (p)\r\n 1. n   length[p]-1\r\n 2. for i ← 1 to n\r\n 3. do m [i, i] ← 0\r\n 4. for l ← 2 to n    \r\n 5. do for i ← 1 to n-l + 1\r\n 6. do j ← i+ l -1\r\n 7. m[i,j] ←  ∞\r\n 8. for k  ← i to j-1\r\n 9. do q  ← m [i, k] + m [k + 1, j] + p[i-1]*p[k]*p[j]	\r\n 10. If q < m [i,j]\r\n 11. then m [i,j] ← q\r\n 12. s [i,j] ← k\r\n 13. return m and s.  ', '2020-05-25'),
(391, 8, 4601012018, '#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\nint nextpowerof2(int k)\n{\n    return pow(2, int(ceil(log2(k))));\n}\nvoid display(vector< vector<int> > &matrix, int m, int n)\n{\n    for (int i = 0; i < m; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            cout <<matrix[i][j]<<\" \";\n        }\n        printf(\"\n\");\n    }\n}\n\nvoid add(vector<vector<int> > &A, vector<vector<int> > &B, vector<vector<int> > &C, int size)\n{\n    int i, j;\n\n    for (i = 0; i < size; i++)\n    {\n        for (j = 0; j < size; j++)\n        {\n            C[i][j] = A[i][j] + B[i][j];\n        }\n    }\n}\n\nvoid sub(vector<vector<int> > &A, vector<vector<int> > &B, vector<vector<int> > &C, int size)\n{\n    int i, j;\n\n    for (i = 0; i < size; i++)\n    {\n        for (j = 0; j < size; j++)\n        {\n            C[i][j] = A[i][j] - B[i][j];\n        }\n    }\n}\n\nvoid STRASSEN_algorithmA(vector<vector<int> > &A, vector<vector<int> > &B, vector<vector<int> > &C, int size)\n{\n    if (size == 1)\n    {\n        C[0][0] = A[0][0] * B[0][0];\n        return;\n    }\n    else\n    {\n        int new_size = size / 2;\n        vector<int> z(new_size);\n        vector<vector<int> >\n            a11(new_size, z), a12(new_size, z), a21(new_size, z), a22(new_size, z),\n            b11(new_size, z), b12(new_size, z), b21(new_size, z), b22(new_size, z),\n            c11(new_size, z), c12(new_size, z), c21(new_size, z), c22(new_size, z),\n            p1(new_size, z), p2(new_size, z), p3(new_size, z), p4(new_size, z),\n            p5(new_size, z), p6(new_size, z), p7(new_size, z),\n            aResult(new_size, z), bResult(new_size, z);\n\nint i, j;\nfor (i = 0; i < new_size; i++)\n        {\n            for (j = 0; j < new_size; j++)\n            {\n                a11[i][j] = A[i][j];\n                a12[i][j] = A[i][j + new_size];\n                a21[i][j] = A[i + new_size][j];\n                a22[i][j] = A[i + new_size][j + new_size];\n\n                b11[i][j] = B[i][j];\n                b12[i][j] = B[i][j + new_size];\n                b21[i][j] = B[i + new_size][j];\n                b22[i][j] = B[i + new_size][j + new_size];\n            }\n}\n\n        add(a11, a22, aResult, new_size);     \n        add(b11, b22, bResult, new_size);    \n        STRASSEN_algorithmA(aResult, bResult, p1, new_size); \n        add(a21, a22, aResult, new_size); \n        STRASSEN_algorithmA(aResult, b11, p2, new_size);\n        sub(b12, b22, bResult, new_size);      \n        STRASSEN_algorithmA(a11, bResult, p3, new_size);\n        sub(b21, b11, bResult, new_size);       \n        STRASSEN_algorithmA(a22, bResult, p4, new_size); \n        add(a11, a12, aResult, new_size);      \n        STRASSEN_algorithmA(aResult, b22, p5, new_size);\n        sub(a21, a11, aResult, new_size);      \n        add(b11, b12, bResult, new_size); \n        STRASSEN_algorithmA(aResult, bResult, p6, new_size);\n        sub(a12, a22, aResult, new_size);      \n        add(b21, b22, bResult, new_size);  \n        STRASSEN_algorithmA(aResult, bResult, p7, new_size);\n        add(p3, p5, c12, new_size); \n        add(p2, p4, c21, new_size); \n        add(p1, p4, aResult, new_size);       \n        add(aResult, p7, bResult, new_size);  \n        sub(bResult, p5, c11, new_size); \n        add(p1, p3, aResult, new_size);       \n        add(aResult, p6, bResult, new_size);  \n        sub(bResult, p2, c22, new_size); \n        for (i = 0; i < new_size; i++)\n        {\n            for (j = 0; j < new_size; j++)\n            {\n                C[i][j] = c11[i][j];\n                C[i][j + new_size] = c12[i][j];\n                C[i + new_size][j] = c21[i][j];\n                C[i + new_size][j + new_size] = c22[i][j];\n            }\n        }\n    }\n}\nvoid STRASSEN_algorithm(vector<vector<int> > &A, vector<vector<int> > &B, int m, int n, int a, int b)\n{  \n    int k = max(n,n);\n    int s = nextpowerof2(k);\n    vector<int> z(s);\n    vector<vector<int> > Aa(s, z), Bb(s, z), Cc(s, z);\n    for (unsigned int i = 0; i < m; i++)\n    {\n        for (unsigned int j = 0; j < n; j++)\n        {\n            Aa[i][j] = A[i][j];\n        }\n    }\n    for (unsigned int i = 0; i < a; i++)\n    {\n        for (unsigned int j = 0; j < b; j++)\n        {\n            Bb[i][j] = B[i][j];\n        }\n    }\n    STRASSEN_algorithmA(Aa, Bb, Cc, s);\n    vector<int> temp1(b);\n    vector<vector<int> > C(m, temp1);\n    for (unsigned int i = 0; i < m; i++)\n    {\n        for (unsigned int j = 0; j < b; j++)\n        {\n            C[i][j] = Cc[i][j];\n        }\n    }\n    display(C, m, b);\n}\nint main()\n{\n    int n;\n    cin >> n;\n    vector<vector<int> > A;\n    for (int i = 0; i < n; i++)\n    {\n        vector<int> temp;\n        for (int j = 0; j < n; j++)\n        {\n            int i;\n            cin >> i;\n            temp.push_back(i);\n        }\n        A.push_back(temp);\n    }\n    vector<vector<int> > B;\n    for (int i = 0; i < n; i++)\n    {\n        vector<int> temp;\n        for (int j = 0; j < n; j++)\n        {\n            int i;\n            cin >> i;\n            temp.push_back(i);\n        }\n        B.push_back(temp);\n    }\n        STRASSEN_algorithm(A, B, n, n, n, n);\n    return 0;\n\n}', 0, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '', 'We can use strassen’s formula to multiply two matrix by dividing the matrices into 2*2 matrices and then applying strassen’s formula and combining the result.\nThis algorithm will multiply 2 matrix A and B by using strassen’s formula as:\nmatrix A = |a b|, matrix B = |e f|\n           |c d|             |g h|\np1=a * (f - h)\np2=(a + b) * h\np3=(c + d) * e\np4=d * (g - e)\np5(a + d) * (e + h)\np6(b - d) * (g + h)\np7=(a - c) * (e + f)\np5+p4-p2+p6 = (a+d)*(e+h) + d*(g-e) - (a+b)*h + (b-d)*(g+h)\n            = (ae+de+ah+dh) + (dg-de) - (ah+bh) + (bg-dg+bh-dh)\n            = ae+bg\n p1+p2 = a*(f-h) + (a+b)*h\n       = (af-ah) + (ah+bh)\n       = af+bh\n p3+p4 = (c+d)*e + d*(g-e)\n       = (ce+de) + (dg-de)\n       = ce+dg \n p1+p5-p3-p7 = a*(f-h) + (a+d)*(e+h) - (c+d)*e - (a-c)*(e+f)\n             = (af-ah) + (ae+de+ah+dh) -(ce+de) - (ae-ce+af-cf)\n             = cf+dh\nmatrix C = |p5+p4-p2+p6    p1+p2   |\n           |   p3+p4    p1+p5-p3-p7| \nmatrix C is the required result', '2020-05-25'),
(392, 5, 4601012018, '#include<iostream>\n#include<stdio.h>\nusing namespace std; \ntypedef long long lld; \ninline lld** MatrixMultiply(lld** a, lld** b, int n, int l, int m) \n{ \n    lld** c = new lld*[n]; \n    for (int i = 0; i < n; i++) \n        c[i] = new lld[m];   \n    for (int i = 0; i < n; i++) \n    { \n        for (int j = 0; j < m; j++) \n        { \n            c[i][j] = 0; \n            for (int k = 0; k < l; k++) \n            { \n                c[i][j] += a[i][k] * b[k][j]; \n            } \n        } \n    } \n    return c; \n}   \ninline lld** Strassen(lld** a, lld** b, int n, int l, int m) \n{ \n    if (n == 1 || l == 1 || m == 1)  \n        return MatrixMultiply(a, b, n, l, m);  \n    lld** c = new lld*[n]; \n    for (int i = 0; i < n; i++) \n        c[i] = new lld[m];  \n    int adjN = (n >> 1) + (n & 1); \n    int adjL = (l >> 1) + (l & 1); \n    int adjM = (m >> 1) + (m & 1);  \n    lld**** As = new lld***[2]; \n    for (int x = 0; x < 2; x++) \n    { \n        As[x] = new lld**[2]; \n        for (int y = 0; y < 2; y++) \n        { \n            As[x][y] = new lld*[adjN]; \n            for (int i = 0; i < adjN; i++) \n            { \n                As[x][y][i] = new lld[adjL]; \n                for (int j = 0; j < adjL; j++) \n                { \n                    int I = i + (x & 1) * adjN; \n                    int J = j + (y & 1) * adjL; \n                    As[x][y][i][j] = (I < n && J < l) ? a[I][J] : 0; \n                } \n            } \n        } \n    }  \n    lld**** Bs = new lld***[2]; \n    for (int x = 0; x < 2; x++)\n    { \n        Bs[x] = new lld**[2]; \n        for (int y = 0; y < 2; y++) \n        { \n            Bs[x][y] = new lld*[adjN]; \n            for (int i = 0; i < adjL; i++) \n            { \n                Bs[x][y][i] = new lld[adjM]; \n                for (int j = 0; j < adjM; j++) \n                { \n                    int I = i + (x & 1) * adjL; \n                    int J = j + (y & 1) * adjM; \n                    Bs[x][y][i][j] = (I < l && J < m) ? b[I][J] : 0; \n                } \n            } \n        } \n    }   \n    lld*** s = new lld**[10]; \n    for (int i = 0; i < 10; i++) \n    { \n        switch (i) \n        { \n        case 0: \n            s[i] = new lld*[adjL]; \n            for (int j = 0; j < adjL; j++) \n            { \n                s[i][j] = new lld[adjM]; \n                for (int k = 0; k < adjM; k++) \n                { \n                    s[i][j][k] = Bs[0][1][j][k] - Bs[1][1][j][k]; \n                } \n            } \n            break; \n        case 1: \n            s[i] = new lld*[adjN]; \n            for (int j = 0; j < adjN; j++) \n            { \n                s[i][j] = new lld[adjL]; \n                for (int k = 0; k < adjL; k++) \n                { \n                    s[i][j][k] = As[0][0][j][k] + As[0][1][j][k]; \n                } \n            } \n            break; \n        case 2: \n            s[i] = new lld*[adjN]; \n            for (int j = 0; j < adjN; j++) \n            { \n                s[i][j] = new lld[adjL]; \n                for (int k = 0; k < adjL; k++) \n                { \n                    s[i][j][k] = As[1][0][j][k] + As[1][1][j][k]; \n                } \n            } \n            break; \n        case 3: \n            s[i] = new lld*[adjL]; \n            for (int j = 0; j < adjL; j++) \n            { \n                s[i][j] = new lld[adjM]; \n                for (int k = 0; k < adjM; k++) \n                { \n                    s[i][j][k] = Bs[1][0][j][k] - Bs[0][0][j][k]; \n                } \n            } \n            break; \n        case 4: \n            s[i] = new lld*[adjN]; \n            for (int j = 0; j < adjN; j++) \n            { \n                s[i][j] = new lld[adjL]; \n                for (int k = 0; k < adjL; k++) \n                { \n                    s[i][j][k] = As[0][0][j][k] + As[1][1][j][k]; \n                } \n            } \n            break; \n        case 5: \n            s[i] = new lld*[adjL]; \n            for (int j = 0; j < adjL; j++) \n            { \n                s[i][j] = new lld[adjM]; \n                for (int k = 0; k < adjM; k++) \n                { \n                    s[i][j][k] = Bs[0][0][j][k] + Bs[1][1][j][k]; \n                } \n            } \n            break; \n        case 6: \n            s[i] = new lld*[adjN]; \n            for (int j = 0; j < adjN; j++) \n            { \n                s[i][j] = new lld[adjL]; \n                for (int k = 0; k < adjL; k++) \n                { \n                    s[i][j][k] = As[0][1][j][k] - As[1][1][j][k]; \n                } \n            } \n            break; \n        case 7: \n            s[i] = new lld*[adjL]; \n            for (int j = 0; j < adjL; j++) \n            { \n                s[i][j] = new lld[adjM]; \n                for (int k = 0; k < adjM; k++) \n                { \n                    s[i][j][k] = Bs[1][0][j][k] + Bs[1][1][j][k]; \n                } \n            } \n            break; \n        case 8: \n            s[i] = new lld*[adjN]; \n            for (int j = 0; j < adjN; j++) \n            { \n                s[i][j] = new lld[adjL]; \n                for (int k = 0; k < adjL; k++) \n                { \n                    s[i][j][k] = As[0][0][j][k] - As[1][0][j][k]; \n                } \n            } \n            break; \n        case 9: \n            s[i] = new lld*[adjL]; \n            for (int j = 0; j < adjL; j++) \n            { \n                s[i][j] = new lld[adjM]; \n                for (int k = 0; k < adjM; k++) \n                { \n                    s[i][j][k] = Bs[0][0][j][k] + Bs[0][1][j][k]; \n                } \n            } \n            break; \n        } \n    }  \n    lld*** p = new lld**[7]; \n    p[0] = Strassen(As[0][0], s[0], adjN, adjL, adjM); \n    p[1] = Strassen(s[1], Bs[1][1], adjN, adjL, adjM); \n    p[2] = Strassen(s[2], Bs[0][0], adjN, adjL, adjM); \n    p[3] = Strassen(As[1][1], s[3], adjN, adjL, adjM); \n    p[4] = Strassen(s[4], s[5], adjN, adjL, adjM); \n    p[5] = Strassen(s[6], s[7], adjN, adjL, adjM); \n    p[6] = Strassen(s[8], s[9], adjN, adjL, adjM);  \n    for (int i = 0; i < adjN; i++) \n    { \n        for (int j = 0; j < adjM; j++) \n        { \n            c[i][j] = p[4][i][j] + p[3][i][j] - p[1][i][j] + p[5][i][j]; \n            if (j + adjM < m) \n                c[i][j + adjM] = p[0][i][j] + p[1][i][j]; \n            if (i + adjN < n) \n                c[i + adjN][j] = p[2][i][j] + p[3][i][j]; \n            if (i + adjN < n && j + adjM < m) \n                c[i + adjN][j + adjM] = p[4][i][j] + p[0][i][j] - p[2][i][j] - p[6][i][j]; \n        } \n    }   \n    for (int x = 0; x < 2; x++) \n    { \n        for (int y = 0; y < 2; y++) \n        { \n            for (int i = 0; i < adjN; i++) \n            { \n                delete[] As[x][y][i]; \n            } \n            delete[] As[x][y]; \n        } \n        delete[] As[x]; \n    } \n    delete[] As;   \n    for (int x = 0; x < 2; x++) \n    { \n        for (int y = 0; y < 2; y++) \n        { \n            for (int i = 0; i < adjL; i++) \n            { \n                delete[] Bs[x][y][i]; \n            } \n            delete[] Bs[x][y]; \n        } \n        delete[] Bs[x]; \n    } \n    delete[] Bs;  \n    for (int i = 0; i < 10; i++) \n    { \n        switch (i) \n        { \n        case 0: \n        case 3: \n        case 5: \n        case 7: \n        case 9: \n            for (int j = 0; j < adjL; j++) \n            { \n                delete[] s[i][j]; \n            } \n            break; \n        case 1: \n        case 2: \n        case 4: \n        case 6: \n        case 8: \n            for (int j = 0; j < adjN; j++) \n            { \n                delete[] s[i][j]; \n            } \n            break; \n        } \n        delete[] s[i]; \n    } \n    delete[] s;   \n    for (int i = 0; i < 7; i++) { \n        for (int j = 0; j < (n >> 1); j++) \n        { \n            delete[] p[i][j]; \n        } \n        delete[] p[i]; \n    } \n    delete[] p;   \n    return c; \n}   \nint main() \n{ \n    lld** matA; \n    matA = new lld*[3]; \n    for (int i = 0; i < 3; i++) \n        matA[i] = new lld[3]; \n    matA[0][0] = 1; \n    matA[0][1] = 0; \n    matA[0][2] = 0; \n    matA[1][0] = 0; \n    matA[1][1] = 1; \n    matA[1][2] = 0;\n    matA[2][0] = 0; \n    matA[2][1] = 0; \n    matA[2][2] = 1;  \n    lld** matB; \n    matB = new lld*[3]; \n    for (int i = 0; i < 3; i++) \n        matB[i] = new lld[3]; \n    matB[0][0] = 1; \n    matB[0][1] = 0; \n    matB[0][2] = 0; \n    matB[1][0] = 0; \n    matB[1][1] = 1; \n    matB[1][2] = 0;\n    matB[2][0] = 0; \n    matB[2][1] = 0; \n    matB[2][2] = 1;  \n    lld** matC = Strassen(matA, matB, 3, 3, 3);\n    printf(\"Matrix A is :\n\"); \n    for(int i=0;i<3;i++)\n    {\n      for(int j=0;j<3;j++)\n      {\n        printf(\"%lld \", matA[i][j]);\n      }\n      printf(\"\n\");\n    }\n    printf(\"Matrix B is :\n\"); \n    for(int i=0;i<3;i++)\n    {\n      for(int j=0;j<3;j++)\n      {\n        printf(\"%lld \", matB[i][j]);\n      }\n      printf(\"\n\");\n    }\n    printf(\"Their product is :\n\");\n    for (int i = 0; i < 3; i++) \n    { \n        for (int j = 0; j < 3; j++) \n        { \n            printf(\"%lld \", matC[i][j]); \n        }\n        printf(\"\n\");\n    }  \n    return 0; \n} ', 1000, '', '', 'This algorithm will multiply 2 matrix A and B by using strassen’s formula as:\nmatrix A = |a b|, matrix B = |e f|\n           |c d|             |g h|\np1=a * (f - h)\np2=(a + b) * h\np3=(c + d) * e\np4=d * (g - e)\np5(a + d) * (e + h)\np6(b - d) * (g + h)\np7=(a - c) * (e + f)\np5+p4-p2+p6 = (a+d)*(e+h) + d*(g-e) - (a+b)*h + (b-d)*(g+h)\n            = (ae+de+ah+dh) + (dg-de) - (ah+bh) + (bg-dg+bh-dh)\n            = ae+bg\n p1+p2 = a*(f-h) + (a+b)*h\n       = (af-ah) + (ah+bh)\n       = af+bh\n p3+p4 = (c+d)*e + d*(g-e)\n       = (ce+de) + (dg-de)\n       = ce+dg \n p1+p5-p3-p7 = a*(f-h) + (a+d)*(e+h) - (c+d)*e - (a-c)*(e+f)\n             = (af-ah) + (ae+de+ah+dh) -(ce+de) - (ae-ce+af-cf)\n             = cf+dh\nmatrix C = |p5+p4-p2+p6    p1+p2   |\n           |   p3+p4    p1+p5-p3-p7| \nmatrix C is the required result', '2020-05-25'),
(393, 16, 4601012018, '#include<iostream>\r\n#include <string.h>\r\n#include <cstring>\r\nusing namespace std;\r\n#define d 10\r\nvoid rabinKarp(string pattern, string text, int q)\r\n{\r\n	int m = pattern.length();\r\n	int n = text.length();\r\n	int i, j;\r\n	int p = 0;\r\n	int t = 0;\r\n	int h = 1;\r\n	for (i = 0; i < m - 1; i++)\r\n		h = (h * d) % q;\r\n	for (i = 0; i < m; i++)\r\n	{\r\n		p = (d * p + pattern[i]) % q;\r\n		t = (d * t + text[i]) % q;\r\n	}\r\n	for (i = 0; i <= n - m; i++)\r\n	{\r\n		if (p == t)\r\n		{\r\n			for (j = 0; j < m; j++)\r\n			{\r\n				if (text[i + j] != pattern[j])\r\n					break;\r\n			}\r\n\r\n			if (j == m)\r\n				printf(\"Pattern found at index %d \n\", i );\r\n		}\r\n		if (i < n - m)\r\n		{\r\n			t = (d * (t - text[i] * h) + text[i + m]) % q;\r\n\r\n			if (t < 0)\r\n				t = (t + q);\r\n		}\r\n	}\r\n}\r\nint main()\r\n{\r\n    string text;\r\n    string pattern;\r\n    getline(cin, text);\r\n    getline(cin, pattern);\r\n    int q = 13;\r\n    rabinKarp(pattern, text, q);\r\n    return 0;\r\n}', 1000, '', '', 'n = t.length\r\nm = p.length\r\nh = dm-1 mod q\r\np = 0\r\nt0 = 0\r\nfor i = 1 to m\r\n    p = (dp + p[i]) mod q\r\n    t0 = (dt0 + t[i]) mod q\r\nfor s = 0 to n - m\r\n    if p = ts\r\n        if p[1.....m] = t[s + 1..... s + m]\r\n            print \"pattern found at position\" s\r\n    If s < n-m\r\n        ts + 1 = (d (ts - t[s + 1]h) + t[s + m + 1]) mod q', '2020-05-25'),
(394, 9, 4701012018, '??#\0i\0n\0c\0l\0u\0d\0e\0 \0<\0i\0o\0s\0t\0r\0e\0a\0m\0>\0 \0\r\0\n\0u\0s\0i\0n\0g\0 \0n\0a\0m\0e\0s\0p\0a\0c\0e\0 \0s\0t\0d\0;\0 \0\r\0\n\0c\0l\0a\0s\0s\0 \0D\0i\0s\0j\0S\0e\0t\0 \0\r\0\n\0{\0 \0\r\0\n\0 \0 \0 \0 \0i\0n\0t\0 \0*\0r\0a\0n\0k\0,\0 \0*\0p\0a\0r\0e\0n\0t\0,\0 \0n\0;\0 \0 \0 \0\r\0\n\0p\0u\0b\0l\0i\0c\0:\0 \0\r\0\n\0 \0 \0 \0 \0D\0i\0s\0j\0S\0e\0t\0(\0i\0n\0t\0 \0n\0)\0 \0\r\0\n\0 \0 \0 \0 \0{\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0r\0a\0n\0k\0 \0=\0 \0n\0e\0w\0 \0i\0n\0t\0[\0n\0]\0;\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0p\0a\0r\0e\0n\0t\0 \0=\0 \0n\0e\0w\0 \0i\0n\0t\0[\0n\0]\0;\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0t\0h\0i\0s\0-\0>\0n\0 \0=\0 \0n\0;\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0m\0a\0k\0e\0S\0e\0t\0(\0)\0;\0 \0\r\0\n\0 \0 \0 \0 \0}\0 \0\r\0\n\0 \0 \0 \0 \0v\0o\0i\0d\0 \0m\0a\0k\0e\0S\0e\0t\0(\0)\0 \0\r\0\n\0 \0 \0 \0 \0{\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0f\0o\0r\0 \0(\0i\0n\0t\0 \0i\0 \0=\0 \00\0;\0 \0i\0 \0<\0 \0n\0;\0 \0i\0+\0+\0)\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0{\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0p\0a\0r\0e\0n\0t\0[\0i\0]\0 \0=\0 \0i\0;\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0}\0 \0\r\0\n\0 \0 \0 \0 \0}\0 \0\r\0\n\0 \0 \0 \0 \0i\0n\0t\0 \0f\0i\0n\0d\0(\0i\0n\0t\0 \0x\0)\0 \0\r\0\n\0 \0 \0 \0 \0{\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0i\0f\0 \0(\0p\0a\0r\0e\0n\0t\0[\0x\0]\0 \0!\0=\0 \0x\0)\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0{\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0p\0a\0r\0e\0n\0t\0[\0x\0]\0 \0=\0 \0f\0i\0n\0d\0(\0p\0a\0r\0e\0n\0t\0[\0x\0]\0)\0;\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0}\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0r\0e\0t\0u\0r\0n\0 \0p\0a\0r\0e\0n\0t\0[\0x\0]\0;\0 \0\r\0\n\0 \0 \0 \0 \0}\0 \0\r\0\n\0 \0 \0 \0 \0v\0o\0i\0d\0 \0U\0n\0i\0o\0n\0(\0i\0n\0t\0 \0x\0,\0 \0i\0n\0t\0 \0y\0)\0 \0\r\0\n\0 \0 \0 \0 \0{\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0i\0n\0t\0 \0x\0s\0e\0t\0 \0=\0 \0f\0i\0n\0d\0(\0x\0)\0;\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0i\0n\0t\0 \0y\0s\0e\0t\0 \0=\0 \0f\0i\0n\0d\0(\0y\0)\0;\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0i\0f\0 \0(\0x\0s\0e\0t\0 \0=\0=\0 \0y\0s\0e\0t\0)\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0r\0e\0t\0u\0r\0n\0;\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0i\0f\0 \0(\0r\0a\0n\0k\0[\0x\0s\0e\0t\0]\0 \0<\0 \0r\0a\0n\0k\0[\0y\0s\0e\0t\0]\0)\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0{\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0p\0a\0r\0e\0n\0t\0[\0x\0s\0e\0t\0]\0 \0=\0 \0y\0s\0e\0t\0;\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0}\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0e\0l\0s\0e\0 \0i\0f\0 \0(\0r\0a\0n\0k\0[\0x\0s\0e\0t\0]\0 \0>\0 \0r\0a\0n\0k\0[\0y\0s\0e\0t\0]\0)\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0{\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0p\0a\0r\0e\0n\0t\0[\0y\0s\0e\0t\0]\0 \0=\0 \0x\0s\0e\0t\0;\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0}\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0e\0l\0s\0e\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0{\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0p\0a\0r\0e\0n\0t\0[\0y\0s\0e\0t\0]\0 \0=\0 \0x\0s\0e\0t\0;\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0r\0a\0n\0k\0[\0x\0s\0e\0t\0]\0 \0=\0 \0r\0a\0n\0k\0[\0x\0s\0e\0t\0]\0 \0+\0 \01\0;\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0}\0 \0\r\0\n\0 \0 \0 \0 \0}\0 \0\r\0\n\0}\0;\0 \0 \0\r\0\n\0i\0n\0t\0 \0m\0a\0i\0n\0(\0)\0 \0\r\0\n\0{\0 \0\r\0\n\0 \0 \0 \0 \0D\0i\0s\0j\0S\0e\0t\0 \0o\0b\0j\0(\05\0)\0;\0 \0\r\0\n\0 \0 \0 \0 \0o\0b\0j\0.\0U\0n\0i\0o\0n\0(\00\0,\0 \02\0)\0;\0 \0\r\0\n\0 \0 \0 \0 \0o\0b\0j\0.\0U\0n\0i\0o\0n\0(\04\0,\0 \02\0)\0;\0 \0\r\0\n\0 \0 \0 \0 \0o\0b\0j\0.\0U\0n\0i\0o\0n\0(\03\0,\0 \01\0)\0;\0 \0\r\0\n\0 \0 \0 \0 \0i\0f\0 \0(\0o\0b\0j\0.\0f\0i\0n\0d\0(\04\0)\0 \0=\0=\0 \0o\0b\0j\0.\0f\0i\0n\0d\0(\00\0)\0)\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0c\0o\0u\0t\0 \0<\0<\0 \0\"\0Y\0e\0s\0\0n\0\"\0;\0 \0\r\0\n\0 \0 \0 \0 \0e\0l\0s\0e\0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0c\0o\0u\0t\0 \0<\0<\0 \0\"\0N\0o\0\0n\0\"\0;\0 \0\r\0\n\0 \0 \0 \0 \0i\0f\0 \0(\0o\0b\0j\0.\0f\0i\0n\0d\0(\01\0)\0 \0=\0=\0 \0o\0b\0j\0.\0f\0i\0n\0d\0(\00\0)\0)\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0c\0o\0u\0t\0 \0<\0<\0 \0\"\0Y\0e\0s\0\0n\0\"\0;\0 \0\r\0\n\0 \0 \0 \0 \0e\0l\0s\0e\0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0c\0o\0u\0t\0 \0<\0<\0 \0\"\0N\0o\0\0n\0\"\0;\0 \0\r\0\n\0 \0 \0\r\0\n\0 \0 \0 \0 \0r\0e\0t\0u\0r\0n\0 \00\0;\0 \0\r\0\n\0}\0 \0', 1000, '', '', 'Begin\r\n   Assume k is the element\r\n   makeset(k):\r\n      k.parent = k.\r\n   Find(x):\r\n   If k.parent == k\r\n      return k.\r\n   else\r\n   return Find(k.parent)\r\n   Union (a,b):\r\n      Take two set a and b as input.\r\n      aroot = Find(a)\r\n      broot = Find(b)\r\n      aroot.parent = broot\r\nEnd', '2020-05-25'),
(395, 15, 4701012018, '#include<iostream>\r\nusing namespace std;\r\nint MatrixChainOrder(int p[], int i, int j)\r\n{\r\n    if(i == j)\r\n        return 0;\r\n    int k;\r\n    int min = INT_MAX;\r\n    int count;\r\n\r\n    for (k = i; k < j; k++)\r\n    {\r\n        count = MatrixChainOrder(p, i, k) +\r\n                MatrixChainOrder(p, k + 1, j) +\r\n                p[i - 1] * p[k] * p[j];\r\n\r\n        if (count < min)\r\n            min = count;\r\n    }\r\n    return min;\r\n}\r\nint main()\r\n{\r\n    int n=0;\r\n    cin>>n;\r\n    int arr[n];\r\n    for(int i=0;i<n;i++){\r\n        cin>>arr[i];\r\n    }\r\n         cout<< MatrixChainOrder(arr, 1, n - 1);\r\n}\r\n', 1000, '', '', 'MATRIX-CHAIN-ORDER (p)\r\n 1. n   length[p]-1\r\n 2. for i ← 1 to n\r\n 3. do m [i, i] ← 0\r\n 4. for l ← 2 to n    \r\n 5. do for i ← 1 to n-l + 1\r\n 6. do j ← i+ l -1\r\n 7. m[i,j] ←  ∞\r\n 8. for k  ← i to j-1\r\n 9. do q  ← m [i, k] + m [k + 1, j] + p[i-1]*p[k]*p[j]	\r\n 10. If q < m [i,j]\r\n 11. then m [i,j] ← q\r\n 12. s [i,j] ← k\r\n 13. return m and s.  ', '2020-05-25'),
(396, 8, 4701012018, '#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\nint nextpowerof2(int k)\n{\n    return pow(2, int(ceil(log2(k))));\n}\nvoid display(vector< vector<int> > &matrix, int m, int n)\n{\n    for (int i = 0; i < m; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            cout <<matrix[i][j]<<\" \";\n        }\n        printf(\"\n\");\n    }\n}\n\nvoid add(vector<vector<int> > &A, vector<vector<int> > &B, vector<vector<int> > &C, int size)\n{\n    int i, j;\n\n    for (i = 0; i < size; i++)\n    {\n        for (j = 0; j < size; j++)\n        {\n            C[i][j] = A[i][j] + B[i][j];\n        }\n    }\n}\n\nvoid sub(vector<vector<int> > &A, vector<vector<int> > &B, vector<vector<int> > &C, int size)\n{\n    int i, j;\n\n    for (i = 0; i < size; i++)\n    {\n        for (j = 0; j < size; j++)\n        {\n            C[i][j] = A[i][j] - B[i][j];\n        }\n    }\n}\n\nvoid STRASSEN_algorithmA(vector<vector<int> > &A, vector<vector<int> > &B, vector<vector<int> > &C, int size)\n{\n    if (size == 1)\n    {\n        C[0][0] = A[0][0] * B[0][0];\n        return;\n    }\n    else\n    {\n        int new_size = size / 2;\n        vector<int> z(new_size);\n        vector<vector<int> >\n            a11(new_size, z), a12(new_size, z), a21(new_size, z), a22(new_size, z),\n            b11(new_size, z), b12(new_size, z), b21(new_size, z), b22(new_size, z),\n            c11(new_size, z), c12(new_size, z), c21(new_size, z), c22(new_size, z),\n            p1(new_size, z), p2(new_size, z), p3(new_size, z), p4(new_size, z),\n            p5(new_size, z), p6(new_size, z), p7(new_size, z),\n            aResult(new_size, z), bResult(new_size, z);\n\nint i, j;\nfor (i = 0; i < new_size; i++)\n        {\n            for (j = 0; j < new_size; j++)\n            {\n                a11[i][j] = A[i][j];\n                a12[i][j] = A[i][j + new_size];\n                a21[i][j] = A[i + new_size][j];\n                a22[i][j] = A[i + new_size][j + new_size];\n\n                b11[i][j] = B[i][j];\n                b12[i][j] = B[i][j + new_size];\n                b21[i][j] = B[i + new_size][j];\n                b22[i][j] = B[i + new_size][j + new_size];\n            }\n}\n\n        add(a11, a22, aResult, new_size);     \n        add(b11, b22, bResult, new_size);    \n        STRASSEN_algorithmA(aResult, bResult, p1, new_size); \n        add(a21, a22, aResult, new_size); \n        STRASSEN_algorithmA(aResult, b11, p2, new_size);\n        sub(b12, b22, bResult, new_size);      \n        STRASSEN_algorithmA(a11, bResult, p3, new_size);\n        sub(b21, b11, bResult, new_size);       \n        STRASSEN_algorithmA(a22, bResult, p4, new_size); \n        add(a11, a12, aResult, new_size);      \n        STRASSEN_algorithmA(aResult, b22, p5, new_size);\n        sub(a21, a11, aResult, new_size);      \n        add(b11, b12, bResult, new_size); \n        STRASSEN_algorithmA(aResult, bResult, p6, new_size);\n        sub(a12, a22, aResult, new_size);      \n        add(b21, b22, bResult, new_size);  \n        STRASSEN_algorithmA(aResult, bResult, p7, new_size);\n        add(p3, p5, c12, new_size); \n        add(p2, p4, c21, new_size); \n        add(p1, p4, aResult, new_size);       \n        add(aResult, p7, bResult, new_size);  \n        sub(bResult, p5, c11, new_size); \n        add(p1, p3, aResult, new_size);       \n        add(aResult, p6, bResult, new_size);  \n        sub(bResult, p2, c22, new_size); \n        for (i = 0; i < new_size; i++)\n        {\n            for (j = 0; j < new_size; j++)\n            {\n                C[i][j] = c11[i][j];\n                C[i][j + new_size] = c12[i][j];\n                C[i + new_size][j] = c21[i][j];\n                C[i + new_size][j + new_size] = c22[i][j];\n            }\n        }\n    }\n}\nvoid STRASSEN_algorithm(vector<vector<int> > &A, vector<vector<int> > &B, int m, int n, int a, int b)\n{  \n    int k = max(n,n);\n    int s = nextpowerof2(k);\n    vector<int> z(s);\n    vector<vector<int> > Aa(s, z), Bb(s, z), Cc(s, z);\n    for (unsigned int i = 0; i < m; i++)\n    {\n        for (unsigned int j = 0; j < n; j++)\n        {\n            Aa[i][j] = A[i][j];\n        }\n    }\n    for (unsigned int i = 0; i < a; i++)\n    {\n        for (unsigned int j = 0; j < b; j++)\n        {\n            Bb[i][j] = B[i][j];\n        }\n    }\n    STRASSEN_algorithmA(Aa, Bb, Cc, s);\n    vector<int> temp1(b);\n    vector<vector<int> > C(m, temp1);\n    for (unsigned int i = 0; i < m; i++)\n    {\n        for (unsigned int j = 0; j < b; j++)\n        {\n            C[i][j] = Cc[i][j];\n        }\n    }\n    display(C, m, b);\n}\nint main()\n{\n    int n;\n    cin >> n;\n    vector<vector<int> > A;\n    for (int i = 0; i < n; i++)\n    {\n        vector<int> temp;\n        for (int j = 0; j < n; j++)\n        {\n            int i;\n            cin >> i;\n            temp.push_back(i);\n        }\n        A.push_back(temp);\n    }\n    vector<vector<int> > B;\n    for (int i = 0; i < n; i++)\n    {\n        vector<int> temp;\n        for (int j = 0; j < n; j++)\n        {\n            int i;\n            cin >> i;\n            temp.push_back(i);\n        }\n        B.push_back(temp);\n    }\n        STRASSEN_algorithm(A, B, n, n, n, n);\n    return 0;\n\n}', 0, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '', 'We can use strassen’s formula to multiply two matrix by dividing the matrices into 2*2 matrices and then applying strassen’s formula and combining the result by using divide and conquer strategy\nThis algorithm will multiply 2 matrix A and B by using strassen’s formula as:\nmatrix A = |a b|, matrix B = |e f|\n           |c d|             |g h|\np1=a * (f - h)\np2=(a + b) * h\np3=(c + d) * e\np4=d * (g - e)\np5(a + d) * (e + h)\np6(b - d) * (g + h)\np7=(a - c) * (e + f)\np5+p4-p2+p6 = (a+d)*(e+h) + d*(g-e) - (a+b)*h + (b-d)*(g+h)\n            = (ae+de+ah+dh) + (dg-de) - (ah+bh) + (bg-dg+bh-dh)\n            = ae+bg\n p1+p2 = a*(f-h) + (a+b)*h\n       = (af-ah) + (ah+bh)\n       = af+bh\n p3+p4 = (c+d)*e + d*(g-e)\n       = (ce+de) + (dg-de)\n       = ce+dg \n p1+p5-p3-p7 = a*(f-h) + (a+d)*(e+h) - (c+d)*e - (a-c)*(e+f)\n             = (af-ah) + (ae+de+ah+dh) -(ce+de) - (ae-ce+af-cf)\n             = cf+dh\nmatrix C = |p5+p4-p2+p6    p1+p2   |\n           |   p3+p4    p1+p5-p3-p7| \nmatrix C is the required result', '2020-05-25');
INSERT INTO `qtos_map` (`ID`, `Q_ID`, `ROLL`, `SUBMISSION`, `SCORE`, `INPUT`, `OP`, `ALGO`, `DATE`) VALUES
(397, 5, 4701012018, '#include<iostream>\n#include<stdio.h>\nusing namespace std; \ntypedef long long lld; \ninline lld** MatrixMultiply(lld** a, lld** b, int n, int l, int m) \n{ \n    lld** c = new lld*[n]; \n    for (int i = 0; i < n; i++) \n        c[i] = new lld[m];   \n    for (int i = 0; i < n; i++) \n    { \n        for (int j = 0; j < m; j++) \n        { \n            c[i][j] = 0; \n            for (int k = 0; k < l; k++) \n            { \n                c[i][j] += a[i][k] * b[k][j]; \n            } \n        } \n    } \n    return c; \n}   \ninline lld** Strassen(lld** a, lld** b, int n, int l, int m) \n{ \n    if (n == 1 || l == 1 || m == 1)  \n        return MatrixMultiply(a, b, n, l, m);  \n    lld** c = new lld*[n]; \n    for (int i = 0; i < n; i++) \n        c[i] = new lld[m];  \n    int adjN = (n >> 1) + (n & 1); \n    int adjL = (l >> 1) + (l & 1); \n    int adjM = (m >> 1) + (m & 1);  \n    lld**** As = new lld***[2]; \n    for (int x = 0; x < 2; x++) \n    { \n        As[x] = new lld**[2]; \n        for (int y = 0; y < 2; y++) \n        { \n            As[x][y] = new lld*[adjN]; \n            for (int i = 0; i < adjN; i++) \n            { \n                As[x][y][i] = new lld[adjL]; \n                for (int j = 0; j < adjL; j++) \n                { \n                    int I = i + (x & 1) * adjN; \n                    int J = j + (y & 1) * adjL; \n                    As[x][y][i][j] = (I < n && J < l) ? a[I][J] : 0; \n                } \n            } \n        } \n    }  \n    lld**** Bs = new lld***[2]; \n    for (int x = 0; x < 2; x++)\n    { \n        Bs[x] = new lld**[2]; \n        for (int y = 0; y < 2; y++) \n        { \n            Bs[x][y] = new lld*[adjN]; \n            for (int i = 0; i < adjL; i++) \n            { \n                Bs[x][y][i] = new lld[adjM]; \n                for (int j = 0; j < adjM; j++) \n                { \n                    int I = i + (x & 1) * adjL; \n                    int J = j + (y & 1) * adjM; \n                    Bs[x][y][i][j] = (I < l && J < m) ? b[I][J] : 0; \n                } \n            } \n        } \n    }   \n    lld*** s = new lld**[10]; \n    for (int i = 0; i < 10; i++) \n    { \n        switch (i) \n        { \n        case 0: \n            s[i] = new lld*[adjL]; \n            for (int j = 0; j < adjL; j++) \n            { \n                s[i][j] = new lld[adjM]; \n                for (int k = 0; k < adjM; k++) \n                { \n                    s[i][j][k] = Bs[0][1][j][k] - Bs[1][1][j][k]; \n                } \n            } \n            break; \n        case 1: \n            s[i] = new lld*[adjN]; \n            for (int j = 0; j < adjN; j++) \n            { \n                s[i][j] = new lld[adjL]; \n                for (int k = 0; k < adjL; k++) \n                { \n                    s[i][j][k] = As[0][0][j][k] + As[0][1][j][k]; \n                } \n            } \n            break; \n        case 2: \n            s[i] = new lld*[adjN]; \n            for (int j = 0; j < adjN; j++) \n            { \n                s[i][j] = new lld[adjL]; \n                for (int k = 0; k < adjL; k++) \n                { \n                    s[i][j][k] = As[1][0][j][k] + As[1][1][j][k]; \n                } \n            } \n            break; \n        case 3: \n            s[i] = new lld*[adjL]; \n            for (int j = 0; j < adjL; j++) \n            { \n                s[i][j] = new lld[adjM]; \n                for (int k = 0; k < adjM; k++) \n                { \n                    s[i][j][k] = Bs[1][0][j][k] - Bs[0][0][j][k]; \n                } \n            } \n            break; \n        case 4: \n            s[i] = new lld*[adjN]; \n            for (int j = 0; j < adjN; j++) \n            { \n                s[i][j] = new lld[adjL]; \n                for (int k = 0; k < adjL; k++) \n                { \n                    s[i][j][k] = As[0][0][j][k] + As[1][1][j][k]; \n                } \n            } \n            break; \n        case 5: \n            s[i] = new lld*[adjL]; \n            for (int j = 0; j < adjL; j++) \n            { \n                s[i][j] = new lld[adjM]; \n                for (int k = 0; k < adjM; k++) \n                { \n                    s[i][j][k] = Bs[0][0][j][k] + Bs[1][1][j][k]; \n                } \n            } \n            break; \n        case 6: \n            s[i] = new lld*[adjN]; \n            for (int j = 0; j < adjN; j++) \n            { \n                s[i][j] = new lld[adjL]; \n                for (int k = 0; k < adjL; k++) \n                { \n                    s[i][j][k] = As[0][1][j][k] - As[1][1][j][k]; \n                } \n            } \n            break; \n        case 7: \n            s[i] = new lld*[adjL]; \n            for (int j = 0; j < adjL; j++) \n            { \n                s[i][j] = new lld[adjM]; \n                for (int k = 0; k < adjM; k++) \n                { \n                    s[i][j][k] = Bs[1][0][j][k] + Bs[1][1][j][k]; \n                } \n            } \n            break; \n        case 8: \n            s[i] = new lld*[adjN]; \n            for (int j = 0; j < adjN; j++) \n            { \n                s[i][j] = new lld[adjL]; \n                for (int k = 0; k < adjL; k++) \n                { \n                    s[i][j][k] = As[0][0][j][k] - As[1][0][j][k]; \n                } \n            } \n            break; \n        case 9: \n            s[i] = new lld*[adjL]; \n            for (int j = 0; j < adjL; j++) \n            { \n                s[i][j] = new lld[adjM]; \n                for (int k = 0; k < adjM; k++) \n                { \n                    s[i][j][k] = Bs[0][0][j][k] + Bs[0][1][j][k]; \n                } \n            } \n            break; \n        } \n    }  \n    lld*** p = new lld**[7]; \n    p[0] = Strassen(As[0][0], s[0], adjN, adjL, adjM); \n    p[1] = Strassen(s[1], Bs[1][1], adjN, adjL, adjM); \n    p[2] = Strassen(s[2], Bs[0][0], adjN, adjL, adjM); \n    p[3] = Strassen(As[1][1], s[3], adjN, adjL, adjM); \n    p[4] = Strassen(s[4], s[5], adjN, adjL, adjM); \n    p[5] = Strassen(s[6], s[7], adjN, adjL, adjM); \n    p[6] = Strassen(s[8], s[9], adjN, adjL, adjM);  \n    for (int i = 0; i < adjN; i++) \n    { \n        for (int j = 0; j < adjM; j++) \n        { \n            c[i][j] = p[4][i][j] + p[3][i][j] - p[1][i][j] + p[5][i][j]; \n            if (j + adjM < m) \n                c[i][j + adjM] = p[0][i][j] + p[1][i][j]; \n            if (i + adjN < n) \n                c[i + adjN][j] = p[2][i][j] + p[3][i][j]; \n            if (i + adjN < n && j + adjM < m) \n                c[i + adjN][j + adjM] = p[4][i][j] + p[0][i][j] - p[2][i][j] - p[6][i][j]; \n        } \n    }   \n    for (int x = 0; x < 2; x++) \n    { \n        for (int y = 0; y < 2; y++) \n        { \n            for (int i = 0; i < adjN; i++) \n            { \n                delete[] As[x][y][i]; \n            } \n            delete[] As[x][y]; \n        } \n        delete[] As[x]; \n    } \n    delete[] As;   \n    for (int x = 0; x < 2; x++) \n    { \n        for (int y = 0; y < 2; y++) \n        { \n            for (int i = 0; i < adjL; i++) \n            { \n                delete[] Bs[x][y][i]; \n            } \n            delete[] Bs[x][y]; \n        } \n        delete[] Bs[x]; \n    } \n    delete[] Bs;  \n    for (int i = 0; i < 10; i++) \n    { \n        switch (i) \n        { \n        case 0: \n        case 3: \n        case 5: \n        case 7: \n        case 9: \n            for (int j = 0; j < adjL; j++) \n            { \n                delete[] s[i][j]; \n            } \n            break; \n        case 1: \n        case 2: \n        case 4: \n        case 6: \n        case 8: \n            for (int j = 0; j < adjN; j++) \n            { \n                delete[] s[i][j]; \n            } \n            break; \n        } \n        delete[] s[i]; \n    } \n    delete[] s;   \n    for (int i = 0; i < 7; i++) { \n        for (int j = 0; j < (n >> 1); j++) \n        { \n            delete[] p[i][j]; \n        } \n        delete[] p[i]; \n    } \n    delete[] p;   \n    return c; \n}   \nint main() \n{ \n    lld** matA; \n    matA = new lld*[3]; \n    for (int i = 0; i < 3; i++) \n        matA[i] = new lld[3]; \n    matA[0][0] = 1; \n    matA[0][1] = 0; \n    matA[0][2] = 0; \n    matA[1][0] = 0; \n    matA[1][1] = 1; \n    matA[1][2] = 0;\n    matA[2][0] = 0; \n    matA[2][1] = 0; \n    matA[2][2] = 1;  \n    lld** matB; \n    matB = new lld*[3]; \n    for (int i = 0; i < 3; i++) \n        matB[i] = new lld[3]; \n    matB[0][0] = 1; \n    matB[0][1] = 0; \n    matB[0][2] = 0; \n    matB[1][0] = 0; \n    matB[1][1] = 1; \n    matB[1][2] = 0;\n    matB[2][0] = 0; \n    matB[2][1] = 0; \n    matB[2][2] = 1;  \n    lld** matC = Strassen(matA, matB, 3, 3, 3);\n    printf(\"Matrix A is :\n\"); \n    for(int i=0;i<3;i++)\n    {\n      for(int j=0;j<3;j++)\n      {\n        printf(\"%lld \", matA[i][j]);\n      }\n      printf(\"\n\");\n    }\n    printf(\"Matrix B is :\n\"); \n    for(int i=0;i<3;i++)\n    {\n      for(int j=0;j<3;j++)\n      {\n        printf(\"%lld \", matB[i][j]);\n      }\n      printf(\"\n\");\n    }\n    printf(\"Their product is :\n\");\n    for (int i = 0; i < 3; i++) \n    { \n        for (int j = 0; j < 3; j++) \n        { \n            printf(\"%lld \", matC[i][j]); \n        }\n        printf(\"\n\");\n    }  \n    return 0; \n} ', 1000, '', '', 'This algorithm will multiply 2 matrix A and B by using strassen’s formula as:\nmatrix A = |a b|, matrix B = |e f|\n           |c d|             |g h|\np1=a * (f - h)\np2=(a + b) * h\np3=(c + d) * e\np4=d * (g - e)\np5(a + d) * (e + h)\np6(b - d) * (g + h)\np7=(a - c) * (e + f)\np5+p4-p2+p6 = (a+d)*(e+h) + d*(g-e) - (a+b)*h + (b-d)*(g+h)\n            = (ae+de+ah+dh) + (dg-de) - (ah+bh) + (bg-dg+bh-dh)\n            = ae+bg\n p1+p2 = a*(f-h) + (a+b)*h\n       = (af-ah) + (ah+bh)\n       = af+bh\n p3+p4 = (c+d)*e + d*(g-e)\n       = (ce+de) + (dg-de)\n       = ce+dg \n p1+p5-p3-p7 = a*(f-h) + (a+d)*(e+h) - (c+d)*e - (a-c)*(e+f)\n             = (af-ah) + (ae+de+ah+dh) -(ce+de) - (ae-ce+af-cf)\n             = cf+dh\nmatrix C = |p5+p4-p2+p6    p1+p2   |\n           |   p3+p4    p1+p5-p3-p7| \nmatrix C is the required result', '2020-05-25'),
(398, 16, 4701012018, '#include<iostream>\r\n#include <string.h>\r\n#include <cstring>\r\nusing namespace std;\r\n#define d 10\r\nvoid rabinKarp(string pattern, string text, int q)\r\n{\r\n	int m = pattern.length();\r\n	int n = text.length();\r\n	int i, j;\r\n	int p = 0;\r\n	int t = 0;\r\n	int h = 1;\r\n	for (i = 0; i < m - 1; i++)\r\n		h = (h * d) % q;\r\n	for (i = 0; i < m; i++)\r\n	{\r\n		p = (d * p + pattern[i]) % q;\r\n		t = (d * t + text[i]) % q;\r\n	}\r\n	for (i = 0; i <= n - m; i++)\r\n	{\r\n		if (p == t)\r\n		{\r\n			for (j = 0; j < m; j++)\r\n			{\r\n				if (text[i + j] != pattern[j])\r\n					break;\r\n			}\r\n\r\n			if (j == m)\r\n				printf(\"Pattern found at index %d \n\", i );\r\n		}\r\n		if (i < n - m)\r\n		{\r\n			t = (d * (t - text[i] * h) + text[i + m]) % q;\r\n\r\n			if (t < 0)\r\n				t = (t + q);\r\n		}\r\n	}\r\n}\r\nint main()\r\n{\r\n    string text;\r\n    string pattern;\r\n    getline(cin, text);\r\n    getline(cin, pattern);\r\n    int q = 13;\r\n    rabinKarp(pattern, text, q);\r\n    return 0;\r\n}', 1000, '', '', 'n = t.length\r\nm = p.length\r\nh = dm-1 mod q\r\np = 0\r\nt0 = 0\r\nfor i = 1 to m\r\n    p = (dp + p[i]) mod q\r\n    t0 = (dt0 + t[i]) mod q\r\nfor s = 0 to n - m\r\n    if p = ts\r\n        if p[1.....m] = t[s + 1..... s + m]\r\n            print \"pattern found at position\" s\r\n    If s < n-m\r\n        ts + 1 = (d (ts - t[s + 1]h) + t[s + m + 1]) mod q', '2020-05-25'),
(399, 3, 4801012018, '#include <bits/stdc++.h> \r\nusing namespace std;  \r\n  \r\n// A utility function to swap two elements  \r\nvoid swap(int* a, int* b)  \r\n{  \r\n    int t = *a;  \r\n    *a = *b;  \r\n    *b = t;  \r\n}  \r\n  \r\n\r\nint partition (int arr[], int low, int high)  \r\n{  \r\n    int pivot = arr[high]; // pivot  \r\n    int i = (low - 1); // Index of smaller element  \r\n  \r\n    for (int j = low; j <= high - 1; j++)  \r\n    {  \r\n        // If current element is smaller than the pivot  \r\n        if (arr[j] < pivot)  \r\n        {  \r\n            i++; // increment index of smaller element  \r\n            swap(&arr[i], &arr[j]);  \r\n        }  \r\n    }  \r\n    swap(&arr[i + 1], &arr[high]);  \r\n    return (i + 1);  \r\n}  \r\n \r\nvoid quickSort(int arr[], int low, int high)  \r\n{  \r\n    if (low < high)  \r\n    {  \r\n       \r\n        int pi = partition(arr, low, high);  \r\n  \r\n        quickSort(arr, low, pi - 1);  \r\n        quickSort(arr, pi + 1, high);  \r\n    }  \r\n}  \r\n  \r\nvoid printArray(int arr[], int size)  \r\n{  \r\n    int i;  \r\n    for (i = 0; i < size; i++)  \r\n        cout << arr[i] << \" \";  \r\n\r\n}  \r\n  \r\n// Driver Code \r\nint main()  \r\n{  \r\n\r\n	int n;\r\n	cin>>n;\r\n	int arr[n];\r\n	for(int i=0;i<n;i++)\r\n	{\r\n	cin>>arr[i];\r\n	} \r\n    quickSort(arr, 0, n - 1);  \r\n    printArray(arr, n);  \r\n    return 0;  \r\n}', 10, '1 2000', '2000 ', 'quickSort(arr[], low, high)\r\n{\r\n	if (low < high)\r\n	{\r\n    	\r\n    	pi = partition(arr, low, high);\r\n \r\n    	quickSort(arr, low, pi - 1);  // Before pi\r\n    	quickSort(arr, pi + 1, high); // After pi\r\n	}\r\n}\r\nPseudo code for partition()\r\n \r\npartition (arr[], low, high)\r\n{\r\n    	pivot = arr[high]; \r\n \r\n	i = (low – 1)\r\n	for (j = low; j <= high- 1; j++)\r\n	{\r\n            	if (arr[j] < pivot)\r\n    	{\r\n        	i++;	\r\n        	swap arr[i] and arr[j]\r\n    	}\r\n	}\r\n	swap arr[i + 1] and arr[high])\r\n	return (i + 1)\r\n}\r\n', '2020-05-25'),
(400, 9, 4801012018, '/#include <iostream> \nusing namespace std; \nclass createset { \n	int *rank, *parent, n; \n\npublic: \n	createset(int n) \n	{ \n		rank = new int[n]; \n		parent = new int[n]; \n		this->n = n; \n		makeSet(); \n	} \n\n	void makeset() \n	{ \n		for(int i=0;i<n;i++)\n                 {\n                  parent[i]=i;	} \n}\n\n	int findset(int x) \n	{ \n		if (parent[x] != x) { \n			parent[x] = find(parent[x]); \n		} \n\n		return parent[x]; \n	} \n\n\n	void mergeset(int x, int y) \n	{ \n		int xset = find(x); \n		int yset = find(y); \n\n		if (xset == yset) \n			return; \n\n		if (rank[xset] < rank[yset]) { \n			parent[xset] = yset; \n		} \n		else if (rank[xset] > rank[yset]) { \n			parent[yset] = xset; \n		} \n\n		else { \n			parent[yset] = xset; \n			rank[xset] = rank[xset] + 1; \n		} \n	} \n}; \n\nint main() \n{ \n    \n	createset obj(6);\n	\n	obj.mergeset(4,5);\n	obj.mergeset(0, 2); \n	obj.mergeset(5, 3); \n	obj.mergeset(3, 1); \n	if (obj.findset(4) == obj.findset(5)) \n		cout << \"Yes\n\"; \n	else\n		cout << \"No\n\"; \n	if (obj.findset(1) == obj.findset(3)) \n		cout << \"Yes\n\"; \n	else\n		cout << \"No\n\"; \n\n	return 0; \n} \n\n', 1000, '', '', 'function MakeSet(x)\r\n   x.parent = x\r\n\r\nfunction Find(x)\r\n   if x.parent == x\r\n      return x\r\n   else\r\n      return Find(x.parent)\r\n\r\nfunction Union(x,y)\r\n   xRoot = Find(x)\r\n   yRoot = Find(y)\r\n   xRoot.parent = yRoot', '2020-05-25'),
(401, 10, 4801012018, '\r\n#include<iostream>\r\n#include<stdio.h> \r\n  \r\n \r\nint max(int a, int b) { return (a > b)? a : b; } \r\n  \r\n \r\nint knapSack(int W, int wt[], int val[], int n) \r\n{ \r\n   int i, w; \r\n   int K[n+1][W+1]; \r\n  \r\n \r\n   for (i = 0; i <= n; i++) \r\n   { \r\n       for (w = 0; w <= W; w++) \r\n       { \r\n           if (i==0 || w==0) \r\n               K[i][w] = 0; \r\n           else if (wt[i-1] <= w) \r\n                 K[i][w] = max(val[i-1] + K[i-1][w-wt[i-1]],  K[i-1][w]); \r\n           else\r\n                 K[i][w] = K[i-1][w]; \r\n       } \r\n   } \r\n  \r\n   return K[n][W]; \r\n} \r\n  \r\nint main() \r\n{ \r\n    int n,w;\r\n    int val[n];\r\n    int wt[n];\r\n    for(int i=0;i<n;i++)\r\n    {\r\n        cin>>val[i];\r\n    } \r\n    for(int i=0;i<n;i++)\r\n    {\r\n        cin>>wt[i];\r\n    } \r\n    cin>>w;\r\n    int n = sizeof(val)/sizeof(val[0]); \r\n    cout<<\"\n\"<<knapSack(W, wt, val, n)); \r\n    return 0; \r\n} ', 0, '5 15 4 2 1 2 10 12 2 1 1 4', '', '﻿An efficient solution is to use the Greedy approach. The basic idea of the greedy approach is to calculate the ratio value/weight for each item and sort the item on the basis of this ratio. Then take the item with the highest ratio and add them until we can’t add the next item as a whole and at the end add the next item as much as we can. Which will always be the optimal solution to this problem.\r\n\r\n\r\nAlgorithm: Greedy-Fractional-Knapsack (w[1..n], p[1..n], W) \r\nfor i = 1 to n \r\n   do x[i] = 0 \r\nweight = 0 \r\nfor i = 1 to n \r\n   if weight + w[i] ≤ W then  \r\n      x[i] = 1 \r\n      weight = weight + w[i] \r\n   else \r\n      x[i] = (W - weight) / w[i] \r\n      weight = W \r\n      break \r\nreturn x', '2020-05-25'),
(402, 12, 4801012018, '﻿#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n\r\nclass Edge\r\n{\r\n    public:\r\n    int src, dest, weight;\r\n};\r\n\r\n\r\nclass Graph\r\n{\r\n    public:\r\n\r\n\r\n    int V, E;\r\n\r\n\r\n    Edge* edge;\r\n};\r\n\r\n\r\n\r\n\r\nGraph* createGraph(int V, int E)\r\n{\r\n    Graph* graph = new Graph;\r\n    graph->V = V;\r\n    graph->E = E;\r\n\r\n\r\n    graph->edge = new Edge[E];\r\n\r\n\r\n    return graph;\r\n}\r\n\r\n\r\nclass subset\r\n{\r\n    public:\r\n    int parent;\r\n    int rank;\r\n};\r\n\r\n\r\n\r\n\r\nint find(subset subsets[], int i)\r\n{\r\n    if (subsets[i].parent != i)\r\n        subsets[i].parent = find(subsets, subsets[i].parent);\r\n\r\n\r\n    return subsets[i].parent;\r\n}\r\n\r\n\r\n\r\n\r\nvoid Union(subset subsets[], int x, int y)\r\n{\r\n    int xroot = find(subsets, x);\r\n    int yroot = find(subsets, y);\r\n\r\n\r\n\r\n\r\n    if (subsets[xroot].rank < subsets[yroot].rank)\r\n        subsets[xroot].parent = yroot;\r\n    else if (subsets[xroot].rank > subsets[yroot].rank)\r\n        subsets[yroot].parent = xroot;\r\n\r\n\r\n    else\r\n    {\r\n        subsets[yroot].parent = xroot;\r\n        subsets[xroot].rank++;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\nint myComp(const void* a, const void* b)\r\n{\r\n    Edge* a1 = (Edge*)a;\r\n    Edge* b1 = (Edge*)b;\r\n    return a1->weight > b1->weight;\r\n}\r\n\r\n\r\n\r\n\r\nvoid KruskalMST(Graph* graph)\r\n{\r\n    int V = graph->V;\r\n    Edge result[V];\r\n    int e = 0;\r\n    int i = 0;\r\n\r\n\r\n    qsort(graph->edge, graph->E, sizeof(graph->edge[0]), myComp);\r\n\r\n\r\n\r\n\r\n    subset *subsets = new subset[( V * sizeof(subset) )];\r\n\r\n\r\n    for (int v = 0; v < V; ++v)\r\n    {\r\n        subsets[v].parent = v;\r\n        subsets[v].rank = 0;\r\n    }\r\n\r\n\r\n\r\n\r\n    while (e < V - 1 && i < graph->E)\r\n    {\r\n        Edge next_edge = graph->edge[i++];\r\n\r\n\r\n        int x = find(subsets, next_edge.src);\r\n        int y = find(subsets, next_edge.dest);\r\n\r\n\r\n        if (x != y)\r\n        {\r\n            result[e++] = next_edge;\r\n            Union(subsets, x, y);\r\n        }\r\n\r\n\r\n    }\r\n\r\n    for (i = 0; i < e; ++i)\r\n        cout<<result[i].src<<\" --- \"<<result[i].dest<<\" ==> \"<<result[i].weight<<endl;\r\n    return;\r\n}\r\n\r\n\r\n\r\n\r\nint main()\r\n{\r\n    int V = 4;\r\n    int E = 5;\r\n    Graph* graph = createGraph(V, E);\r\n\r\n\r\n    graph->edge[0].src = 0;\r\n    graph->edge[0].dest = 1;\r\n    graph->edge[0].weight = 10;\r\n\r\n\r\n    graph->edge[1].src = 0;\r\n    graph->edge[1].dest = 2;\r\n    graph->edge[1].weight = 6;\r\n\r\n\r\n\r\n\r\n    graph->edge[2].src = 0;\r\n    graph->edge[2].dest = 3;\r\n    graph->edge[2].weight = 5;\r\n\r\n\r\n\r\n\r\n    graph->edge[3].src = 1;\r\n    graph->edge[3].dest = 3;\r\n    graph->edge[3].weight = 15;\r\n\r\n\r\n\r\n\r\n    graph->edge[4].src = 2;\r\n    graph->edge[4].dest = 3;\r\n    graph->edge[4].weight = 4;\r\n\r\n\r\n    KruskalMST(graph);\r\n\r\n\r\n    return 0;\r\n}', 1000, '', '', '﻿1. Sort all the edges in non-decreasing order of their weight.\r\n2. Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If a cycle is not formed, include this edge. Else, discard it.\r\n3. Repeat step#2 until there are (V-1) edges in the spanning tree.', '2020-05-25'),
(403, 13, 4801012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n\r\nint minKey(int V,int key[], bool mstSet[]) \r\n{ \r\n	int min = INT_MAX, min_index; \r\n	for (int v = 1; v <= V; v++) \r\n		if (mstSet[v] == false && key[v] < min) \r\n			min = key[v], min_index = v; \r\n\r\n	return min_index; \r\n} \r\n\r\n\r\nvoid printMST(int V,int parent[], int graph[100][100]) \r\n{ \r\n	 \r\n	int sum=0;\r\n	for (int i = 1; i <= V; i++) \r\n	{sum+=graph[i][parent[i]];\r\n		 }\r\n		cout<<sum<<endl;\r\n} \r\n\r\n\r\nvoid primMST(int V,int graph[100][100]) \r\n{ \r\n	 \r\n	int parent[V+1]; \r\n	int key[V+1]; \r\n	bool mstSet[V+1]; \r\n\r\n	for (int i = 1; i <= V; i++) \r\n		key[i] = INT_MAX, mstSet[i] = false; \r\n\r\n	key[1] = 0; \r\n	parent[1] = -1;  \r\n	for (int count = 1; count < V; count++) \r\n	{ \r\n		int u = minKey(V,key, mstSet);\r\n		mstSet[u] = true; \r\n		for (int v = 1; v <= V; v++) \r\n			if (graph[u][v] && mstSet[v] == false && graph[u][v] < key[v]) \r\n				parent[v] = u, key[v] = graph[u][v]; \r\n	} \r\n	printMST( V,parent, graph); \r\n} \r\n\r\n\r\nint main() \r\n{ \r\n	\r\nint V,E;\r\ncin>>V;\r\ncin>>E;\r\n\r\nint graph[100][100];\r\n	\r\n      for(int i=0;i<=V;i++)\r\n       for(int j=0;j<=V;j++)\r\n        {\r\n        graph[i][j]=0;\r\n       }\r\n       int a,b,w;\r\n      for(int i=0;i<E;i++)\r\n       {\r\n       cin>>a>>b>>w;\r\n       graph[a][b]=w;\r\n       graph[b][a]=w;\r\n       }\r\n	primMST(V,graph); \r\n\r\n	return 0; \r\n} ', 1000, '', '', '﻿1. Associate with each vertex v of the graph a number C[v] (the cheapest cost of a connection to v) and an edge E[v] (the edge providing that cheapest connection). To initialize these values, set all values of C[v] to +∞ (or to any number larger than the maximum edge weight) and set each E[v] to a special flag value indicating that there is no edge connecting v to earlier vertices.\r\n2. Initialize an empty forest F and a set Q of vertices that have not yet been included in F (initially, all vertices).\r\n3. Repeat the following steps until Q is empty:\r\n   1. Find and remove a vertex v from Q having the minimum possible value of C[v]\r\n   2. Add v to F and, if E[v] is not the special flag value, also add E[v] to F\r\n   3. Loop over the edges vw connecting v to other vertices w. For each such edge, if w still belongs to Q and vw has smaller weight than C[w], perform the following steps:\r\n      1. Set C[w] to the cost of edge vw\r\n      2. Set E[w] to point to edge vw.\r\n4. Return F', '2020-05-25'),
(404, 14, 4801012018, '﻿#include <bits/stdc++.h>\r\nstruct Edge {\r\n    int src, dest, weight;\r\n};\r\nstruct Graph {\r\n       int V, E;\r\n      struct Edge* edge;\r\n};\r\nstruct Graph* createGraph(int V, int E)\r\n{\r\n    struct Graph* graph = new Graph;\r\n    graph->V = V;\r\n    graph->E = E;\r\n    graph->edge = new Edge[E];\r\n    return graph;\r\n}\r\nvoid printArr(int dist[], int n)\r\n{\r\n    printf(\"Vertex   Distance from Source\n\");\r\n    for (int i = 0; i < n; ++i)\r\n        printf(\"%d 		 %d\n\", i, dist[i]);\r\n}\r\nvoid BellmanFord(struct Graph* graph, int src)\r\n{\r\n    int V = graph->V;\r\n    int E = graph->E;\r\n    int dist[V];\r\n      for (int i = 0; i < V; i++)\r\n        dist[i] = INT_MAX;\r\n    dist[src] = 0;\r\n      for (int i = 1; i <= V - 1; i++) {\r\n        for (int j = 0; j < E; j++) {\r\n            int u = graph->edge[j].src;\r\n            int v = graph->edge[j].dest;\r\n            int weight = graph->edge[j].weight;\r\n            if (dist[u] != INT_MAX && dist[u] + weight < dist[v])\r\n                dist[v] = dist[u] + weight;\r\n        }\r\n    }\r\n      for (int i = 0; i < E; i++) {\r\n        int u = graph->edge[i].src;\r\n        int v = graph->edge[i].dest;\r\n        int weight = graph->edge[i].weight;\r\n        if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {\r\n            printf(\"Graph contains negative weight cycle\");\r\n            return; // If negative cycle is detected, simply return\r\n        }\r\n    }\r\n    printArr(dist, V);\r\n    return;\r\n}\r\n  \r\nint main()\r\n{\r\n    int V = 5; // Number of vertices in graph\r\n    int E = 8; // Number of edges in graph\r\n    struct Graph* graph = createGraph(V, E);\r\n \r\n    graph->edge[0].src = 0;\r\n    graph->edge[0].dest = -1;\r\n    graph->edge[0].weight = -1;\r\n    graph->edge[1].src = 0;\r\n    graph->edge[1].dest = 2;\r\n    graph->edge[1].weight = 4;\r\n    graph->edge[2].src = 1;\r\n    graph->edge[2].dest = 2;\r\n    graph->edge[2].weight = 3;\r\n    graph->edge[3].src = 1;\r\n    graph->edge[3].dest = 3;\r\n    graph->edge[3].weight = 2;\r\n    graph->edge[4].src = 1;\r\n    graph->edge[4].dest = 4;\r\n    graph->edge[4].weight = 2;\r\n    graph->edge[5].src = 3;\r\n    graph->edge[5].dest = 2;\r\n    graph->edge[5].weight = 5;\r\n  \r\n \r\n    graph->edge[6].src = 3;\r\n    graph->edge[6].dest = 1;\r\n    graph->edge[6].weight = 1;\r\n    graph->edge[7].src = 4;\r\n    graph->edge[7].dest = 3;\r\n    graph->edge[7].weight = -3;\r\n  \r\n    BellmanFord(graph, 0);\r\n  \r\n    return 0;\r\n}', 1000, '', '', '﻿function BellmanFord(list vertices, list edges, vertex source) is\r\n    ::distance[], predecessor[]\r\n\r\n\r\n    // This implementation takes in a graph, represented as\r\n    // lists of vertices and edges, and fills two arrays\r\n    // (distance and predecessor) about the shortest path\r\n    // from the source to each vertex\r\n\r\n\r\n    // Step 1: initialize graph\r\n    for each vertex v in vertices do\r\n        distance[v] := inf             // Initialize the distance to all vertices to infinity\r\n        predecessor[v] := null         // And having a null predecessor\r\n    \r\n    distance[source] := 0              // The distance from the source to itself is, of course, zero\r\n    // Step 2: relax edges repeatedly\r\n    for i from 1 to size(vertices)−1 do //just |V|−1 repetitions; i is never referenced\r\n        for each edge (u, v) with weight w in edges do\r\n            if distance[u] + w < distance[v] then\r\n                distance[v] := distance[u] + w\r\n                predecessor[v] := u\r\n\r\n\r\n    // Step 3: check for negative-weight cycles\r\n    for each edge (u, v) with weight w in edges do\r\n        if distance[u] + w < distance[v] then\r\n            error \"Graph contains a negative-weight cycle\"\r\n\r\n\r\n    return distance[], predecessor[]', '2020-05-25'),
(405, 15, 4801012018, '﻿#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\n\r\nint MatrixChainOrder(int p[], int n)\r\n{\r\n\r\n\r\n    int m[n][n];\r\n\r\n\r\n    int i, j, k, L, q;\r\n\r\n\r\n\r\n\r\n    for (i = 1; i < n; i++)\r\n        m[i][i] = 0;\r\n\r\n\r\n    for (L = 2; L < n; L++)\r\n    {\r\n        for (i = 1; i < n - L + 1; i++)\r\n        {\r\n            j = i + L - 1;\r\n            m[i][j] = INT_MAX;\r\n            for (k = i; k <= j - 1; k++)\r\n            {\r\n\r\n\r\n                q = m[i][k] + m[k + 1][j] +\r\n                    p[i - 1] * p[k] * p[j];\r\n                if (q < m[i][j])\r\n                    m[i][j] = q;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    return m[1][n - 1];\r\n}\r\n\r\n\r\n\r\n\r\nint main()\r\n{\r\n    int n; cin>>n;\r\n    int* arr = new int[n];\r\n    for(int i = 0; i < n; i++)\r\n        cin>>arr[i];\r\n\r\n\r\n    int size = n;\r\n       cout<< MatrixChainOrder(arr, size);\r\n\r\n\r\n    getchar();\r\n    return 0;\r\n}', 1000, '', '', '﻿In general, we can find the minimum cost using the following recursive algorithm:\r\n* Take the sequence of matrices and separate it into two subsequences.\r\n* Find the minimum cost of multiplying out each subsequence.\r\n* Add these costs together, and add in the cost of multiplying the two result matrices.\r\n* Do this for each possible position at which the sequence of matrices can be split, and take the minimum over all of them.\r\n\r\n\r\nMatrixChainOrder(int dims[])\r\n{\r\n    // length[dims] = n + 1\r\n    n = dims.length - 1;\r\n    // m[i,j] = Minimum number of scalar multiplications (i.e., cost)\r\n    // needed to compute the matrix A[i]A[i+1]...A[j] = A[i..j]\r\n    // The cost is zero when multiplying one matrix\r\n    for (i = 1; i <= n; i++)\r\n        m[i, i] = 0;\r\n\r\n\r\n    for (len = 2; len <= n; len++) { // Subsequence lengths\r\n        for (i = 1; i <= n - len + 1; i++) {\r\n            j = i + len - 1;\r\n            m[i, j] = MAXINT;\r\n            for (k = i; k <= j - 1; k++) {\r\n                cost = m[i, k] + m[k+1, j] + dims[i-1]*dims[k]*dims[j];\r\n                if (cost < m[i, j]) {\r\n                    m[i, j] = cost;\r\n                    s[i, j] = k; // Index of the subsequence split that achieved minimal cost\r\n                }\r\n            }\r\n        }\r\n    }\r\n}', '2020-05-25'),
(406, 8, 4801012018, '#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint nextpowerof2(int k)\n{\n    return pow(2, int(ceil(log2(k))));\n}\nvoid display(vector< vector<int>> &matrix, int m, int n)\n{\n    for (int i = 0; i < m; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (j != 0)\n            {\n                cout <<\" \";\n            }\n            cout << matrix[i][j];\n        }\n        cout << endl;\n    }\n}\n\nvoid add(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n    int i, j;\n\n    for (i = 0; i < size; i++)\n    {\n        for (j = 0; j < size; j++)\n        {\n            C[i][j] = A[i][j] + B[i][j];\n        }\n    }\n}\n\nvoid sub(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n    int i, j;\n\n    for (i = 0; i < size; i++)\n    {\n        for (j = 0; j < size; j++)\n        {\n            C[i][j] = A[i][j] - B[i][j];\n        }\n    }\n}\n\nvoid STRASSEN_algorithmA(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n    if (size == 1)\n    {\n        C[0][0] = A[0][0] * B[0][0];\n        return;\n    }\n    else\n    {\n        int new_size = size / 2;\n        vector<int> z(new_size);\n        vector<vector<int>>\n            a11(new_size, z), a12(new_size, z), a21(new_size, z), a22(new_size, z),\n            b11(new_size, z), b12(new_size, z), b21(new_size, z), b22(new_size, z),\n            c11(new_size, z), c12(new_size, z), c21(new_size, z), c22(new_size, z),\n            p1(new_size, z), p2(new_size, z), p3(new_size, z), p4(new_size, z),\n            p5(new_size, z), p6(new_size, z), p7(new_size, z),\n            aResult(new_size, z), bResult(new_size, z);\n\nint i, j;\nfor (i = 0; i < new_size; i++)\n        {\n            for (j = 0; j < new_size; j++)\n            {\n                a11[i][j] = A[i][j];\n                a12[i][j] = A[i][j + new_size];\n                a21[i][j] = A[i + new_size][j];\n                a22[i][j] = A[i + new_size][j + new_size];\n\n                b11[i][j] = B[i][j];\n                b12[i][j] = B[i][j + new_size];\n                b21[i][j] = B[i + new_size][j];\n                b22[i][j] = B[i + new_size][j + new_size];\n            }\n}\n\n        add(a11, a22, aResult, new_size);\n        add(b11, b22, bResult, new_size);\n        STRASSEN_algorithmA(aResult, bResult, p1, new_size);\n\n        add(a21, a22, aResult, new_size);\n        STRASSEN_algorithmA(aResult, b11, p2, new_size);\n\n        sub(b12, b22, bResult, new_size);\n        STRASSEN_algorithmA(a11, bResult, p3, new_size);\n\n\n        sub(b21, b11, bResult, new_size);\n        STRASSEN_algorithmA(a22, bResult, p4, new_size);\n        add(a11, a12, aResult, new_size);\n        STRASSEN_algorithmA(aResult, b22, p5, new_size);\n\n        sub(a21, a11, aResult, new_size);\n        add(b11, b12, bResult, new_size);\n        STRASSEN_algorithmA(aResult, bResult, p6, new_size);\n\n        sub(a12, a22, aResult, new_size);\n        add(b21, b22, bResult, new_size);\n        STRASSEN_algorithmA(aResult, bResult, p7, new_size);\n\n        add(p3, p5, c12, new_size);\n        add(p2, p4, c21, new_size);\n\n        add(p1, p4, aResult, new_size);\n        add(aResult, p7, bResult, new_size);\n        sub(bResult, p5, c11, new_size);\n\n        add(p1, p3, aResult, new_size);\n        add(aResult, p6, bResult, new_size);\n        sub(bResult, p2, c22, new_size);\n        for (i = 0; i < new_size; i++)\n        {\n            for (j = 0; j < new_size; j++)\n            {\n                C[i][j] = c11[i][j];\n                C[i][j + new_size] = c12[i][j];\n                C[i + new_size][j] = c21[i][j];\n                C[i + new_size][j + new_size] = c22[i][j];\n            }\n        }\n    }\n}\nvoid STRASSEN_algorithm(vector<vector<int>> &A, vector<vector<int>> &B, int m, int n, int a, int b)\n{\n    int k = max({m, n, a, b});\n\n    int s = nextpowerof2(k);\n\n    vector<int> z(s);\n    vector<vector<int>> Aa(s, z), Bb(s, z), Cc(s, z);\n\n    for (unsigned int i = 0; i < m; i++)\n    {\n        for (unsigned int j = 0; j < n; j++)\n        {\n            Aa[i][j] = A[i][j];\n        }\n    }\n    for (unsigned int i = 0; i < a; i++)\n    {\n        for (unsigned int j = 0; j < b; j++)\n        {\n            Bb[i][j] = B[i][j];\n        }\n    }\n    STRASSEN_algorithmA(Aa, Bb, Cc, s);\n    vector<int> temp1(b);\n    vector<vector<int>> C(m, temp1);\n    for (unsigned int i = 0; i < m; i++)\n    {\n        for (unsigned int j = 0; j < b; j++)\n        {\n            C[i][j] = Cc[i][j];\n        }\n    }\n    display(C, m, b);\n}\n\nbool check(int n, int a)\n{\n    if (n == a)\n        return true;\n    else\n        return false;\n}\n\nint main()\n{\n    int n, a, b;\n    cin >> n;\n\n    vector<vector<int>> A;\n    for (int i = 0; i < n; i++)\n    {\n        vector<int> temp;\n        for (int j = 0; j < n; j++)\n        {\n            int i;\n            cin >> i;\n            temp.push_back(i);\n        }\n        A.push_back(temp);\n    }\n\n    vector<vector<int>> B;\n    for (int i = 0; i < n; i++)\n    {\n        vector<int> temp;\n        for (int j = 0; j < n; j++)\n        {\n            int i;\n            cin >> i;\n            temp.push_back(i);\n        }\n        B.push_back(temp);\n    }\n\n\n        STRASSEN_algorithm(A, B, n, n, n, n);\n\n    return 0;\n}\n\n', 0, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '', '1)Divide matrices A and B in 4 sub-matrices of size N/2 x N/2. \r\n2)Calculate the 7 matrix multiplications recursively.\r\n3)Compute the submatricies of C.\r\n4)Combine these submatricies into our new matrix C', '2020-05-25'),
(407, 5, 4801012018, '#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint nextpowerof2(int k)\n{\n    return pow(2, int(ceil(log2(k))));\n}\nvoid display(vector< vector<int>> &matrix, int m, int n)\n{\n    for (int i = 0; i < m; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (j != 0)\n            {\n                cout << \" \";\n            }\n            cout << matrix[i][j];\n        }\n        cout << endl;\n    }\n}\n\nvoid add(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n    int i, j;\n\n    for (i = 0; i < size; i++)\n    {\n        for (j = 0; j < size; j++)\n        {\n            C[i][j] = A[i][j] + B[i][j];\n        }\n    }\n}\n\nvoid sub(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n    int i, j;\n\n    for (i = 0; i < size; i++)\n    {\n        for (j = 0; j < size; j++)\n        {\n            C[i][j] = A[i][j] - B[i][j];\n        }\n    }\n}\n\nvoid STRASSEN_algorithmA(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n   \n    if (size == 1)\n    {\n        C[0][0] = A[0][0] * B[0][0];\n        return;\n    }\n    else\n    {\n        int new_size = size / 2;\n        vector<int> z(new_size);\n        vector<vector<int>>\n            a11(new_size, z), a12(new_size, z), a21(new_size, z), a22(new_size, z),\n            b11(new_size, z), b12(new_size, z), b21(new_size, z), b22(new_size, z),\n            c11(new_size, z), c12(new_size, z), c21(new_size, z), c22(new_size, z),\n            p1(new_size, z), p2(new_size, z), p3(new_size, z), p4(new_size, z),\n            p5(new_size, z), p6(new_size, z), p7(new_size, z),\n            aResult(new_size, z), bResult(new_size, z);\n\nint i, j;\n\nfor (i = 0; i < new_size; i++)\n        {\n            for (j = 0; j < new_size; j++)\n            {\n                a11[i][j] = A[i][j];\n                a12[i][j] = A[i][j + new_size];\n                a21[i][j] = A[i + new_size][j];\n                a22[i][j] = A[i + new_size][j + new_size];\n\n                b11[i][j] = B[i][j];\n                b12[i][j] = B[i][j + new_size];\n                b21[i][j] = B[i + new_size][j];\n                b22[i][j] = B[i + new_size][j + new_size];\n            }\n}\n\n\n        add(a11, a22, aResult, new_size);    \n        add(b11, b22, bResult, new_size);    \n        STRASSEN_algorithmA(aResult, bResult, p1, new_size); \n\n        add(a21, a22, aResult, new_size); \n        STRASSEN_algorithmA(aResult, b11, p2, new_size);\n\n        sub(b12, b22, bResult, new_size);      \n        STRASSEN_algorithmA(a11, bResult, p3, new_size);\n\n        sub(b21, b11, bResult, new_size);     \n        STRASSEN_algorithmA(a22, bResult, p4, new_size); \n\n        add(a11, a12, aResult, new_size);     \n        STRASSEN_algorithmA(aResult, b22, p5, new_size);\n\n        sub(a21, a11, aResult, new_size);      \n        add(b11, b12, bResult, new_size);               \n      \n        STRASSEN_algorithmA(aResult, bResult, p6, new_size);\n\n        sub(a12, a22, aResult, new_size);      \n        add(b21, b22, bResult, new_size);                \n        \n        STRASSEN_algorithmA(aResult, bResult, p7, new_size);\n        \n\n        add(p3, p5, c12, new_size); \n        add(p2, p4, c21, new_size); \n\n        add(p1, p4, aResult, new_size);      \n        add(aResult, p7, bResult, new_size); \n        sub(bResult, p5, c11, new_size); \n\n        add(p1, p3, aResult, new_size);     \n        add(aResult, p6, bResult, new_size);  \n        sub(bResult, p2, c22, new_size); \n\n        for (i = 0; i < new_size; i++)\n        {\n            for (j = 0; j < new_size; j++)\n            {\n                C[i][j] = c11[i][j];\n                C[i][j + new_size] = c12[i][j];\n                C[i + new_size][j] = c21[i][j];\n                C[i + new_size][j + new_size] = c22[i][j];\n            }\n        }\n    }\n}\nvoid STRASSEN_algorithm(vector<vector<int>> &A, vector<vector<int>> &B, int m, int n, int a, int b)\n{  \n    int k = max({m, n, a, b});\n\n    int s = nextpowerof2(k);\n\n    vector<int> z(s);\n    vector<vector<int>> Aa(s, z), Bb(s, z), Cc(s, z);\n\n    for (unsigned int i = 0; i < m; i++)\n    {\n        for (unsigned int j = 0; j < n; j++)\n        {\n            Aa[i][j] = A[i][j];\n        }\n    }\n    for (unsigned int i = 0; i < a; i++)\n    {\n        for (unsigned int j = 0; j < b; j++)\n        {\n            Bb[i][j] = B[i][j];\n        }\n    }\n    STRASSEN_algorithmA(Aa, Bb, Cc, s);\n    vector<int> temp1(b);\n    vector<vector<int>> C(m, temp1);\n    for (unsigned int i = 0; i < m; i++)\n    {\n        for (unsigned int j = 0; j < b; j++)\n        {\n            C[i][j] = Cc[i][j];\n        }\n    }\n    display(C, m, b);\n}\n\nbool check(int n, int a)\n{\n    if (n == a)\n        return true;\n    else\n        return false;\n}\n\nint main()\n{\n    int m = 3, n=4, a=4, b=3;\n    vector<vector<int>> A;\n    A = {{1,2,3,4},{4,5,6,1},{7,8,9,2}};\n\n    vector<vector<int>> B;\n    B = {{1,2,3},{5,7,2},{6,3,2},{1,9,2}};\n\n    bool k = check(n, a);\n    if (k)\n    {\n        STRASSEN_algorithm(A, B, m, n, a, b);\n    }\n    else\n    {\n        cout << \"-1\";\n    }\n    return 0;\n}\n\n\n', 1000, '', '', 'function Strassen(M,N)\r\nif M is 1 ? 1 then\r\nreturn M11N11\r\nend if\r\nLet M =  A B\r\n         C D \r\nand N =  E F\r\n         G H \r\nSet S1 = Strassen(B - D, G + H)\r\nSet S2 = Strassen(A + D, E + H)\r\nSet S3 = Strassen(A - C, E + F)\r\nSet S4 = Strassen(A + B, H)\r\nSet S5 = Strassen(A, F - H)\r\nSet S6 = Strassen(D, G - E)\r\nSet S7 = Strassen(C + D, E)\r\nreturn (\r\nS1 + S2 - S4 + S6    S4 + S5\r\nS6 + S7              S2 - S3 + S5 - S7\r\n)\r\nend function\r\n', '2020-05-25'),
(408, 16, 4801012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n\r\n#define d 256 \r\n\r\nvoid search(char pat[], char txt[],int q) \r\n{ \r\n	int M = strlen(pat); \r\n	int N = strlen(txt); \r\n	int i, j; \r\n	int p = 0; \r\n	int t = 0;  \r\n	int h = 1; \r\n\r\n	for (i = 0; i < M - 1; i++) \r\n		h = (h * d) % q; \r\n\r\n	for (i = 0; i < M; i++) \r\n	{ \r\n		p = (d * p + pat[i]) % q; \r\n		t = (d * t + txt[i]) % q; \r\n	} \r\n\r\n	for (i = 0; i <= N - M; i++) \r\n	{ \r\n		if ( p == t ) \r\n		{ \r\n			for (j = 0; j < M; j++) \r\n			{ \r\n				if (txt[i+j] != pat[j]) \r\n					break; \r\n			} \r\n\r\n			if (j == M) \r\n				cout<<\"Pattern found at index \"<< i<<endl; \r\n		} \r\n\r\n		if ( i < N-M ) \r\n		{ \r\n			t = (d*(t - txt[i]*h) + txt[i+M])%q; \r\n\r\n			if (t < 0) \r\n			t = (t + q); \r\n		} \r\n	} \r\n} \r\n\r\nint main() \r\n{ \r\n	char txt[];\r\n        cin>>txt;\r\n	char pat[];\r\n        cin>>pat;\r\n	int q = 101;  \r\n	search(pat, txt, q); \r\n	return 0; \r\n} \r\n\r\n', 1000, '', '', '1. n ← length [T]\r\n 2. m  ← length [P]\r\n 3. h  ←  dm-1 mod q\r\n 4. p ←  0\r\n 5. t0 ←  0\r\n 6. for i ← 1 to m\r\n 7. do p ←  (dp + P[i]) mod q\r\n 8. t0 ← (dt0+T [i]) mod q\r\n 9. for s  ←  0 to n-m\r\n 10. do if p = ts\r\n 11. then if P [1.....m] = T [s+1.....s + m]\r\n 12. then \"Pattern occurs with shift\" s\r\n 13. If s < n-m\r\n 14. then ts+1 ←  (d (ts-T [s+1]h)+T [s+m+1])mod q', '2020-05-25'),
(409, 9, 4901012018, '/#include <iostream> \nusing namespace std; \nclass DisjSet { \n	int *rank, *parent, n; \n\npublic: \n	DisjSet(int n) \n	{ \n		rank = new int[n]; \n		parent = new int[n]; \n		this->n = n; \n		makeSet(); \n	} \n\n	void makeSet() \n	{ \n		for (int i = 0; i < n; i++) { \n			parent[i] = i; \n		} \n	} \n\n	int find(int x) \n	{ \n		if (parent[x] != x) { \n			parent[x] = find(parent[x]); \n		} \n\n		return parent[x]; \n	} \n\n\n	void Union(int x, int y) \n	{ \n		int xset = find(x); \n		int yset = find(y); \n\n		if (xset == yset) \n			return; \n\n		if (rank[xset] < rank[yset]) { \n			parent[xset] = yset; \n		} \n		else if (rank[xset] > rank[yset]) { \n			parent[yset] = xset; \n		} \n\n		else { \n			parent[yset] = xset; \n			rank[xset] = rank[xset] + 1; \n		} \n	} \n}; \n\nint main() \n{ \n    \n	DisjSet obj(6);\n	\n	obj.Union(4,5);\n	obj.Union(0, 2); \n	obj.Union(5, 3); \n	obj.Union(3, 1); \n	if (obj.find(4) == obj.find(5)) \n		cout << \"Yes\n\"; \n	else\n		cout << \"No\n\"; \n	if (obj.find(1) == obj.find(3)) \n		cout << \"Yes\n\"; \n	else\n		cout << \"No\n\"; \n\n	return 0; \n} \n\n', 1000, '', '', '/#include <iostream> \nusing namespace std; \nclass DisjSet { \n	int *rank, *parent, n; \n\npublic: \n	DisjSet(int n) \n	{ \n		rank = new int[n]; \n		parent = new int[n]; \n		this->n = n; \n		makeSet(); \n	} \n\n	void makeSet() \n	{ \n		for (int i = 0; i < n; i++) { \n			parent[i] = i; \n		} \n	} \n\n	int find(int x) \n	{ \n		if (parent[x] != x) { \n			parent[x] = find(parent[x]); \n		} \n\n		return parent[x]; \n	} \n\n\n	void Union(int x, int y) \n	{ \n		int xset = find(x); \n		int yset = find(y); \n\n		if (xset == yset) \n			return; \n\n		if (rank[xset] < rank[yset]) { \n			parent[xset] = yset; \n		} \n		else if (rank[xset] > rank[yset]) { \n			parent[yset] = xset; \n		} \n\n		else { \n			parent[yset] = xset; \n			rank[xset] = rank[xset] + 1; \n		} \n	} \n}; \n\nint main() \n{ \n    \n	DisjSet obj(6);\n	\n	obj.Union(4,5);\n	obj.Union(0, 2); \n	obj.Union(5, 3); \n	obj.Union(3, 1); \n	if (obj.find(4) == obj.find(5)) \n		cout << \"Yes\n\"; \n	else\n		cout << \"No\n\"; \n	if (obj.find(1) == obj.find(3)) \n		cout << \"Yes\n\"; \n	else\n		cout << \"No\n\"; \n\n	return 0; \n} \n\n', '2020-05-25');
INSERT INTO `qtos_map` (`ID`, `Q_ID`, `ROLL`, `SUBMISSION`, `SCORE`, `INPUT`, `OP`, `ALGO`, `DATE`) VALUES
(410, 12, 4901012018, '#include<bits/stdc++.h> \r\nusing namespace std; \r\n\r\ntypedef  pair<int, int> iPair; \r\n  \r\n// Structure to represent a graph \r\nstruct Graph \r\n{ \r\n    int V, E; \r\n    vector< pair<int, iPair> > edges; \r\n  \r\n    Graph(int V, int E) \r\n    { \r\n        this->V = V; \r\n        this->E = E; \r\n    } \r\n  \r\n   \r\n    void addEdge(int u, int v, int w) \r\n    { \r\n        edges.push_back({w, {u, v}}); \r\n    } \r\n  \r\n   \r\n    int kruskalMST(); \r\n}; \r\n  \r\n\r\nstruct DisjointSets \r\n{ \r\n    int *parent, *rnk; \r\n    int n; \r\n  \r\n    \r\n    DisjointSets(int n) \r\n    { \r\n        // Allocate memory \r\n        this->n = n; \r\n        parent = new int[n+1]; \r\n        rnk = new int[n+1]; \r\n  \r\n       \r\n        for (int i = 0; i <= n; i++) \r\n        { \r\n            rnk[i] = 0; \r\n  \r\n           \r\n            parent[i] = i; \r\n        } \r\n    } \r\n  \r\n  \r\n    int find(int u) \r\n    { \r\n        \r\n        if (u != parent[u]) \r\n            parent[u] = find(parent[u]); \r\n        return parent[u]; \r\n    } \r\n  \r\n   \r\n    void merge(int x, int y) \r\n    { \r\n        x = find(x), y = find(y); \r\n  \r\n        \r\n        if (rnk[x] > rnk[y]) \r\n            parent[y] = x; \r\n        else // If rnk[x] <= rnk[y] \r\n            parent[x] = y; \r\n  \r\n        if (rnk[x] == rnk[y]) \r\n            rnk[y]++; \r\n    } \r\n}; \r\n  \r\n \r\n  \r\nint Graph::kruskalMST() \r\n{ \r\n    int mst_wt = 0; // Initialize result \r\n  \r\n    \r\n    sort(edges.begin(), edges.end()); \r\n  \r\n   \r\n    DisjointSets ds(V); \r\n  \r\n    \r\n    vector< pair<int, iPair> >::iterator it; \r\n    for (it=edges.begin(); it!=edges.end(); it++) \r\n    { \r\n        int u = it->second.first; \r\n        int v = it->second.second; \r\n  \r\n        int set_u = ds.find(u); \r\n        int set_v = ds.find(v); \r\n  \r\n        \r\n        if (set_u != set_v) \r\n        { \r\n            \r\n            cout << u << \" - \" << v << endl; \r\n  \r\n            // Update MST weight \r\n            mst_wt += it->first; \r\n  \r\n            // Merge two sets \r\n            ds.merge(set_u, set_v); \r\n        } \r\n    } \r\n  \r\n    return mst_wt; \r\n} \r\n  \r\n\r\nint main() \r\n{ \r\n    \r\n    int V = 9, E = 14; \r\n    Graph g(V, E); \r\n  \r\n    //  making above shown graph \r\n    g.addEdge(0, 1, 4); \r\n    g.addEdge(0, 7, 8); \r\n    g.addEdge(1, 2, 8); \r\n    g.addEdge(1, 7, 11); \r\n    g.addEdge(2, 3, 7); \r\n    g.addEdge(2, 8, 2); \r\n    g.addEdge(2, 5, 4); \r\n    g.addEdge(3, 4, 9); \r\n    g.addEdge(3, 5, 14); \r\n    g.addEdge(4, 5, 10); \r\n    g.addEdge(5, 6, 2); \r\n    g.addEdge(6, 7, 1); \r\n    g.addEdge(6, 8, 6); \r\n    g.addEdge(7, 8, 7); \r\n  \r\n    cout << \"Edges of MST are \n\"; \r\n    int mst_wt = g.kruskalMST(); \r\n  \r\n    cout << \"\nWeight of MST is \" << mst_wt; \r\n  \r\n    return 0; \r\n}', 1000, '', '', '#include<bits/stdc++.h> \r\nusing namespace std; \r\n\r\ntypedef  pair<int, int> iPair; \r\n  \r\n// Structure to represent a graph \r\nstruct Graph \r\n{ \r\n    int V, E; \r\n    vector< pair<int, iPair> > edges; \r\n  \r\n    Graph(int V, int E) \r\n    { \r\n        this->V = V; \r\n        this->E = E; \r\n    } \r\n  \r\n   \r\n    void addEdge(int u, int v, int w) \r\n    { \r\n        edges.push_back({w, {u, v}}); \r\n    } \r\n  \r\n   \r\n    int kruskalMST(); \r\n}; \r\n  \r\n\r\nstruct DisjointSets \r\n{ \r\n    int *parent, *rnk; \r\n    int n; \r\n  \r\n    \r\n    DisjointSets(int n) \r\n    { \r\n        // Allocate memory \r\n        this->n = n; \r\n        parent = new int[n+1]; \r\n        rnk = new int[n+1]; \r\n  \r\n       \r\n        for (int i = 0; i <= n; i++) \r\n        { \r\n            rnk[i] = 0; \r\n  \r\n           \r\n            parent[i] = i; \r\n        } \r\n    } \r\n  \r\n  \r\n    int find(int u) \r\n    { \r\n        \r\n        if (u != parent[u]) \r\n            parent[u] = find(parent[u]); \r\n        return parent[u]; \r\n    } \r\n  \r\n   \r\n    void merge(int x, int y) \r\n    { \r\n        x = find(x), y = find(y); \r\n  \r\n        \r\n        if (rnk[x] > rnk[y]) \r\n            parent[y] = x; \r\n        else // If rnk[x] <= rnk[y] \r\n            parent[x] = y; \r\n  \r\n        if (rnk[x] == rnk[y]) \r\n            rnk[y]++; \r\n    } \r\n}; \r\n  \r\n \r\n  \r\nint Graph::kruskalMST() \r\n{ \r\n    int mst_wt = 0; // Initialize result \r\n  \r\n    \r\n    sort(edges.begin(), edges.end()); \r\n  \r\n   \r\n    DisjointSets ds(V); \r\n  \r\n    \r\n    vector< pair<int, iPair> >::iterator it; \r\n    for (it=edges.begin(); it!=edges.end(); it++) \r\n    { \r\n        int u = it->second.first; \r\n        int v = it->second.second; \r\n  \r\n        int set_u = ds.find(u); \r\n        int set_v = ds.find(v); \r\n  \r\n        \r\n        if (set_u != set_v) \r\n        { \r\n            \r\n            cout << u << \" - \" << v << endl; \r\n  \r\n            // Update MST weight \r\n            mst_wt += it->first; \r\n  \r\n            // Merge two sets \r\n            ds.merge(set_u, set_v); \r\n        } \r\n    } \r\n  \r\n    return mst_wt; \r\n} \r\n  \r\n\r\nint main() \r\n{ \r\n    \r\n    int V = 9, E = 14; \r\n    Graph g(V, E); \r\n  \r\n    //  making above shown graph \r\n    g.addEdge(0, 1, 4); \r\n    g.addEdge(0, 7, 8); \r\n    g.addEdge(1, 2, 8); \r\n    g.addEdge(1, 7, 11); \r\n    g.addEdge(2, 3, 7); \r\n    g.addEdge(2, 8, 2); \r\n    g.addEdge(2, 5, 4); \r\n    g.addEdge(3, 4, 9); \r\n    g.addEdge(3, 5, 14); \r\n    g.addEdge(4, 5, 10); \r\n    g.addEdge(5, 6, 2); \r\n    g.addEdge(6, 7, 1); \r\n    g.addEdge(6, 8, 6); \r\n    g.addEdge(7, 8, 7); \r\n  \r\n    cout << \"Edges of MST are \n\"; \r\n    int mst_wt = g.kruskalMST(); \r\n  \r\n    cout << \"\nWeight of MST is \" << mst_wt; \r\n  \r\n    return 0; \r\n}', '2020-05-25'),
(411, 13, 4901012018, ' #include <iostream>\r\n#include <conio.h>\r\nusing namespace std;\r\nstruct node\r\n{   \r\nint fr, to, cost;\r\n}p[n];\r\nint c = 0, temp1 = 0, temp = 0, n;\r\nvoid prims(int *a, int b[][n], int i, int j)\r\n{\r\n    a[i] = 1;\r\n    while (c < n)\r\n    {\r\n        int min = 999;\r\n        for (int i = 0; i < n; i++)\r\n        {\r\n            if (a[i] == 1)\r\n            {\r\n                for (int j = 0; j < n; )\r\n                {\r\n                    if (b[i][j] >= min || b[i][j] == 0)\r\n                    {\r\n                        j++;\r\n                    }\r\n                    else if (b[i][j] < min)\r\n                    {\r\n                        min = b[i][j];\r\n                        temp = i;\r\n                        temp1 = j;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        a[temp1] = 1;\r\n        p[c].fr = temp;\r\n        p[c].to = temp1;\r\n        p[c].cost = min;\r\n        c++;       \r\n        b[temp][temp1] = b[temp1][temp]=1000;\r\n    }\r\n    for (int k = 0; k < n-1; k++)\r\n    {\r\n        cout<<\"source node:\"<<p[k].fr<<endl;\r\n        cout<<\"destination node:\"<<p[k].to<<endl;\r\n        cout<<\"weight of node\"<<p[k].cost<<endl;\r\n    }\r\n}\r\nint main()\r\n{\r\n    cin>>n;\r\n    int a[n];\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        a[i] = 0;\r\n    }\r\n    int b[n][n];\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        cout<<\"enter values for \"<<(i+1)<<\" row\"<<endl;\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            cin>>b[i][j];\r\n        }\r\n    }\r\n    prims(a, b, 0, 0);\r\n    getch();\r\n}', 1000, '', '', ' #include <iostream>\r\n#include <conio.h>\r\nusing namespace std;\r\nstruct node\r\n{   \r\nint fr, to, cost;\r\n}p[n];\r\nint c = 0, temp1 = 0, temp = 0, n;\r\nvoid prims(int *a, int b[][n], int i, int j)\r\n{\r\n    a[i] = 1;\r\n    while (c < n)\r\n    {\r\n        int min = 999;\r\n        for (int i = 0; i < n; i++)\r\n        {\r\n            if (a[i] == 1)\r\n            {\r\n                for (int j = 0; j < n; )\r\n                {\r\n                    if (b[i][j] >= min || b[i][j] == 0)\r\n                    {\r\n                        j++;\r\n                    }\r\n                    else if (b[i][j] < min)\r\n                    {\r\n                        min = b[i][j];\r\n                        temp = i;\r\n                        temp1 = j;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        a[temp1] = 1;\r\n        p[c].fr = temp;\r\n        p[c].to = temp1;\r\n        p[c].cost = min;\r\n        c++;       \r\n        b[temp][temp1] = b[temp1][temp]=1000;\r\n    }\r\n    for (int k = 0; k < n-1; k++)\r\n    {\r\n        cout<<\"source node:\"<<p[k].fr<<endl;\r\n        cout<<\"destination node:\"<<p[k].to<<endl;\r\n        cout<<\"weight of node\"<<p[k].cost<<endl;\r\n    }\r\n}\r\nint main()\r\n{\r\n    cin>>n;\r\n    int a[n];\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        a[i] = 0;\r\n    }\r\n    int b[n][n];\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        cout<<\"enter values for \"<<(i+1)<<\" row\"<<endl;\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            cin>>b[i][j];\r\n        }\r\n    }\r\n    prims(a, b, 0, 0);\r\n    getch();\r\n}', '2020-05-25'),
(412, 14, 4901012018, '#include <iostream>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <limits.h>\r\n \r\nusing namespace std;\r\n \r\nstruct Edge\r\n{\r\n    \r\n    int source, destination, weight;\r\n};\r\n \r\n\r\nstruct Graph\r\n{\r\n    int V, E;\r\n	\r\n \r\n    struct Edge* edge;\r\n\r\n};\r\n \r\nstruct Graph* createGraph(int V, int E)\r\n{\r\n    struct Graph* graph = (struct Graph*) malloc( sizeof(struct Graph));\r\n	\r\n \r\n    graph->V = V;   \r\n \r\n    graph->E = E;\r\n \r\n    graph->edge = (struct Edge*) malloc( graph->E * sizeof( struct Edge ) );\r\n	\r\n \r\n    return graph;\r\n}\r\n \r\nvoid FinalSolution(int dist[], int n)\r\n{\r\n    cout<<\"\nVertex	Distance from Source Vertex\n\";\r\n    int i;\r\n \r\n    for (i = 0; i < n; ++i){\r\n		cout<<i<<\"		\"<<dist[i]<<\"\n\";\r\n	}\r\n}\r\n \r\nvoid BellmanFord(struct Graph* graph, int source)\r\n{\r\n    int V = graph->V;\r\n \r\n    int E = graph->E;\r\n \r\n    int StoreDistance[V];\r\n \r\n    int i,j;\r\n \r\n    // This is initial step that we know , we initialize all distance to infinity except source.\r\n	// We assign source distance as 0(zero)\r\n \r\n    for (i = 0; i < V; i++)\r\n        StoreDistance[i] = INT_MAX;\r\n \r\n    StoreDistance[source] = 0;\r\n \r\n    for (i = 1; i <= V-1; i++)\r\n    {\r\n        for (j = 0; j < E; j++)\r\n        {\r\n            int u = graph->edge[j].source;\r\n \r\n            int v = graph->edge[j].destination;\r\n \r\n            int weight = graph->edge[j].weight;\r\n \r\n            if (StoreDistance[u] + weight < StoreDistance[v])\r\n                StoreDistance[v] = StoreDistance[u] + weight;\r\n        }\r\n    }\r\n \r\n    \r\n    for (i = 0; i < E; i++)\r\n    {\r\n        int u = graph->edge[i].source;\r\n \r\n        int v = graph->edge[i].destination;\r\n \r\n        int weight = graph->edge[i].weight;\r\n \r\n        if (StoreDistance[u] + weight < StoreDistance[v])\r\n            cout<<\"\nThis graph contains negative edge cycle\n\";\r\n    }\r\n \r\n    FinalSolution(StoreDistance, V);\r\n \r\n    return;\r\n}\r\n \r\nint main()\r\n{\r\n    int V,E,S;  \r\n \r\n	cout<<\"Enter number of vertices in graph\n\";\r\n    cin>>V;\r\n \r\n	cout<<\"Enter number of edges in graph\n\";\r\n    cin>>E;\r\n \r\n	cout<<\"Enter your source vertex number\n\";\r\n	cin>>S;\r\n \r\n    struct Graph* graph = createGraph(V, E);    \r\n \r\n    int i;\r\n    for(i=0;i<E;i++){\r\n        cout<<\"\nEnter edge \"<<i+1<<\" properties Source, destination, weight respectively\n\";\r\n        cin>>graph->edge[i].source;\r\n        cin>>graph->edge[i].destination;\r\n        cin>>graph->edge[i].weight;\r\n    }\r\n \r\n    BellmanFord(graph, S);\r\n	\r\n \r\n    return 0;\r\n}', 1000, '', '', '#include <iostream>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <limits.h>\r\n \r\nusing namespace std;\r\n \r\nstruct Edge\r\n{\r\n    \r\n    int source, destination, weight;\r\n};\r\n \r\n\r\nstruct Graph\r\n{\r\n    int V, E;\r\n	\r\n \r\n    struct Edge* edge;\r\n\r\n};\r\n \r\nstruct Graph* createGraph(int V, int E)\r\n{\r\n    struct Graph* graph = (struct Graph*) malloc( sizeof(struct Graph));\r\n	\r\n \r\n    graph->V = V;   \r\n \r\n    graph->E = E;\r\n \r\n    graph->edge = (struct Edge*) malloc( graph->E * sizeof( struct Edge ) );\r\n	\r\n \r\n    return graph;\r\n}\r\n \r\nvoid FinalSolution(int dist[], int n)\r\n{\r\n    cout<<\"\nVertex	Distance from Source Vertex\n\";\r\n    int i;\r\n \r\n    for (i = 0; i < n; ++i){\r\n		cout<<i<<\"		\"<<dist[i]<<\"\n\";\r\n	}\r\n}\r\n \r\nvoid BellmanFord(struct Graph* graph, int source)\r\n{\r\n    int V = graph->V;\r\n \r\n    int E = graph->E;\r\n \r\n    int StoreDistance[V];\r\n \r\n    int i,j;\r\n \r\n    // This is initial step that we know , we initialize all distance to infinity except source.\r\n	// We assign source distance as 0(zero)\r\n \r\n    for (i = 0; i < V; i++)\r\n        StoreDistance[i] = INT_MAX;\r\n \r\n    StoreDistance[source] = 0;\r\n \r\n    for (i = 1; i <= V-1; i++)\r\n    {\r\n        for (j = 0; j < E; j++)\r\n        {\r\n            int u = graph->edge[j].source;\r\n \r\n            int v = graph->edge[j].destination;\r\n \r\n            int weight = graph->edge[j].weight;\r\n \r\n            if (StoreDistance[u] + weight < StoreDistance[v])\r\n                StoreDistance[v] = StoreDistance[u] + weight;\r\n        }\r\n    }\r\n \r\n    \r\n    for (i = 0; i < E; i++)\r\n    {\r\n        int u = graph->edge[i].source;\r\n \r\n        int v = graph->edge[i].destination;\r\n \r\n        int weight = graph->edge[i].weight;\r\n \r\n        if (StoreDistance[u] + weight < StoreDistance[v])\r\n            cout<<\"\nThis graph contains negative edge cycle\n\";\r\n    }\r\n \r\n    FinalSolution(StoreDistance, V);\r\n \r\n    return;\r\n}\r\n \r\nint main()\r\n{\r\n    int V,E,S;  \r\n \r\n	cout<<\"Enter number of vertices in graph\n\";\r\n    cin>>V;\r\n \r\n	cout<<\"Enter number of edges in graph\n\";\r\n    cin>>E;\r\n \r\n	cout<<\"Enter your source vertex number\n\";\r\n	cin>>S;\r\n \r\n    struct Graph* graph = createGraph(V, E);    \r\n \r\n    int i;\r\n    for(i=0;i<E;i++){\r\n        cout<<\"\nEnter edge \"<<i+1<<\" properties Source, destination, weight respectively\n\";\r\n        cin>>graph->edge[i].source;\r\n        cin>>graph->edge[i].destination;\r\n        cin>>graph->edge[i].weight;\r\n    }\r\n \r\n    BellmanFord(graph, S);\r\n	\r\n \r\n    return 0;\r\n}', '2020-05-25'),
(413, 15, 4901012018, '#include<iostream>\r\nusing namespace std;\r\n\r\nint matOrder(int array[], int n) {\r\n   int minMul[n][n];\r\n   for (int i=1; i<n; i++)\r\n      minMul[i][i] = 0;\r\n\r\n   for (int length=2; length<n; length++) {\r\n      for (int i=1; i<n-length+1; i++) {\r\n         int j = i+length-1;\r\n         minMul[i][j] = INT_MAX;\r\n         for (int k=i; k<=j-1; k++) {\r\n\r\n            int q = minMul[i][k] + minMul[k+1][j] + array[i- 1]*array[k]*array[j];\r\n            if (q < minMul[i][j])\r\n               minMul[i][j] = q;\r\n         }\r\n      }\r\n   }\r\n   return minMul[1][n-1];\r\n}\r\n\r\nint main() {\r\n\r\n   int size; cin>>size;\r\n   int arr[size];\r\n   for(int i=0;i<size;i++) cin>>arr[i];\r\n   cout << \"Minimum number of matrix multiplications: \" << matOrder(arr, size);\r\n}\r\n', 1000, '', '', '#include<iostream>\r\nusing namespace std;\r\n\r\nint matOrder(int array[], int n) {\r\n   int minMul[n][n];\r\n   for (int i=1; i<n; i++)\r\n      minMul[i][i] = 0;\r\n\r\n   for (int length=2; length<n; length++) {\r\n      for (int i=1; i<n-length+1; i++) {\r\n         int j = i+length-1;\r\n         minMul[i][j] = INT_MAX;\r\n         for (int k=i; k<=j-1; k++) {\r\n\r\n            int q = minMul[i][k] + minMul[k+1][j] + array[i- 1]*array[k]*array[j];\r\n            if (q < minMul[i][j])\r\n               minMul[i][j] = q;\r\n         }\r\n      }\r\n   }\r\n   return minMul[1][n-1];\r\n}\r\n\r\nint main() {\r\n\r\n   int size; cin>>size;\r\n   int arr[size];\r\n   for(int i=0;i<size;i++) cin>>arr[i];\r\n   cout << \"Minimum number of matrix multiplications: \" << matOrder(arr, size);\r\n}\r\n', '2020-05-25'),
(414, 4, 4901012018, '#include<stdio.h>\r\nstruct pair\r\n{\r\n  int min;\r\n  int max;\r\n};\r\n\r\nstruct pair getMinMax(int arr[], int low, int high)\r\n{\r\n  struct pair minmax, mml, mmr;\r\n  int mid;\r\n\r\n  if (low == high)\r\n  {\r\n     minmax.max = arr[low];\r\n     minmax.min = arr[low];\r\n     return minmax;\r\n  }\r\n\r\n  if (high == low + 1)\r\n  {\r\n     if (arr[low] > arr[high])\r\n     {\r\n        minmax.max = arr[low];\r\n        minmax.min = arr[high];\r\n     }\r\n     else\r\n     {\r\n        minmax.max = arr[high];\r\n        minmax.min = arr[low];\r\n     }\r\n     return minmax;\r\n  }\r\n\r\n  mid = (low + high)/2;\r\n  mml = getMinMax(arr, low, mid);\r\n  mmr = getMinMax(arr, mid+1, high);\r\n\r\n\r\n  if (mml.min < mmr.min)\r\n    minmax.min = mml.min;\r\n  else\r\n    minmax.min = mmr.min;\r\n\r\n\r\n  if (mml.max > mmr.max)\r\n    minmax.max = mml.max;\r\n  else\r\n    minmax.max = mmr.max;\r\n\r\n  return minmax;\r\n}\r\n\r\n\r\nint main()\r\n{\r\n  int arr_size;\r\n  scanf(\"%d\",&arr_size);\r\n  int arr[arr_size];\r\n  for(int i=0;i<arr_size;i++) scanf(\"%d\",&arr[i]);\r\n  struct pair minmax = getMinMax(arr, 0, arr_size-1);\r\n  printf(\"Minimum element is %d\", minmax.min);\r\n  printf(\"\n\");\r\n  printf(\"Maximum element is %d\", minmax.max);\r\n  getchar();\r\n}\r\n', 0, '6 1000 11 445 1 330 3000', 'Minimum element is 1\nMaximum element is 3000', '#include<stdio.h>\r\nstruct pair\r\n{\r\n  int min;\r\n  int max;\r\n};\r\n\r\nstruct pair getMinMax(int arr[], int low, int high)\r\n{\r\n  struct pair minmax, mml, mmr;\r\n  int mid;\r\n\r\n  if (low == high)\r\n  {\r\n     minmax.max = arr[low];\r\n     minmax.min = arr[low];\r\n     return minmax;\r\n  }\r\n\r\n  if (high == low + 1)\r\n  {\r\n     if (arr[low] > arr[high])\r\n     {\r\n        minmax.max = arr[low];\r\n        minmax.min = arr[high];\r\n     }\r\n     else\r\n     {\r\n        minmax.max = arr[high];\r\n        minmax.min = arr[low];\r\n     }\r\n     return minmax;\r\n  }\r\n\r\n  mid = (low + high)/2;\r\n  mml = getMinMax(arr, low, mid);\r\n  mmr = getMinMax(arr, mid+1, high);\r\n\r\n\r\n  if (mml.min < mmr.min)\r\n    minmax.min = mml.min;\r\n  else\r\n    minmax.min = mmr.min;\r\n\r\n\r\n  if (mml.max > mmr.max)\r\n    minmax.max = mml.max;\r\n  else\r\n    minmax.max = mmr.max;\r\n\r\n  return minmax;\r\n}\r\n\r\n\r\nint main()\r\n{\r\n  int arr_size;\r\n  scanf(\"%d\",&arr_size);\r\n  int arr[arr_size];\r\n  for(int i=0;i<arr_size;i++) scanf(\"%d\",&arr[i]);\r\n  struct pair minmax = getMinMax(arr, 0, arr_size-1);\r\n  printf(\"Minimum element is %d\", minmax.min);\r\n  printf(\"\n\");\r\n  printf(\"Maximum element is %d\", minmax.max);\r\n  getchar();\r\n}\r\n', '2020-05-25'),
(415, 8, 4901012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\ntypedef long long lld; \r\n\r\n  \r\ninline lld** MatrixMultiply(lld** a, lld** b, int n, \r\n                                      int l, int m) \r\n{ \r\n    lld** c = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        c[i] = new lld[m]; \r\n  \r\n    for (int i = 0; i < n; i++) { \r\n        for (int j = 0; j < m; j++) { \r\n            c[i][j] = 0; \r\n            for (int k = 0; k < l; k++) { \r\n                c[i][j] += a[i][k] * b[k][j]; \r\n            } \r\n        } \r\n    } \r\n    return c; \r\n} \r\n  \r\ninline lld** Strassen(lld** a, lld** b, int n,  \r\n                                int l, int m) \r\n{ \r\n    if (n == 1 || l == 1 || m == 1)  \r\n        return MatrixMultiply(a, b, n, l, m); \r\n  \r\n    lld** c = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        c[i] = new lld[m]; \r\n  \r\n    int adjN = (n >> 1) + (n & 1); \r\n    int adjL = (l >> 1) + (l & 1); \r\n    int adjM = (m >> 1) + (m & 1); \r\n  \r\n    lld**** As = new lld***[2]; \r\n    for (int x = 0; x < 2; x++) { \r\n        As[x] = new lld**[2]; \r\n        for (int y = 0; y < 2; y++) { \r\n            As[x][y] = new lld*[adjN]; \r\n            for (int i = 0; i < adjN; i++) { \r\n                As[x][y][i] = new lld[adjL]; \r\n                for (int j = 0; j < adjL; j++) { \r\n                    int I = i + (x & 1) * adjN; \r\n                    int J = j + (y & 1) * adjL; \r\n                    As[x][y][i][j] = (I < n && J < l) ? a[I][J] : 0; \r\n                } \r\n            } \r\n        } \r\n    } \r\n  \r\n    lld**** Bs = new lld***[2]; \r\n    for (int x = 0; x < 2; x++) { \r\n        Bs[x] = new lld**[2]; \r\n        for (int y = 0; y < 2; y++) { \r\n            Bs[x][y] = new lld*[adjN]; \r\n            for (int i = 0; i < adjL; i++) { \r\n                Bs[x][y][i] = new lld[adjM]; \r\n                for (int j = 0; j < adjM; j++) { \r\n                    int I = i + (x & 1) * adjL; \r\n                    int J = j + (y & 1) * adjM; \r\n                    Bs[x][y][i][j] = (I < l && J < m) ? b[I][J] : 0; \r\n                } \r\n            } \r\n        } \r\n    } \r\n  \r\n    lld*** s = new lld**[10]; \r\n    for (int i = 0; i < 10; i++) { \r\n        switch (i) { \r\n        case 0: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][1][j][k] - Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 1: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] + As[0][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 2: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[1][0][j][k] + As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 3: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[1][0][j][k] - Bs[0][0][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 4: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] + As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 5: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 6: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][1][j][k] - As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 7: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[1][0][j][k] + Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 8: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] - As[1][0][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 9: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[0][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        } \r\n    } \r\n  \r\n    lld*** p = new lld**[7]; \r\n    p[0] = Strassen(As[0][0], s[0], adjN, adjL, adjM); \r\n    p[1] = Strassen(s[1], Bs[1][1], adjN, adjL, adjM); \r\n    p[2] = Strassen(s[2], Bs[0][0], adjN, adjL, adjM); \r\n    p[3] = Strassen(As[1][1], s[3], adjN, adjL, adjM); \r\n    p[4] = Strassen(s[4], s[5], adjN, adjL, adjM); \r\n    p[5] = Strassen(s[6], s[7], adjN, adjL, adjM); \r\n    p[6] = Strassen(s[8], s[9], adjN, adjL, adjM); \r\n  \r\n    for (int i = 0; i < adjN; i++) { \r\n        for (int j = 0; j < adjM; j++) { \r\n            c[i][j] = p[4][i][j] + p[3][i][j] - p[1][i][j] + p[5][i][j]; \r\n            if (j + adjM < m) \r\n                c[i][j + adjM] = p[0][i][j] + p[1][i][j]; \r\n            if (i + adjN < n) \r\n                c[i + adjN][j] = p[2][i][j] + p[3][i][j]; \r\n            if (i + adjN < n && j + adjM < m) \r\n                c[i + adjN][j + adjM] = p[4][i][j] + p[0][i][j] - p[2][i][j] - p[6][i][j]; \r\n        } \r\n    } \r\n  \r\n    for (int x = 0; x < 2; x++) { \r\n        for (int y = 0; y < 2; y++) { \r\n            for (int i = 0; i < adjN; i++) { \r\n                delete[] As[x][y][i]; \r\n            } \r\n            delete[] As[x][y]; \r\n        } \r\n        delete[] As[x]; \r\n    } \r\n    delete[] As; \r\n  \r\n    for (int x = 0; x < 2; x++) { \r\n        for (int y = 0; y < 2; y++) { \r\n            for (int i = 0; i < adjL; i++) { \r\n                delete[] Bs[x][y][i]; \r\n            } \r\n            delete[] Bs[x][y]; \r\n        } \r\n        delete[] Bs[x]; \r\n    } \r\n    delete[] Bs; \r\n  \r\n    for (int i = 0; i < 10; i++) { \r\n        switch (i) { \r\n        case 0: \r\n        case 3: \r\n        case 5: \r\n        case 7: \r\n        case 9: \r\n            for (int j = 0; j < adjL; j++) { \r\n                delete[] s[i][j]; \r\n            } \r\n            break; \r\n        case 1: \r\n        case 2: \r\n        case 4: \r\n        case 6: \r\n        case 8: \r\n            for (int j = 0; j < adjN; j++) { \r\n                delete[] s[i][j]; \r\n            } \r\n            break; \r\n        } \r\n        delete[] s[i]; \r\n    } \r\n    delete[] s; \r\n  \r\n    for (int i = 0; i < 7; i++) { \r\n        for (int j = 0; j < (n >> 1); j++) { \r\n            delete[] p[i][j]; \r\n        } \r\n        delete[] p[i]; \r\n    } \r\n    delete[] p; \r\n  \r\n    return c; \r\n} \r\n  \r\nint main() \r\n{ \r\n    lld** matA; \r\n    matA = new lld*[2]; \r\nint n; cin>>n;\r\n    for (int i = 0; i < n; i++) \r\n        matA[i] = new lld[n]; \r\n    for(int i=0;i<n;i++)\r\n{\r\n     for(int j=0;j<n;j++) cin>>matA[i][j];\r\n}\r\n    \r\n  \r\n    lld** matB; \r\n    matB = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        matB[i] = new lld[n]; \r\n    for(int i=0;i<n;i++)\r\n{\r\n    for(int j=0;j<n;j++) cin>>matB[i][j];\r\n}\r\n  \r\n    lld** matC = Strassen(matA, matB, n, n, n); \r\n    for (int i = 0; i < n; i++) { \r\n        for (int j = 0; j < n; j++) { \r\n            printf(\"%lld \", matC[i][j]); \r\n        } \r\n        printf(\"\n\"); \r\n    } \r\n  \r\n    return 0; \r\n}', 0, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '', '#include <bits/stdc++.h> \r\nusing namespace std; \r\ntypedef long long lld; \r\n\r\n  \r\ninline lld** MatrixMultiply(lld** a, lld** b, int n, \r\n                                      int l, int m) \r\n{ \r\n    lld** c = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        c[i] = new lld[m]; \r\n  \r\n    for (int i = 0; i < n; i++) { \r\n        for (int j = 0; j < m; j++) { \r\n            c[i][j] = 0; \r\n            for (int k = 0; k < l; k++) { \r\n                c[i][j] += a[i][k] * b[k][j]; \r\n            } \r\n        } \r\n    } \r\n    return c; \r\n} \r\n  \r\ninline lld** Strassen(lld** a, lld** b, int n,  \r\n                                int l, int m) \r\n{ \r\n    if (n == 1 || l == 1 || m == 1)  \r\n        return MatrixMultiply(a, b, n, l, m); \r\n  \r\n    lld** c = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        c[i] = new lld[m]; \r\n  \r\n    int adjN = (n >> 1) + (n & 1); \r\n    int adjL = (l >> 1) + (l & 1); \r\n    int adjM = (m >> 1) + (m & 1); \r\n  \r\n    lld**** As = new lld***[2]; \r\n    for (int x = 0; x < 2; x++) { \r\n        As[x] = new lld**[2]; \r\n        for (int y = 0; y < 2; y++) { \r\n            As[x][y] = new lld*[adjN]; \r\n            for (int i = 0; i < adjN; i++) { \r\n                As[x][y][i] = new lld[adjL]; \r\n                for (int j = 0; j < adjL; j++) { \r\n                    int I = i + (x & 1) * adjN; \r\n                    int J = j + (y & 1) * adjL; \r\n                    As[x][y][i][j] = (I < n && J < l) ? a[I][J] : 0; \r\n                } \r\n            } \r\n        } \r\n    } \r\n  \r\n    lld**** Bs = new lld***[2]; \r\n    for (int x = 0; x < 2; x++) { \r\n        Bs[x] = new lld**[2]; \r\n        for (int y = 0; y < 2; y++) { \r\n            Bs[x][y] = new lld*[adjN]; \r\n            for (int i = 0; i < adjL; i++) { \r\n                Bs[x][y][i] = new lld[adjM]; \r\n                for (int j = 0; j < adjM; j++) { \r\n                    int I = i + (x & 1) * adjL; \r\n                    int J = j + (y & 1) * adjM; \r\n                    Bs[x][y][i][j] = (I < l && J < m) ? b[I][J] : 0; \r\n                } \r\n            } \r\n        } \r\n    } \r\n  \r\n    lld*** s = new lld**[10]; \r\n    for (int i = 0; i < 10; i++) { \r\n        switch (i) { \r\n        case 0: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][1][j][k] - Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 1: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] + As[0][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 2: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[1][0][j][k] + As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 3: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[1][0][j][k] - Bs[0][0][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 4: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] + As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 5: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 6: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][1][j][k] - As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 7: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[1][0][j][k] + Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 8: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] - As[1][0][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 9: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[0][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        } \r\n    } \r\n  \r\n    lld*** p = new lld**[7]; \r\n    p[0] = Strassen(As[0][0], s[0], adjN, adjL, adjM); \r\n    p[1] = Strassen(s[1], Bs[1][1], adjN, adjL, adjM); \r\n    p[2] = Strassen(s[2], Bs[0][0], adjN, adjL, adjM); \r\n    p[3] = Strassen(As[1][1], s[3], adjN, adjL, adjM); \r\n    p[4] = Strassen(s[4], s[5], adjN, adjL, adjM); \r\n    p[5] = Strassen(s[6], s[7], adjN, adjL, adjM); \r\n    p[6] = Strassen(s[8], s[9], adjN, adjL, adjM); \r\n  \r\n    for (int i = 0; i < adjN; i++) { \r\n        for (int j = 0; j < adjM; j++) { \r\n            c[i][j] = p[4][i][j] + p[3][i][j] - p[1][i][j] + p[5][i][j]; \r\n            if (j + adjM < m) \r\n                c[i][j + adjM] = p[0][i][j] + p[1][i][j]; \r\n            if (i + adjN < n) \r\n                c[i + adjN][j] = p[2][i][j] + p[3][i][j]; \r\n            if (i + adjN < n && j + adjM < m) \r\n                c[i + adjN][j + adjM] = p[4][i][j] + p[0][i][j] - p[2][i][j] - p[6][i][j]; \r\n        } \r\n    } \r\n  \r\n    for (int x = 0; x < 2; x++) { \r\n        for (int y = 0; y < 2; y++) { \r\n            for (int i = 0; i < adjN; i++) { \r\n                delete[] As[x][y][i]; \r\n            } \r\n            delete[] As[x][y]; \r\n        } \r\n        delete[] As[x]; \r\n    } \r\n    delete[] As; \r\n  \r\n    for (int x = 0; x < 2; x++) { \r\n        for (int y = 0; y < 2; y++) { \r\n            for (int i = 0; i < adjL; i++) { \r\n                delete[] Bs[x][y][i]; \r\n            } \r\n            delete[] Bs[x][y]; \r\n        } \r\n        delete[] Bs[x]; \r\n    } \r\n    delete[] Bs; \r\n  \r\n    for (int i = 0; i < 10; i++) { \r\n        switch (i) { \r\n        case 0: \r\n        case 3: \r\n        case 5: \r\n        case 7: \r\n        case 9: \r\n            for (int j = 0; j < adjL; j++) { \r\n                delete[] s[i][j]; \r\n            } \r\n            break; \r\n        case 1: \r\n        case 2: \r\n        case 4: \r\n        case 6: \r\n        case 8: \r\n            for (int j = 0; j < adjN; j++) { \r\n                delete[] s[i][j]; \r\n            } \r\n            break; \r\n        } \r\n        delete[] s[i]; \r\n    } \r\n    delete[] s; \r\n  \r\n    for (int i = 0; i < 7; i++) { \r\n        for (int j = 0; j < (n >> 1); j++) { \r\n            delete[] p[i][j]; \r\n        } \r\n        delete[] p[i]; \r\n    } \r\n    delete[] p; \r\n  \r\n    return c; \r\n} \r\n  \r\nint main() \r\n{ \r\n    lld** matA; \r\n    matA = new lld*[2]; \r\nint n; cin>>n;\r\n    for (int i = 0; i < n; i++) \r\n        matA[i] = new lld[n]; \r\n    for(int i=0;i<n;i++)\r\n{\r\n     for(int j=0;j<n;j++) cin>>matA[i][j];\r\n}\r\n    \r\n  \r\n    lld** matB; \r\n    matB = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        matB[i] = new lld[n]; \r\n    for(int i=0;i<n;i++)\r\n{\r\n    for(int j=0;j<n;j++) cin>>matB[i][j];\r\n}\r\n  \r\n    lld** matC = Strassen(matA, matB, n, n, n); \r\n    for (int i = 0; i < n; i++) { \r\n        for (int j = 0; j < n; j++) { \r\n            printf(\"%lld \", matC[i][j]); \r\n        } \r\n        printf(\"\n\"); \r\n    } \r\n  \r\n    return 0; \r\n}', '2020-05-25');
INSERT INTO `qtos_map` (`ID`, `Q_ID`, `ROLL`, `SUBMISSION`, `SCORE`, `INPUT`, `OP`, `ALGO`, `DATE`) VALUES
(416, 5, 4901012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\ntypedef long long lld; \r\n\r\n  \r\ninline lld** MatrixMultiply(lld** a, lld** b, int n, \r\n                                      int l, int m) \r\n{ \r\n    lld** c = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        c[i] = new lld[m]; \r\n  \r\n    for (int i = 0; i < n; i++) { \r\n        for (int j = 0; j < m; j++) { \r\n            c[i][j] = 0; \r\n            for (int k = 0; k < l; k++) { \r\n                c[i][j] += a[i][k] * b[k][j]; \r\n            } \r\n        } \r\n    } \r\n    return c; \r\n} \r\n  \r\ninline lld** Strassen(lld** a, lld** b, int n,  \r\n                                int l, int m) \r\n{ \r\n    if (n == 1 || l == 1 || m == 1)  \r\n        return MatrixMultiply(a, b, n, l, m); \r\n  \r\n    lld** c = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        c[i] = new lld[m]; \r\n  \r\n    int adjN = (n >> 1) + (n & 1); \r\n    int adjL = (l >> 1) + (l & 1); \r\n    int adjM = (m >> 1) + (m & 1); \r\n  \r\n    lld**** As = new lld***[2]; \r\n    for (int x = 0; x < 2; x++) { \r\n        As[x] = new lld**[2]; \r\n        for (int y = 0; y < 2; y++) { \r\n            As[x][y] = new lld*[adjN]; \r\n            for (int i = 0; i < adjN; i++) { \r\n                As[x][y][i] = new lld[adjL]; \r\n                for (int j = 0; j < adjL; j++) { \r\n                    int I = i + (x & 1) * adjN; \r\n                    int J = j + (y & 1) * adjL; \r\n                    As[x][y][i][j] = (I < n && J < l) ? a[I][J] : 0; \r\n                } \r\n            } \r\n        } \r\n    } \r\n  \r\n    lld**** Bs = new lld***[2]; \r\n    for (int x = 0; x < 2; x++) { \r\n        Bs[x] = new lld**[2]; \r\n        for (int y = 0; y < 2; y++) { \r\n            Bs[x][y] = new lld*[adjN]; \r\n            for (int i = 0; i < adjL; i++) { \r\n                Bs[x][y][i] = new lld[adjM]; \r\n                for (int j = 0; j < adjM; j++) { \r\n                    int I = i + (x & 1) * adjL; \r\n                    int J = j + (y & 1) * adjM; \r\n                    Bs[x][y][i][j] = (I < l && J < m) ? b[I][J] : 0; \r\n                } \r\n            } \r\n        } \r\n    } \r\n  \r\n    lld*** s = new lld**[10]; \r\n    for (int i = 0; i < 10; i++) { \r\n        switch (i) { \r\n        case 0: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][1][j][k] - Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 1: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] + As[0][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 2: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[1][0][j][k] + As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 3: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[1][0][j][k] - Bs[0][0][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 4: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] + As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 5: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 6: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][1][j][k] - As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 7: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[1][0][j][k] + Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 8: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] - As[1][0][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 9: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[0][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        } \r\n    } \r\n  \r\n    lld*** p = new lld**[7]; \r\n    p[0] = Strassen(As[0][0], s[0], adjN, adjL, adjM); \r\n    p[1] = Strassen(s[1], Bs[1][1], adjN, adjL, adjM); \r\n    p[2] = Strassen(s[2], Bs[0][0], adjN, adjL, adjM); \r\n    p[3] = Strassen(As[1][1], s[3], adjN, adjL, adjM); \r\n    p[4] = Strassen(s[4], s[5], adjN, adjL, adjM); \r\n    p[5] = Strassen(s[6], s[7], adjN, adjL, adjM); \r\n    p[6] = Strassen(s[8], s[9], adjN, adjL, adjM); \r\n  \r\n    for (int i = 0; i < adjN; i++) { \r\n        for (int j = 0; j < adjM; j++) { \r\n            c[i][j] = p[4][i][j] + p[3][i][j] - p[1][i][j] + p[5][i][j]; \r\n            if (j + adjM < m) \r\n                c[i][j + adjM] = p[0][i][j] + p[1][i][j]; \r\n            if (i + adjN < n) \r\n                c[i + adjN][j] = p[2][i][j] + p[3][i][j]; \r\n            if (i + adjN < n && j + adjM < m) \r\n                c[i + adjN][j + adjM] = p[4][i][j] + p[0][i][j] - p[2][i][j] - p[6][i][j]; \r\n        } \r\n    } \r\n  \r\n    for (int x = 0; x < 2; x++) { \r\n        for (int y = 0; y < 2; y++) { \r\n            for (int i = 0; i < adjN; i++) { \r\n                delete[] As[x][y][i]; \r\n            } \r\n            delete[] As[x][y]; \r\n        } \r\n        delete[] As[x]; \r\n    } \r\n    delete[] As; \r\n  \r\n    for (int x = 0; x < 2; x++) { \r\n        for (int y = 0; y < 2; y++) { \r\n            for (int i = 0; i < adjL; i++) { \r\n                delete[] Bs[x][y][i]; \r\n            } \r\n            delete[] Bs[x][y]; \r\n        } \r\n        delete[] Bs[x]; \r\n    } \r\n    delete[] Bs; \r\n  \r\n    for (int i = 0; i < 10; i++) { \r\n        switch (i) { \r\n        case 0: \r\n        case 3: \r\n        case 5: \r\n        case 7: \r\n        case 9: \r\n            for (int j = 0; j < adjL; j++) { \r\n                delete[] s[i][j]; \r\n            } \r\n            break; \r\n        case 1: \r\n        case 2: \r\n        case 4: \r\n        case 6: \r\n        case 8: \r\n            for (int j = 0; j < adjN; j++) { \r\n                delete[] s[i][j]; \r\n            } \r\n            break; \r\n        } \r\n        delete[] s[i]; \r\n    } \r\n    delete[] s; \r\n  \r\n    for (int i = 0; i < 7; i++) { \r\n        for (int j = 0; j < (n >> 1); j++) { \r\n            delete[] p[i][j]; \r\n        } \r\n        delete[] p[i]; \r\n    } \r\n    delete[] p; \r\n  \r\n    return c; \r\n} \r\n  \r\nint main() \r\n{ \r\n    lld** matA; \r\n    matA = new lld*[2]; \r\nint n; cin>>n;\r\n    for (int i = 0; i < n; i++) \r\n        matA[i] = new lld[n]; \r\n    for(int i=0;i<n;i++)\r\n{\r\n     for(int j=0;j<n;j++) cin>>matA[i][j];\r\n}\r\n    \r\n  \r\n    lld** matB; \r\n    matB = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        matB[i] = new lld[n]; \r\n    for(int i=0;i<n;i++)\r\n{\r\n    for(int j=0;j<n;j++) cin>>matB[i][j];\r\n}\r\n  \r\n    lld** matC = Strassen(matA, matB, n, n, n); \r\n    for (int i = 0; i < n; i++) { \r\n        for (int j = 0; j < n; j++) { \r\n            printf(\"%lld \", matC[i][j]); \r\n        } \r\n        printf(\"\n\"); \r\n    } \r\n  \r\n    return 0; \r\n}', 1000, '', '', '#include <bits/stdc++.h> \r\nusing namespace std; \r\ntypedef long long lld; \r\n\r\n  \r\ninline lld** MatrixMultiply(lld** a, lld** b, int n, \r\n                                      int l, int m) \r\n{ \r\n    lld** c = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        c[i] = new lld[m]; \r\n  \r\n    for (int i = 0; i < n; i++) { \r\n        for (int j = 0; j < m; j++) { \r\n            c[i][j] = 0; \r\n            for (int k = 0; k < l; k++) { \r\n                c[i][j] += a[i][k] * b[k][j]; \r\n            } \r\n        } \r\n    } \r\n    return c; \r\n} \r\n  \r\ninline lld** Strassen(lld** a, lld** b, int n,  \r\n                                int l, int m) \r\n{ \r\n    if (n == 1 || l == 1 || m == 1)  \r\n        return MatrixMultiply(a, b, n, l, m); \r\n  \r\n    lld** c = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        c[i] = new lld[m]; \r\n  \r\n    int adjN = (n >> 1) + (n & 1); \r\n    int adjL = (l >> 1) + (l & 1); \r\n    int adjM = (m >> 1) + (m & 1); \r\n  \r\n    lld**** As = new lld***[2]; \r\n    for (int x = 0; x < 2; x++) { \r\n        As[x] = new lld**[2]; \r\n        for (int y = 0; y < 2; y++) { \r\n            As[x][y] = new lld*[adjN]; \r\n            for (int i = 0; i < adjN; i++) { \r\n                As[x][y][i] = new lld[adjL]; \r\n                for (int j = 0; j < adjL; j++) { \r\n                    int I = i + (x & 1) * adjN; \r\n                    int J = j + (y & 1) * adjL; \r\n                    As[x][y][i][j] = (I < n && J < l) ? a[I][J] : 0; \r\n                } \r\n            } \r\n        } \r\n    } \r\n  \r\n    lld**** Bs = new lld***[2]; \r\n    for (int x = 0; x < 2; x++) { \r\n        Bs[x] = new lld**[2]; \r\n        for (int y = 0; y < 2; y++) { \r\n            Bs[x][y] = new lld*[adjN]; \r\n            for (int i = 0; i < adjL; i++) { \r\n                Bs[x][y][i] = new lld[adjM]; \r\n                for (int j = 0; j < adjM; j++) { \r\n                    int I = i + (x & 1) * adjL; \r\n                    int J = j + (y & 1) * adjM; \r\n                    Bs[x][y][i][j] = (I < l && J < m) ? b[I][J] : 0; \r\n                } \r\n            } \r\n        } \r\n    } \r\n  \r\n    lld*** s = new lld**[10]; \r\n    for (int i = 0; i < 10; i++) { \r\n        switch (i) { \r\n        case 0: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][1][j][k] - Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 1: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] + As[0][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 2: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[1][0][j][k] + As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 3: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[1][0][j][k] - Bs[0][0][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 4: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] + As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 5: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 6: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][1][j][k] - As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 7: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[1][0][j][k] + Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 8: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] - As[1][0][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 9: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[0][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        } \r\n    } \r\n  \r\n    lld*** p = new lld**[7]; \r\n    p[0] = Strassen(As[0][0], s[0], adjN, adjL, adjM); \r\n    p[1] = Strassen(s[1], Bs[1][1], adjN, adjL, adjM); \r\n    p[2] = Strassen(s[2], Bs[0][0], adjN, adjL, adjM); \r\n    p[3] = Strassen(As[1][1], s[3], adjN, adjL, adjM); \r\n    p[4] = Strassen(s[4], s[5], adjN, adjL, adjM); \r\n    p[5] = Strassen(s[6], s[7], adjN, adjL, adjM); \r\n    p[6] = Strassen(s[8], s[9], adjN, adjL, adjM); \r\n  \r\n    for (int i = 0; i < adjN; i++) { \r\n        for (int j = 0; j < adjM; j++) { \r\n            c[i][j] = p[4][i][j] + p[3][i][j] - p[1][i][j] + p[5][i][j]; \r\n            if (j + adjM < m) \r\n                c[i][j + adjM] = p[0][i][j] + p[1][i][j]; \r\n            if (i + adjN < n) \r\n                c[i + adjN][j] = p[2][i][j] + p[3][i][j]; \r\n            if (i + adjN < n && j + adjM < m) \r\n                c[i + adjN][j + adjM] = p[4][i][j] + p[0][i][j] - p[2][i][j] - p[6][i][j]; \r\n        } \r\n    } \r\n  \r\n    for (int x = 0; x < 2; x++) { \r\n        for (int y = 0; y < 2; y++) { \r\n            for (int i = 0; i < adjN; i++) { \r\n                delete[] As[x][y][i]; \r\n            } \r\n            delete[] As[x][y]; \r\n        } \r\n        delete[] As[x]; \r\n    } \r\n    delete[] As; \r\n  \r\n    for (int x = 0; x < 2; x++) { \r\n        for (int y = 0; y < 2; y++) { \r\n            for (int i = 0; i < adjL; i++) { \r\n                delete[] Bs[x][y][i]; \r\n            } \r\n            delete[] Bs[x][y]; \r\n        } \r\n        delete[] Bs[x]; \r\n    } \r\n    delete[] Bs; \r\n  \r\n    for (int i = 0; i < 10; i++) { \r\n        switch (i) { \r\n        case 0: \r\n        case 3: \r\n        case 5: \r\n        case 7: \r\n        case 9: \r\n            for (int j = 0; j < adjL; j++) { \r\n                delete[] s[i][j]; \r\n            } \r\n            break; \r\n        case 1: \r\n        case 2: \r\n        case 4: \r\n        case 6: \r\n        case 8: \r\n            for (int j = 0; j < adjN; j++) { \r\n                delete[] s[i][j]; \r\n            } \r\n            break; \r\n        } \r\n        delete[] s[i]; \r\n    } \r\n    delete[] s; \r\n  \r\n    for (int i = 0; i < 7; i++) { \r\n        for (int j = 0; j < (n >> 1); j++) { \r\n            delete[] p[i][j]; \r\n        } \r\n        delete[] p[i]; \r\n    } \r\n    delete[] p; \r\n  \r\n    return c; \r\n} \r\n  \r\nint main() \r\n{ \r\n    lld** matA; \r\n    matA = new lld*[2]; \r\nint n; cin>>n;\r\n    for (int i = 0; i < n; i++) \r\n        matA[i] = new lld[n]; \r\n    for(int i=0;i<n;i++)\r\n{\r\n     for(int j=0;j<n;j++) cin>>matA[i][j];\r\n}\r\n    \r\n  \r\n    lld** matB; \r\n    matB = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        matB[i] = new lld[n]; \r\n    for(int i=0;i<n;i++)\r\n{\r\n    for(int j=0;j<n;j++) cin>>matB[i][j];\r\n}\r\n  \r\n    lld** matC = Strassen(matA, matB, n, n, n); \r\n    for (int i = 0; i < n; i++) { \r\n        for (int j = 0; j < n; j++) { \r\n            printf(\"%lld \", matC[i][j]); \r\n        } \r\n        printf(\"\n\"); \r\n    } \r\n  \r\n    return 0; \r\n}', '2020-05-25'),
(417, 16, 4901012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n  \r\n/\r\n#define d 256  \r\n  \r\n\r\nvoid search(char pat[], char txt[], int q)  \r\n{  \r\n    int M = strlen(pat);  \r\n    int N = strlen(txt);  \r\n    int i, j;  \r\n    int p = 0; // hash value for pattern  \r\n    int t = 0; // hash value for txt  \r\n    int h = 1;  \r\n  \r\n    // The value of h would be \"pow(d, M-1)%q\"  \r\n    for (i = 0; i < M - 1; i++)  \r\n        h = (h * d) % q;  \r\n  \r\n    for (i = 0; i < M; i++)  \r\n    {  \r\n        p = (d * p + pat[i]) % q;  \r\n        t = (d * t + txt[i]) % q;  \r\n    }  \r\n  \r\n    // Slide the pattern over text one by one  \r\n    for (i = 0; i <= N - M; i++)  \r\n    {  \r\n  \r\n       \r\n        if ( p == t )  \r\n        {  \r\n           \r\n            for (j = 0; j < M; j++)  \r\n            {  \r\n                if (txt[i+j] != pat[j])  \r\n                    break;  \r\n            }  \r\n  \r\n           \r\n            if (j == M)  \r\n                cout<<\"Pattern found at index \"<< i<<endl;  \r\n        }  \r\n  \r\n       \r\n        if ( i < N-M )  \r\n        {  \r\n            t = (d*(t - txt[i]*h) + txt[i+M])%q;  \r\n  \r\n            \r\n            if (t < 0)  \r\n            t = (t + q);  \r\n        }  \r\n    }  \r\n}  \r\n  \r\n/* Driver code */\r\nint main()  \r\n{  \r\n    char txt[1000]; cin>>txt;  \r\n    char pat[1000]; cin>>pat;  \r\n    int q = 101;  \r\n    search(pat, txt, q);  \r\n    return 0;  \r\n}  ', 1000, '', '', '#include <bits/stdc++.h> \r\nusing namespace std; \r\n  \r\n/\r\n#define d 256  \r\n  \r\n\r\nvoid search(char pat[], char txt[], int q)  \r\n{  \r\n    int M = strlen(pat);  \r\n    int N = strlen(txt);  \r\n    int i, j;  \r\n    int p = 0; // hash value for pattern  \r\n    int t = 0; // hash value for txt  \r\n    int h = 1;  \r\n  \r\n    // The value of h would be \"pow(d, M-1)%q\"  \r\n    for (i = 0; i < M - 1; i++)  \r\n        h = (h * d) % q;  \r\n  \r\n    for (i = 0; i < M; i++)  \r\n    {  \r\n        p = (d * p + pat[i]) % q;  \r\n        t = (d * t + txt[i]) % q;  \r\n    }  \r\n  \r\n    // Slide the pattern over text one by one  \r\n    for (i = 0; i <= N - M; i++)  \r\n    {  \r\n  \r\n       \r\n        if ( p == t )  \r\n        {  \r\n           \r\n            for (j = 0; j < M; j++)  \r\n            {  \r\n                if (txt[i+j] != pat[j])  \r\n                    break;  \r\n            }  \r\n  \r\n           \r\n            if (j == M)  \r\n                cout<<\"Pattern found at index \"<< i<<endl;  \r\n        }  \r\n  \r\n       \r\n        if ( i < N-M )  \r\n        {  \r\n            t = (d*(t - txt[i]*h) + txt[i+M])%q;  \r\n  \r\n            \r\n            if (t < 0)  \r\n            t = (t + q);  \r\n        }  \r\n    }  \r\n}  \r\n  \r\n/* Driver code */\r\nint main()  \r\n{  \r\n    char txt[1000]; cin>>txt;  \r\n    char pat[1000]; cin>>pat;  \r\n    int q = 101;  \r\n    search(pat, txt, q);  \r\n    return 0;  \r\n}  ', '2020-05-25'),
(418, 9, 5001012018, '﻿#include <iostream>\r\nusing namespace std;\r\nclass DisjSet {\r\n    int *rank, *parent, n;\r\n  \r\npublic:\r\n        DisjSet(int n)\r\n    {\r\n        rank = new int[n];\r\n        parent = new int[n];\r\n        this->n = n;\r\n        makeSet();\r\n    }\r\n  \r\n      void makeSet()\r\n    {\r\n        for (int i = 0; i < n; i++) {\r\n            parent[i] = i;\r\n        }\r\n    }\r\n  \r\n      int find(int x)\r\n    {\r\n                if (parent[x] != x) {\r\n  \r\n                       parent[x] = find(parent[x]);\r\n  \r\n                }\r\n  \r\n        return parent[x];\r\n    }\r\n  \r\n       void Union(int x, int y)\r\n    {\r\n               int xset = find(x);\r\n        int yset = find(y);\r\n  \r\n               if (xset == yset)\r\n            return;\r\n  \r\n                if (rank[xset] < rank[yset]) {\r\n            parent[xset] = yset;\r\n        }\r\n        else if (rank[xset] > rank[yset]) {\r\n            parent[yset] = xset;\r\n        }\r\n  \r\n                else {\r\n            parent[yset] = xset;\r\n            rank[xset] = rank[xset] + 1;\r\n        }\r\n    }\r\n};\r\n  \r\nint main()\r\n{\r\n    DisjSet obj(5);\r\n    obj.Union(0, 2);\r\n    obj.Union(4, 2);\r\n    obj.Union(3, 1);\r\n    if (obj.find(4) == obj.find(0))\r\n        cout << \"Yes\n\";\r\n    else\r\n        cout << \"No\n\";\r\n    if (obj.find(1) == obj.find(0))\r\n        cout << \"Yes\n\";\r\n    else\r\n        cout << \"No\n\";\r\n  \r\n    return 0;\r\n}', 1000, '', '', '﻿procedure mergesort( var a as array )\r\n   if ( n == 1 ) return a\r\n\r\n\r\n   var l1 as array = a[0] ... a[n/2]\r\n   var l2 as array = a[n/2+1] ... a[n]\r\n\r\n\r\n   l1 = mergesort( l1 )\r\n   l2 = mergesort( l2 )\r\n\r\n\r\n   return merge( l1, l2 )\r\nend procedure\r\n\r\n\r\nprocedure merge( var a as array, var b as array )\r\n\r\n\r\n   var c as array\r\n   while ( a and b have elements )\r\n      if ( a[0] > b[0] )\r\n         add b[0] to the end of c\r\n         remove b[0] from b\r\n      else\r\n         add a[0] to the end of c\r\n         remove a[0] from a\r\n      end if\r\n   end while\r\n   \r\n   while ( a has elements )\r\n      add a[0] to the end of c\r\n      remove a[0] from a\r\n   end while\r\n   \r\n   while ( b has elements )\r\n      add b[0] to the end of c\r\n      remove b[0] from b\r\n   end while\r\n   \r\n   return c\r\n        \r\nend procedure', '2020-05-25'),
(419, 13, 5001012018, '\r\n#include<iostream>\r\n#include<climits>\r\nusing namespace std;\r\n\r\nint findMinVertex(int* weights, bool* visited, int n){\r\n\r\n	int minVertex = -1;\r\n	for(int i = 0; i < n; i++){\r\n		if(!visited[i] && (minVertex == - 1 || weights[i] < weights[minVertex])){\r\n			minVertex = i;\r\n		}\r\n	}\r\n	return minVertex;\r\n}\r\n\r\n\r\nvoid prims(int** edges, int n){\r\n\r\n	int* parent = new int[n];\r\n	int* weights = new int[n];\r\n	bool* visited = new bool[n];\r\n\r\n	for(int i = 0; i < n; i++){\r\n		visited[i] = false;\r\n		weights[i] = INT_MAX;\r\n	}\r\n	parent[0] = -1;\r\n	weights[0] = 0;\r\n\r\n	for(int i = 0; i < n - 1; i++){\r\n		// Find Min Vertex\r\n		int minVertex = findMinVertex(weights, visited, n);\r\n		visited[minVertex] = true;\r\n		// Explore un visted neighbours\r\n		for(int j = 0; j < n; j++){\r\n			if(edges[minVertex][j] != 0 && !visited[j]){\r\n				if(edges[minVertex][j] < weights[j]){\r\n					weights[j] = edges[minVertex][j];\r\n					parent[j] = minVertex;\r\n				}\r\n			}\r\n		}\r\n	}\r\n\r\n\r\n	int ans=0;\r\n	for(int i = 1; i < n; i++)\r\n    {\r\n			ans+= weights[i];\r\n\r\n	}\r\n	cout<<ans;\r\n}\r\n\r\nint main() {\r\n	int n;\r\n	int e;\r\n	cin >> n >> e;\r\n	int** edges = new int*[n];\r\n	for (int i = 0; i < n; i++) {\r\n		edges[i] = new int[n];\r\n		for (int j = 0; j < n; j++) {\r\n			edges[i][j] = 0;\r\n		}\r\n	}\r\n\r\n	for (int i = 0; i < e; i++) {\r\n		int f, s, weight;\r\n		cin >> f >> s >> weight;\r\n		edges[f][s] = weight;\r\n		edges[s][f] = weight;\r\n	}\r\n\r\n	prims(edges, n);\r\n\r\n}\r\n\r\n', 1000, '', '', '﻿void initialize( int Arr[ ], int N)\r\n{\r\n    for(int i = 0;i<N;i++)\r\n    Arr[ i ] = i ;\r\n}\r\n bool find( int Arr[ ], int A, int B)                           \r\n{\r\nif(Arr[ A ] == Arr[ B ])\r\nreturn true;\r\nelse\r\nreturn false;   \r\n}\r\n//change all entries from Arr[ A ] to Arr[ B ].\r\nvoid union(int Arr[ ], int N, int A, int B)\r\n{\r\n    int TEMP = Arr[ A ];\r\nfor(int i = 0; i < N;i++)\r\n    {\r\n    if(Arr[ i ] == TEMP)\r\n    Arr[ i ] = Arr[ B ]; \r\n    }\r\n}', '2020-05-25'),
(420, 14, 5001012018, '#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nstruct Edge {\r\n	int src, dest, weight;\r\n};\r\n\r\nstruct Graph {\r\n\r\n	int V, E;\r\n\r\n	struct Edge* edge;\r\n};\r\n\r\nstruct Graph* createGraph(int V, int E)\r\n{\r\n	struct Graph* graph = new Graph;\r\n	graph->V = V;\r\n	graph->E = E;\r\n	graph->edge = new Edge[E];\r\n	return graph;\r\n}\r\n\r\n\r\nvoid printArr(int dist[], int n)\r\n{\r\n	printf(\"Vertex Distance from Source\n\");\r\n	for (int i = 0; i < n; ++i)\r\n		printf(\"%d     %d \n\", i, dist[i]);\r\n}\r\n\r\nvoid BellmanFord(struct Graph* graph, int src)\r\n{\r\n	int V = graph->V;\r\n	int E = graph->E;\r\n	int dist[V];\r\n\r\n	for (int i = 0; i < V; i++)\r\n		dist[i] = INT_MAX;\r\n	dist[src] = 0;\r\n\r\n	for (int i = 1; i <= V - 1; i++) {\r\n		for (int j = 0; j < E; j++) {\r\n			int u = graph->edge[j].src;\r\n			int v = graph->edge[j].dest;\r\n			int weight = graph->edge[j].weight;\r\n			if (dist[u] != INT_MAX && dist[u] + weight < dist[v])\r\n				dist[v] = dist[u] + weight;\r\n		}\r\n	}\r\n\r\n	for (int i = 0; i < E; i++) {\r\n		int u = graph->edge[i].src;\r\n		int v = graph->edge[i].dest;\r\n		int weight = graph->edge[i].weight;\r\n		if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {\r\n			printf(\"Graph contains negative weight cycle\");\r\n			return;\r\n		}\r\n	}\r\n\r\n	printArr(dist, V);\r\n\r\n	return;\r\n}\r\n\r\n\r\nint main()\r\n{\r\n\r\n	int V=5,E=8;\r\n	//v=5,e=8\r\n\r\n	//cin>>V>>E;\r\n\r\n    struct Graph* graph = createGraph(V, E);\r\n\r\n    graph->edge[0].src = 0;\r\n    graph->edge[0].dest = 1;\r\n    graph->edge[0].weight = -1;\r\n\r\n\r\n    graph->edge[1].src = 0;\r\n    graph->edge[1].dest = 2;\r\n    graph->edge[1].weight = 4;\r\n\r\n    graph->edge[2].src = 1;\r\n    graph->edge[2].dest = 2;\r\n    graph->edge[2].weight = 3;\r\n\r\n    graph->edge[3].src = 1;\r\n    graph->edge[3].dest = 3;\r\n    graph->edge[3].weight = 2;\r\n\r\n\r\n    graph->edge[4].src = 1;\r\n    graph->edge[4].dest = 4;\r\n    graph->edge[4].weight = 2;\r\n\r\n\r\n    graph->edge[5].src = 3;\r\n    graph->edge[5].dest = 2;\r\n    graph->edge[5].weight = 5;\r\n\r\n\r\n    graph->edge[6].src = 3;\r\n    graph->edge[6].dest = 1;\r\n    graph->edge[6].weight = 1;\r\n\r\n\r\n    graph->edge[7].src = 4;\r\n    graph->edge[7].dest = 3;\r\n    graph->edge[7].weight = -3;\r\n    BellmanFord(graph, 0);\r\n\r\n	return 0;\r\n\r\n}\r\n', 1000, '', '', '??D\0y\0n\0a\0m\0i\0c\0-\00\0-\01\0-\0k\0n\0a\0p\0s\0a\0c\0k\0 \0(\0v\0,\0 \0w\0,\0 \0n\0,\0 \0W\0)\0\r\0\n\0f\0o\0r\0 \0w\0 \0=\0 \00\0 \0t\0o\0 \0W\0 \0d\0o\0\r\0\n\0 \0 \0 \0c\0[\00\0,\0 \0w\0]\0 \0=\0 \00\0\r\0\n\0f\0o\0r\0 \0i\0 \0=\0 \01\0 \0t\0o\0 \0n\0 \0d\0o\0 \0 \0\r\0\n\0 \0 \0 \0c\0[\0i\0,\0 \00\0]\0 \0=\0 \00\0\r\0\n\0 \0 \0 \0f\0o\0r\0 \0w\0 \0=\0 \01\0 \0t\0o\0 \0W\0 \0d\0o\0\r\0\n\0 \0 \0	\0i\0f\0 \0w\0i\0 \0d\" \0w\0 \0t\0h\0e\0n\0\r\0\n\0 \0 \0 \0 \0 \0	\0i\0f\0 \0v\0i\0 \0+\0 \0c\0[\0i\0-\01\0,\0 \0w\0-\0w\0i\0]\0 \0t\0h\0e\0n\0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0	\0c\0[\0i\0,\0 \0w\0]\0 \0=\0 \0v\0i\0 \0+\0 \0c\0[\0i\0-\01\0,\0 \0w\0-\0w\0i\0]\0\r\0\n\0 \0 \0 \0 \0 \0	\0e\0l\0s\0e\0 \0c\0[\0i\0,\0 \0w\0]\0 \0=\0 \0c\0[\0i\0-\01\0,\0 \0w\0]\0\r\0\n\0 \0 \0	\0e\0l\0s\0e\0\r\0\n\0 \0 \0 \0 \0 \0	\0c\0[\0i\0,\0 \0w\0]\0 \0=\0 \0c\0[\0i\0-\01\0,\0 \0w\0]\0', '2020-05-25'),
(421, 15, 5001012018, '#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint MatrixChainOrder(int p[], int i, int j)\r\n{\r\n    if(i == j)\r\n        return 0;\r\n    int k;\r\n    int min = INT_MAX;\r\n    int count;\r\n\r\n    for (k = i; k < j; k++)\r\n    {\r\n        count = MatrixChainOrder(p, i, k) +\r\n                MatrixChainOrder(p, k + 1, j) +\r\n                p[i - 1] * p[k] * p[j];\r\n\r\n        if (count < min)\r\n            min = count;\r\n    }\r\n\r\n    return min;\r\n}\r\n\r\nint main()\r\n{\r\n    int n=0;\r\n\r\n    cin>>n;\r\n\r\n    int arr[n];\r\n    for(int i=0;i<n;i++){\r\n        cin>>arr[i];\r\n    }\r\n\r\n\r\n         cout<< MatrixChainOrder(arr, 1, n - 1);\r\n}\r\n', 1000, '', '', '﻿1. Create a leaf node for each unique character and build a min heap of all leaf nodes (Min Heap is used as a priority queue. The value of frequency field is used to compare two nodes in min heap. Initially, the least frequent character is at root)\r\n2. Extract two nodes with the minimum frequency from the min heap.\r\n3. Create a new internal node with a frequency equal to the sum of the two nodes frequencies. Make the first extracted node as its left child and the other extracted node as its right child. Add this node to the min heap.\r\n4. Repeat steps#2 and #3 until the heap contains only one node. The remaining node is the root node and the tree is complete.', '2020-05-25'),
(422, 5, 5001012018, '#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\n\r\ninline ll** MatrixMultiply(ll** a, ll** b, int n, int l, int m)\r\n{\r\n    ll** c = new ll*[n];\r\n    for (int i = 0; i < n; i++)\r\n        c[i] = new ll[m];\r\n\r\n    for (int i = 0; i < n; i++) {\r\n        for (int j = 0; j < m; j++) {\r\n            c[i][j] = 0;\r\n            for (int k = 0; k < l; k++) {\r\n                c[i][j] += a[i][k] * b[k][j];\r\n            }\r\n        }\r\n    }\r\n    return c;\r\n}\r\n\r\ninline ll** Strassen(ll** a, ll** b, int n, int l, int m)\r\n{\r\n    if (n == 1 || l == 1 || m == 1)\r\n        return MatrixMultiply(a, b, n, l, m);\r\n\r\n    ll** c = new ll*[n];\r\n    for (int i = 0; i < n; i++)\r\n        c[i] = new ll[m];\r\n\r\n    int adjN = (n >> 1) + (n & 1);\r\n    int adjL = (l >> 1) + (l & 1);\r\n    int adjM = (m >> 1) + (m & 1);\r\n\r\n    ll**** As = new ll***[2];\r\n    for (int x = 0; x < 2; x++) {\r\n        As[x] = new ll**[2];\r\n        for (int y = 0; y < 2; y++) {\r\n            As[x][y] = new ll*[adjN];\r\n            for (int i = 0; i < adjN; i++) {\r\n                As[x][y][i] = new ll[adjL];\r\n                for (int j = 0; j < adjL; j++) {\r\n                    int I = i + (x & 1) * adjN;\r\n                    int J = j + (y & 1) * adjL;\r\n                    As[x][y][i][j] = (I < n && J < l) ? a[I][J] : 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    ll**** Bs = new ll***[2];\r\n    for (int x = 0; x < 2; x++) {\r\n        Bs[x] = new ll**[2];\r\n        for (int y = 0; y < 2; y++) {\r\n            Bs[x][y] = new ll*[adjN];\r\n            for (int i = 0; i < adjL; i++) {\r\n                Bs[x][y][i] = new ll[adjM];\r\n                for (int j = 0; j < adjM; j++) {\r\n                    int I = i + (x & 1) * adjL;\r\n                    int J = j + (y & 1) * adjM;\r\n                    Bs[x][y][i][j] = (I < l && J < m) ? b[I][J] : 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    ll*** s = new ll**[10];\r\n    for (int i = 0; i < 10; i++) {\r\n        switch (i) {\r\n        case 0:\r\n            s[i] = new ll*[adjL];\r\n            for (int j = 0; j < adjL; j++) {\r\n                s[i][j] = new ll[adjM];\r\n                for (int k = 0; k < adjM; k++) {\r\n                    s[i][j][k] = Bs[0][1][j][k] - Bs[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 1:\r\n            s[i] = new ll*[adjN];\r\n            for (int j = 0; j < adjN; j++) {\r\n                s[i][j] = new ll[adjL];\r\n                for (int k = 0; k < adjL; k++) {\r\n                    s[i][j][k] = As[0][0][j][k] + As[0][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 2:\r\n            s[i] = new ll*[adjN];\r\n            for (int j = 0; j < adjN; j++) {\r\n                s[i][j] = new ll[adjL];\r\n                for (int k = 0; k < adjL; k++) {\r\n                    s[i][j][k] = As[1][0][j][k] + As[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 3:\r\n            s[i] = new ll*[adjL];\r\n            for (int j = 0; j < adjL; j++) {\r\n                s[i][j] = new ll[adjM];\r\n                for (int k = 0; k < adjM; k++) {\r\n                    s[i][j][k] = Bs[1][0][j][k] - Bs[0][0][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 4:\r\n            s[i] = new ll*[adjN];\r\n            for (int j = 0; j < adjN; j++) {\r\n                s[i][j] = new ll[adjL];\r\n                for (int k = 0; k < adjL; k++) {\r\n                    s[i][j][k] = As[0][0][j][k] + As[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 5:\r\n            s[i] = new ll*[adjL];\r\n            for (int j = 0; j < adjL; j++) {\r\n                s[i][j] = new ll[adjM];\r\n                for (int k = 0; k < adjM; k++) {\r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 6:\r\n            s[i] = new ll*[adjN];\r\n            for (int j = 0; j < adjN; j++) {\r\n                s[i][j] = new ll[adjL];\r\n                for (int k = 0; k < adjL; k++) {\r\n                    s[i][j][k] = As[0][1][j][k] - As[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 7:\r\n            s[i] = new ll*[adjL];\r\n            for (int j = 0; j < adjL; j++) {\r\n                s[i][j] = new ll[adjM];\r\n                for (int k = 0; k < adjM; k++) {\r\n                    s[i][j][k] = Bs[1][0][j][k] + Bs[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 8:\r\n            s[i] = new ll*[adjN];\r\n            for (int j = 0; j < adjN; j++) {\r\n                s[i][j] = new ll[adjL];\r\n                for (int k = 0; k < adjL; k++) {\r\n                    s[i][j][k] = As[0][0][j][k] - As[1][0][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 9:\r\n            s[i] = new ll*[adjL];\r\n            for (int j = 0; j < adjL; j++) {\r\n                s[i][j] = new ll[adjM];\r\n                for (int k = 0; k < adjM; k++) {\r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[0][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    }\r\n\r\n    ll*** p = new ll**[7];\r\n    p[0] = Strassen(As[0][0], s[0], adjN, adjL, adjM);\r\n    p[1] = Strassen(s[1], Bs[1][1], adjN, adjL, adjM);\r\n    p[2] = Strassen(s[2], Bs[0][0], adjN, adjL, adjM);\r\n    p[3] = Strassen(As[1][1], s[3], adjN, adjL, adjM);\r\n    p[4] = Strassen(s[4], s[5], adjN, adjL, adjM);\r\n    p[5] = Strassen(s[6], s[7], adjN, adjL, adjM);\r\n    p[6] = Strassen(s[8], s[9], adjN, adjL, adjM);\r\n\r\n    for (int i = 0; i < adjN; i++) {\r\n        for (int j = 0; j < adjM; j++) {\r\n            c[i][j] = p[4][i][j] + p[3][i][j] - p[1][i][j] + p[5][i][j];\r\n            if (j + adjM < m)\r\n                c[i][j + adjM] = p[0][i][j] + p[1][i][j];\r\n            if (i + adjN < n)\r\n                c[i + adjN][j] = p[2][i][j] + p[3][i][j];\r\n            if (i + adjN < n && j + adjM < m)\r\n                c[i + adjN][j + adjM] = p[4][i][j] + p[0][i][j] - p[2][i][j] - p[6][i][j];\r\n        }\r\n    }\r\n\r\n    for (int x = 0; x < 2; x++) {\r\n        for (int y = 0; y < 2; y++) {\r\n            for (int i = 0; i < adjN; i++) {\r\n                delete[] As[x][y][i];\r\n            }\r\n            delete[] As[x][y];\r\n        }\r\n        delete[] As[x];\r\n    }\r\n    delete[] As;\r\n\r\n    for (int x = 0; x < 2; x++) {\r\n        for (int y = 0; y < 2; y++) {\r\n            for (int i = 0; i < adjL; i++) {\r\n                delete[] Bs[x][y][i];\r\n            }\r\n            delete[] Bs[x][y];\r\n        }\r\n        delete[] Bs[x];\r\n    }\r\n    delete[] Bs;\r\n\r\n    for (int i = 0; i < 10; i++) {\r\n        switch (i) {\r\n        case 0:\r\n        case 3:\r\n        case 5:\r\n        case 7:\r\n        case 9:\r\n            for (int j = 0; j < adjL; j++) {\r\n                delete[] s[i][j];\r\n            }\r\n            break;\r\n        case 1:\r\n        case 2:\r\n        case 4:\r\n        case 6:\r\n        case 8:\r\n            for (int j = 0; j < adjN; j++) {\r\n                delete[] s[i][j];\r\n            }\r\n            break;\r\n        }\r\n        delete[] s[i];\r\n    }\r\n    delete[] s;\r\n\r\n    for (int i = 0; i < 7; i++) {\r\n        for (int j = 0; j < (n >> 1); j++) {\r\n            delete[] p[i][j];\r\n        }\r\n        delete[] p[i];\r\n    }\r\n    delete[] p;\r\n\r\n    return c;\r\n}\r\n\r\nint main()\r\n{\r\nint n=3;\r\n    //cin>>n;\r\n    int mat1_m=n,mat1_n=n,mat2_m=n,mat2_n=n;\r\n\r\n    ll** mat1 =new ll*[mat1_m];\r\n\r\n\r\n    for(int i=0;i<mat1_m;i++)\r\n    {\r\n        mat1[i]=new ll[mat1_n];\r\n\r\n    }\r\n    mat1[0][0]=1;\r\n    mat1[0][1]=0;\r\n    mat1[0][2]=0;\r\n    mat1[1][0]=0;\r\n    mat1[1][1]=1;\r\n    mat1[1][2]=0;\r\n    mat1[2][0]=0;\r\n    mat1[2][1]=0;\r\n    mat1[2][2]=1;\r\n    //mat1[10][10]={{1,0,0},{0,1,0},{0,0,1}};\r\n\r\n    ll**mat2 =new ll*[mat2_m];\r\n\r\n    for(int i=0;i<mat2_m;i++)\r\n    {\r\n        mat2[i]=new ll[mat2_n];\r\n\r\n\r\n    }\r\n     mat2[0][0]=1;\r\n    mat2[0][1]=0;\r\n    mat2[0][2]=0;\r\n    mat2[1][0]=0;\r\n    mat2[1][1]=1;\r\n    mat2[1][2]=0;\r\n    mat2[2][0]=0;\r\n    mat2[2][1]=0;\r\n    mat2[2][2]=1;\r\n\r\n    ll** mat3 = Strassen(mat1, mat2, mat1_m, mat1_n, mat2_n);\r\n    for (int i = 0; i < mat1_m; i++)\r\n    {\r\n        for (int j = 0; j < mat2_n; j++)\r\n        {\r\n            cout<<mat3[i][j]<<\" \";\r\n        }\r\n        cout<<\"\n\";\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n', 1000, '', '', 'Algorithm\r\nFollowing are the detailed steps.\r\n \r\nInput: Graph and a source vertex src\r\nOutput: Shortest distance to all vertices from src. If there is a negative weight cycle, then shortest distances are not calculated, negative weight cycle is reported.\r\n \r\n \r\n \r\n \r\n1) This step initializes distances from source to all vertices as infinite and distance to source itself as 0. Create an array dist[] of size |V| with all values as infinite except dist[src] where src is source vertex.\r\n \r\n2) This step calculates shortest distances. Do following |V|-1 times where |V| is the number of vertices in given graph.\r\n?..a) Do following for each edge u-v\r\n??????If dist[v] > dist[u] + weight of edge uv, then update dist[v]\r\n???????.dist[v] = dist[u] + weight of edge uv\r\n \r\n3) This step reports if there is a negative weight cycle in graph. Do following for each edge u-v\r\n??If dist[v] > dist[u] + weight of edge uv, then ?Graph contains negative weight cycle?\r\nThe idea of step 3 is, step 2 guarantees shortest distances if graph doesn?t contain negative weight cycle. If we iterate through all edges one ', '2020-05-25'),
(423, 16, 5001012018, '#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define d 256\r\n\r\n\r\nvoid search(char pat[], char txt[], int q,int l1,int l2)\r\n{\r\n    int M = l2;\r\n    int N = l1;\r\n    int i, j;\r\n    int p = 0;\r\n    int t = 0;\r\n    int h = 1;\r\n\r\n\r\n    for (i = 0; i < M - 1; i++)\r\n        h = (h * d) % q;\r\n\r\n\r\n    for (i = 0; i < M; i++)\r\n    {\r\n        p = (d * p + pat[i]) % q;\r\n        t = (d * t + txt[i]) % q;\r\n    }\r\n\r\n\r\n    for (i = 0; i <= N - M; i++)\r\n    {\r\n\r\n\r\n        if ( p == t )\r\n        {\r\n\r\n            for (j = 0; j < M; j++)\r\n            {\r\n                if (txt[i+j] != pat[j])\r\n                    break;\r\n            }\r\n\r\n\r\n            if (j == M)\r\n                cout<<\"Pattern found at index \"<< i<<endl;\r\n        }\r\n\r\n\r\n        if ( i < N-M )\r\n        {\r\n            t = (d*(t - txt[i]*h) + txt[i+M])%q;\r\n\r\n            if (t < 0)\r\n            t = (t + q);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nint main()\r\n{\r\n\r\n    string s1;\r\n    getline(cin,s1);\r\n    int l1=s1.length();\r\n     char txt[l1];\r\n    for(int i=0;i<l1;i++){\r\n        txt[i]=s1[i];\r\n    }\r\n\r\n\r\n\r\n    string s2;\r\n    getline(cin,s2);\r\n    int l2=s2.length();\r\n    char pat[l2];\r\n\r\n    for(int i=0;i<l2;i++){\r\n        pat[i]=s2[i];\r\n    }\r\n\r\n\r\n    int q = 101;\r\n\r\n    search(pat, txt, q,l1,l2);\r\n    return 0;\r\n}\r\n\r\n\r\n', 1000, '', '', 'Algorithm..\r\nMatrix-Multiply(A,B)\r\n1.If columns[A]!=rows[B]\r\n2. then error “incomplete dimensions”\r\n3. else for i = 1 to rows[A]\r\n4.        	do for j = 1 to columns[B]\r\n5.                        	do C[i,j] = 0\r\n6.                                        	for k = 1 to columns[A]\r\n7.                                                        	Do C[i,j]=C[i,j]+A[i,k]*B[k,j]\r\n8. Return C\r\n', '2020-05-25'),
(424, 9, 5101012018, '#include <iostream>\r\nusing namespace std;\r\nclass DisjSet {\r\n    int *rank, *parent, n;\r\n\r\npublic:\r\n        DisjSet(int n)\r\n    {\r\n        rank = new int[n];\r\n        parent = new int[n];\r\n        this->n = n;\r\n        makeSet();\r\n    }\r\n\r\n      void makeSet()\r\n    {\r\n        for (int i = 0; i < n; i++) {\r\n            parent[i] = i;\r\n        }\r\n    }\r\n\r\n      int find(int x)\r\n    {\r\n                if (parent[x] != x) {\r\n\r\n                       parent[x] = find(parent[x]);\r\n\r\n                }\r\n\r\n        return parent[x];\r\n    }\r\n\r\n       void Union(int x, int y)\r\n    {\r\n               int xset = find(x);\r\n        int yset = find(y);\r\n\r\n               if (xset == yset)\r\n            return;\r\n\r\n                if (rank[xset] < rank[yset]) {\r\n            parent[xset] = yset;\r\n        }\r\n        else if (rank[xset] > rank[yset]) {\r\n            parent[yset] = xset;\r\n        }\r\n\r\n                else {\r\n            parent[yset] = xset;\r\n            rank[xset] = rank[xset] + 1;\r\n        }\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    DisjSet obj(5);\r\n    obj.Union(0, 2);\r\n    obj.Union(4, 2);\r\n    obj.Union(3, 1);\r\n    if (obj.find(4) == obj.find(0))\r\n        cout << \"Yes\n\";\r\n    else\r\n        cout << \"No\n\";\r\n    if (obj.find(1) == obj.find(0))\r\n        cout << \"Yes\n\";\r\n    else\r\n        cout << \"No\n\";\r\n\r\n    return 0;\r\n}\r\n\r\n', 1000, '', '', ' Disjoint Set Data Structure:\r\n\r\nvoid initialize( int Arr[ ], int N)\r\n{\r\n    for(int i = 0;i<N;i++)\r\n    Arr[ i ] = i ;\r\n}\r\n bool find( int Arr[ ], int A, int B)                           \r\n{\r\nif(Arr[ A ] == Arr[ B ])\r\nreturn true;\r\nelse\r\nreturn false;   \r\n}\r\n\r\nvoid union(int Arr[ ], int N, int A, int B)\r\n{\r\n    int TEMP = Arr[ A ];\r\nfor(int i = 0; i < N;i++)\r\n    {\r\n    if(Arr[ i ] == TEMP)\r\n    Arr[ i ] = Arr[ B ]; \r\n    }\r\n}\r\n\r\n\r\n', '2020-05-25'),
(425, 14, 5101012018, '#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nstruct Edge {\r\n	int src, dest, weight;\r\n};\r\n\r\nstruct Graph {\r\n\r\n	int V, E;\r\n\r\n	struct Edge* edge;\r\n};\r\n\r\nstruct Graph* createGraph(int V, int E)\r\n{\r\n	struct Graph* graph = new Graph;\r\n	graph->V = V;\r\n	graph->E = E;\r\n	graph->edge = new Edge[E];\r\n	return graph;\r\n}\r\n\r\n\r\nvoid printArr(int dist[], int n)\r\n{\r\n	printf(\"Vertex Distance from Source\n\");\r\n	for (int i = 0; i < n; ++i)\r\n		printf(\"%d     %d \n\", i, dist[i]);\r\n}\r\n\r\nvoid BellmanFord(struct Graph* graph, int src)\r\n{\r\n	int V = graph->V;\r\n	int E = graph->E;\r\n	int dist[V];\r\n\r\n	for (int i = 0; i < V; i++)\r\n		dist[i] = INT_MAX;\r\n	dist[src] = 0;\r\n\r\n	for (int i = 1; i <= V - 1; i++) {\r\n		for (int j = 0; j < E; j++) {\r\n			int u = graph->edge[j].src;\r\n			int v = graph->edge[j].dest;\r\n			int weight = graph->edge[j].weight;\r\n			if (dist[u] != INT_MAX && dist[u] + weight < dist[v])\r\n				dist[v] = dist[u] + weight;\r\n		}\r\n	}\r\n\r\n	for (int i = 0; i < E; i++) {\r\n		int u = graph->edge[i].src;\r\n		int v = graph->edge[i].dest;\r\n		int weight = graph->edge[i].weight;\r\n		if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {\r\n			printf(\"Graph contains negative weight cycle\");\r\n			return;\r\n		}\r\n	}\r\n\r\n	printArr(dist, V);\r\n\r\n	return;\r\n}\r\n\r\n\r\nint main()\r\n{\r\n\r\n	int V=5,E=8;\r\n	//v=5,e=8\r\n\r\n	//cin>>V>>E;\r\n\r\n    struct Graph* graph = createGraph(V, E);\r\n\r\n    graph->edge[0].src = 0;\r\n    graph->edge[0].dest = 1;\r\n    graph->edge[0].weight = -1;\r\n\r\n\r\n    graph->edge[1].src = 0;\r\n    graph->edge[1].dest = 2;\r\n    graph->edge[1].weight = 4;\r\n\r\n    graph->edge[2].src = 1;\r\n    graph->edge[2].dest = 2;\r\n    graph->edge[2].weight = 3;\r\n\r\n    graph->edge[3].src = 1;\r\n    graph->edge[3].dest = 3;\r\n    graph->edge[3].weight = 2;\r\n\r\n\r\n    graph->edge[4].src = 1;\r\n    graph->edge[4].dest = 4;\r\n    graph->edge[4].weight = 2;\r\n\r\n\r\n    graph->edge[5].src = 3;\r\n    graph->edge[5].dest = 2;\r\n    graph->edge[5].weight = 5;\r\n\r\n\r\n    graph->edge[6].src = 3;\r\n    graph->edge[6].dest = 1;\r\n    graph->edge[6].weight = 1;\r\n\r\n\r\n    graph->edge[7].src = 4;\r\n    graph->edge[7].dest = 3;\r\n    graph->edge[7].weight = -3;\r\n    BellmanFord(graph, 0);\r\n\r\n	return 0;\r\n\r\n}\r\n', 1000, '', '', 'Algorithm\r\nFollowing are the detailed steps.\r\n \r\nInput: Graph and a source vertex src\r\nOutput: Shortest distance to all vertices from src. If there is a negative weight cycle, then shortest distances are not calculated, negative weight cycle is reported.\r\n \r\n \r\n \r\n \r\n1) This step initializes distances from source to all vertices as infinite and distance to source itself as 0. Create an array dist[] of size |V| with all values as infinite except dist[src] where src is source vertex.\r\n \r\n2) This step calculates shortest distances. Do following |V|-1 times where |V| is the number of vertices in given graph.\r\n?..a) Do following for each edge u-v\r\n??????If dist[v] > dist[u] + weight of edge uv, then update dist[v]\r\n???????.dist[v] = dist[u] + weight of edge uv\r\n \r\n3) This step reports if there is a negative weight cycle in graph. Do following for each edge u-v\r\n??If dist[v] > dist[u] + weight of edge uv, then ?Graph contains negative weight cycle?\r\nThe idea of step 3 is, step 2 guarantees shortest distances if graph doesn?t contain negative weight cycle. If we iterate through all edges one more time and get a shorter path for any vertex, then there is a negative weight cycle\r\n', '2020-05-25'),
(426, 15, 5101012018, '#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint MatrixChainOrder(int p[], int i, int j)\r\n{\r\n    if(i == j)\r\n        return 0;\r\n    int k;\r\n    int min = INT_MAX;\r\n    int count;\r\n\r\n    for (k = i; k < j; k++)\r\n    {\r\n        count = MatrixChainOrder(p, i, k) +\r\n                MatrixChainOrder(p, k + 1, j) +\r\n                p[i - 1] * p[k] * p[j];\r\n\r\n        if (count < min)\r\n            min = count;\r\n    }\r\n\r\n    return min;\r\n}\r\n\r\nint main()\r\n{\r\n    int n=0;\r\n    //cout<<\"Enter size of the array:\";\r\n    cin>>n;\r\n    //cout<<\"Enter elements:\n\";\r\n    int arr[n];\r\n    for(int i=0;i<n;i++){\r\n        cin>>arr[i];\r\n    }\r\n\r\n   // cout << \"Minimum number of multiplications is \";\r\n         cout<< MatrixChainOrder(arr, 1, n - 1);\r\n}\r\n', 1000, '', '', 'Algorithm..\r\nMatrix-Multiply(A,B)\r\n1.If columns[A]!=rows[B]\r\n2. then error ?incomplete dimensions?\r\n3. else for i = 1 to rows[A]\r\n4.        	do for j = 1 to columns[B]\r\n5.                        	do C[i,j] = 0\r\n6.                                        	for k = 1 to columns[A]\r\n7.                                                        	Do C[i,j]=C[i,j]+A[i,k]*B[k,j]\r\n8. Return C\r\n', '2020-05-25');
INSERT INTO `qtos_map` (`ID`, `Q_ID`, `ROLL`, `SUBMISSION`, `SCORE`, `INPUT`, `OP`, `ALGO`, `DATE`) VALUES
(427, 8, 5101012018, '#include<iostream>\r\n#include<vector>\r\n#include<cmath>\r\n#include<algorithm>\r\nusing namespace std;\r\n\r\nint nextpowerof2(int k)\r\n{\r\n    return pow(2, int(ceil(log2(k))));\r\n}\r\nvoid display(vector<vector<int> > &matrix, int m, int n)\r\n{\r\n    for (int i = 0; i < m; i++)\r\n    {\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            if (j != 0)\r\n            {\r\n                cout <<\" \";\r\n            }\r\n            cout << matrix[i][j];\r\n        }\r\n        cout <<endl;\r\n    }\r\n}\r\n\r\nvoid add(vector<vector<int> > &A, vector<vector<int> > &B, vector<vector<int> > &C, int size)\r\n{\r\n    int i, j;\r\n\r\n    for (i = 0; i < size; i++)\r\n    {\r\n        for (j = 0; j < size; j++)\r\n        {\r\n            C[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid sub(vector<vector<int> > &A, vector<vector<int> > &B, vector<vector<int> > &C, int size)\r\n{\r\n    int i, j;\r\n\r\n    for (i = 0; i < size; i++)\r\n    {\r\n        for (j = 0; j < size; j++)\r\n        {\r\n            C[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid STRASSEN_algorithmA(vector<vector<int> > &A, vector<vector<int> > &B, vector<vector<int> > &C, int size)\r\n{\r\n    if (size == 1)\r\n    {\r\n        C[0][0] = A[0][0] * B[0][0];\r\n        return;\r\n    }\r\n    else\r\n    {\r\n        int new_size = size / 2;\r\n        vector<int> z(new_size);\r\n        vector<vector<int> >\r\n            a11(new_size, z), a12(new_size, z), a21(new_size, z), a22(new_size, z),\r\n            b11(new_size, z), b12(new_size, z), b21(new_size, z), b22(new_size, z),\r\n            c11(new_size, z), c12(new_size, z), c21(new_size, z), c22(new_size, z),\r\n            p1(new_size, z), p2(new_size, z), p3(new_size, z), p4(new_size, z),\r\n            p5(new_size, z), p6(new_size, z), p7(new_size, z),\r\n            aResult(new_size, z), bResult(new_size, z);\r\n\r\nint i, j;\r\nfor (i = 0; i < new_size; i++)\r\n        {\r\n            for (j = 0; j < new_size; j++)\r\n            {\r\n                a11[i][j] = A[i][j];\r\n                a12[i][j] = A[i][j + new_size];\r\n                a21[i][j] = A[i + new_size][j];\r\n                a22[i][j] = A[i + new_size][j + new_size];\r\n\r\n                b11[i][j] = B[i][j];\r\n                b12[i][j] = B[i][j + new_size];\r\n                b21[i][j] = B[i + new_size][j];\r\n                b22[i][j] = B[i + new_size][j + new_size];\r\n            }\r\n}\r\n\r\n        add(a11, a22, aResult, new_size);\r\n        add(b11, b22, bResult, new_size);\r\n        STRASSEN_algorithmA(aResult, bResult, p1, new_size);\r\n\r\n        add(a21, a22, aResult, new_size);\r\n        STRASSEN_algorithmA(aResult, b11, p2, new_size);\r\n\r\n        sub(b12, b22, bResult, new_size);\r\n        STRASSEN_algorithmA(a11, bResult, p3, new_size);\r\n\r\n\r\n        sub(b21, b11, bResult, new_size);\r\n        STRASSEN_algorithmA(a22, bResult, p4, new_size);\r\n        add(a11, a12, aResult, new_size);\r\n        STRASSEN_algorithmA(aResult, b22, p5, new_size);\r\n\r\n        sub(a21, a11, aResult, new_size);\r\n        add(b11, b12, bResult, new_size);\r\n        STRASSEN_algorithmA(aResult, bResult, p6, new_size);\r\n\r\n        sub(a12, a22, aResult, new_size);\r\n        add(b21, b22, bResult, new_size);\r\n        STRASSEN_algorithmA(aResult, bResult, p7, new_size);\r\n\r\n        add(p3, p5, c12, new_size);\r\n        add(p2, p4, c21, new_size);\r\n\r\n        add(p1, p4, aResult, new_size);\r\n        add(aResult, p7, bResult, new_size);\r\n        sub(bResult, p5, c11, new_size);\r\n\r\n        add(p1, p3, aResult, new_size);\r\n        add(aResult, p6, bResult, new_size);\r\n        sub(bResult, p2, c22, new_size);\r\n        for (i = 0; i < new_size; i++)\r\n        {\r\n            for (j = 0; j < new_size; j++)\r\n            {\r\n                C[i][j] = c11[i][j];\r\n                C[i][j + new_size] = c12[i][j];\r\n                C[i + new_size][j] = c21[i][j];\r\n                C[i + new_size][j + new_size] = c22[i][j];\r\n            }\r\n        }\r\n    }\r\n}\r\nvoid STRASSEN_algorithm(vector<vector<int> > &A, vector<vector<int> > &B, int m, int n, int a, int b)\r\n{\r\n    int c1=std::max(a,b);\r\n    int c2=std::max(c1,m);\r\n    int c3=std::max(c1,n);\r\n    int k = c3;\r\n\r\n    int s = nextpowerof2(k);\r\n\r\n    vector<int> z(s);\r\n    vector<vector<int> > Aa(s,z),Bb(s,z),Cc(s,z);\r\n\r\n    for (unsigned int i = 0; i < m; i++)\r\n    {\r\n        for (unsigned int j = 0; j < n; j++)\r\n        {\r\n            Aa[i][j] = A[i][j];\r\n        }\r\n    }\r\n    for (unsigned int i = 0; i < a; i++)\r\n    {\r\n        for (unsigned int j = 0; j < b; j++)\r\n        {\r\n            Bb[i][j] = B[i][j];\r\n        }\r\n    }\r\n    STRASSEN_algorithmA(Aa,Bb,Cc,s);\r\n    vector<int> temp1(b);\r\n    vector<vector<int> > C(m, temp1);\r\n    for (unsigned int i = 0; i < m; i++)\r\n    {\r\n        for (unsigned int j = 0; j < b; j++)\r\n        {\r\n            C[i][j] = Cc[i][j];\r\n        }\r\n    }\r\n    display(C, m, b);\r\n}\r\n\r\nbool check(int n, int a)\r\n{\r\n    if (n == a)\r\n        return true;\r\n    else\r\n        return false;\r\n}\r\n\r\nint main()\r\n{\r\n    int n, a, b;\r\n    cin >> n;\r\n\r\n    vector<vector<int> > A;\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        vector<int> temp;\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            int i;\r\n            cin >> i;\r\n            temp.push_back(i);\r\n        }\r\n        A.push_back(temp);\r\n    }\r\n\r\n    vector<vector<int> > B;\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        vector<int> temp;\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            int i;\r\n            cin >> i;\r\n            temp.push_back(i);\r\n        }\r\n        B.push_back(temp);\r\n    }\r\n\r\n\r\n        STRASSEN_algorithm(A,B,n,n,n,n);\r\n\r\n    return 0;\r\n}\r\n\r\n', 0, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '-17 -4 -7\n10 2 11\n40 92 107\n', 'Formulas for Stassen?s matrix multiplication\r\nIn Strassen?s matrix multiplication there are seven multiplication and four addition, subtraction in total.\r\n\r\n    1.	D1 =  (a11 + a22) (b11 + b22)\r\n    2.	D2 =  (a21 + a22).b11\r\n    3.	D3 =  (b12 ? b22).a11\r\n    4.	D4 =  (b21 ? b11).a22\r\n    5.	D5 =  (a11 + a12).b22\r\n    6.	D6 =  (a21 ? a11) . (b11 + b12)\r\n    7.	D7 =  (a12 ? a22) . (b21 + b22)\r\n\r\n    C11 = d1 + d4 ? d5 + d7\r\n    C12 = d3 + d5\r\n    C21 = d2 + d4\r\n    C22 = d1 + d3 ? d2 ? d6\r\nAlgorithm for Strassen?s matrix multiplication\r\nAlgorithm Strassen(n, a, b, d)\r\n\r\nbegin \r\n	If n = threshold then compute\r\n		C = a * b is a conventional matrix.\r\n	Else\r\n		Partition a into four sub matrices  a11, a12, a21, a22.\r\n		Partition b into four sub matrices b11, b12, b21, b22.\r\n		Strassen ( n/2, a11 + a22, b11 + b22, d1)\r\n		Strassen ( n/2, a21 + a22, b11, d2)\r\n		Strassen ( n/2, a11, b12 ? b22, d3)\r\n		Strassen ( n/2, a22, b21 ? b11, d4)\r\n		Strassen ( n/2, a11 + a12, b22, d5)\r\n		Strassen (n/2, a21 ? a11, b11 + b22, d6)\r\n		Strassen (n/2, a12 ? a22, b21 + b22, d7)\r\n\r\n		C = d1+d4-d5+d7     d3+d5\r\n		    d2+d4           d1+d3-d2-d6  \r\n		\r\n	end if\r\n	\r\n	return (C)\r\nend.\r\n', '2020-05-25'),
(428, 5, 5101012018, '#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\n\r\ninline ll** MatrixMultiply(ll** a, ll** b, int n, int l, int m)\r\n{\r\n    ll** c = new ll*[n];\r\n    for (int i = 0; i < n; i++)\r\n        c[i] = new ll[m];\r\n\r\n    for (int i = 0; i < n; i++) {\r\n        for (int j = 0; j < m; j++) {\r\n            c[i][j] = 0;\r\n            for (int k = 0; k < l; k++) {\r\n                c[i][j] += a[i][k] * b[k][j];\r\n            }\r\n        }\r\n    }\r\n    return c;\r\n}\r\n\r\ninline ll** Strassen(ll** a, ll** b, int n, int l, int m)\r\n{\r\n    if (n == 1 || l == 1 || m == 1)\r\n        return MatrixMultiply(a, b, n, l, m);\r\n\r\n    ll** c = new ll*[n];\r\n    for (int i = 0; i < n; i++)\r\n        c[i] = new ll[m];\r\n\r\n    int adjN = (n >> 1) + (n & 1);\r\n    int adjL = (l >> 1) + (l & 1);\r\n    int adjM = (m >> 1) + (m & 1);\r\n\r\n    ll**** As = new ll***[2];\r\n    for (int x = 0; x < 2; x++) {\r\n        As[x] = new ll**[2];\r\n        for (int y = 0; y < 2; y++) {\r\n            As[x][y] = new ll*[adjN];\r\n            for (int i = 0; i < adjN; i++) {\r\n                As[x][y][i] = new ll[adjL];\r\n                for (int j = 0; j < adjL; j++) {\r\n                    int I = i + (x & 1) * adjN;\r\n                    int J = j + (y & 1) * adjL;\r\n                    As[x][y][i][j] = (I < n && J < l) ? a[I][J] : 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    ll**** Bs = new ll***[2];\r\n    for (int x = 0; x < 2; x++) {\r\n        Bs[x] = new ll**[2];\r\n        for (int y = 0; y < 2; y++) {\r\n            Bs[x][y] = new ll*[adjN];\r\n            for (int i = 0; i < adjL; i++) {\r\n                Bs[x][y][i] = new ll[adjM];\r\n                for (int j = 0; j < adjM; j++) {\r\n                    int I = i + (x & 1) * adjL;\r\n                    int J = j + (y & 1) * adjM;\r\n                    Bs[x][y][i][j] = (I < l && J < m) ? b[I][J] : 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    ll*** s = new ll**[10];\r\n    for (int i = 0; i < 10; i++) {\r\n        switch (i) {\r\n        case 0:\r\n            s[i] = new ll*[adjL];\r\n            for (int j = 0; j < adjL; j++) {\r\n                s[i][j] = new ll[adjM];\r\n                for (int k = 0; k < adjM; k++) {\r\n                    s[i][j][k] = Bs[0][1][j][k] - Bs[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 1:\r\n            s[i] = new ll*[adjN];\r\n            for (int j = 0; j < adjN; j++) {\r\n                s[i][j] = new ll[adjL];\r\n                for (int k = 0; k < adjL; k++) {\r\n                    s[i][j][k] = As[0][0][j][k] + As[0][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 2:\r\n            s[i] = new ll*[adjN];\r\n            for (int j = 0; j < adjN; j++) {\r\n                s[i][j] = new ll[adjL];\r\n                for (int k = 0; k < adjL; k++) {\r\n                    s[i][j][k] = As[1][0][j][k] + As[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 3:\r\n            s[i] = new ll*[adjL];\r\n            for (int j = 0; j < adjL; j++) {\r\n                s[i][j] = new ll[adjM];\r\n                for (int k = 0; k < adjM; k++) {\r\n                    s[i][j][k] = Bs[1][0][j][k] - Bs[0][0][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 4:\r\n            s[i] = new ll*[adjN];\r\n            for (int j = 0; j < adjN; j++) {\r\n                s[i][j] = new ll[adjL];\r\n                for (int k = 0; k < adjL; k++) {\r\n                    s[i][j][k] = As[0][0][j][k] + As[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 5:\r\n            s[i] = new ll*[adjL];\r\n            for (int j = 0; j < adjL; j++) {\r\n                s[i][j] = new ll[adjM];\r\n                for (int k = 0; k < adjM; k++) {\r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 6:\r\n            s[i] = new ll*[adjN];\r\n            for (int j = 0; j < adjN; j++) {\r\n                s[i][j] = new ll[adjL];\r\n                for (int k = 0; k < adjL; k++) {\r\n                    s[i][j][k] = As[0][1][j][k] - As[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 7:\r\n            s[i] = new ll*[adjL];\r\n            for (int j = 0; j < adjL; j++) {\r\n                s[i][j] = new ll[adjM];\r\n                for (int k = 0; k < adjM; k++) {\r\n                    s[i][j][k] = Bs[1][0][j][k] + Bs[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 8:\r\n            s[i] = new ll*[adjN];\r\n            for (int j = 0; j < adjN; j++) {\r\n                s[i][j] = new ll[adjL];\r\n                for (int k = 0; k < adjL; k++) {\r\n                    s[i][j][k] = As[0][0][j][k] - As[1][0][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 9:\r\n            s[i] = new ll*[adjL];\r\n            for (int j = 0; j < adjL; j++) {\r\n                s[i][j] = new ll[adjM];\r\n                for (int k = 0; k < adjM; k++) {\r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[0][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    }\r\n\r\n    ll*** p = new ll**[7];\r\n    p[0] = Strassen(As[0][0], s[0], adjN, adjL, adjM);\r\n    p[1] = Strassen(s[1], Bs[1][1], adjN, adjL, adjM);\r\n    p[2] = Strassen(s[2], Bs[0][0], adjN, adjL, adjM);\r\n    p[3] = Strassen(As[1][1], s[3], adjN, adjL, adjM);\r\n    p[4] = Strassen(s[4], s[5], adjN, adjL, adjM);\r\n    p[5] = Strassen(s[6], s[7], adjN, adjL, adjM);\r\n    p[6] = Strassen(s[8], s[9], adjN, adjL, adjM);\r\n\r\n    for (int i = 0; i < adjN; i++) {\r\n        for (int j = 0; j < adjM; j++) {\r\n            c[i][j] = p[4][i][j] + p[3][i][j] - p[1][i][j] + p[5][i][j];\r\n            if (j + adjM < m)\r\n                c[i][j + adjM] = p[0][i][j] + p[1][i][j];\r\n            if (i + adjN < n)\r\n                c[i + adjN][j] = p[2][i][j] + p[3][i][j];\r\n            if (i + adjN < n && j + adjM < m)\r\n                c[i + adjN][j + adjM] = p[4][i][j] + p[0][i][j] - p[2][i][j] - p[6][i][j];\r\n        }\r\n    }\r\n\r\n    for (int x = 0; x < 2; x++) {\r\n        for (int y = 0; y < 2; y++) {\r\n            for (int i = 0; i < adjN; i++) {\r\n                delete[] As[x][y][i];\r\n            }\r\n            delete[] As[x][y];\r\n        }\r\n        delete[] As[x];\r\n    }\r\n    delete[] As;\r\n\r\n    for (int x = 0; x < 2; x++) {\r\n        for (int y = 0; y < 2; y++) {\r\n            for (int i = 0; i < adjL; i++) {\r\n                delete[] Bs[x][y][i];\r\n            }\r\n            delete[] Bs[x][y];\r\n        }\r\n        delete[] Bs[x];\r\n    }\r\n    delete[] Bs;\r\n\r\n    for (int i = 0; i < 10; i++) {\r\n        switch (i) {\r\n        case 0:\r\n        case 3:\r\n        case 5:\r\n        case 7:\r\n        case 9:\r\n            for (int j = 0; j < adjL; j++) {\r\n                delete[] s[i][j];\r\n            }\r\n            break;\r\n        case 1:\r\n        case 2:\r\n        case 4:\r\n        case 6:\r\n        case 8:\r\n            for (int j = 0; j < adjN; j++) {\r\n                delete[] s[i][j];\r\n            }\r\n            break;\r\n        }\r\n        delete[] s[i];\r\n    }\r\n    delete[] s;\r\n\r\n    for (int i = 0; i < 7; i++) {\r\n        for (int j = 0; j < (n >> 1); j++) {\r\n            delete[] p[i][j];\r\n        }\r\n        delete[] p[i];\r\n    }\r\n    delete[] p;\r\n\r\n    return c;\r\n}\r\n\r\nint main()\r\n{\r\nint n=3;\r\n    //cin>>n;\r\n    int mat1_m=n,mat1_n=n,mat2_m=n,mat2_n=n;\r\n\r\n    ll** mat1 =new ll*[mat1_m];\r\n\r\n\r\n    for(int i=0;i<mat1_m;i++)\r\n    {\r\n        mat1[i]=new ll[mat1_n];\r\n\r\n    }\r\n    mat1[0][0]=1;\r\n    mat1[0][1]=0;\r\n    mat1[0][2]=0;\r\n    mat1[1][0]=0;\r\n    mat1[1][1]=1;\r\n    mat1[1][2]=0;\r\n    mat1[2][0]=0;\r\n    mat1[2][1]=0;\r\n    mat1[2][2]=1;\r\n    //mat1[10][10]={{1,0,0},{0,1,0},{0,0,1}};\r\n\r\n    ll**mat2 =new ll*[mat2_m];\r\n\r\n    for(int i=0;i<mat2_m;i++)\r\n    {\r\n        mat2[i]=new ll[mat2_n];\r\n\r\n\r\n    }\r\n     mat2[0][0]=1;\r\n    mat2[0][1]=0;\r\n    mat2[0][2]=0;\r\n    mat2[1][0]=0;\r\n    mat2[1][1]=1;\r\n    mat2[1][2]=0;\r\n    mat2[2][0]=0;\r\n    mat2[2][1]=0;\r\n    mat2[2][2]=1;\r\n\r\n    ll** mat3 = Strassen(mat1, mat2, mat1_m, mat1_n, mat2_n);\r\n    for (int i = 0; i < mat1_m; i++)\r\n    {\r\n        for (int j = 0; j < mat2_n; j++)\r\n        {\r\n            cout<<mat3[i][j]<<\" \";\r\n        }\r\n        cout<<\"\n\";\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n', 1000, '', '', '\r\nfunction Strassen(M,N)\r\nif M is 1 ? 1 then\r\nreturn M11N11\r\nend if\r\nLet M =  A B\r\n         C D \r\nand N =  E F\r\n         G H \r\nSet S1 = Strassen(B - D, G + H)\r\nSet S2 = Strassen(A + D, E + H)\r\nSet S3 = Strassen(A - C, E + F)\r\nSet S4 = Strassen(A + B, H)\r\nSet S5 = Strassen(A, F - H)\r\nSet S6 = Strassen(D, G - E)\r\nSet S7 = Strassen(C + D, E)\r\nreturn (\r\nS1 + S2 - S4 + S6    S4 + S5\r\nS6 + S7              S2 - S3 + S5 - S7\r\n)\r\nend function\r\n', '2020-05-25'),
(429, 16, 5101012018, '\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n\r\n#define d 256\r\n\r\nvoid search(char pat[], char txt[], int q,int l1,int l2)\r\n{\r\n    int M = l2;\r\n    int N = l1;\r\n    int i, j;\r\n    int p = 0;\r\n    int t = 0;\r\n    int h = 1;\r\n\r\n\r\n    for (i = 0; i < M - 1; i++)\r\n        h = (h * d) % q;\r\n\r\n\r\n    for (i = 0; i < M; i++)\r\n    {\r\n        p = (d * p + pat[i]) % q;\r\n        t = (d * t + txt[i]) % q;\r\n    }\r\n\r\n\r\n    for (i = 0; i <= N - M; i++)\r\n    {\r\n\r\n\r\n        if ( p == t )\r\n        {\r\n\r\n            for (j = 0; j < M; j++)\r\n            {\r\n                if (txt[i+j] != pat[j])\r\n                    break;\r\n            }\r\n\r\n\r\n            if (j == M)\r\n                cout<<\"Pattern found at index \"<< i<<\" \"<<endl;\r\n        }\r\n\r\n\r\n        if ( i < N-M )\r\n        {\r\n            t = (d*(t - txt[i]*h) + txt[i+M])%q;\r\n\r\n\r\n            if (t < 0)\r\n            t = (t + q);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nint main()\r\n{\r\n\r\n    string s1;\r\n    getline(cin,s1);\r\n    int l1=s1.length();\r\n     char txt[l1];\r\n    for(int i=0;i<l1;i++){\r\n        txt[i]=s1[i];\r\n    }\r\n\r\n\r\n\r\n    string s2;\r\n    getline(cin,s2);\r\n    int l2=s2.length();\r\n    char pat[l2];\r\n\r\n    for(int i=0;i<l2;i++){\r\n        pat[i]=s2[i];\r\n    }\r\n\r\n\r\n    int q = 101;\r\n\r\n    search(pat, txt, q,l1,l2);\r\n    return 0;\r\n}\r\n', 1000, '', '', '??B\0e\0g\0i\0n\0\r\0\n\0 \0 \0 \0p\0a\0t\0L\0e\0n\0 \0:\0=\0 \0p\0a\0t\0t\0e\0r\0n\0 \0L\0e\0n\0g\0t\0h\0\r\0\n\0 \0 \0 \0s\0t\0r\0L\0e\0n\0 \0:\0=\0 \0s\0t\0r\0i\0n\0g\0 \0L\0e\0n\0g\0t\0h\0\r\0\n\0 \0 \0 \0p\0a\0t\0H\0a\0s\0h\0 \0:\0=\0 \00\0 \0a\0n\0d\0 \0s\0t\0r\0H\0a\0s\0h\0 \0:\0=\0 \00\0,\0 \0h\0 \0:\0=\0 \01\0\r\0\n\0 \0 \0 \0m\0a\0x\0C\0h\0a\0r\0 \0:\0=\0 \0t\0o\0t\0a\0l\0 \0n\0u\0m\0b\0e\0r\0 \0o\0f\0 \0c\0h\0a\0r\0a\0c\0t\0e\0r\0s\0 \0i\0n\0 \0c\0h\0a\0r\0a\0c\0t\0e\0r\0 \0s\0e\0t\0\r\0\n\0 \0\r\0\n\0 \0 \0 \0f\0o\0r\0 \0i\0n\0d\0e\0x\0 \0i\0 \0o\0f\0 \0a\0l\0l\0 \0c\0h\0a\0r\0a\0c\0t\0e\0r\0 \0i\0n\0 \0p\0a\0t\0t\0e\0r\0n\0,\0 \0d\0o\0\r\0\n\0 \0 \0	\0h\0 \0:\0=\0 \0(\0h\0*\0m\0a\0x\0C\0h\0a\0r\0)\0 \0m\0o\0d\0 \0p\0r\0i\0m\0e\0\r\0\n\0 \0 \0 \0d\0o\0n\0e\0\r\0\n\0 \0\r\0\n\0 \0 \0 \0f\0o\0r\0 \0a\0l\0l\0 \0c\0h\0a\0r\0a\0c\0t\0e\0r\0 \0i\0n\0d\0e\0x\0 \0i\0 \0o\0f\0 \0p\0a\0t\0t\0e\0r\0n\0,\0 \0d\0o\0\r\0\n\0 \0 \0	\0p\0a\0t\0H\0a\0s\0h\0 \0:\0=\0 \0(\0m\0a\0x\0C\0h\0a\0r\0*\0p\0a\0t\0H\0a\0s\0h\0 \0+\0 \0p\0a\0t\0t\0e\0r\0n\0[\0i\0]\0)\0 \0m\0o\0d\0 \0p\0r\0i\0m\0e\0\r\0\n\0 \0 \0	\0s\0t\0r\0H\0a\0s\0h\0 \0:\0=\0 \0(\0m\0a\0x\0C\0h\0a\0r\0*\0s\0t\0r\0H\0a\0s\0h\0 \0+\0 \0t\0e\0x\0t\0[\0i\0]\0)\0 \0m\0o\0d\0 \0p\0r\0i\0m\0e\0\r\0\n\0 \0 \0 \0d\0o\0n\0e\0\r\0\n\0 \0\r\0\n\0 \0 \0 \0f\0o\0r\0 \0i\0 \0:\0=\0 \00\0 \0t\0o\0 \0(\0s\0t\0r\0L\0e\0n\0 \0-\0 \0p\0a\0t\0L\0e\0n\0)\0,\0 \0d\0o\0\r\0\n\0 \0 \0	\0i\0f\0 \0p\0a\0t\0H\0a\0s\0h\0 \0=\0 \0s\0t\0r\0H\0a\0s\0h\0,\0 \0t\0h\0e\0n\0\r\0\n\0 \0 \0 \0 \0 \0	\0f\0o\0r\0 \0c\0h\0a\0r\0I\0n\0d\0e\0x\0 \0:\0=\0 \00\0 \0t\0o\0 \0p\0a\0t\0L\0e\0n\0 \0-\01\0,\0 \0d\0o\0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0	\0i\0f\0 \0t\0e\0x\0t\0[\0i\0+\0c\0h\0a\0r\0I\0n\0d\0e\0x\0]\0 \0`\" \0p\0a\0t\0t\0e\0r\0n\0[\0c\0h\0a\0r\0I\0n\0d\0e\0x\0]\0,\0 \0t\0h\0e\0n\0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0	\0b\0r\0e\0a\0k\0 \0t\0h\0e\0 \0l\0o\0o\0p\0\r\0\n\0 \0 \0 \0 \0 \0	\0d\0o\0n\0e\0\r\0\n\0 \0\r\0\n\0 \0 \0 \0 \0 \0	\0i\0f\0 \0c\0h\0a\0r\0I\0n\0d\0e\0x\0 \0=\0 \0p\0a\0t\0L\0e\0n\0,\0 \0t\0h\0e\0n\0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0	\0p\0r\0i\0n\0t\0 \0t\0h\0e\0 \0l\0o\0c\0a\0t\0i\0o\0n\0 \0i\0 \0a\0s\0 \0p\0a\0t\0t\0e\0r\0n\0 \0f\0o\0u\0n\0d\0 \0a\0t\0 \0i\0 \0p\0o\0s\0i\0t\0i\0o\0n\0.\0\r\0\n\0 \0 \0	\0i\0f\0 \0i\0 \0<\0 \0(\0s\0t\0r\0L\0e\0n\0 \0-\0 \0p\0a\0t\0L\0e\0n\0)\0,\0 \0t\0h\0e\0n\0\r\0\n\0 \0 \0 \0 \0 \0	\0s\0t\0r\0H\0a\0s\0h\0 \0:\0=\0 \0(\0m\0a\0x\0C\0h\0a\0r\0*\0(\0s\0t\0r\0H\0a\0s\0h\0 \0  \0t\0e\0x\0t\0[\0i\0]\0*\0h\0)\0+\0t\0e\0x\0t\0[\0i\0+\0p\0a\0t\0L\0e\0n\0]\0)\0 \0m\0o\0d\0 \0p\0r\0i\0m\0e\0,\0 \0t\0h\0e\0n\0\r\0\n\0 \0 \0	\0i\0f\0 \0s\0t\0r\0H\0a\0s\0h\0 \0<\0 \00\0,\0 \0t\0h\0e\0n\0\r\0\n\0 \0 \0 \0 \0 \0	\0s\0t\0r\0H\0a\0s\0h\0 \0:\0=\0 \0s\0t\0r\0H\0a\0s\0h\0 \0+\0 \0p\0r\0i\0m\0e\0\r\0\n\0 \0 \0 \0d\0o\0n\0e\0\r\0\n\0E\0n\0d\0\r\0\n\0', '2020-05-25'),
(430, 3, 5301012018, '#include<stdio.h> \r\n  \r\nvoid swap(int* a, int* b) \r\n{ \r\n    int t = *a; \r\n    *a = *b; \r\n    *b = t; \r\n} \r\n  \r\nint partition (int arr[], int low, int high) \r\n{ \r\n    int pivot = arr[high];     \r\n    int i = (low - 1);  \r\n  \r\n    for (int j = low; j <= high- 1; j++) \r\n    { \r\n        if (arr[j] < pivot) \r\n        { \r\n            i++;    \r\n            swap(&arr[i], &arr[j]); \r\n        } \r\n    } \r\n    swap(&arr[i + 1], &arr[high]); \r\n    return (i + 1); \r\n} \r\n  \r\nvoid quickSort(int arr[], int low, int high) \r\n{ \r\n    if (low < high) \r\n    { \r\n        int pi = partition(arr, low, high); \r\n  \r\n        quickSort(arr, low, pi - 1); \r\n        quickSort(arr, pi + 1, high); \r\n    } \r\n} \r\n  \r\nvoid printArray(int arr[], int size) \r\n{ \r\n    int i; \r\n    for (i=0; i < size; i++) \r\n        printf(\"%d \", arr[i]); \r\n} \r\n  \r\nint main() \r\n{  \r\n    int n;\r\n    scanf(\"%d\",&n);\r\n    int i,arr[n];\r\n    for(i=0;i<n;i++)\r\n        scanf(\"%d\",&arr[i]); \r\n    quickSort(arr, 0, n-1);  \r\n    printArray(arr, n); \r\n    return 0; \r\n}', 8, '1 2000', '2000 ', 'quickSort(array, leftmostIndex, rightmostIndex)\r\n  if (leftmostIndex < rightmostIndex)\r\n    pivotIndex <- partition(array,leftmostIndex, rightmostIndex)\r\n    quickSort(array, leftmostIndex, pivotIndex)\r\n    quickSort(array, pivotIndex + 1, rightmostIndex)\r\n\r\npartition(array, leftmostIndex, rightmostIndex)\r\n  set rightmostIndex as pivotIndex\r\n  storeIndex <- leftmostIndex - 1\r\n  for i <- leftmostIndex + 1 to rightmostIndex\r\n  if element[i] < pivotElement\r\n    swap element[i] and element[storeIndex]\r\n    storeIndex++\r\n  swap pivotElement and element[storeIndex+1]\r\nreturn storeIndex + 1', '2020-05-25'),
(431, 7, 5301012018, '#include <cstdlib> \r\n#include <stdio.h>\r\n#include <iostream> \r\nusing namespace std; \r\n  \r\nint partition(int arr[], int start, int end) \r\n{ \r\n    int pivot = arr[end]; \r\n    int i = (start - 1); \r\n  \r\n    for (int j = start; j <= end - 1; j++) { \r\n  \r\n        if (arr[j] <= pivot) { \r\n  \r\n            i++; \r\n            swap(arr[i], arr[j]); \r\n        } \r\n    } \r\n    swap(arr[i + 1], arr[end]); \r\n    return (i + 1); \r\n} \r\n  \r\nint random_partition(int arr[], int start, int end) \r\n{ \r\n   \r\n    int random = start + rand() % (end - start); \r\n  \r\n    swap(arr[random], arr[end]); \r\n  \r\n    return partition(arr, start, end); \r\n} \r\n  \r\nvoid quickSort(int arr[], int start, int end) \r\n{ \r\n    if (start < end) { \r\n  \r\n        int pi = random_partition(arr, start, end); \r\n  \r\n        quickSort(arr, start, pi - 1); \r\n        quickSort(arr, pi + 1, end); \r\n    } \r\n} \r\n  \r\nvoid printArray(int arr[], int size) \r\n{ \r\n    for (int i = 0; i < size; i++){ \r\n 	 cout<<arr[i]<<endl; \r\n    }\r\n   \r\n} \r\n  \r\nint main() \r\n{ \r\n    \r\n    int n;\r\n    cin >> n; \r\n    int arr[n];\r\n    for (int i = 0; i < n; ++i){\r\n	 cin >> arr[i];\r\n    }\r\n    quickSort(arr, 0, n - 1); \r\n    printArray(arr, n);   \r\n} ', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0\n1\n4\n5\n6\n6\n8\n8\n8\n9\n9\n1000\n14000\n', 'partition(arr[], lo, hi) \r\n    pivot = arr[hi]\r\n    i = lo     // place for swapping\r\n    for j := lo to hi – 1 do\r\n        if arr[j] <= pivot then\r\n            swap arr[i] with arr[j]\r\n            i = i + 1\r\n    swap arr[i] with arr[hi]\r\n    return i\r\n\r\npartition_r(arr[], lo, hi)\r\n    r = Random Number from lo to hi\r\n    Swap arr[r] and arr[hi]\r\n    return partition(arr, lo, hi)\r\n\r\nquicksort(arr[], lo, hi)\r\n    if lo < hi\r\n        p = partition_r(arr, lo, hi)\r\n        quicksort(arr, p-1, hi)\r\n        quicksort(arr, p+1, hi)\r\n ', '2020-05-25'),
(432, 9, 5301012018, '#include <iostream>\r\nusing namespace std;\r\nclass DisjSet {\r\n	int *rank, *parent, n;\r\n\r\npublic:\r\n	DisjSet(int n)\r\n	{\r\n		rank = new int[n];\r\n		parent = new int[n];\r\n		this->n = n;\r\n		makeSet();\r\n	}\r\n\r\n	void makeSet()\r\n	{\r\n		for (int i = 0; i < n; i++) {\r\n			parent[i] = i;\r\n		}\r\n	}\r\n\r\n	int find(int x)\r\n	{\r\n		if (parent[x] != x) {\r\n\r\n			parent[x] = find(parent[x]);\r\n		}\r\n\r\n		return parent[x];\r\n	}\r\n\r\n	void Union(int x, int y)\r\n	{\r\n		int xset = find(x);\r\n		int yset = find(y);\r\n\r\n		if (xset == yset)\r\n			return;\r\n\r\n		if (rank[xset] < rank[yset]) {\r\n			parent[xset] = yset;\r\n		}\r\n		else if (rank[xset] > rank[yset]) {\r\n			parent[yset] = xset;\r\n		}\r\n		else {\r\n			parent[yset] = xset;\r\n			rank[xset] = rank[xset] + 1;\r\n		}\r\n	}\r\n};\r\n\r\nint main()\r\n{\r\n	DisjSet obj(5);\r\n    obj.Union(0, 2);\r\n    obj.Union(4, 2);\r\n    obj.Union(3, 1);\r\n    if (obj.find(4) == obj.find(0))\r\n        cout << \"Yes\n\";\r\n    else\r\n        cout << \"No\n\";\r\n    if (obj.find(1) == obj.find(0))\r\n        cout << \"Yes\n\";\r\n    else\r\n        cout << \"No\n\";\r\n\r\n    return 0;\r\n}\r\n', 1000, '', '', 'Begin\r\n   Assume k is the element\r\n   makeset(k):\r\n      k.parent = k.\r\n   Find(x):\r\n   If k.parent == k\r\n      return k.\r\n   else\r\n   return Find(k.parent)\r\n   Union (a,b):\r\n      Take two set a and b as input.\r\n      aroot = Find(a)\r\n      broot = Find(b)\r\n      aroot.parent = broot\r\nEnd', '2020-05-25'),
(433, 10, 5301012018, 'import java.io.*;\r\nimport java.util.*;\r\n\r\npublic class Main {\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        Scanner scn = new Scanner(System.in);\r\n        int n = scn.nextInt();\r\n	int cap = scn.nextInt();\r\n        int[] weight = new int[n];\r\n        int[] price = new int[n];\r\n        for (int i = 0; i < n; i++) {\r\n            price[i] = scn.nextInt();\r\n        }\r\n        for (int i = 0; i < n; i++) {\r\n            weight[i] = scn.nextInt();\r\n        }      \r\n        System.out.println(knapsack(weight, price, cap));\r\n    }\r\n\r\n    public static int knapsack(int[] weight, int[] price, int cap) {\r\n        int[][] dp = new int[price.length][cap + 1];\r\n        \r\n        for (int i = 0; i < dp[0].length; i++) {\r\n            if (weight[0] <= cap && i >= weight[0]) {\r\n                dp[0][i] = price[0];\r\n            }\r\n        }\r\n        for (int i = 1; i < dp.length; i++) {\r\n            for (int j = 1; j < dp[0].length; j++) {\r\n                int val = weight[i];\r\n                if (j - val >= 0) {\r\n                    dp[i][j] = Math.max(dp[i - 1][j], price[i] + dp[i - 1][j - val]);\r\n                } else {\r\n                    dp[i][j] = dp[i - 1][j];\r\n                }\r\n            }\r\n        }\r\n        return dp[dp.length-1][dp[0].length-1];\r\n    }\r\n}', 0, '5 15 4 2 1 2 10 12 2 1 1 4', '15\n', '??G\0r\0e\0e\0d\0y\0-\0F\0r\0a\0c\0t\0i\0o\0n\0a\0l\0-\0K\0n\0a\0p\0s\0a\0c\0k\0 \0(\0w\0[\01\0.\0.\0n\0]\0,\0 \0p\0[\01\0.\0.\0n\0]\0,\0 \0W\0)\0 \0\r\0\n\0f\0o\0r\0 \0i\0 \0=\0 \01\0 \0t\0o\0 \0n\0 \0\r\0\n\0 \0 \0 \0d\0o\0 \0x\0[\0i\0]\0 \0=\0 \00\0 \0\r\0\n\0w\0e\0i\0g\0h\0t\0 \0=\0 \00\0 \0\r\0\n\0f\0o\0r\0 \0i\0 \0=\0 \01\0 \0t\0o\0 \0n\0 \0\r\0\n\0 \0 \0 \0i\0f\0 \0w\0e\0i\0g\0h\0t\0 \0+\0 \0w\0[\0i\0]\0 \0d\" \0W\0 \0t\0h\0e\0n\0 \0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0x\0[\0i\0]\0 \0=\0 \01\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0w\0e\0i\0g\0h\0t\0 \0=\0 \0w\0e\0i\0g\0h\0t\0 \0+\0 \0w\0[\0i\0]\0 \0\r\0\n\0 \0 \0 \0e\0l\0s\0e\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0x\0[\0i\0]\0 \0=\0 \0(\0W\0 \0-\0 \0w\0e\0i\0g\0h\0t\0)\0 \0/\0 \0w\0[\0i\0]\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0w\0e\0i\0g\0h\0t\0 \0=\0 \0W\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0b\0r\0e\0a\0k\0 \0\r\0\n\0r\0e\0t\0u\0r\0n\0 \0x\0', '2020-05-25'),
(434, 12, 5301012018, '#include<iostream>\r\n#include<algorithm>\r\nusing namespace std;\r\n\r\nclass Edge\r\n{\r\n	public:\r\n	int source;\r\n	int dest;\r\n	int weight;\r\n};\r\n\r\nbool compare(Edge e1,Edge e2){\r\n    return e1.weight< e2.weight;\r\n}\r\nint findParent(int v,int *parent){\r\n    if(parent[v]==v){\r\n        return v;\r\n    }\r\n    return findParent(parent[v],parent);\r\n}\r\nvoid Kruskals(Edge *input,int n,int E){\r\n    sort(input,input+E,compare);\r\n    Edge *output=new Edge[n-1];\r\n    int *parent= new int[n];\r\n    for(int i=0;i<n;i++){\r\n        parent[i]=i;\r\n    }\r\n    int count=0;\r\n    int i=0;\r\n    while(count!=n-1){\r\n        Edge currentEdge = input[i];\r\n        int sourceParent = findParent(currentEdge.source,parent);\r\n        int destParent = findParent(currentEdge.dest,parent);\r\n\r\n        if(sourceParent!=destParent){\r\n            output[count]=currentEdge;\r\n            count++;\r\n            parent[sourceParent]=destParent;\r\n        }\r\n        i++;\r\n    }\r\n    for(int i=0;i<n-1;i++){\r\n        if(output[i].source<output[i].dest){\r\n            cout<<output[i].source<<\"---\"<<output[i].dest<<\"==>\"<<output[i].weight<<\" \";\r\n        }else{\r\n            cout<<output[i].dest<<\"---\"<<output[i].source<<\"==>\"<<output[i].weight<<\" \";\r\n        }\r\n    }\r\n}\r\n\r\nint main(){\r\n    int n=4;\r\n    int E=4;\r\n    Edge *input=new Edge[E];\r\n        input[0].source=0;\r\n        input[0].dest=1;\r\n        input[0].weight=3;\r\n        input[1].source=0;\r\n        input[1].dest=3;\r\n        input[1].weight=5;\r\n        input[2].source=1;\r\n        input[2].dest=2;\r\n        input[2].weight=1;\r\n        input[3].source=2;\r\n        input[3].dest=3;\r\n        input[3].weight=8;\r\n    Kruskals(input,n,E);\r\n}\r\n', 1000, '', '', '1. Sort all the edges in non-decreasing order of their weight.\r\n2. Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If cycle is not formed, include this edge. Else, discard it.\r\n3. Repeat step#2 until there are (V-1) edges in the spanning tree.', '2020-05-25'),
(435, 13, 5301012018, '#include <iostream>\r\n#include <vector>\r\n#include <queue>\r\n#include <functional>\r\n#include <utility>\r\n\r\nusing namespace std;\r\nconst int MAX = 1e4 + 5;\r\ntypedef pair<long long, int> PII;\r\nbool marked[MAX];\r\nvector <PII> adj[MAX];\r\n\r\nlong long prim(int x)\r\n{\r\n    priority_queue<PII, vector<PII>, greater<PII> > Q;\r\n    int y;\r\n    long long minimumCost = 0;\r\n    PII p;\r\n    Q.push(make_pair(0, x));\r\n    while(!Q.empty())\r\n    {\r\n        p = Q.top();\r\n        Q.pop();\r\n        x = p.second;\r\n        if(marked[x] == true)\r\n            continue;\r\n        minimumCost += p.first;\r\n        marked[x] = true;\r\n        for(int i = 0;i < adj[x].size();++i)\r\n        {\r\n            y = adj[x][i].second;\r\n            if(marked[y] == false)\r\n                Q.push(adj[x][i]);\r\n        }\r\n    }\r\n    return minimumCost;\r\n}\r\n\r\nint main()\r\n{\r\n    int nodes, edges, x, y;\r\n    long long weight, minimumCost;\r\n    cin >> nodes >> edges;\r\n    for(int i = 0;i < edges;++i)\r\n    {\r\n        cin >> x >> y >> weight;\r\n        adj[x].push_back(make_pair(weight, y));\r\n        adj[y].push_back(make_pair(weight, x));\r\n    }\r\n    minimumCost = prim(1);\r\n    cout << minimumCost << endl;\r\n    return 0;\r\n}', 1000, '', '', 'Algorithm\r\n1) Create a set mstSet that keeps track of vertices already included in MST.\r\n2) Assign a key value to all vertices in the input graph. Initialize all key values as INFINITE. Assign key value as 0 for the first vertex so that it is picked first.\r\n3) While mstSet doesn’t include all vertices\r\n….a) Pick a vertex u which is not there in mstSet and has minimum key value.\r\n….b) Include u to mstSet.\r\n….c) Update key value of all adjacent vertices of u. To update the key values, iterate through all adjacent vertices. For every adjacent vertex v, if weight of edge u-v is less than the previous key value of v, update the key value as weight of u-v', '2020-05-25'),
(436, 14, 5301012018, '#include<iostream>\r\n#include<conio.h>\r\n#include<stdio.h>\r\nstruct Edge {\r\n    int src, dest, weight;\r\n};\r\n\r\nstruct Graph\r\n{\r\n    int V, E;\r\n    struct Edge* edge;\r\n};\r\nstruct Graph* createGraph(int V, int E)\r\n{\r\n    struct Graph* graph = new Graph;\r\n    graph->V = V;\r\n    graph->E = E;\r\n    graph->edge = new Edge[E];\r\n    return graph;\r\n}\r\nvoid printArr(int dist[], int n)\r\n{\r\n    for (int i = 0; i < n; ++i)\r\n        printf(\"%d %d \", i, dist[i]);\r\n}\r\n\r\nvoid BellmanFord(struct Graph* graph, int src)\r\n{\r\n    int V = graph->V;\r\n    int E = graph->E;\r\n    int dist[V];\r\n\r\n    for (int i = 0; i < V; i++)\r\n        dist[i] = INT_MAX;\r\n    dist[src] = 0;\r\n\r\n    for (int i = 1; i <= V - 1; i++) {\r\n        for (int j = 0; j < E; j++) {\r\n            int u = graph->edge[j].src;\r\n            int v = graph->edge[j].dest;\r\n            int weight = graph->edge[j].weight;\r\n            if (dist[u] != INT_MAX && dist[u] + weight < dist[v])\r\n                dist[v] = dist[u] + weight;\r\n        }\r\n    }\r\n     for (int i = 0; i < E; i++) {\r\n        int u = graph->edge[i].src;\r\n        int v = graph->edge[i].dest;\r\n        int weight = graph->edge[i].weight;\r\n        if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {\r\n            printf(\"Graph contains negative weight cycle\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printArr(dist, V);\r\n\r\n    return;\r\n}\r\n\r\nint main()\r\n{\r\n    int V = 5;\r\n    int E = 8;\r\n    struct Graph* graph = createGraph(V, E);\r\n\r\n\r\n    graph->edge[0].src = 0;\r\n    graph->edge[0].dest = 1;\r\n    graph->edge[0].weight = -1;\r\n\r\n\r\n    graph->edge[1].src = 0;\r\n    graph->edge[1].dest = 2;\r\n    graph->edge[1].weight = 4;\r\n\r\n\r\n    graph->edge[2].src = 1;\r\n    graph->edge[2].dest = 2;\r\n    graph->edge[2].weight = 3;\r\n\r\n\r\n    graph->edge[3].src = 1;\r\n    graph->edge[3].dest = 3;\r\n    graph->edge[3].weight = 2;\r\n\r\n\r\n    graph->edge[4].src = 1;\r\n    graph->edge[4].dest = 4;\r\n    graph->edge[4].weight = 2;\r\n\r\n\r\n    graph->edge[5].src = 3;\r\n    graph->edge[5].dest = 2;\r\n    graph->edge[5].weight = 5;\r\n\r\n\r\n    graph->edge[6].src = 3;\r\n    graph->edge[6].dest = 1;\r\n    graph->edge[6].weight = 1;\r\n\r\n\r\n    graph->edge[7].src = 4;\r\n    graph->edge[7].dest = 3;\r\n    graph->edge[7].weight = -3;\r\n\r\n    BellmanFord(graph, 0);\r\n\r\n    return 0;\r\n}\r\n', 1000, '', '', 'Algorithm\r\nFollowing are the detailed steps.\r\n\r\nInput: Graph and a source vertex src\r\nOutput: Shortest distance to all vertices from src. If there is a negative weight cycle, then shortest distances are not calculated, negative weight cycle is reported.\r\n\r\n\r\n\r\n\r\n1) This step initializes distances from source to all vertices as infinite and distance to source itself as 0. Create an array dist[] of size |V| with all values as infinite except dist[src] where src is source vertex.\r\n\r\n2) This step calculates shortest distances. Do following |V|-1 times where |V| is the number of vertices in given graph.\r\n…..a) Do following for each edge u-v\r\n………………If dist[v] > dist[u] + weight of edge uv, then update dist[v]\r\n………………….dist[v] = dist[u] + weight of edge uv\r\n\r\n3) This step reports if there is a negative weight cycle in graph. Do following for each edge u-v\r\n……If dist[v] > dist[u] + weight of edge uv, then “Graph contains negative weight cycle”\r\nThe idea of step 3 is, step 2 guarantees shortest distances if graph doesn’t contain negative weight cycle. If we iterate through all edges one more time and get a shorter path for any vertex, then there is a negative weight cycle', '2020-05-25'),
(437, 15, 5301012018, '#include<iostream>\r\nusing namespace std;\r\n\r\nint matrix_chain(int array[], int n) {\r\n   int minMul[n][n];\r\n   for (int i=1; i<n; i++)\r\n      minMul[i][i] = 0;\r\n\r\n   for (int length=2; length<n; length++) {\r\n      for (int i=1; i<n-length+1; i++) {\r\n         int j = i+length-1;\r\n         minMul[i][j] = INT_MAX;\r\n         for (int k=i; k<=j-1; k++) {\r\n            int q = minMul[i][k] + minMul[k+1][j] + array[i- 1]*array[k]*array[j];\r\n            if (q < minMul[i][j])\r\n               minMul[i][j] = q;\r\n         }\r\n        }\r\n   }\r\n   return minMul[1][n-1];\r\n}\r\n\r\nint main() {\r\n    int n;\r\n    cin>>n;\r\n    int arr[n];\r\n    for(int i=0;i<n;i++){\r\n        cin>>arr[i];\r\n    }\r\n   cout <<matrix_chain(arr, n);\r\n}\r\n', 1000, '', '', 'Algorithm of Matrix Chain Multiplication\r\nMATRIX-CHAIN-ORDER (p)\r\n\r\n\r\n 1. n   length[p]-1\r\n 2. for i ← 1 to n\r\n 3. do m [i, i] ← 0\r\n 4. for l ← 2 to n    // l is the chain length\r\n 5. do for i ← 1 to n-l + 1\r\n 6. do j ← i+ l -1\r\n 7. m[i,j] ←  ∞\r\n 8. for k  ← i to j-1\r\n 9. do q  ← m [i, k] + m [k + 1, j] + pi-1 pk pj	\r\n 10. If q < m [i,j]\r\n 11. then m [i,j] ← q\r\n 12. s [i,j] ← k\r\n 13. return m and s.  ', '2020-05-25'),
(438, 4, 5301012018, '#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nclass Pair{\r\npublic:\r\n	int min;\r\n	int max;\r\n};\r\n\r\nPair MaxMin(int arr[], int start, int end){\r\n	Pair mxMn;\r\n	if (end == start){\r\n		mxMn.min = arr[start];\r\n		mxMn.max = arr[start];\r\n		return mxMn;\r\n	}\r\n\r\n	if (end - start == 1){\r\n		if (arr[start] < arr[end]){\r\n			mxMn.min = arr[start];\r\n			mxMn.max = arr[end];\r\n		}\r\n		else {\r\n			mxMn.min = arr[end];\r\n			mxMn.max = arr[start];\r\n		}\r\n		return mxMn;\r\n	}\r\n\r\n	int mid = (start + end) / 2;\r\n\r\n	Pair ml = MaxMin(arr, start, mid);\r\n	Pair mr = MaxMin(arr, mid + 1, end);\r\n\r\n	if (ml.min > mr.min) mxMn.min = mr.min;\r\n	else mxMn.min = ml.min;\r\n\r\n	if (ml.max > mr.max) mxMn.max = ml.max;\r\n	else mxMn.max = mr.max;\r\n	return mxMn;\r\n}\r\n\r\nint main(){\r\n	int n=6;\r\n	int arr[] = {10, 37, 194, 365, 82, 55};\r\n	Pair mxMn = MaxMin(arr, 0, n - 1);\r\n	cout << mxMn.min << \" \" << mxMn.max;\r\n}\r\n', 0, '6 1000 11 445 1 330 3000', '10 365', 'Algorithm: Max-Min-Element (numbers[]) \r\nmax := numbers[1] \r\nmin := numbers[1] \r\n\r\nfor i = 2 to n do \r\n   if numbers[i] > max then  \r\n      max := numbers[i] \r\n   if numbers[i] < min then  \r\n      min := numbers[i] \r\nreturn (max, min) ', '2020-05-25'),
(439, 8, 5301012018, '#include<bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nconst int N = 10000 + 5;\r\n\r\nint A[N][N];\r\nint B[N][N];\r\nint D[N][N];\r\n\r\nvoid matrix_multiply(int n){\r\n	for(int i=0;i<n;i++){\r\n		for(int j=0;j<n;j++){\r\n			D[i][j] = 0;\r\n			for(int k=0;k<n;k++)\r\n				D[i][j] += A[i][k]*B[k][j];\r\n				cout << D[i][j] << \" \";\r\n		}\r\n\r\n	}\r\n}\r\n\r\nstruct matrix{\r\n	int k;\r\n	vector<vector<int> > mat;\r\n\r\n	matrix(int sz){\r\n		k=sz;\r\n		mat.resize(sz);\r\n		for(int i=0;i<sz;i++)\r\n			mat[i].resize(sz);\r\n	}\r\n\r\n	matrix operator + (const matrix &o){\r\n        matrix res(k);\r\n        for(int i=0;i<k;i++){\r\n        	for(int j=0;j<k;j++)\r\n	        	res.mat[i][j]=o.mat[i][j] + mat[i][j];\r\n	    }\r\n        return res;\r\n    }\r\n\r\n    matrix operator - (const matrix &o){\r\n        matrix res(k);\r\n        for(int i=0;i<k;i++){\r\n        	for(int j=0;j<k;j++)\r\n	        	res.mat[i][j]= mat[i][j] - o.mat[i][j];\r\n	    }\r\n        return res;\r\n    }\r\n\r\n	void print(){\r\n		for(int i=0;i<k;i++){\r\n			for(int j=0;j<k;j++){\r\n				cout<<mat[i][j]<<\" \";\r\n			}\r\n\r\n		}\r\n	}\r\n};\r\n\r\nmatrix multiply(matrix A, matrix B, int n){\r\n	if(n==2){\r\n		matrix res(2);\r\n		res.mat[0][0] = A.mat[0][0]*B.mat[0][0] + A.mat[0][1]*B.mat[1][0];\r\n		res.mat[0][1] = A.mat[0][0]*B.mat[0][1] + A.mat[0][1]*B.mat[1][1];\r\n		res.mat[1][0] = A.mat[1][0]*B.mat[0][0] + A.mat[1][1]*B.mat[1][0];\r\n		res.mat[1][1] = A.mat[1][0]*B.mat[0][1] + A.mat[1][1]*B.mat[1][1];\r\n		return res;\r\n	}\r\n	if(n==1){\r\n		matrix res(1);\r\n		res.mat[0][0] = A.mat[0][0]*B.mat[0][0];\r\n		return res;\r\n	}\r\n	int h = n/2;\r\n	matrix A00(h), A01(h), A10(h), A11(h);\r\n	matrix B00(h), B01(h), B10(h), B11(h);\r\n	matrix C00(h), C01(h), C10(h), C11(h);\r\n	for(int i=0;i<h;i++){\r\n		for(int j=0;j<h;j++)\r\n		{\r\n			A00.mat[i][j] = A.mat[i][j];\r\n			B00.mat[i][j] = B.mat[i][j];\r\n			A01.mat[i][j] = A.mat[i][j+h];\r\n			B01.mat[i][j] = B.mat[i][j+h];\r\n			A10.mat[i][j] = A.mat[i+h][j];\r\n			B10.mat[i][j] = B.mat[i+h][j];\r\n			A11.mat[i][j] = A.mat[i+h][j+h];\r\n			B11.mat[i][j] = B.mat[i+h][j+h];\r\n		}\r\n	}\r\n	matrix M1(h), M2(h), M3(h), M4(h), M5(h), M6(h), M7(h);\r\n	M1 = multiply(A00 + A11, (B00 + B11), h);\r\n	M2 = multiply(A10 +  A11, B00, h);\r\n	M3 = multiply(A00, B01 - B11, h);\r\n	M4 = multiply(A11, B10 - B00, h);\r\n	M5 = multiply(A00 + A01, B11, h);\r\n	M6 = multiply(A10 - A00, B00 + B01, h);\r\n	M7 = multiply(A01 - A11, B10 + B11, h);\r\n	C00 = M1 + M4 - M5 + M7;\r\n	C01 = M3 + M5;\r\n	C10 = M2 + M4;\r\n	C11 = M1 - M2 + M3 + M6;\r\n	matrix C(n);\r\n	for(int i=0;i<h;i++){\r\n		for(int j=0;j<h;j++){\r\n			C.mat[i][j] = C00.mat[i][j];\r\n			C.mat[i][j+h] = C01.mat[i][j];\r\n			C.mat[i+h][j] = C10.mat[i][j];\r\n			C.mat[i+h][j+h] = C11.mat[i][j];\r\n		}\r\n	}\r\n	return C;\r\n}\r\n\r\nint main(){\r\n		int n;\r\n		cin>>n;\r\n		matrix E(n), F(n);\r\n		for(int i=0;i<n;i++){\r\n			for(int j=0;j<n;j++){\r\n				cin>>A[i][j];\r\n				E.mat[i][j] = A[i][j];\r\n			}\r\n		}\r\n		cout<<endl;\r\n		for(int i=0;i<n;i++){\r\n			for(int j=0;j<n;j++){\r\n				cin>>B[i][j];\r\n				F.mat[i][j] = B[i][j];\r\n			}\r\n		}\r\n\r\n\r\n		matrix_multiply(n);\r\n		cout<<endl;\r\n\r\n}\r\n', 0, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '\n-17 -4 -7 10 2 11 40 92 107 \n', 'void multiply(int A[][N], int B[][N], int C[][N]) \r\n{ \r\n    for (int i = 0; i < N; i++) \r\n    { \r\n        for (int j = 0; j < N; j++) \r\n        { \r\n            C[i][j] = 0; \r\n            for (int k = 0; k < N; k++) \r\n            { \r\n                C[i][j] += A[i][k]*B[k][j]; \r\n            } \r\n        } \r\n    } \r\n} ', '2020-05-25');
INSERT INTO `qtos_map` (`ID`, `Q_ID`, `ROLL`, `SUBMISSION`, `SCORE`, `INPUT`, `OP`, `ALGO`, `DATE`) VALUES
(440, 5, 5301012018, '#include<iostream>\r\n#include<conio.h>\r\n#include<stdio.h>\r\nusing namespace std; \r\ntypedef long long lld; \r\ninline lld** MatrixMultiply(lld** a, lld** b, int n, \r\n                                      int l, int m) \r\n{ \r\n    lld** c = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        c[i] = new lld[m]; \r\n  \r\n    for (int i = 0; i < n; i++) { \r\n        for (int j = 0; j < m; j++) { \r\n            c[i][j] = 0; \r\n            for (int k = 0; k < l; k++) { \r\n                c[i][j] += a[i][k] * b[k][j]; \r\n            } \r\n        } \r\n    } \r\n    return c; \r\n} \r\n  \r\ninline lld** Strassen(lld** a, lld** b, int n,  \r\n                                int l, int m) \r\n{ \r\n    if (n == 1 || l == 1 || m == 1)  \r\n        return MatrixMultiply(a, b, n, l, m); \r\n  \r\n    lld** c = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        c[i] = new lld[m]; \r\n  \r\n    int adjN = (n >> 1) + (n & 1); \r\n    int adjL = (l >> 1) + (l & 1); \r\n    int adjM = (m >> 1) + (m & 1); \r\n  \r\n    lld**** As = new lld***[2]; \r\n    for (int x = 0; x < 2; x++) { \r\n        As[x] = new lld**[2]; \r\n        for (int y = 0; y < 2; y++) { \r\n            As[x][y] = new lld*[adjN]; \r\n            for (int i = 0; i < adjN; i++) { \r\n                As[x][y][i] = new lld[adjL]; \r\n                for (int j = 0; j < adjL; j++) { \r\n                    int I = i + (x & 1) * adjN; \r\n                    int J = j + (y & 1) * adjL; \r\n                    As[x][y][i][j] = (I < n && J < l) ? a[I][J] : 0; \r\n                } \r\n            } \r\n        } \r\n    } \r\n  \r\n    lld**** Bs = new lld***[2]; \r\n    for (int x = 0; x < 2; x++) { \r\n        Bs[x] = new lld**[2]; \r\n        for (int y = 0; y < 2; y++) { \r\n            Bs[x][y] = new lld*[adjN]; \r\n            for (int i = 0; i < adjL; i++) { \r\n                Bs[x][y][i] = new lld[adjM]; \r\n                for (int j = 0; j < adjM; j++) { \r\n                    int I = i + (x & 1) * adjL; \r\n                    int J = j + (y & 1) * adjM; \r\n                    Bs[x][y][i][j] = (I < l && J < m) ? b[I][J] : 0; \r\n                } \r\n            } \r\n        } \r\n    } \r\n  \r\n    lld*** s = new lld**[10]; \r\n    for (int i = 0; i < 10; i++) { \r\n        switch (i) { \r\n        case 0: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][1][j][k] - Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 1: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] + As[0][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 2: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[1][0][j][k] + As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 3: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[1][0][j][k] - Bs[0][0][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 4: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] + As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 5: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 6: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][1][j][k] - As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 7: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[1][0][j][k] + Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 8: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] - As[1][0][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 9: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[0][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        } \r\n    } \r\n  \r\n    lld*** p = new lld**[7]; \r\n    p[0] = Strassen(As[0][0], s[0], adjN, adjL, adjM); \r\n    p[1] = Strassen(s[1], Bs[1][1], adjN, adjL, adjM); \r\n    p[2] = Strassen(s[2], Bs[0][0], adjN, adjL, adjM); \r\n    p[3] = Strassen(As[1][1], s[3], adjN, adjL, adjM); \r\n    p[4] = Strassen(s[4], s[5], adjN, adjL, adjM); \r\n    p[5] = Strassen(s[6], s[7], adjN, adjL, adjM); \r\n    p[6] = Strassen(s[8], s[9], adjN, adjL, adjM); \r\n  \r\n    for (int i = 0; i < adjN; i++) { \r\n        for (int j = 0; j < adjM; j++) { \r\n            c[i][j] = p[4][i][j] + p[3][i][j] - p[1][i][j] + p[5][i][j]; \r\n            if (j + adjM < m) \r\n                c[i][j + adjM] = p[0][i][j] + p[1][i][j]; \r\n            if (i + adjN < n) \r\n                c[i + adjN][j] = p[2][i][j] + p[3][i][j]; \r\n            if (i + adjN < n && j + adjM < m) \r\n                c[i + adjN][j + adjM] = p[4][i][j] + p[0][i][j] - p[2][i][j] - p[6][i][j]; \r\n        } \r\n    } \r\n  \r\n    for (int x = 0; x < 2; x++) { \r\n        for (int y = 0; y < 2; y++) { \r\n            for (int i = 0; i < adjN; i++) { \r\n                delete[] As[x][y][i]; \r\n            } \r\n            delete[] As[x][y]; \r\n        } \r\n        delete[] As[x]; \r\n    } \r\n    delete[] As; \r\n  \r\n    for (int x = 0; x < 2; x++) { \r\n        for (int y = 0; y < 2; y++) { \r\n            for (int i = 0; i < adjL; i++) { \r\n                delete[] Bs[x][y][i]; \r\n            } \r\n            delete[] Bs[x][y]; \r\n        } \r\n        delete[] Bs[x]; \r\n    } \r\n    delete[] Bs; \r\n  \r\n    for (int i = 0; i < 10; i++) { \r\n        switch (i) { \r\n        case 0: \r\n        case 3: \r\n        case 5: \r\n        case 7: \r\n        case 9: \r\n            for (int j = 0; j < adjL; j++) { \r\n                delete[] s[i][j]; \r\n            } \r\n            break; \r\n        case 1: \r\n        case 2: \r\n        case 4: \r\n        case 6: \r\n        case 8: \r\n            for (int j = 0; j < adjN; j++) { \r\n                delete[] s[i][j]; \r\n            } \r\n            break; \r\n        } \r\n        delete[] s[i]; \r\n    } \r\n    delete[] s; \r\n  \r\n    for (int i = 0; i < 7; i++) { \r\n        for (int j = 0; j < (n >> 1); j++) { \r\n            delete[] p[i][j]; \r\n        } \r\n        delete[] p[i]; \r\n    } \r\n    delete[] p; \r\n  \r\n    return c; \r\n} \r\n  \r\nint main() \r\n{ \r\n    lld** matA; \r\n    matA = new lld*[2]; \r\n    for (int i = 0; i < 2; i++) \r\n        matA[i] = new lld[3]; \r\n    matA[0][0] = 1; \r\n    matA[0][1] = 2; \r\n    matA[0][2] = 3; \r\n    matA[1][0] = 4; \r\n    matA[1][1] = 5; \r\n    matA[1][2] = 6; \r\n  \r\n    lld** matB; \r\n    matB = new lld*[3]; \r\n    for (int i = 0; i < 3; i++) \r\n        matB[i] = new lld[2]; \r\n    matB[0][0] = 7; \r\n    matB[0][1] = 8; \r\n    matB[1][0] = 9; \r\n    matB[1][1] = 10; \r\n    matB[2][0] = 11; \r\n    matB[2][1] = 12; \r\n  \r\n    lld** matC = Strassen(matA, matB, 2, 3, 2); \r\n    for (int i = 0; i < 2; i++) { \r\n        for (int j = 0; j < 2; j++) { \r\n            printf(\"%lld \", matC[i][j]); \r\n        } \r\n        printf(\"\n\"); \r\n    } \r\n  \r\n    return 0; \r\n', 1000, '', '', 'void multiply(int A[][N], int B[][N], int C[][N]) \r\n{ \r\n    for (int i = 0; i < N; i++) \r\n    { \r\n        for (int j = 0; j < N; j++) \r\n        { \r\n            C[i][j] = 0; \r\n            for (int k = 0; k < N; k++) \r\n            { \r\n                C[i][j] += A[i][k]*B[k][j]; \r\n            } \r\n        } \r\n    } \r\n} ', '2020-05-25'),
(441, 16, 5301012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n\r\n#define d 256 \r\n\r\nvoid search(char pat[], char txt[], int q) \r\n{ \r\n	int M = strlen(pat); \r\n	int N = strlen(txt); \r\n	int i, j; \r\n	int p = 0; \r\n	int t = 0; \r\n	int h = 1; \r\n\r\n	for (i = 0; i < M - 1; i++) \r\n		h = (h * d) % q; \r\n\r\n	for (i = 0; i < M; i++) \r\n	{ \r\n		p = (d * p + pat[i]) % q; \r\n		t = (d * t + txt[i]) % q; \r\n	} \r\n\r\n	for (i = 0; i <= N - M; i++) \r\n	{ \r\n\r\n		if ( p == t ) \r\n		{ \r\n			for (j = 0; j < M; j++) \r\n			{ \r\n				if (txt[i+j] != pat[j]) \r\n					break; \r\n			} \r\n\r\n			if (j == M) \r\n				cout<<\"Pattern found at index\"<<\" \"<<i<<\" \"; \r\n		} \r\n\r\n		if ( i < N-M ) \r\n		{ \r\n			t = (d*(t - txt[i]*h) + txt[i+M])%q; \r\n\r\n			if (t < 0) \r\n			t = (t + q); \r\n		} \r\n	} \r\n} \r\n\r\nint main() \r\n{ \r\n	char txt[101]; \r\n	char pat[101]; \r\n	cin >> txt >> pat;\r\n	int q = 101; \r\n	search(pat, txt, q); \r\n	return 0; \r\n} \r\n\r\n', 1000, '', '', 'function RabinKarp(string s[1..n], string pattern[1..m])\r\n    hpattern := hash(pattern[1..m]);\r\n    for i from 1 to n-m+1\r\n        hs := hash(s[i..i+m-1])\r\n        if hs = hpattern\r\n            if s[i..i+m-1] = pattern[1..m]\r\n                return i\r\n    return not found', '2020-05-25'),
(442, 2, 5401012018, 'class Main\r\n{ \r\n    \r\n    void merge(int arr[], int l, int m, int r) \r\n    { \r\n        \r\n        int n1 = m - l + 1; \r\n        int n2 = r - m; \r\n  \r\n        int L[] = new int [n1]; \r\n        int R[] = new int [n2]; \r\n  \r\n       \r\n        for (int i=0; i<n1; ++i) \r\n            L[i] = arr[l + i]; \r\n        for (int j=0; j<n2; ++j) \r\n            R[j] = arr[m + 1+ j]; \r\n  \r\n  \r\n      \r\n        int i = 0, j = 0; \r\n  \r\n    \r\n        int k = l; \r\n        while (i < n1 && j < n2) \r\n        { \r\n            if (L[i] <= R[j]) \r\n            { \r\n                arr[k] = L[i]; \r\n                i++; \r\n            } \r\n            else\r\n            { \r\n                arr[k] = R[j]; \r\n                j++; \r\n            } \r\n            k++; \r\n        } \r\n  \r\n       \r\n        while (i < n1) \r\n        { \r\n            arr[k] = L[i]; \r\n            i++; \r\n            k++; \r\n        } \r\n  \r\n     \r\n        while (j < n2) \r\n        { \r\n            arr[k] = R[j]; \r\n            j++; \r\n            k++; \r\n        } \r\n    } \r\n  \r\n     \r\n    void sort(int arr[], int l, int r) \r\n    { \r\n        if (l < r) \r\n        { \r\n            int m = (l+r)/2; \r\n  \r\n           \r\n            sort(arr, l, m); \r\n            sort(arr , m+1, r); \r\n  \r\n            \r\n            merge(arr, l, m, r); \r\n        } \r\n    } \r\n  \r\n    /* A utility function to print array of size n */\r\n    static void printArray(int arr[]) \r\n    { \r\n        int n = arr.length; \r\n        for (int i=0; i<n; ++i) \r\n            System.out.print(arr[i] + \" \"); \r\n        System.out.println(); \r\n    } \r\n \r\n    public static void main(String args[]) \r\n    { \r\n         Scanner cin=new Scanner(System.in);\r\n         int n=cin.nextInt();\r\n         int arr[] = new int [n];\r\n         for(int i=0;i<n;i++){\r\n         arr[i]=cin.nextInt();\r\n}\r\n  \r\n      \r\n  \r\n        MergeSort ob = new MergeSort(); \r\n        ob.sort(arr, 0, arr.length-1); \r\n  \r\n       \r\n        printArray(arr); \r\n    } \r\n} ', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '', 'MergeSort(arr[], l,  r)\r\nIf r > l\r\n     1. Find the middle point to divide the array into two halves:  \r\n             middle m = (l+r)/2\r\n     2. Call mergeSort for first half:   \r\n             Call mergeSort(arr, l, m)\r\n     3. Call mergeSort for second half:\r\n             Call mergeSort(arr, m+1, r)\r\n     4. Merge the two halves sorted in step 2 and 3:\r\n             Call merge(arr, l, m, r)', '2020-05-25'),
(443, 3, 5401012018, 'class Main \r\n{ \r\n    \r\n   public static  int partition(int arr[], int low, int high) \r\n    { \r\n        int pivot = arr[high];  \r\n        int i = (low-1); // index of smaller element \r\n        for (int j=low; j<high; j++) \r\n        { \r\n            \r\n            if (arr[j] < pivot) \r\n            { \r\n                i++; \r\n  \r\n                // swap arr[i] and arr[j] \r\n                int temp = arr[i]; \r\n                arr[i] = arr[j]; \r\n                arr[j] = temp; \r\n            } \r\n        } \r\n  \r\n        \r\n        int temp = arr[i+1]; \r\n        arr[i+1] = arr[high]; \r\n        arr[high] = temp; \r\n  \r\n        return i+1; \r\n    } \r\n  \r\n  \r\n   \r\n  public static void sort(int arr[], int low, int high) \r\n    { \r\n        if (low < high) \r\n        { \r\n            int pi = partition(arr, low, high); \r\n  \r\n            \r\n            sort(arr, low, pi-1); \r\n            sort(arr, pi+1, high); \r\n        } \r\n    } \r\n  \r\n    \r\n    public static void printArray(int arr[]) \r\n    { \r\n        int n = arr.length; \r\n        for (int i=0; i<n; ++i) \r\n            System.out.print(arr[i]+\" \"); \r\n        System.out.println(); \r\n    } \r\n  \r\n \r\n    public static void main(String args[]) \r\n    { \r\n        Scanner cin=new Scanner(System.in);\r\n         int n=cin.nextInt();\r\n         int arr[] = new int [n];\r\n         for(int i=0;i<n;i++){\r\n         arr[i]=cin.nextInt();\r\n          }\r\n        QuickSort ob = new QuickSort(); \r\n        ob.sort(arr, 0, n-1); \r\n        printArray(arr); \r\n    } \r\n} ', 0, '1 2000', '', 'quickSort(arr[], low, high)\r\n{\r\n    if (low < high)\r\n    {\r\n        \r\n           \r\n        pi = partition(arr, low, high);\r\n\r\n        quickSort(arr, low, pi - 1);  \r\n        quickSort(arr, pi + 1, high); \r\n    }\r\n}', '2020-05-25'),
(444, 7, 5401012018, 'import java.util.*; \r\n  \r\nclass Main\r\n{  \r\n    public static int N = 5; \r\n    public static int[] arr = new int[N]; \r\n      \r\n    \r\n   public static void random(int low,int high) \r\n    { \r\n      \r\n        Random rand= new Random(); \r\n        int pivot = rand.nextInt(high-low) + low; \r\n          \r\n        int temp1=arr[pivot]; \r\n        arr[pivot]=arr[high]; \r\n        arr[high]=temp1; \r\n    } \r\n      \r\n    \r\n      \r\n    public static int partition(int arr[], int low, int high)  \r\n    {  \r\n        \r\n        int pivot = arr[high];  \r\n      \r\n  \r\n        int i = (low-1); \r\n        for (int j = low; j < high; j++)  \r\n        {  \r\n              \r\n            if (arr[j] <= pivot)  \r\n            {  \r\n                i++;  \r\n  \r\n                int temp = arr[i];  \r\n                arr[i] = arr[j];  \r\n                arr[j] = temp;  \r\n            }  \r\n        }  \r\n  \r\n      \r\n        int temp = arr[i+1];  \r\n        arr[i+1] = arr[high];  \r\n        arr[high] = temp;  \r\n  \r\n        return i+1;  \r\n    }  \r\n  \r\n  \r\n \r\n    public static void sort(int arr[], int low, int high)  \r\n    {  \r\n        if (low < high)  \r\n        {  \r\n            \r\n            int pi = partition(arr, low, high);  \r\n   \r\n            sort(arr, low, pi-1);  \r\n            sort(arr, pi+1, high);  \r\n        }  \r\n    }  \r\n  \r\n    \r\n    public static void printArray(int arr[])  \r\n    {  \r\n        int n = arr.length;  \r\n        for (int i = 0; i < n; ++i)  \r\n            System.out.print(arr[i]+\" \");  \r\n        System.out.println();  \r\n    }  \r\n  \r\n   \r\n    public static void main(String args[])  \r\n    {  \r\n        Scanner cin=new Scanner(System.in);\r\n         int n=cin.nextInt();\r\n         int arr[] = new int [n];\r\n         for(int i=0;i<n;i++){\r\n         arr[i]=cin.nextInt();\r\n         }\r\n   \r\n  \r\n        RandomisedQuickSort ob = new RandomisedQuickSort();  \r\n        ob.sort(arr, 0, n-1);  \r\n  \r\n      \r\n        printArray(arr);  \r\n    }  \r\n}  ', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '', '\r\npartition(arr[], lo, hi) \r\n    pivot = arr[hi]\r\n    i = lo     // place for swapping\r\n    for j := lo to hi ? 1 do\r\n        if arr[j] <= pivot then\r\n            swap arr[i] with arr[j]\r\n            i = i + 1\r\n    swap arr[i] with arr[hi]\r\n    return i\r\n\r\npartition_r(arr[], lo, hi)\r\n    r = Random Number from lo to hi\r\n    Swap arr[r] and arr[hi]\r\n    return partition(arr, lo, hi)\r\n\r\nquicksort(arr[], lo, hi)\r\n    if lo < hi\r\n        p = partition_r(arr, lo, hi)\r\n        quicksort(arr, p-1, hi)\r\n        quicksort(arr, p+1, hi)', '2020-05-25'),
(445, 9, 5401012018, '\r\n \r\nimport java.io.*; \r\nimport java.util.*; \r\n  \r\nclass DisjointUnionSets { \r\n    int[] rank, parent; \r\n    int n; \r\n  \r\n    public DisjointUnionSets(int n) \r\n    { \r\n        rank = new int[n]; \r\n        parent = new int[n]; \r\n        this.n = n; \r\n        makeSet(); \r\n    } \r\n  \r\n   \r\n    void makeSet() \r\n    { \r\n        for (int i = 0; i < n; i++) { \r\n           \r\n            parent[i] = i; \r\n        } \r\n    } \r\n  \r\n    \r\n    int find(int x) \r\n    { \r\n       \r\n        if (parent[x] != x) { \r\n           \r\n            parent[x] = find(parent[x]); \r\n  \r\n           \r\n        } \r\n  \r\n        return parent[x]; \r\n    } \r\n  \r\n    \r\n    void union(int x, int y) \r\n    { \r\n        \r\n        int xRoot = find(x), yRoot = find(y); \r\n  \r\n        if (xRoot == yRoot) \r\n            return; \r\n  \r\n       \r\n        if (rank[xRoot] < rank[yRoot]) \r\n  \r\n           \r\n            parent[xRoot] = yRoot; \r\n  \r\n       \r\n        else if (rank[yRoot] < rank[xRoot]) \r\n  \r\n           \r\n            parent[yRoot] = xRoot; \r\n  \r\n        else \r\n        { \r\n            \r\n            parent[yRoot] = xRoot; \r\n  \r\n          \r\n            rank[xRoot] = rank[xRoot] + 1; \r\n        } \r\n    } \r\n} \r\n  \r\n\r\npublic class Main { \r\n    public static void main(String[] args) \r\n    { \r\n        int n = 5; \r\n        DisjointUnionSets dus =  \r\n                new DisjointUnionSets(n); \r\n  \r\n      \r\n        dus.union(0, 2); \r\n  \r\n         \r\n        dus.union(4, 2); \r\n  \r\n        dus.union(3, 1); \r\n  \r\n        // Check if 4 is a friend of 0 \r\n        if (dus.find(4) == dus.find(0)) \r\n            System.out.println(\"Yes\"); \r\n        else\r\n            System.out.println(\"No\"); \r\n  \r\n        // Check if 1 is a friend of 0 \r\n        if (dus.find(1) == dus.find(0)) \r\n            System.out.println(\"Yes\"); \r\n        else\r\n            System.out.println(\"No\"); \r\n    } \r\n} ', 1000, '', '', ' Partitioning the individuals into different sets according to the groups in which they fall. This method is known as disjoint set data structure which maintains collection of disjoint sets and each set is represented by its representative which is one of its members.\r\n\r\nApproach:\r\n\r\nHow to Resolve sets ? Initially all elements belong to different sets. After working on the given relations, we select a member as representative. There can by many ways to select a representative, a simple one is to select with the biggest index.\r\nCheck if 2 persons are in the same group ? If representatives of two individuals are same, then they?ll become friends.\r\n ', '2020-05-25'),
(446, 10, 5401012018, 'class Main\r\n{ \r\n  \r\n    \r\n   public  static int max(int a, int b) { return (a > b)? a : b; } \r\n       \r\n  \r\n  public   static int knapSack(int W, int wt[], int val[], int n) \r\n    { \r\n         int i, w; \r\n     int K[][] = new int[n+1][W+1]; \r\n       \r\n     // Build table K[][] in bottom up manner \r\n     for (i = 0; i <= n; i++) \r\n     { \r\n         for (w = 0; w <= W; w++) \r\n         { \r\n             if (i==0 || w==0) \r\n                  K[i][w] = 0; \r\n             else if (wt[i-1] <= w) \r\n                   K[i][w] = max(val[i-1] + K[i-1][w-wt[i-1]],  K[i-1][w]); \r\n             else\r\n                   K[i][w] = K[i-1][w]; \r\n         } \r\n      } \r\n       \r\n      return K[n][W]; \r\n    } \r\n  \r\n    public static void main(String args[]) \r\n    {  Scanner cin=new Scanner(System.in);\r\n       int n=cin.nextInt();\r\n        int val[] = new int[n];\r\n   for(int i=0;i<n;i++){\r\n      int val=cin.nextInt();\r\n      val[i]=val;   \r\n} \r\n    int wt[] = new int[n];\r\n for(int i=0;i<n;i++){\r\n      int val=cin.nextInt();\r\n      wt[i]=val;   \r\n} \r\n    int W=cin.nextInt();\r\n    System.out.println(knapSack(W, wt, val, n)); \r\n    } \r\n} ', 0, '5 15 4 2 1 2 10 12 2 1 1 4', '', 'Algorithm :\r\n1.Declare a 2-d array DP[][] of dimensions (Number of weight elements+1)*(capacity)\r\n2.Consider ?0th? row as ?weight value=0? and ?0th? column as ?capacity=0? fill the ?0th? row and ?0th? column with ?0?.\r\n3.Now loop through all weight elements ?wi?.\r\n4.For each ?wi? loop through all weights in the columns ?wj>wi? and DP[i][j]=max(DP[i-1][j],val[wi]+DP[i-1][j-wi]).\r\nreturn the value DP[Number of weight elements][capacity]', '2020-05-25'),
(447, 11, 5401012018, '0', 0, '8 a b c d e f g h 1 1 2 3 5 8 13 21', 'h:0\ng:10\nf:110\ne:1110\nd:11110\nc:111110\na:1111110\nb:1111111\n', 'Input is an array of unique characters along with their frequency of occurrences and output is Huffman Tree.\r\n\r\n1. Create a leaf node for each unique character and build a min heap of all leaf nodes (Min Heap is used as a priority queue. The value of frequency field is used to compare two nodes in min heap. Initially, the least frequent character is at root)\r\n\r\n2. Extract two nodes with the minimum frequency from the min heap.\r\n\r\n3. Create a new internal node with a frequency equal to the sum of the two nodes frequencies. Make the first extracted node as its left child and the other extracted node as its right child. Add this node to the min heap.\r\n\r\n4. Repeat steps#2 and #3 until the heap contains only one node. The remaining node is the root node and the tree is complete.', '2020-05-25'),
(448, 12, 5401012018, 'import java.util.*; \r\nimport java.lang.*; \r\nimport java.io.*; \r\n  \r\nclass Main\r\n{ \r\n  \r\n    class Edge implements Comparable<Edge> \r\n    { \r\n        int src, dest, weight; \r\n  \r\n       \r\n        public int compareTo(Edge compareEdge) \r\n        { \r\n            return this.weight-compareEdge.weight; \r\n        } \r\n    }; \r\n  \r\n    \r\n    class subset \r\n    { \r\n        int parent, rank; \r\n    }; \r\n  \r\n    int V, E;    \r\n    Edge edge[]; \r\n  \r\n\r\n    Graph(int v, int e) \r\n    { \r\n        V = v; \r\n        E = e; \r\n        edge = new Edge[E]; \r\n        for (int i=0; i<e; ++i) \r\n            edge[i] = new Edge(); \r\n    } \r\n  \r\n    \r\n    int find(subset subsets[], int i) \r\n    { \r\n       \r\n        if (subsets[i].parent != i) \r\n            subsets[i].parent = find(subsets, subsets[i].parent); \r\n  \r\n        return subsets[i].parent; \r\n    } \r\n  \r\n    \r\n    void Union(subset subsets[], int x, int y) \r\n    { \r\n        int xroot = find(subsets, x); \r\n        int yroot = find(subsets, y); \r\n  \r\n       \r\n        if (subsets[xroot].rank < subsets[yroot].rank) \r\n            subsets[xroot].parent = yroot; \r\n        else if (subsets[xroot].rank > subsets[yroot].rank) \r\n            subsets[yroot].parent = xroot; \r\n  \r\n      \r\n        else\r\n        { \r\n            subsets[yroot].parent = xroot; \r\n            subsets[xroot].rank++; \r\n        } \r\n    } \r\n  \r\n    void KruskalMST() \r\n    { \r\n        Edge result[] = new Edge[V];  \r\n        int e = 0;  \r\n        int i = 0;  \r\n        for (i=0; i<V; ++i) \r\n            result[i] = new Edge(); \r\n  \r\n        \r\n        Arrays.sort(edge); \r\n  \r\n       \r\n        subset subsets[] = new subset[V]; \r\n        for(i=0; i<V; ++i) \r\n            subsets[i]=new subset(); \r\n  \r\n       \r\n        for (int v = 0; v < V; ++v) \r\n        { \r\n            subsets[v].parent = v; \r\n            subsets[v].rank = 0; \r\n        } \r\n  \r\n        i = 0;  \r\n  \r\n        \r\n        while (e < V - 1) \r\n        { \r\n          \r\n            Edge next_edge = new Edge(); \r\n            next_edge = edge[i++]; \r\n  \r\n            int x = find(subsets, next_edge.src); \r\n            int y = find(subsets, next_edge.dest); \r\n  \r\n         \r\n            if (x != y) \r\n            { \r\n                result[e++] = next_edge; \r\n                Union(subsets, x, y); \r\n            } \r\n         \r\n        } \r\n  \r\n      \r\n        System.out.println(\"Following are the edges in \" +  \r\n                                     \"the constructed MST\"); \r\n        for (i = 0; i < e; ++i) \r\n            System.out.println(result[i].src+\" -- \" +  \r\n                   result[i].dest+\" == \" + result[i].weight); \r\n    } \r\n  \r\n    public static void main (String[] args) \r\n    { \r\n        int V = 4;  \r\n        int E = 5;  \r\n        Graph graph = new Graph(V, E); \r\n  \r\n      \r\n        graph.edge[0].src = 0; \r\n        graph.edge[0].dest = 1; \r\n        graph.edge[0].weight = 10; \r\n  \r\n   \r\n        graph.edge[1].src = 0; \r\n        graph.edge[1].dest = 2; \r\n        graph.edge[1].weight = 6; \r\n  \r\n      \r\n        graph.edge[2].src = 0; \r\n        graph.edge[2].dest = 3; \r\n        graph.edge[2].weight = 5; \r\n  \r\n      \r\n        graph.edge[3].src = 1; \r\n        graph.edge[3].dest = 3; \r\n        graph.edge[3].weight = 15; \r\n  \r\n        \r\n        graph.edge[4].src = 2; \r\n        graph.edge[4].dest = 3; \r\n        graph.edge[4].weight = 4; \r\n  \r\n        graph.KruskalMST(); \r\n    } \r\n} ', 1000, '', '', '1. Sort all the edges in non-decreasing order of their weight.\r\n2. Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If cycle is not formed, include this edge. Else, discard it.\r\n3. Repeat step#2 until there are (V-1) edges in the spanning tree.', '2020-05-25'),
(449, 13, 5401012018, 'import java.util.*;\r\npublic class Main\r\n{\r\n    public  int isVisited[] = new int[15];\r\n    public  int cost[][] = new int[10][10];\r\n public int minimum_cost;\r\n     \r\n    public void calc(int n)\r\n    {   \r\n        int flag[] = new int[n+1];\r\n        int i,j,min=999,num_edges=1,a=1,b=1,minpos_i=1,minpos_j=1;\r\n         \r\n  while(num_edges < n)\r\n        {    \r\n            \r\n            for(i=1,min=999;i<=n;i++)\r\n             for(j=1;j<=n;j++)\r\n              if(this.cost[i][j]<min)\r\n                if(this.isVisited[i]!=0)\r\n                 {\r\n                      min=this.cost[i][j];\r\n                      a=minpos_i=i;\r\n                      b=minpos_j=j;\r\n                 }\r\n if(this.isVisited[minpos_i]==0 || this.isVisited[minpos_j]==0)\r\n             {\r\n  System.out.println(\"Edge Number 	\"+num_edges+\"	 from Vertex 	\"+a+\"	  to Vertex 	\"+b+\"-mincost:\"+min+\" \n\");\r\n                      this.minimum_cost=this.minimum_cost+min;\r\n        num_edges=num_edges+1; \r\n                      this.isVisited[b]=1;\r\n             }\r\n                   this.cost[a][b]=this.cost[b][a]=999;   \r\n        \r\n        \r\n  }   \r\n         \r\n    }\r\n    public static void main(String args[])\r\n    {\r\n        int nodes,i,j;\r\n        Scanner in = new Scanner(System.in);\r\n        nodes = in.nextInt();\r\n        Prims p = new Prims();\r\n        for(i=1;i<=nodes;i++)\r\n          for(j=1;j<=nodes;j++)\r\n          {\r\n            p.cost[i][j]=in.nextInt();\r\n            if(p.cost[i][j]==0)\r\n              p.cost[i][j]=999;\r\n          }\r\n       \r\n        p.isVisited[1]=1; \r\n        p.calc(nodes);\r\n  \r\n         \r\n    }   \r\n}', 1000, '', '', 'Algorithm\r\n1) Create a set mstSet that keeps track of vertices already included in MST.\r\n2) Assign a key value to all vertices in the input graph. Initialize all key values as INFINITE. Assign key value as 0 for the first vertex so that it is picked first.\r\n3) While mstSet doesn?t include all vertices\r\n?.a) Pick a vertex u which is not there in mstSet and has minimum key value.\r\n?.b) Include u to mstSet.\r\n?.c) Update key value of all adjacent vertices of u. To update the key values, iterate through all adjacent vertices. For every adjacent vertex v, if weight of edge u-v is less than the previous key value of v, update the key value as weight of u-v\r\nThe idea of using key values is to pick the minimum weight edge from cut. The key values are used only for vertices which are not yet included in MST, the key value for these vertices indicate the minimum weight edges connecting them to the set of vertices included in MST.\r\n\r\n', '2020-05-25'),
(450, 14, 5401012018, '\r\nimport java.util.*; \r\nimport java.lang.*; \r\nimport java.io.*; \r\n  \r\n\r\nclass Main { \r\n    \r\n    class Edge { \r\n        int src, dest, weight; \r\n        Edge() \r\n        { \r\n            src = dest = weight = 0; \r\n        } \r\n    }; \r\n  \r\n    int V, E; \r\n    Edge edge[]; \r\n  \r\n    \r\n    Graph(int v, int e) \r\n    { \r\n        V = v; \r\n        E = e; \r\n        edge = new Edge[e]; \r\n        for (int i = 0; i < e; ++i) \r\n            edge[i] = new Edge(); \r\n    } \r\n  \r\n   \r\n   public static void BellmanFord(Graph graph, int src) \r\n    { \r\n        int V = graph.V, E = graph.E; \r\n        int dist[] = new int[V]; \r\n  \r\n        \r\n        for (int i = 0; i < V; ++i) \r\n            dist[i] = Integer.MAX_VALUE; \r\n        dist[src] = 0; \r\n  \r\n      \r\n        for (int i = 1; i < V; ++i) { \r\n            for (int j = 0; j < E; ++j) { \r\n                int u = graph.edge[j].src; \r\n                int v = graph.edge[j].dest; \r\n                int weight = graph.edge[j].weight; \r\n                if (dist[u] != Integer.MAX_VALUE && dist[u] + weight < dist[v]) \r\n                    dist[v] = dist[u] + weight; \r\n            } \r\n        } \r\n  \r\n        \r\n        for (int j = 0; j < E; ++j) { \r\n            int u = graph.edge[j].src; \r\n            int v = graph.edge[j].dest; \r\n            int weight = graph.edge[j].weight; \r\n            if (dist[u] != Integer.MAX_VALUE && dist[u] + weight < dist[v]) { \r\n                System.out.println(\"Graph contains negative weight cycle\"); \r\n                return; \r\n            } \r\n        } \r\n        printArr(dist, V); \r\n    } \r\n  \r\n   \r\n    void printArr(int dist[], int V) \r\n    { \r\n        for (int i = 0; i < V; ++i) \r\n            System.out.println(i + \"		\" + dist[i]); \r\n    } \r\n  \r\n   \r\n    public static void main(String[] args) \r\n    { \r\n        int V = 5; \r\n        int E = 8; \r\n  \r\n        Graph graph = new Graph(V, E); \r\n  \r\n        // add edge 0-1 (or A-B in above figure) \r\n        graph.edge[0].src = 0; \r\n        graph.edge[0].dest = 1; \r\n        graph.edge[0].weight = -1; \r\n  \r\n        // add edge 0-2 (or A-C in above figure) \r\n        graph.edge[1].src = 0; \r\n        graph.edge[1].dest = 2; \r\n        graph.edge[1].weight = 4; \r\n  \r\n        // add edge 1-2 (or B-C in above figure) \r\n        graph.edge[2].src = 1; \r\n        graph.edge[2].dest = 2; \r\n        graph.edge[2].weight = 3; \r\n  \r\n        // add edge 1-3 (or B-D in above figure) \r\n        graph.edge[3].src = 1; \r\n        graph.edge[3].dest = 3; \r\n        graph.edge[3].weight = 2; \r\n  \r\n        // add edge 1-4 (or A-E in above figure) \r\n        graph.edge[4].src = 1; \r\n        graph.edge[4].dest = 4; \r\n        graph.edge[4].weight = 2; \r\n  \r\n        // add edge 3-2 (or D-C in above figure) \r\n        graph.edge[5].src = 3; \r\n        graph.edge[5].dest = 2; \r\n        graph.edge[5].weight = 5; \r\n  \r\n        // add edge 3-1 (or D-B in above figure) \r\n        graph.edge[6].src = 3; \r\n        graph.edge[6].dest = 1; \r\n        graph.edge[6].weight = 1; \r\n  \r\n        // add edge 4-3 (or E-D in above figure) \r\n        graph.edge[7].src = 4; \r\n        graph.edge[7].dest = 3; \r\n        graph.edge[7].weight = -3; \r\n  \r\n        graph.BellmanFord(graph, 0); \r\n    } \r\n} ', 1000, '', '', 'Algorithm\r\nFollowing are the detailed steps.\r\n\r\nInput: Graph and a source vertex src\r\nOutput: Shortest distance to all vertices from src. If there is a negative weight cycle, then shortest distances are not calculated, negative weight cycle is reported.\r\n\r\n\r\n\r\n\r\n1) This step initializes distances from the source to all vertices as infinite and distance to the source itself as 0. Create an array dist[] of size |V| with all values as infinite except dist[src] where src is source vertex.\r\n\r\n2) This step calculates shortest distances. Do following |V|-1 times where |V| is the number of vertices in given graph.\r\n?..a) Do following for each edge u-v\r\n??????If dist[v] > dist[u] + weight of edge uv, then update dist[v]\r\n???????.dist[v] = dist[u] + weight of edge uv\r\n\r\n3) This step reports if there is a negative weight cycle in graph. Do following for each edge u-v\r\n??If dist[v] > dist[u] + weight of edge uv, then ?Graph contains negative weight cycle?', '2020-05-25'),
(451, 15, 5401012018, 'class MatrixChainMultiplication \r\n{ \r\n  public static int MatrixChainOrder(int p[], int i, int j) \r\n    { \r\n        if (i == j) \r\n            return 0; \r\n  \r\n        int min = Integer.MAX_VALUE; \r\n        for (int k=i; k<j; k++) \r\n        { \r\n            int count = MatrixChainOrder(p, i, k) + \r\n                        MatrixChainOrder(p, k+1, j) + \r\n                        p[i-1]*p[k]*p[j]; \r\n  \r\n            if (count < min) \r\n                min = count; \r\n        } \r\n  \r\n        return min; \r\n    } \r\n  \r\n    \r\n    public static void main(String args[]) \r\n    {   Scanner cin=new Scanner(System.in);\r\n        int n=cin.nextInt();\r\n        int arr[] = new int[n] ;\r\n        for(int i=0;i<n;i++){\r\n         int val=cin.nextInt();\r\n        arr[i]=val;           \r\n}\r\n  \r\n        System.out.println(MatrixChainOrder(arr, 1, n-1)); \r\n  \r\n    } \r\n} ', 1000, '', '', 'A simple solution is to place parenthesis at all possible places, calculate the cost for each placement and return the minimum value. In a chain of matrices of size n, we can place the first set of parenthesis in n-1 ways. For example, if the given chain is of 4 matrices. let the chain be ABCD, then there are 3 ways to place first set of parenthesis outer side: (A)(BCD), (AB)(CD) and (ABC)(D). So when we place a set of parenthesis, we divide the problem into subproblems of smaller size. Therefore, the problem has optimal substructure property and can be easily solved using recursion.\r\n\r\nMinimum number of multiplication needed to multiply a chain of size n = Minimum of all n-1 placements (these placements create subproblems of smaller size)', '2020-05-25'),
(452, 4, 5401012018, 'public class Main { \r\n\r\n    static class Pair { \r\n  \r\n        int min; \r\n        int max; \r\n    } \r\n  \r\n public static Pair getMinMax(int arr[], int low, int high) { \r\n        Pair minmax = new Pair(); \r\n        Pair mml = new Pair(); \r\n        Pair mmr = new Pair(); \r\n        int mid; \r\n  \r\n        \r\n        if (low == high) { \r\n            minmax.max = arr[low]; \r\n            minmax.min = arr[low]; \r\n            return minmax; \r\n        } \r\n  \r\n       \r\n        if (high == low + 1) { \r\n            if (arr[low] > arr[high]) { \r\n                minmax.max = arr[low]; \r\n                minmax.min = arr[high]; \r\n            } else { \r\n                minmax.max = arr[high]; \r\n                minmax.min = arr[low]; \r\n            } \r\n            return minmax; \r\n        } \r\n  \r\n       \r\n        mid = (low + high) / 2; \r\n        mml = getMinMax(arr, low, mid); \r\n        mmr = getMinMax(arr, mid + 1, high); \r\n  \r\n        if (mml.min < mmr.min) { \r\n            minmax.min = mml.min; \r\n        } else { \r\n            minmax.min = mmr.min; \r\n        } \r\n        if (mml.max > mmr.max) { \r\n            minmax.max = mml.max; \r\n        } else { \r\n            minmax.max = mmr.max; \r\n        } \r\n  \r\n        return minmax; \r\n    } \r\n  \r\n    public static void main(String args[]) { \r\n        int arr[] = {1000, 11, 445, 1, 330, 3000}; \r\n        int arr_size = 6; \r\n        Pair minmax = getMinMax(arr, arr_size); \r\n        System.out.printf(\"\nMinimum element is %d\", minmax.min); \r\n        System.out.printf(\"\nMaximum element is %d\", minmax.max); \r\n  \r\n    } \r\n} ', 0, '6 1000 11 445 1 330 3000', '', 'Pair MaxMin(array, array_size)\r\n   if array_size = 1\r\n      return element as both max and min\r\n   else if arry_size = 2\r\n      one comparison to determine max and min\r\n      return that pair\r\n   else    /* array_size  > 2 */\r\n      recur for max and min of left half\r\n      recur for max and min of right half\r\n      one comparison determines true max of the two candidates\r\n      one comparison determines true min of the two candidates\r\n      return the pair of max and min', '2020-05-25'),
(453, 16, 5401012018, 'public class Main  \r\n{ \r\n    \r\n    public final static int d = 256; \r\n      \r\n  \r\n    static void search(String pat, String txt, int q) \r\n    { \r\n        int M = pat.length(); \r\n        int N = txt.length(); \r\n        int i, j; \r\n        int p = 0; \r\n        int t = 0; \r\n        int h = 1; \r\n      \r\n        \r\n        for (i = 0; i < M-1; i++) \r\n            h = (h*d)%q; \r\n      \r\n      \r\n        for (i = 0; i < M; i++) \r\n        { \r\n            p = (d*p + pat.charAt(i))%q; \r\n            t = (d*t + txt.charAt(i))%q; \r\n        } \r\n      \r\n       \r\n        for (i = 0; i <= N - M; i++) \r\n        { \r\n      \r\n            \r\n            if ( p == t ) \r\n            { \r\n               \r\n                for (j = 0; j < M; j++) \r\n                { \r\n                    if (txt.charAt(i+j) != pat.charAt(j)) \r\n                        break; \r\n                } \r\n      \r\n                \r\n                if (j == M) \r\n                    System.out.println(\"Pattern found at index \" + i); \r\n            } \r\n      \r\n            \r\n            if ( i < N-M ) \r\n            { \r\n                t = (d*(t - txt.charAt(i)*h) + txt.charAt(i+M))%q; \r\n      \r\n                if (t < 0) \r\n                t = (t + q); \r\n            } \r\n        } \r\n    } \r\n      \r\n    \r\n    public static void main(String[] args) \r\n    {   Scanner cin=new Scanner(System.in);\r\n        String txt = cin.nextLine();\r\n        String pat = cin.nextLine(); \r\n        int q = 101; \r\n        search(pat, txt, q); \r\n    } \r\n} ', 1000, '', '', ' Rabin Karp algorithm matches the hash value of the pattern with the hash value of current substring of text, and if the hash values match then only it starts matching individual characters. So Rabin Karp algorithm needs to calculate hash values for following strings.\r\n1) Pattern itself.\r\n2) All the substrings of text of length m.\r\n\r\nSince we need to efficiently calculate hash values for all the substrings of size m of text, we must have a hash function which has following property.\r\nHash at the next shift must be efficiently computable from the current hash value and next character in text or we can say hash(txt[s+1 .. s+m]) must be efficiently computable from hash(txt[s .. s+m-1]) and txt[s+m] i.e., hash(txt[s+1 .. s+m])= rehash(txt[s+m], hash(txt[s .. s+m-1])) and rehash must be O(1) operation.\r\n\r\nThe hash function suggested by Rabin and Karp calculates an integer value. The integer value for a string is numeric value of a string. For example, if all possible characters are from 1 to 10, the numeric value of ?122? will be 122. The number of possible characters is higher than 10 (256 in general) and pattern length can be large. So the numeric values cannot be practically stored as an integer. Therefore, the numeric value is calculated using modular arithmetic to make sure that the hash values can be stored in an integer variable (can fit in memory words). To do rehashing, we need to take off the most significant digit and add the new least significant digit for in hash value. Rehashing is done using the following formula.\r\n\r\nhash( txt[s+1 .. s+m] ) = ( d ( hash( txt[s .. s+m-1]) ? txt[s]*h ) + txt[s + m] ) mod q\r\n\r\nhash( txt[s .. s+m-1] ) : Hash value at shift s.\r\nhash( txt[s+1 .. s+m] ) : Hash value at next shift (or shift s+1)\r\nd: Number of characters in the alphabet\r\nq: A prime number\r\nh: d^(m-1)\r\n\r\n', '2020-05-25'),
(454, 2, 5501012018, '#include<stdio.h>\r\nvoid merge(int input[],int l,int m,int r)\r\n{\r\n    int i,j,k;\r\n    int n1=m-l+1;\r\n    int n2=r-m;\r\n    int L[n1],R[n2];\r\n    for(i=0;i<n1;i++)\r\n        L[i]=input[l+i];\r\n    for(j=0;j<n2;j++)\r\n        R[j]=input[m+1+j];\r\n    i=0;\r\n    j=0;\r\n    k=l;\r\n    while(i<n1&&j<n2)\r\n    {\r\n        if(L[i]<=R[j])\r\n        {\r\n            input[k]=L[i];\r\n            i++;\r\n            k++;\r\n        }\r\n        else\r\n        {\r\n            input[k]=R[j];\r\n            j++;\r\n            k++;\r\n        }\r\n    }\r\n    while(i<n1)\r\n    {\r\n         input[k]=L[i];\r\n         i++;\r\n         k++;\r\n    }\r\n    while(j<n2)\r\n    {\r\n         input[k]=R[j];\r\n         j++;\r\n         k++;\r\n    }\r\n}\r\nvoid merge_Sort(int input[],int l,int r)\r\n{\r\n    int m;\r\n    if(l<r)\r\n    {\r\n        m=(r+l)/2;\r\n        merge_Sort(input,l,m);\r\n        merge_Sort(input,m+1,r);\r\n        merge(input,l,m,r);\r\n    }\r\n}\r\n\r\nvoid mergeSort(int input[], int size)\r\n{\r\n    int l=0;\r\n    int r=size-1;\r\n    merge_Sort(input,l,r);\r\n}\r\n\r\nint main()\r\n{\r\n    int input[100],n,i;\r\n    scanf(\"%d\",&n);\r\n    for(i=0; i < n; i++)\r\n        scanf(\"%d\",&input[i]);\r\n    mergeSort(input, n);\r\n    for(i = 0; i < n; i++)\r\n    {\r\n        printf(\"%d \",input[i]);\r\n    }\r\n    return 0;\r\n}\r\n', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', 'MERGE SORT ALGORITHM\r\nsteps to be followed:\r\n1. if it is only one element in the list it is already sorted, return.\r\n2. divide the list recursively into two halves until it can no more be divided.\r\n3. merge the smaller lists into new list in sorted order.\r\n', '2020-05-25'),
(455, 3, 5501012018, '#include<stdio.h>\r\n\r\nint partition(int arr[],int si,int en)\r\n{\r\n    int pivot=arr[si];\r\n    int countsmaller=0,i;\r\n    for(i=si+1;i<=en;i++)\r\n        if(arr[i]<=pivot)\r\n            countsmaller++;\r\n\r\n    int pivotindex=si+countsmaller;\r\n    arr[si]=arr[pivotindex];\r\n    arr[pivotindex]=pivot;\r\n\r\n    i=si;\r\n    int j=en;\r\n\r\n    while(i<pivotindex && j>pivotindex)\r\n    {\r\n        if(arr[i]<=pivot)\r\n            i++;\r\n        else if(arr[j]>pivot)\r\n            j--;\r\n        else\r\n        {\r\n            int temp=arr[i];\r\n            arr[i]=arr[j];\r\n            arr[j]=temp;\r\n            i++;\r\n            j--;\r\n        }\r\n    }\r\n    return pivotindex;\r\n}\r\n\r\nvoid quicksort(int arr[],int i,int j)\r\n{\r\n    if(i<j)\r\n    {\r\n        int p=partition(arr,i,j);\r\n        quicksort(arr,i,p-1);\r\n        quicksort(arr,p+1,j);\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    int arr[100],i;\r\n    int n;\r\n    scanf(\"%d\",&n);\r\n    for(i=0;i<n;i++)\r\n        scanf(\"%d\",&arr[i]);\r\n\r\n    quicksort(arr,0,n-1);\r\n    for(i=0;i<n;i++)\r\n    {\r\n        printf(\"%d \",arr[i]);\r\n    }\r\n    return 0;\r\n}\r\n', 10, '1 2000', '2000 ', 'QUICK SORT ALGORITHM\r\n 1 − Choose the highest index value has pivot\r\n 2 − Take two variables to point left and right of the list excluding pivot\r\n 3 − left points to the low index\r\n 4 − right points to the high\r\n 5 − while value at left is less than pivot move right\r\n 6 − while value at right is greater than pivot move left\r\n 7 − if both step 5 and step 6 does not match swap left and right\r\n 8 − if left ≥ right, the point where they met is new pivot', '2020-05-25'),
(456, 7, 5501012018, '#include<stdio.h>\r\n#include<math.h>\r\n#include<stdlib.h>\r\nvoid quicksort(int *ar,int start,int end);\r\nint  divide(int *ar,int start,int end,int pivot);\r\n\r\nvoid main()\r\n{\r\n        int size;\r\n        int itr;\r\n        scanf(\"%d\",&size);\r\n        int a[size];\r\n        for(itr=0;itr<size;itr++)\r\n        {\r\n            scanf(\"%d\",&a[itr]);\r\n        }\r\n        quicksort(a,0,size-1);\r\n        for(itr=0;itr<size;itr++)\r\n            if(itr==size-1)\r\n                printf(\"%d\",a[itr]);\r\n            else\r\n                printf(\"%d \",a[itr]);\r\n\r\n}\r\n\r\nvoid quicksort(int *ar,int start,int end)\r\n{\r\n        if(start < end)\r\n        {\r\n            int pivot = start;\r\n            pivot = rand() % (end - start) + start ;\r\n            pivot = divide(ar,start,end,pivot);\r\n            quicksort(ar,start,pivot-1);\r\n            quicksort (ar,pivot+1,end);\r\n        }\r\n}\r\nint  divide(int *ar,int start,int end,int pivot)\r\n{\r\n        int itr,temp,next,next1;\r\n        temp =ar[pivot];\r\n        ar[pivot]=ar[start];\r\n        ar[start]=temp;\r\n        pivot =start;\r\n        next =start+1;\r\n        while(next<=end)\r\n        {\r\n            if(ar[next]<ar[pivot])\r\n            {\r\n                temp = ar[next];\r\n                next1 = next;\r\n                while(next1!=pivot+1)\r\n                {\r\n                    ar[next1]=ar[next1-1];\r\n                    next1--;\r\n                }\r\n                ar[next1]=ar[pivot];\r\n                ar[pivot]=temp;\r\n                pivot++;\r\n            }\r\n            next++;\r\n        }\r\n    return pivot;\r\n}\r\n', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000', 'RANDOMIZED QUICK SORT ALGORITHM\r\n\r\nSTART\r\npartition(arr[], lo, hi) \r\n    pivot = arr[hi]\r\n    i = lo     // place for swapping\r\n    for j := lo to hi – 1 do\r\n        if arr[j] <= pivot then\r\n            swap arr[i] with arr[j]\r\n            i = i + 1\r\n    swap arr[i] with arr[hi]\r\n    return i\r\n\r\npartition_r(arr[], lo, hi)\r\n    r = Random Number from lo to hi\r\n    Swap arr[r] and arr[hi]\r\n    return partition(arr, lo, hi)\r\n\r\nquicksort(arr[], lo, hi)\r\n    if lo < hi\r\n        p = partition_r(arr, lo, hi)\r\n        quicksort(arr, p-1, hi)\r\n        quicksort(arr, p+1, hi)\r\nEND', '2020-05-25');
INSERT INTO `qtos_map` (`ID`, `Q_ID`, `ROLL`, `SUBMISSION`, `SCORE`, `INPUT`, `OP`, `ALGO`, `DATE`) VALUES
(457, 9, 5501012018, '\r\n#include <iostream>\r\nusing namespace std;\r\nclass DisjSet {\r\n    int *rank, *parent, n;\r\n\r\npublic:\r\n\r\n    DisjSet(int n)\r\n    {\r\n        rank = new int[n];\r\n        parent = new int[n];\r\n        this->n = n;\r\n        makeSet();\r\n    }\r\n\r\n    void makeSet()\r\n    {\r\n        for (int i = 0; i < n; i++) {\r\n            parent[i] = i;\r\n        }\r\n    }\r\n\r\n    int find(int x)\r\n    {\r\n\r\n        if (parent[x] != x) {\r\n\r\n            parent[x] = find(parent[x]);\r\n\r\n        }\r\n\r\n        return parent[x];\r\n    }\r\n\r\n    void Union(int x, int y)\r\n    {\r\n\r\n        int xset = find(x);\r\n        int yset = find(y);\r\n        if (xset == yset)\r\n            return;\r\n\r\n        if (rank[xset] < rank[yset]) {\r\n            parent[xset] = yset;\r\n        }\r\n        else if (rank[xset] > rank[yset]) {\r\n            parent[yset] = xset;\r\n        }\r\n\r\n        else {\r\n            parent[yset] = xset;\r\n            rank[xset] = rank[xset] + 1;\r\n        }\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    DisjSet obj(5);\r\n    obj.Union(0, 2);\r\n    obj.Union(4, 2);\r\n    obj.Union(3, 1);\r\n    if (obj.find(4) == obj.find(0))\r\n        cout << \"Yes\n\";\r\n    else\r\n        cout << \"No\n\";\r\n    if (obj.find(1) == obj.find(0))\r\n        cout << \"Yes\n\";\r\n    else\r\n        cout << \"No\n\";\r\n\r\n    return 0;\r\n}\r\n', 1000, '', '', 'Begin\r\n   Assume k is the element\r\n   makeset(k):\r\n      k.parent = k.\r\n   Find(x):\r\n   If k.parent == k\r\n      return k.\r\n   else\r\n   return Find(k.parent)\r\n   Union (a,b):\r\n      Take two set a and b as input.\r\n      aroot = Find(a)\r\n      broot = Find(b)\r\n      aroot.parent = broot\r\nEnd', '2020-05-25'),
(458, 10, 5501012018, '#include<stdio.h>\r\n#include<limits.h>\r\nint max(int a, int b) { return (a > b)? a : b; }\r\nint knapSack(int W, int wt[], int val[], int n)\r\n{\r\n   if (n == 0 || W == 0)\r\n       return 0;\r\n   if (wt[n-1] > W)\r\n       return knapSack(W, wt, val, n-1);\r\n\r\n   else return max( val[n-1] + knapSack(W-wt[n-1], wt, val, n-1),\r\n                    knapSack(W, wt, val, n-1) );\r\n}\r\n\r\nint main()\r\n{\r\n    int n;\r\n    int  W ,i;\r\n    scanf(\"%d\",&n);\r\n    scanf(\"%d\",&W);\r\n    int wt[n],val[n];\r\n    for(i=0;i<n;i++)\r\n    scanf(\"%d\",&val[i]);\r\n    for(i=0;i<n;i++)\r\n    scanf(\"%d\",&wt[i]);\r\n    printf(\"%d\", knapSack(W, wt, val, n));\r\n    return 0;\r\n}\r\n', 10, '5 15 4 2 1 2 10 12 2 1 1 4', '15', 'KNAPSACK ALGORITHM PROBLEM\r\n\r\nSTART\r\nKnapsack (w[1..n], p[1..n], W) \r\nfor i = 1 to n \r\n   do x[i] = 0 \r\nweight = 0 \r\nfor i = 1 to n \r\n   if weight + w[i] ≤ W then  \r\n      x[i] = 1 \r\n      weight = weight + w[i] \r\n   else \r\n      x[i] = (W - weight) / w[i] \r\n      weight = W \r\n      break \r\nreturn x\r\nEND', '2020-05-25'),
(459, 12, 5501012018, '\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nclass Edge\r\n{\r\n    public:\r\n    int src, dest, weight;\r\n};\r\n\r\nclass Graph\r\n{\r\n    public:\r\n    int V, E;\r\n\r\n    Edge* edge;\r\n};\r\n\r\nGraph* createGraph(int V, int E)\r\n{\r\n    Graph* graph = new Graph;\r\n    graph->V = V;\r\n    graph->E = E;\r\n\r\n    graph->edge = new Edge[E];\r\n    return graph;\r\n}\r\nclass subset\r\n{\r\n    public:\r\n    int parent;\r\n    int rank;\r\n};\r\n\r\nint find(subset subsets[], int i)\r\n{\r\n    if (subsets[i].parent != i)\r\n        subsets[i].parent = find(subsets, subsets[i].parent);\r\n\r\n    return subsets[i].parent;\r\n}\r\n\r\nvoid Union(subset subsets[], int x, int y)\r\n{\r\n    int xroot = find(subsets, x);\r\n    int yroot = find(subsets, y);\r\n\r\n    if (subsets[xroot].rank < subsets[yroot].rank)\r\n        subsets[xroot].parent = yroot;\r\n    else if (subsets[xroot].rank > subsets[yroot].rank)\r\n        subsets[yroot].parent = xroot;\r\n\r\n    else\r\n    {\r\n        subsets[yroot].parent = xroot;\r\n        subsets[xroot].rank++;\r\n    }\r\n}\r\n\r\nint myComp(const void* a, const void* b)\r\n{\r\n    Edge* a1 = (Edge*)a;\r\n    Edge* b1 = (Edge*)b;\r\n    return a1->weight > b1->weight;\r\n}\r\n\r\nvoid KruskalMST(Graph* graph)\r\n{\r\n    int V = graph->V;\r\n    Edge result[V];\r\n    int e = 0;\r\n    int i = 0;\r\n\r\n    qsort(graph->edge, graph->E, sizeof(graph->edge[0]), myComp);\r\n\r\n    subset *subsets = new subset[( V * sizeof(subset) )];\r\n\r\n    for (int v = 0; v < V; ++v)\r\n    {\r\n        subsets[v].parent = v;\r\n        subsets[v].rank = 0;\r\n    }\r\n    while (e < V - 1 && i < graph->E)\r\n    {\r\n        Edge next_edge = graph->edge[i++];\r\n\r\n        int x = find(subsets, next_edge.src);\r\n        int y = find(subsets, next_edge.dest);\r\n\r\n        if (x != y)\r\n        {\r\n            result[e++] = next_edge;\r\n            Union(subsets, x, y);\r\n        }\r\n    }\r\n\r\n    cout<<\"Following are the edges in the constructed MST\n\";\r\n    for (i = 0; i < e; ++i)\r\n        cout<<result[i].src<<\" -- \"<<result[i].dest<<\" == \"<<result[i].weight<<endl;\r\n    return;\r\n}\r\n\r\nint main()\r\n{\r\n    int V = 4;\r\n    int E = 5;\r\n    Graph* graph = createGraph(V, E);\r\n    graph->edge[0].src = 0;\r\n    graph->edge[0].dest = 1;\r\n    graph->edge[0].weight = 10;\r\n\r\n    graph->edge[1].src = 0;\r\n    graph->edge[1].dest = 2;\r\n    graph->edge[1].weight = 6;\r\n\r\n    graph->edge[2].src = 0;\r\n    graph->edge[2].dest = 3;\r\n    graph->edge[2].weight = 5;\r\n\r\n    graph->edge[3].src = 1;\r\n    graph->edge[3].dest = 3;\r\n    graph->edge[3].weight = 15;\r\n\r\n    graph->edge[4].src = 2;\r\n    graph->edge[4].dest = 3;\r\n    graph->edge[4].weight = 4;\r\n\r\n    KruskalMST(graph);\r\n\r\n    return 0;\r\n}\r\n\r\n', 1000, '', '', 'KRUSKAL MST ALGORITHM\r\n\r\nSTART\r\n1. Sort all the edges in non-decreasing order of their weight.\r\n2. Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If cycle is not formed, include this edge. Else, discard it.\r\n3. Repeat step#2 until there are (V-1) edges in the spanning tree.\r\nEND', '2020-05-25'),
(460, 14, 5501012018, '\r\n#include <bits/stdc++.h>\r\n\r\nstruct Edge {\r\n    int src, dest, weight;\r\n};\r\n\r\nstruct Graph {\r\n    int V, E;\r\n\r\n    struct Edge* edge;\r\n};\r\n\r\nstruct Graph* createGraph(int V, int E)\r\n{\r\n    struct Graph* graph = new Graph;\r\n    graph->V = V;\r\n    graph->E = E;\r\n    graph->edge = new Edge[E];\r\n    return graph;\r\n}\r\n\r\nvoid printArr(int dist[], int n)\r\n{\r\n    printf(\"Vertex   Distance from Source\n\");\r\n    for (int i = 0; i < n; ++i)\r\n        printf(\"%d 		 %d\n\", i, dist[i]);\r\n}\r\n\r\nvoid BellmanFord(struct Graph* graph, int src)\r\n{\r\n    int V = graph->V;\r\n    int E = graph->E;\r\n    int dist[V];\r\n\r\n    for (int i = 0; i < V; i++)\r\n        dist[i] = INT_MAX;\r\n    dist[src] = 0;\r\n\r\n    for (int i = 1; i <= V - 1; i++) {\r\n        for (int j = 0; j < E; j++) {\r\n            int u = graph->edge[j].src;\r\n            int v = graph->edge[j].dest;\r\n            int weight = graph->edge[j].weight;\r\n            if (dist[u] != INT_MAX && dist[u] + weight < dist[v])\r\n                dist[v] = dist[u] + weight;\r\n        }\r\n    }\r\n\r\n    for (int i = 0; i < E; i++) {\r\n        int u = graph->edge[i].src;\r\n        int v = graph->edge[i].dest;\r\n        int weight = graph->edge[i].weight;\r\n        if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {\r\n            printf(\"Graph contains negative weight cycle\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printArr(dist, V);\r\n\r\n    return;\r\n}\r\n\r\nint main()\r\n{\r\n    int V = 5;\r\n    int E = 8;\r\n    struct Graph* graph = createGraph(V, E);\r\n\r\n    graph->edge[0].src = 0;\r\n    graph->edge[0].dest = 1;\r\n    graph->edge[0].weight = -1;\r\n\r\n    graph->edge[1].src = 0;\r\n    graph->edge[1].dest = 2;\r\n    graph->edge[1].weight = 4;\r\n\r\n    graph->edge[2].src = 1;\r\n    graph->edge[2].dest = 2;\r\n    graph->edge[2].weight = 3;\r\n\r\n    graph->edge[3].src = 1;\r\n    graph->edge[3].dest = 3;\r\n    graph->edge[3].weight = 2;\r\n\r\n    graph->edge[4].src = 1;\r\n    graph->edge[4].dest = 4;\r\n    graph->edge[4].weight = 2;\r\n\r\n    graph->edge[5].src = 3;\r\n    graph->edge[5].dest = 2;\r\n    graph->edge[5].weight = 5;\r\n\r\n    graph->edge[6].src = 3;\r\n    graph->edge[6].dest = 1;\r\n    graph->edge[6].weight = 1;\r\n\r\n    graph->edge[7].src = 4;\r\n    graph->edge[7].dest = 3;\r\n    graph->edge[7].weight = -3;\r\n\r\n    BellmanFord(graph, 0);\r\n\r\n    return 0;\r\n}\r\n', 1000, '', '', 'BELLMAN FORD ALGORITHM\r\n\r\n1 - This step initializes distances from the source to all vertices as infinite and distance to the source itself as 0. \r\n	Create an array dist[] of size |V| with all values as infinite except dist[src] where src is source vertex.\r\n\r\n2 - This step calculates shortest distances. Do following |V|-1 times where |V| is the number of vertices in given graph.\r\na) Do following for each edge u-v\r\n	If dist[v] > dist[u] + weight of edge uv, then update dist[v]\r\n	dist[v] = dist[u] + weight of edge uv\r\n3) This step reports if there is a negative weight cycle in graph. Do following for each edge u-v\r\n If dist[v] > dist[u] + weight of edge uv, then “Graph contains negative weight cycle”\r\nThe idea of step 3 is, step 2 guarantees the shortest distances if the graph doesn’t contain a negative weight cycle. \r\nIf we iterate through all edges one more time and get a shorter path for any vertex, then there is a negative weight cycle', '2020-05-25'),
(461, 15, 5501012018, '#include <stdio.h>\r\n#include<limits.h>\r\n#define INFY 999999999\r\nlong int m[20][20];\r\nint s[20][20];\r\nint p[20],i,j,n;\r\n\r\nvoid print_optimal(int i,int j)\r\n{\r\nif (i == j)\r\nprintf(\" A%d \",i);\r\nelse\r\n   {\r\n      printf(\"( \");\r\n      print_optimal(i, s[i][j]);\r\n      print_optimal(s[i][j] + 1, j);\r\n      printf(\" )\");\r\n   }\r\n}\r\n\r\nvoid matmultiply(void)\r\n{\r\nlong int q;\r\nint k;\r\nfor(i=n;i>0;i--)\r\n {\r\n   for(j=i;j<=n;j++)\r\n    {\r\n     if(i==j)\r\n       m[i][j]=0;\r\n     else\r\n       {\r\n        for(k=i;k<j;k++)\r\n        {\r\n         q=m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j];\r\n         if(q<m[i][j])\r\n          {\r\n            m[i][j]=q;\r\n            s[i][j]=k;\r\n          }\r\n         }\r\n        }\r\n      }\r\n }\r\n}\r\n\r\nint MatrixChainOrder(int p[], int i, int j)\r\n{\r\n    if(i == j)\r\n        return 0;\r\n    int k;\r\n    int min = INT_MAX;\r\n    int count;\r\n\r\n    for (k = i; k <j; k++)\r\n    {\r\n        count = MatrixChainOrder(p, i, k) +\r\n                MatrixChainOrder(p, k+1, j) +\r\n                p[i-1]*p[k]*p[j];\r\n\r\n        if (count < min)\r\n            min = count;\r\n    }\r\n\r\n    // Return minimum count\r\n    return min;\r\n}\r\n\r\nvoid main()\r\n{\r\nint k;\r\nprintf(\"Enter the no. of elements: \");\r\nscanf(\"%d\",&n);\r\nfor(i=1;i<=n;i++)\r\nfor(j=i+1;j<=n;j++)\r\n{\r\n m[i][i]=0;\r\n m[i][j]=INFY;\r\n s[i][j]=0;\r\n}\r\nprintf(\"\nEnter the dimensions: \n\");\r\nfor(k=0;k<=n;k++)\r\n{\r\n printf(\"P%d: \",k);\r\n scanf(\"%d\",&p[k]);\r\n}\r\nmatmultiply();\r\n\r\n\r\n\r\ni=1,j=n;\r\nprintf(\"\nMultiplication Sequence : \");\r\nprint_optimal(i,j);\r\nprintf(\"\nMinimum number of multiplications is : %d \",\r\n                          MatrixChainOrder(p, 1, n));\r\n\r\n}\r\n', 1000, '', '', 'MATRIX CHAIN MULTIPLICATION ALGORITHM\r\nMATRIX-CHAIN-ORDER (p)\r\n\r\n\r\n 1. n   length[p]-1\r\n 2. for i ← 1 to n\r\n 3. do m [i, i] ← 0\r\n 4. for l ← 2 to n    // l is the chain length\r\n 5. do for i ← 1 to n-l + 1\r\n 6. do j ← i+ l -1\r\n 7. m[i,j] ←  ∞\r\n 8. for k  ← i to j-1\r\n 9. do q  ← m [i, k] + m [k + 1, j] + pi-1 pk pj	\r\n 10. If q < m [i,j]\r\n 11. then m [i,j] ← q\r\n 12. s [i,j] ← k\r\n 13. return m and s.      \r\n\r\nPRINT-OPTIMAL-PARENS (s, i, j)\r\n 1. if i=j\r\n 2. then print \"A\"\r\n 3. else print \"(\"\r\n 4. PRINT-OPTIMAL-PARENS (s, i, s [i, j])\r\n 5. PRINT-OPTIMAL-PARENS (s, s [i, j] + 1, j)\r\n 6. print \")\"', '2020-05-25'),
(462, 8, 5501012018, '#include<iostream>\r\n#include<vector>\r\n#include<cmath>\r\n#include<algorithm>\r\nusing namespace std;\r\n\r\nint nextpowerof2(int k)\r\n{\r\n    return pow(2, int(ceil(log2(k))));\r\n}\r\nvoid display(vector<vector<int> > &matrix, int m, int n)\r\n{\r\n    for (int i = 0; i < m; i++)\r\n    {\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            if (j != 0)\r\n            {\r\n                cout <<\" \";\r\n            }\r\n            cout << matrix[i][j];\r\n        }\r\n        cout <<endl;\r\n    }\r\n}\r\n\r\nvoid add(vector<vector<int> > &A, vector<vector<int> > &B, vector<vector<int> > &C, int size)\r\n{\r\n    int i, j;\r\n\r\n    for (i = 0; i < size; i++)\r\n    {\r\n        for (j = 0; j < size; j++)\r\n        {\r\n            C[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid sub(vector<vector<int> > &A, vector<vector<int> > &B, vector<vector<int> > &C, int size)\r\n{\r\n    int i, j;\r\n\r\n    for (i = 0; i < size; i++)\r\n    {\r\n        for (j = 0; j < size; j++)\r\n        {\r\n            C[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid STRASSEN_algorithmA(vector<vector<int> > &A, vector<vector<int> > &B, vector<vector<int> > &C, int size)\r\n{\r\n    if (size == 1)\r\n    {\r\n        C[0][0] = A[0][0] * B[0][0];\r\n        return;\r\n    }\r\n    else\r\n    {\r\n        int new_size = size / 2;\r\n        vector<int> z(new_size);\r\n        vector<vector<int> >\r\n            a11(new_size, z), a12(new_size, z), a21(new_size, z), a22(new_size, z),\r\n            b11(new_size, z), b12(new_size, z), b21(new_size, z), b22(new_size, z),\r\n            c11(new_size, z), c12(new_size, z), c21(new_size, z), c22(new_size, z),\r\n            p1(new_size, z), p2(new_size, z), p3(new_size, z), p4(new_size, z),\r\n            p5(new_size, z), p6(new_size, z), p7(new_size, z),\r\n            aResult(new_size, z), bResult(new_size, z);\r\n\r\nint i, j;\r\nfor (i = 0; i < new_size; i++)\r\n        {\r\n            for (j = 0; j < new_size; j++)\r\n            {\r\n                a11[i][j] = A[i][j];\r\n                a12[i][j] = A[i][j + new_size];\r\n                a21[i][j] = A[i + new_size][j];\r\n                a22[i][j] = A[i + new_size][j + new_size];\r\n\r\n                b11[i][j] = B[i][j];\r\n                b12[i][j] = B[i][j + new_size];\r\n                b21[i][j] = B[i + new_size][j];\r\n                b22[i][j] = B[i + new_size][j + new_size];\r\n            }\r\n}\r\n\r\n        add(a11, a22, aResult, new_size);\r\n        add(b11, b22, bResult, new_size);\r\n        STRASSEN_algorithmA(aResult, bResult, p1, new_size);\r\n\r\n        add(a21, a22, aResult, new_size);\r\n        STRASSEN_algorithmA(aResult, b11, p2, new_size);\r\n\r\n        sub(b12, b22, bResult, new_size);\r\n        STRASSEN_algorithmA(a11, bResult, p3, new_size);\r\n\r\n\r\n        sub(b21, b11, bResult, new_size);\r\n        STRASSEN_algorithmA(a22, bResult, p4, new_size);\r\n        add(a11, a12, aResult, new_size);\r\n        STRASSEN_algorithmA(aResult, b22, p5, new_size);\r\n\r\n        sub(a21, a11, aResult, new_size);\r\n        add(b11, b12, bResult, new_size);\r\n        STRASSEN_algorithmA(aResult, bResult, p6, new_size);\r\n\r\n        sub(a12, a22, aResult, new_size);\r\n        add(b21, b22, bResult, new_size);\r\n        STRASSEN_algorithmA(aResult, bResult, p7, new_size);\r\n\r\n        add(p3, p5, c12, new_size);\r\n        add(p2, p4, c21, new_size);\r\n\r\n        add(p1, p4, aResult, new_size);\r\n        add(aResult, p7, bResult, new_size);\r\n        sub(bResult, p5, c11, new_size);\r\n\r\n        add(p1, p3, aResult, new_size);\r\n        add(aResult, p6, bResult, new_size);\r\n        sub(bResult, p2, c22, new_size);\r\n        for (i = 0; i < new_size; i++)\r\n        {\r\n            for (j = 0; j < new_size; j++)\r\n            {\r\n                C[i][j] = c11[i][j];\r\n                C[i][j + new_size] = c12[i][j];\r\n                C[i + new_size][j] = c21[i][j];\r\n                C[i + new_size][j + new_size] = c22[i][j];\r\n            }\r\n        }\r\n    }\r\n}\r\nvoid STRASSEN_algorithm(vector<vector<int> > &A, vector<vector<int> > &B, int m, int n, int a, int b)\r\n{\r\n    int c1=std::max(a,b);\r\n    int c2=std::max(c1,m);\r\n    int c3=std::max(c1,n);\r\n    int k = c3;\r\n\r\n    int s = nextpowerof2(k);\r\n\r\n    vector<int> z(s);\r\n    vector<vector<int> > Aa(s,z),Bb(s,z),Cc(s,z);\r\n\r\n    for (unsigned int i = 0; i < m; i++)\r\n    {\r\n        for (unsigned int j = 0; j < n; j++)\r\n        {\r\n            Aa[i][j] = A[i][j];\r\n        }\r\n    }\r\n    for (unsigned int i = 0; i < a; i++)\r\n    {\r\n        for (unsigned int j = 0; j < b; j++)\r\n        {\r\n            Bb[i][j] = B[i][j];\r\n        }\r\n    }\r\n    STRASSEN_algorithmA(Aa,Bb,Cc,s);\r\n    vector<int> temp1(b);\r\n    vector<vector<int> > C(m, temp1);\r\n    for (unsigned int i = 0; i < m; i++)\r\n    {\r\n        for (unsigned int j = 0; j < b; j++)\r\n        {\r\n            C[i][j] = Cc[i][j];\r\n        }\r\n    }\r\n    display(C, m, b);\r\n}\r\n\r\nbool check(int n, int a)\r\n{\r\n    if (n == a)\r\n        return true;\r\n    else\r\n        return false;\r\n}\r\n\r\nint main()\r\n{\r\n    int n, a, b;\r\n    cin >> n;\r\n\r\n    vector<vector<int> > A;\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        vector<int> temp;\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            int i;\r\n            cin >> i;\r\n            temp.push_back(i);\r\n        }\r\n        A.push_back(temp);\r\n    }\r\n\r\n    vector<vector<int> > B;\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        vector<int> temp;\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            int i;\r\n            cin >> i;\r\n            temp.push_back(i);\r\n        }\r\n        B.push_back(temp);\r\n    }\r\n\r\n\r\n        STRASSEN_algorithm(A,B,n,n,n,n);\r\n\r\n    return 0;\r\n}\r\n\r\n', 0, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '-17 -4 -7\n10 2 11\n40 92 107\n', '\r\n\r\nFormulas for Stassen?s matrix multiplication\r\nIn Strassen?s matrix multiplication there are seven multiplication and four addition, subtraction in total.\r\n\r\n    1.	D1 =  (a11 + a22) (b11 + b22)\r\n    2.	D2 =  (a21 + a22).b11\r\n    3.	D3 =  (b12 ? b22).a11\r\n    4.	D4 =  (b21 ? b11).a22\r\n    5.	D5 =  (a11 + a12).b22\r\n    6.	D6 =  (a21 ? a11) . (b11 + b12)\r\n    7.	D7 =  (a12 ? a22) . (b21 + b22)\r\n\r\n    C11 = d1 + d4 ? d5 + d7\r\n    C12 = d3 + d5\r\n    C21 = d2 + d4\r\n    C22 = d1 + d3 ? d2 ? d6\r\nAlgorithm for Strassen?s matrix multiplication\r\nAlgorithm Strassen(n, a, b, d)\r\n\r\nbegin \r\n	If n = threshold then compute\r\n		C = a * b is a conventional matrix.\r\n	Else\r\n		Partition a into four sub matrices  a11, a12, a21, a22.\r\n		Partition b into four sub matrices b11, b12, b21, b22.\r\n		Strassen ( n/2, a11 + a22, b11 + b22, d1)\r\n		Strassen ( n/2, a21 + a22, b11, d2)\r\n		Strassen ( n/2, a11, b12 ? b22, d3)\r\n		Strassen ( n/2, a22, b21 ? b11, d4)\r\n		Strassen ( n/2, a11 + a12, b22, d5)\r\n		Strassen (n/2, a21 ? a11, b11 + b22, d6)\r\n		Strassen (n/2, a12 ? a22, b21 + b22, d7)\r\n\r\n		C = d1+d4-d5+d7     d3+d5\r\n		    d2+d4           d1+d3-d2-d6  \r\n		\r\n	end if\r\n	\r\n	return (C)\r\nend.\r\n', '2020-05-25'),
(463, 5, 5501012018, '#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\n\r\ninline ll** MatrixMultiply(ll** a, ll** b, int n, int l, int m)\r\n{\r\n    ll** c = new ll*[n];\r\n    for (int i = 0; i < n; i++)\r\n        c[i] = new ll[m];\r\n\r\n    for (int i = 0; i < n; i++) {\r\n        for (int j = 0; j < m; j++) {\r\n            c[i][j] = 0;\r\n            for (int k = 0; k < l; k++) {\r\n                c[i][j] += a[i][k] * b[k][j];\r\n            }\r\n        }\r\n    }\r\n    return c;\r\n}\r\n\r\ninline ll** Strassen(ll** a, ll** b, int n, int l, int m)\r\n{\r\n    if (n == 1 || l == 1 || m == 1)\r\n        return MatrixMultiply(a, b, n, l, m);\r\n\r\n    ll** c = new ll*[n];\r\n    for (int i = 0; i < n; i++)\r\n        c[i] = new ll[m];\r\n\r\n    int adjN = (n >> 1) + (n & 1);\r\n    int adjL = (l >> 1) + (l & 1);\r\n    int adjM = (m >> 1) + (m & 1);\r\n\r\n    ll**** As = new ll***[2];\r\n    for (int x = 0; x < 2; x++) {\r\n        As[x] = new ll**[2];\r\n        for (int y = 0; y < 2; y++) {\r\n            As[x][y] = new ll*[adjN];\r\n            for (int i = 0; i < adjN; i++) {\r\n                As[x][y][i] = new ll[adjL];\r\n                for (int j = 0; j < adjL; j++) {\r\n                    int I = i + (x & 1) * adjN;\r\n                    int J = j + (y & 1) * adjL;\r\n                    As[x][y][i][j] = (I < n && J < l) ? a[I][J] : 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    ll**** Bs = new ll***[2];\r\n    for (int x = 0; x < 2; x++) {\r\n        Bs[x] = new ll**[2];\r\n        for (int y = 0; y < 2; y++) {\r\n            Bs[x][y] = new ll*[adjN];\r\n            for (int i = 0; i < adjL; i++) {\r\n                Bs[x][y][i] = new ll[adjM];\r\n                for (int j = 0; j < adjM; j++) {\r\n                    int I = i + (x & 1) * adjL;\r\n                    int J = j + (y & 1) * adjM;\r\n                    Bs[x][y][i][j] = (I < l && J < m) ? b[I][J] : 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    ll*** s = new ll**[10];\r\n    for (int i = 0; i < 10; i++) {\r\n        switch (i) {\r\n        case 0:\r\n            s[i] = new ll*[adjL];\r\n            for (int j = 0; j < adjL; j++) {\r\n                s[i][j] = new ll[adjM];\r\n                for (int k = 0; k < adjM; k++) {\r\n                    s[i][j][k] = Bs[0][1][j][k] - Bs[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 1:\r\n            s[i] = new ll*[adjN];\r\n            for (int j = 0; j < adjN; j++) {\r\n                s[i][j] = new ll[adjL];\r\n                for (int k = 0; k < adjL; k++) {\r\n                    s[i][j][k] = As[0][0][j][k] + As[0][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 2:\r\n            s[i] = new ll*[adjN];\r\n            for (int j = 0; j < adjN; j++) {\r\n                s[i][j] = new ll[adjL];\r\n                for (int k = 0; k < adjL; k++) {\r\n                    s[i][j][k] = As[1][0][j][k] + As[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 3:\r\n            s[i] = new ll*[adjL];\r\n            for (int j = 0; j < adjL; j++) {\r\n                s[i][j] = new ll[adjM];\r\n                for (int k = 0; k < adjM; k++) {\r\n                    s[i][j][k] = Bs[1][0][j][k] - Bs[0][0][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 4:\r\n            s[i] = new ll*[adjN];\r\n            for (int j = 0; j < adjN; j++) {\r\n                s[i][j] = new ll[adjL];\r\n                for (int k = 0; k < adjL; k++) {\r\n                    s[i][j][k] = As[0][0][j][k] + As[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 5:\r\n            s[i] = new ll*[adjL];\r\n            for (int j = 0; j < adjL; j++) {\r\n                s[i][j] = new ll[adjM];\r\n                for (int k = 0; k < adjM; k++) {\r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 6:\r\n            s[i] = new ll*[adjN];\r\n            for (int j = 0; j < adjN; j++) {\r\n                s[i][j] = new ll[adjL];\r\n                for (int k = 0; k < adjL; k++) {\r\n                    s[i][j][k] = As[0][1][j][k] - As[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 7:\r\n            s[i] = new ll*[adjL];\r\n            for (int j = 0; j < adjL; j++) {\r\n                s[i][j] = new ll[adjM];\r\n                for (int k = 0; k < adjM; k++) {\r\n                    s[i][j][k] = Bs[1][0][j][k] + Bs[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 8:\r\n            s[i] = new ll*[adjN];\r\n            for (int j = 0; j < adjN; j++) {\r\n                s[i][j] = new ll[adjL];\r\n                for (int k = 0; k < adjL; k++) {\r\n                    s[i][j][k] = As[0][0][j][k] - As[1][0][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 9:\r\n            s[i] = new ll*[adjL];\r\n            for (int j = 0; j < adjL; j++) {\r\n                s[i][j] = new ll[adjM];\r\n                for (int k = 0; k < adjM; k++) {\r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[0][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    }\r\n\r\n    ll*** p = new ll**[7];\r\n    p[0] = Strassen(As[0][0], s[0], adjN, adjL, adjM);\r\n    p[1] = Strassen(s[1], Bs[1][1], adjN, adjL, adjM);\r\n    p[2] = Strassen(s[2], Bs[0][0], adjN, adjL, adjM);\r\n    p[3] = Strassen(As[1][1], s[3], adjN, adjL, adjM);\r\n    p[4] = Strassen(s[4], s[5], adjN, adjL, adjM);\r\n    p[5] = Strassen(s[6], s[7], adjN, adjL, adjM);\r\n    p[6] = Strassen(s[8], s[9], adjN, adjL, adjM);\r\n\r\n    for (int i = 0; i < adjN; i++) {\r\n        for (int j = 0; j < adjM; j++) {\r\n            c[i][j] = p[4][i][j] + p[3][i][j] - p[1][i][j] + p[5][i][j];\r\n            if (j + adjM < m)\r\n                c[i][j + adjM] = p[0][i][j] + p[1][i][j];\r\n            if (i + adjN < n)\r\n                c[i + adjN][j] = p[2][i][j] + p[3][i][j];\r\n            if (i + adjN < n && j + adjM < m)\r\n                c[i + adjN][j + adjM] = p[4][i][j] + p[0][i][j] - p[2][i][j] - p[6][i][j];\r\n        }\r\n    }\r\n\r\n    for (int x = 0; x < 2; x++) {\r\n        for (int y = 0; y < 2; y++) {\r\n            for (int i = 0; i < adjN; i++) {\r\n                delete[] As[x][y][i];\r\n            }\r\n            delete[] As[x][y];\r\n        }\r\n        delete[] As[x];\r\n    }\r\n    delete[] As;\r\n\r\n    for (int x = 0; x < 2; x++) {\r\n        for (int y = 0; y < 2; y++) {\r\n            for (int i = 0; i < adjL; i++) {\r\n                delete[] Bs[x][y][i];\r\n            }\r\n            delete[] Bs[x][y];\r\n        }\r\n        delete[] Bs[x];\r\n    }\r\n    delete[] Bs;\r\n\r\n    for (int i = 0; i < 10; i++) {\r\n        switch (i) {\r\n        case 0:\r\n        case 3:\r\n        case 5:\r\n        case 7:\r\n        case 9:\r\n            for (int j = 0; j < adjL; j++) {\r\n                delete[] s[i][j];\r\n            }\r\n            break;\r\n        case 1:\r\n        case 2:\r\n        case 4:\r\n        case 6:\r\n        case 8:\r\n            for (int j = 0; j < adjN; j++) {\r\n                delete[] s[i][j];\r\n            }\r\n            break;\r\n        }\r\n        delete[] s[i];\r\n    }\r\n    delete[] s;\r\n\r\n    for (int i = 0; i < 7; i++) {\r\n        for (int j = 0; j < (n >> 1); j++) {\r\n            delete[] p[i][j];\r\n        }\r\n        delete[] p[i];\r\n    }\r\n    delete[] p;\r\n\r\n    return c;\r\n}\r\n\r\nint main()\r\n{\r\nint n=3;\r\n    //cin>>n;\r\n    int mat1_m=n,mat1_n=n,mat2_m=n,mat2_n=n;\r\n\r\n    ll** mat1 =new ll*[mat1_m];\r\n\r\n\r\n    for(int i=0;i<mat1_m;i++)\r\n    {\r\n        mat1[i]=new ll[mat1_n];\r\n\r\n    }\r\n    mat1[0][0]=1;\r\n    mat1[0][1]=0;\r\n    mat1[0][2]=0;\r\n    mat1[1][0]=0;\r\n    mat1[1][1]=1;\r\n    mat1[1][2]=0;\r\n    mat1[2][0]=0;\r\n    mat1[2][1]=0;\r\n    mat1[2][2]=1;\r\n    //mat1[10][10]={{1,0,0},{0,1,0},{0,0,1}};\r\n\r\n    ll**mat2 =new ll*[mat2_m];\r\n\r\n    for(int i=0;i<mat2_m;i++)\r\n    {\r\n        mat2[i]=new ll[mat2_n];\r\n\r\n\r\n    }\r\n     mat2[0][0]=1;\r\n    mat2[0][1]=0;\r\n    mat2[0][2]=0;\r\n    mat2[1][0]=0;\r\n    mat2[1][1]=1;\r\n    mat2[1][2]=0;\r\n    mat2[2][0]=0;\r\n    mat2[2][1]=0;\r\n    mat2[2][2]=1;\r\n\r\n    ll** mat3 = Strassen(mat1, mat2, mat1_m, mat1_n, mat2_n);\r\n    for (int i = 0; i < mat1_m; i++)\r\n    {\r\n        for (int j = 0; j < mat2_n; j++)\r\n        {\r\n            cout<<mat3[i][j]<<\" \";\r\n        }\r\n        cout<<\"\n\";\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n', 1000, '', '', 'function Strassen(M,N)\r\nif M is 1 ? 1 then\r\nreturn M11N11\r\nend if\r\nLet M =  A B\r\n         C D \r\nand N =  E F\r\n         G H \r\nSet S1 = Strassen(B - D, G + H)\r\nSet S2 = Strassen(A + D, E + H)\r\nSet S3 = Strassen(A - C, E + F)\r\nSet S4 = Strassen(A + B, H)\r\nSet S5 = Strassen(A, F - H)\r\nSet S6 = Strassen(D, G - E)\r\nSet S7 = Strassen(C + D, E)\r\nreturn (\r\nS1 + S2 - S4 + S6    S4 + S5\r\nS6 + S7              S2 - S3 + S5 - S7\r\n)\r\nend function\r\n', '2020-05-25'),
(464, 16, 5501012018, '#include<stdio.h>\r\n#include<string.h>\r\nint main (){\r\n   char txt[80], pat[80];\r\n\r\n   printf (\"Enter the container string \n\");\r\n   scanf (\"%s\", &txt);\r\n   printf (\"Enter the pattern to be searched \n\");\r\n   scanf (\"%s\", &pat);\r\n   int d = 256;\r\n\r\n   int M = strlen (pat);\r\n   int N = strlen (txt);\r\n   int i, j;\r\n   int p = 0;\r\n   int t = 0;\r\n   int h = 1;\r\n   int q = 3;\r\n   for (i = 0; i < M - 1; i++)\r\n      h = (h * d) % q;\r\n   for (i = 0; i < M; i++){\r\n      p = (d * p + pat[i]) % q;\r\n      t = (d * t + txt[i]) % q;\r\n   }\r\n   for (i = 0; i <= N - M; i++){\r\n      if (p == t){\r\n         for (j = 0; j < M; j++){\r\n            if (txt[i + j] != pat[j])\r\n            break;\r\n         }\r\n         if (j == M)\r\n            printf (\"Pattern found at index %d \n\", i);\r\n      }\r\n      if (i < N - M){\r\n         t = (d * (t - txt[i] * h) + txt[i + M]) % q;\r\n         if (t < 0)\r\n            t = (t + q);\r\n      }\r\n   }\r\n   return 0;\r\n}\r\n', 1000, '', '', 'rabinkarp_algo(text, pattern,prime)\r\nSTART\r\n   pat_len := pattern Length\r\n   str_len := string Length\r\n   patHash := 0 and strHash := 0, h := 1\r\n   maxChar := total number of characters in character set\r\nfor index i of all character in the pattern, do\r\n   h := (h*maxChar) mod prime\r\nfor all character index i of pattern, do\r\n   patHash := (maxChar*patHash + pattern[i]) mod prime\r\n   strHash := (maxChar*strHash + text[i]) mod prime\r\nfor i := 0 to (str_len - pat_len), do\r\n   if patHash = strHash, then\r\n      for charIndex := 0 to pat_len -1, do\r\n         if text[i+charIndex] ≠ pattern[charIndex], then\r\n         break\r\nif charIndex = pat_len, then\r\n   print the location i as pattern found at i position.\r\nif i < (str_len - pat_len), then\r\n   strHash := (maxChar*(strHash – text[i]*h)+text[i+patLen]) mod prime, then\r\n   if strHash < 0, then\r\n   strHash := strHash + prime\r\nEND', '2020-05-25'),
(465, 3, 5601012018, '#include<stdio.h> \r\n  \r\nvoid swap(int* a, int* b) \r\n{ \r\n    int t = *a; \r\n    *a = *b; \r\n    *b = t; \r\n} \r\n  \r\nint partition (int arr[], int low, int high) \r\n{ \r\n    int pivot = arr[high];     \r\n    int i = (low - 1);  \r\n  \r\n    for (int j = low; j <= high- 1; j++) \r\n    { \r\n        if (arr[j] < pivot) \r\n        { \r\n            i++;    \r\n            swap(&arr[i], &arr[j]); \r\n        } \r\n    } \r\n    swap(&arr[i + 1], &arr[high]); \r\n    return (i + 1); \r\n} \r\n  \r\nvoid quickSort(int arr[], int low, int high) \r\n{ \r\n    if (low < high) \r\n    { \r\n        int pi = partition(arr, low, high); \r\n  \r\n        quickSort(arr, low, pi - 1); \r\n        quickSort(arr, pi + 1, high); \r\n    } \r\n} \r\n  \r\nvoid printArray(int arr[], int size) \r\n{ \r\n    int i; \r\n    for (i=0; i < size; i++) \r\n        printf(\"%d \", arr[i]); \r\n} \r\n  \r\nint main() \r\n{  \r\n    int n;\r\n    scanf(\"%d\",&n);\r\n    int i,arr[n];\r\n    for(i=0;i<n;i++)\r\n        scanf(\"%d\",&arr[i]); \r\n    quickSort(arr, 0, n-1);  \r\n    printArray(arr, n); \r\n    return 0; \r\n}', 10, '1 2000', '2000 ', 'quickSort(array, leftmostIndex, rightmostIndex)\r\n  if (leftmostIndex < rightmostIndex)\r\n    pivotIndex <- partition(array,leftmostIndex, rightmostIndex)\r\n    quickSort(array, leftmostIndex, pivotIndex)\r\n    quickSort(array, pivotIndex + 1, rightmostIndex)\r\n\r\npartition(array, leftmostIndex, rightmostIndex)\r\n  set rightmostIndex as pivotIndex\r\n  storeIndex <- leftmostIndex - 1\r\n  for i <- leftmostIndex + 1 to rightmostIndex\r\n  if element[i] < pivotElement\r\n    swap element[i] and element[storeIndex]\r\n    storeIndex++\r\n  swap pivotElement and element[storeIndex+1]\r\nreturn storeIndex + 1', '2020-05-25'),
(466, 7, 5601012018, '#include <cstdlib> \r\n#include <stdio.h>\r\n#include <iostream> \r\nusing namespace std; \r\n  \r\nint partition(int arr[], int start, int end) \r\n{ \r\n    int pivot = arr[end]; \r\n    int i = (start - 1); \r\n  \r\n    for (int j = start; j <= end - 1; j++) { \r\n  \r\n        if (arr[j] <= pivot) { \r\n  \r\n            i++; \r\n            swap(arr[i], arr[j]); \r\n        } \r\n    } \r\n    swap(arr[i + 1], arr[end]); \r\n    return (i + 1); \r\n} \r\n  \r\nint random_partition(int arr[], int start, int end) \r\n{ \r\n   \r\n    int random = start + rand() % (end - start); \r\n  \r\n    swap(arr[random], arr[end]); \r\n  \r\n    return partition(arr, start, end); \r\n} \r\n  \r\nvoid quickSort(int arr[], int start, int end) \r\n{ \r\n    if (start < end) { \r\n  \r\n        int pi = random_partition(arr, start, end); \r\n  \r\n        quickSort(arr, start, pi - 1); \r\n        quickSort(arr, pi + 1, end); \r\n    } \r\n} \r\n  \r\nvoid printArray(int arr[], int size) \r\n{ \r\n    for (int i = 0; i < size; i++){ \r\n 	 cout<<arr[i]<<endl; \r\n    }\r\n   \r\n} \r\n  \r\nint main() \r\n{ \r\n    \r\n    int n;\r\n    cin >> n; \r\n    int arr[n];\r\n    for (int i = 0; i < n; ++i){\r\n	 cin >> arr[i];\r\n    }\r\n    quickSort(arr, 0, n - 1); \r\n    printArray(arr, n);   \r\n} ', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0\n1\n4\n5\n6\n6\n8\n8\n8\n9\n9\n1000\n14000\n', 'partition(arr[], lo, hi) \r\n    pivot = arr[hi]\r\n    i = lo     // place for swapping\r\n    for j := lo to hi – 1 do\r\n        if arr[j] <= pivot then\r\n            swap arr[i] with arr[j]\r\n            i = i + 1\r\n    swap arr[i] with arr[hi]\r\n    return i\r\n\r\npartition_r(arr[], lo, hi)\r\n    r = Random Number from lo to hi\r\n    Swap arr[r] and arr[hi]\r\n    return partition(arr, lo, hi)\r\n\r\nquicksort(arr[], lo, hi)\r\n    if lo < hi\r\n        p = partition_r(arr, lo, hi)\r\n        quicksort(arr, p-1, hi)\r\n        quicksort(arr, p+1, hi)\r\n ', '2020-05-25'),
(467, 9, 5601012018, '#include <iostream>\r\nusing namespace std;\r\nclass DisjSet {\r\n	int *rank, *parent, n;\r\n\r\npublic:\r\n	DisjSet(int n)\r\n	{\r\n		rank = new int[n];\r\n		parent = new int[n];\r\n		this->n = n;\r\n		makeSet();\r\n	}\r\n\r\n	void makeSet()\r\n	{\r\n		for (int i = 0; i < n; i++) {\r\n			parent[i] = i;\r\n		}\r\n	}\r\n\r\n	int find(int x)\r\n	{\r\n		if (parent[x] != x) {\r\n\r\n			parent[x] = find(parent[x]);\r\n		}\r\n\r\n		return parent[x];\r\n	}\r\n\r\n	void Union(int x, int y)\r\n	{\r\n		int xset = find(x);\r\n		int yset = find(y);\r\n\r\n		if (xset == yset)\r\n			return;\r\n\r\n		if (rank[xset] < rank[yset]) {\r\n			parent[xset] = yset;\r\n		}\r\n		else if (rank[xset] > rank[yset]) {\r\n			parent[yset] = xset;\r\n		}\r\n		else {\r\n			parent[yset] = xset;\r\n			rank[xset] = rank[xset] + 1;\r\n		}\r\n	}\r\n};\r\n\r\nint main()\r\n{\r\n	DisjSet obj(5);\r\n    obj.Union(0, 2);\r\n    obj.Union(4, 2);\r\n    obj.Union(3, 1);\r\n    if (obj.find(4) == obj.find(0))\r\n        cout << \"Yes\n\";\r\n    else\r\n        cout << \"No\n\";\r\n    if (obj.find(1) == obj.find(0))\r\n        cout << \"Yes\n\";\r\n    else\r\n        cout << \"No\n\";\r\n\r\n    return 0;\r\n}\r\n', 1000, '', '', 'Begin\r\n   Assume k is the element\r\n   makeset(k):\r\n      k.parent = k.\r\n   Find(x):\r\n   If k.parent == k\r\n      return k.\r\n   else\r\n   return Find(k.parent)\r\n   Union (a,b):\r\n      Take two set a and b as input.\r\n      aroot = Find(a)\r\n      broot = Find(b)\r\n      aroot.parent = broot\r\nEnd', '2020-05-25'),
(468, 10, 5601012018, 'import java.io.*;\r\nimport java.util.*;\r\n\r\npublic class Main {\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        Scanner scn = new Scanner(System.in);\r\n        int n = scn.nextInt();\r\n	int cap = scn.nextInt();\r\n        int[] weight = new int[n];\r\n        int[] price = new int[n];\r\n        for (int i = 0; i < n; i++) {\r\n            price[i] = scn.nextInt();\r\n        }\r\n        for (int i = 0; i < n; i++) {\r\n            weight[i] = scn.nextInt();\r\n        }      \r\n        System.out.println(knapsack(weight, price, cap));\r\n    }\r\n\r\n    public static int knapsack(int[] weight, int[] price, int cap) {\r\n        int[][] dp = new int[price.length][cap + 1];\r\n        \r\n        for (int i = 0; i < dp[0].length; i++) {\r\n            if (weight[0] <= cap && i >= weight[0]) {\r\n                dp[0][i] = price[0];\r\n            }\r\n        }\r\n        for (int i = 1; i < dp.length; i++) {\r\n            for (int j = 1; j < dp[0].length; j++) {\r\n                int val = weight[i];\r\n                if (j - val >= 0) {\r\n                    dp[i][j] = Math.max(dp[i - 1][j], price[i] + dp[i - 1][j - val]);\r\n                } else {\r\n                    dp[i][j] = dp[i - 1][j];\r\n                }\r\n            }\r\n        }\r\n        return dp[dp.length-1][dp[0].length-1];\r\n    }\r\n}', 0, '5 15 4 2 1 2 10 12 2 1 1 4', '15\n', '??G\0r\0e\0e\0d\0y\0-\0F\0r\0a\0c\0t\0i\0o\0n\0a\0l\0-\0K\0n\0a\0p\0s\0a\0c\0k\0 \0(\0w\0[\01\0.\0.\0n\0]\0,\0 \0p\0[\01\0.\0.\0n\0]\0,\0 \0W\0)\0 \0\r\0\n\0f\0o\0r\0 \0i\0 \0=\0 \01\0 \0t\0o\0 \0n\0 \0\r\0\n\0 \0 \0 \0d\0o\0 \0x\0[\0i\0]\0 \0=\0 \00\0 \0\r\0\n\0w\0e\0i\0g\0h\0t\0 \0=\0 \00\0 \0\r\0\n\0f\0o\0r\0 \0i\0 \0=\0 \01\0 \0t\0o\0 \0n\0 \0\r\0\n\0 \0 \0 \0i\0f\0 \0w\0e\0i\0g\0h\0t\0 \0+\0 \0w\0[\0i\0]\0 \0d\" \0W\0 \0t\0h\0e\0n\0 \0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0x\0[\0i\0]\0 \0=\0 \01\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0w\0e\0i\0g\0h\0t\0 \0=\0 \0w\0e\0i\0g\0h\0t\0 \0+\0 \0w\0[\0i\0]\0 \0\r\0\n\0 \0 \0 \0e\0l\0s\0e\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0x\0[\0i\0]\0 \0=\0 \0(\0W\0 \0-\0 \0w\0e\0i\0g\0h\0t\0)\0 \0/\0 \0w\0[\0i\0]\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0w\0e\0i\0g\0h\0t\0 \0=\0 \0W\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0b\0r\0e\0a\0k\0 \0\r\0\n\0r\0e\0t\0u\0r\0n\0 \0x\0', '2020-05-25'),
(469, 12, 5601012018, '#include<iostream>\r\n#include<algorithm>\r\nusing namespace std;\r\n\r\nclass Edge\r\n{\r\n	public:\r\n	int source;\r\n	int dest;\r\n	int weight;\r\n};\r\n\r\nbool compare(Edge e1,Edge e2){\r\n    return e1.weight< e2.weight;\r\n}\r\nint findParent(int v,int *parent){\r\n    if(parent[v]==v){\r\n        return v;\r\n    }\r\n    return findParent(parent[v],parent);\r\n}\r\nvoid Kruskals(Edge *input,int n,int E){\r\n    sort(input,input+E,compare);\r\n    Edge *output=new Edge[n-1];\r\n    int *parent= new int[n];\r\n    for(int i=0;i<n;i++){\r\n        parent[i]=i;\r\n    }\r\n    int count=0;\r\n    int i=0;\r\n    while(count!=n-1){\r\n        Edge currentEdge = input[i];\r\n        int sourceParent = findParent(currentEdge.source,parent);\r\n        int destParent = findParent(currentEdge.dest,parent);\r\n\r\n        if(sourceParent!=destParent){\r\n            output[count]=currentEdge;\r\n            count++;\r\n            parent[sourceParent]=destParent;\r\n        }\r\n        i++;\r\n    }\r\n    for(int i=0;i<n-1;i++){\r\n        if(output[i].source<output[i].dest){\r\n            cout<<output[i].source<<\"---\"<<output[i].dest<<\"==>\"<<output[i].weight<<\" \";\r\n        }else{\r\n            cout<<output[i].dest<<\"---\"<<output[i].source<<\"==>\"<<output[i].weight<<\" \";\r\n        }\r\n    }\r\n}\r\n\r\nint main(){\r\n    int n=4;\r\n    int E=4;\r\n    Edge *input=new Edge[E];\r\n        input[0].source=0;\r\n        input[0].dest=1;\r\n        input[0].weight=3;\r\n        input[1].source=0;\r\n        input[1].dest=3;\r\n        input[1].weight=5;\r\n        input[2].source=1;\r\n        input[2].dest=2;\r\n        input[2].weight=1;\r\n        input[3].source=2;\r\n        input[3].dest=3;\r\n        input[3].weight=8;\r\n    Kruskals(input,n,E);\r\n}\r\n', 1000, '', '', '1. Sort all the edges in non-decreasing order of their weight.\r\n2. Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If cycle is not formed, include this edge. Else, discard it.\r\n3. Repeat step#2 until there are (V-1) edges in the spanning tree.', '2020-05-25'),
(470, 13, 5601012018, '#include <iostream>\r\n#include <vector>\r\n#include <queue>\r\n#include <functional>\r\n#include <utility>\r\n\r\nusing namespace std;\r\nconst int MAX = 1e4 + 5;\r\ntypedef pair<long long, int> PII;\r\nbool marked[MAX];\r\nvector <PII> adj[MAX];\r\n\r\nlong long prim(int x)\r\n{\r\n    priority_queue<PII, vector<PII>, greater<PII> > Q;\r\n    int y;\r\n    long long minimumCost = 0;\r\n    PII p;\r\n    Q.push(make_pair(0, x));\r\n    while(!Q.empty())\r\n    {\r\n        p = Q.top();\r\n        Q.pop();\r\n        x = p.second;\r\n        if(marked[x] == true)\r\n            continue;\r\n        minimumCost += p.first;\r\n        marked[x] = true;\r\n        for(int i = 0;i < adj[x].size();++i)\r\n        {\r\n            y = adj[x][i].second;\r\n            if(marked[y] == false)\r\n                Q.push(adj[x][i]);\r\n        }\r\n    }\r\n    return minimumCost;\r\n}\r\n\r\nint main()\r\n{\r\n    int nodes, edges, x, y;\r\n    long long weight, minimumCost;\r\n    cin >> nodes >> edges;\r\n    for(int i = 0;i < edges;++i)\r\n    {\r\n        cin >> x >> y >> weight;\r\n        adj[x].push_back(make_pair(weight, y));\r\n        adj[y].push_back(make_pair(weight, x));\r\n    }\r\n    minimumCost = prim(1);\r\n    cout << minimumCost << endl;\r\n    return 0;\r\n}', 1000, '', '', 'Algorithm\r\n1) Create a set mstSet that keeps track of vertices already included in MST.\r\n2) Assign a key value to all vertices in the input graph. Initialize all key values as INFINITE. Assign key value as 0 for the first vertex so that it is picked first.\r\n3) While mstSet doesn’t include all vertices\r\n….a) Pick a vertex u which is not there in mstSet and has minimum key value.\r\n….b) Include u to mstSet.\r\n….c) Update key value of all adjacent vertices of u. To update the key values, iterate through all adjacent vertices. For every adjacent vertex v, if weight of edge u-v is less than the previous key value of v, update the key value as weight of u-v', '2020-05-25'),
(471, 14, 5601012018, '#include<iostream>\r\n#include<conio.h>\r\n#include<stdio.h>\r\nstruct Edge {\r\n    int src, dest, weight;\r\n};\r\n\r\nstruct Graph\r\n{\r\n    int V, E;\r\n    struct Edge* edge;\r\n};\r\nstruct Graph* createGraph(int V, int E)\r\n{\r\n    struct Graph* graph = new Graph;\r\n    graph->V = V;\r\n    graph->E = E;\r\n    graph->edge = new Edge[E];\r\n    return graph;\r\n}\r\nvoid printArr(int dist[], int n)\r\n{\r\n    for (int i = 0; i < n; ++i)\r\n        printf(\"%d %d \", i, dist[i]);\r\n}\r\n\r\nvoid BellmanFord(struct Graph* graph, int src)\r\n{\r\n    int V = graph->V;\r\n    int E = graph->E;\r\n    int dist[V];\r\n\r\n    for (int i = 0; i < V; i++)\r\n        dist[i] = INT_MAX;\r\n    dist[src] = 0;\r\n\r\n    for (int i = 1; i <= V - 1; i++) {\r\n        for (int j = 0; j < E; j++) {\r\n            int u = graph->edge[j].src;\r\n            int v = graph->edge[j].dest;\r\n            int weight = graph->edge[j].weight;\r\n            if (dist[u] != INT_MAX && dist[u] + weight < dist[v])\r\n                dist[v] = dist[u] + weight;\r\n        }\r\n    }\r\n     for (int i = 0; i < E; i++) {\r\n        int u = graph->edge[i].src;\r\n        int v = graph->edge[i].dest;\r\n        int weight = graph->edge[i].weight;\r\n        if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {\r\n            printf(\"Graph contains negative weight cycle\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printArr(dist, V);\r\n\r\n    return;\r\n}\r\n\r\nint main()\r\n{\r\n    int V = 5;\r\n    int E = 8;\r\n    struct Graph* graph = createGraph(V, E);\r\n\r\n\r\n    graph->edge[0].src = 0;\r\n    graph->edge[0].dest = 1;\r\n    graph->edge[0].weight = -1;\r\n\r\n\r\n    graph->edge[1].src = 0;\r\n    graph->edge[1].dest = 2;\r\n    graph->edge[1].weight = 4;\r\n\r\n\r\n    graph->edge[2].src = 1;\r\n    graph->edge[2].dest = 2;\r\n    graph->edge[2].weight = 3;\r\n\r\n\r\n    graph->edge[3].src = 1;\r\n    graph->edge[3].dest = 3;\r\n    graph->edge[3].weight = 2;\r\n\r\n\r\n    graph->edge[4].src = 1;\r\n    graph->edge[4].dest = 4;\r\n    graph->edge[4].weight = 2;\r\n\r\n\r\n    graph->edge[5].src = 3;\r\n    graph->edge[5].dest = 2;\r\n    graph->edge[5].weight = 5;\r\n\r\n\r\n    graph->edge[6].src = 3;\r\n    graph->edge[6].dest = 1;\r\n    graph->edge[6].weight = 1;\r\n\r\n\r\n    graph->edge[7].src = 4;\r\n    graph->edge[7].dest = 3;\r\n    graph->edge[7].weight = -3;\r\n\r\n    BellmanFord(graph, 0);\r\n\r\n    return 0;\r\n}\r\n', 1000, '', '', 'Algorithm\r\nFollowing are the detailed steps.\r\n\r\nInput: Graph and a source vertex src\r\nOutput: Shortest distance to all vertices from src. If there is a negative weight cycle, then shortest distances are not calculated, negative weight cycle is reported.\r\n\r\n\r\n\r\n\r\n1) This step initializes distances from source to all vertices as infinite and distance to source itself as 0. Create an array dist[] of size |V| with all values as infinite except dist[src] where src is source vertex.\r\n\r\n2) This step calculates shortest distances. Do following |V|-1 times where |V| is the number of vertices in given graph.\r\n…..a) Do following for each edge u-v\r\n………………If dist[v] > dist[u] + weight of edge uv, then update dist[v]\r\n………………….dist[v] = dist[u] + weight of edge uv\r\n\r\n3) This step reports if there is a negative weight cycle in graph. Do following for each edge u-v\r\n……If dist[v] > dist[u] + weight of edge uv, then “Graph contains negative weight cycle”\r\nThe idea of step 3 is, step 2 guarantees shortest distances if graph doesn’t contain negative weight cycle. If we iterate through all edges one more time and get a shorter path for any vertex, then there is a negative weight cycle', '2020-05-25'),
(472, 15, 5601012018, '#include<iostream>\r\nusing namespace std;\r\n\r\nint matrix_chain(int array[], int n) {\r\n   int minMul[n][n];\r\n   for (int i=1; i<n; i++)\r\n      minMul[i][i] = 0;\r\n\r\n   for (int length=2; length<n; length++) {\r\n      for (int i=1; i<n-length+1; i++) {\r\n         int j = i+length-1;\r\n         minMul[i][j] = INT_MAX;\r\n         for (int k=i; k<=j-1; k++) {\r\n            int q = minMul[i][k] + minMul[k+1][j] + array[i- 1]*array[k]*array[j];\r\n            if (q < minMul[i][j])\r\n               minMul[i][j] = q;\r\n         }\r\n        }\r\n   }\r\n   return minMul[1][n-1];\r\n}\r\n\r\nint main() {\r\n    int n;\r\n    cin>>n;\r\n    int arr[n];\r\n    for(int i=0;i<n;i++){\r\n        cin>>arr[i];\r\n    }\r\n   cout <<matrix_chain(arr, n);\r\n}\r\n', 1000, '', '', 'Algorithm of Matrix Chain Multiplication\r\nMATRIX-CHAIN-ORDER (p)\r\n\r\n\r\n 1. n   length[p]-1\r\n 2. for i ← 1 to n\r\n 3. do m [i, i] ← 0\r\n 4. for l ← 2 to n    // l is the chain length\r\n 5. do for i ← 1 to n-l + 1\r\n 6. do j ← i+ l -1\r\n 7. m[i,j] ←  ∞\r\n 8. for k  ← i to j-1\r\n 9. do q  ← m [i, k] + m [k + 1, j] + pi-1 pk pj	\r\n 10. If q < m [i,j]\r\n 11. then m [i,j] ← q\r\n 12. s [i,j] ← k\r\n 13. return m and s.  ', '2020-05-25'),
(473, 4, 5601012018, '#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nclass Pair{\r\npublic:\r\n	int min;\r\n	int max;\r\n};\r\n\r\nPair MaxMin(int arr[], int start, int end){\r\n	Pair mxMn;\r\n	if (end == start){\r\n		mxMn.min = arr[start];\r\n		mxMn.max = arr[start];\r\n		return mxMn;\r\n	}\r\n\r\n	if (end - start == 1){\r\n		if (arr[start] < arr[end]){\r\n			mxMn.min = arr[start];\r\n			mxMn.max = arr[end];\r\n		}\r\n		else {\r\n			mxMn.min = arr[end];\r\n			mxMn.max = arr[start];\r\n		}\r\n		return mxMn;\r\n	}\r\n\r\n	int mid = (start + end) / 2;\r\n\r\n	Pair ml = MaxMin(arr, start, mid);\r\n	Pair mr = MaxMin(arr, mid + 1, end);\r\n\r\n	if (ml.min > mr.min) mxMn.min = mr.min;\r\n	else mxMn.min = ml.min;\r\n\r\n	if (ml.max > mr.max) mxMn.max = ml.max;\r\n	else mxMn.max = mr.max;\r\n	return mxMn;\r\n}\r\n\r\nint main(){\r\n	int n=6;\r\n	int arr[] = {10, 37, 194, 365, 82, 55};\r\n	Pair mxMn = MaxMin(arr, 0, n - 1);\r\n	cout << mxMn.min << \" \" << mxMn.max;\r\n}\r\n', 0, '6 1000 11 445 1 330 3000', '10 365', 'Algorithm: Max-Min-Element (numbers[]) \r\nmax := numbers[1] \r\nmin := numbers[1] \r\n\r\nfor i = 2 to n do \r\n   if numbers[i] > max then  \r\n      max := numbers[i] \r\n   if numbers[i] < min then  \r\n      min := numbers[i] \r\nreturn (max, min) ', '2020-05-25');
INSERT INTO `qtos_map` (`ID`, `Q_ID`, `ROLL`, `SUBMISSION`, `SCORE`, `INPUT`, `OP`, `ALGO`, `DATE`) VALUES
(474, 8, 5601012018, '#include<bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nconst int N = 10000 + 5;\r\n\r\nint A[N][N];\r\nint B[N][N];\r\nint D[N][N];\r\n\r\nvoid matrix_multiply(int n){\r\n	for(int i=0;i<n;i++){\r\n		for(int j=0;j<n;j++){\r\n			D[i][j] = 0;\r\n			for(int k=0;k<n;k++)\r\n				D[i][j] += A[i][k]*B[k][j];\r\n				cout << D[i][j] << \" \";\r\n		}\r\n\r\n	}\r\n}\r\n\r\nstruct matrix{\r\n	int k;\r\n	vector<vector<int> > mat;\r\n\r\n	matrix(int sz){\r\n		k=sz;\r\n		mat.resize(sz);\r\n		for(int i=0;i<sz;i++)\r\n			mat[i].resize(sz);\r\n	}\r\n\r\n	matrix operator + (const matrix &o){\r\n        matrix res(k);\r\n        for(int i=0;i<k;i++){\r\n        	for(int j=0;j<k;j++)\r\n	        	res.mat[i][j]=o.mat[i][j] + mat[i][j];\r\n	    }\r\n        return res;\r\n    }\r\n\r\n    matrix operator - (const matrix &o){\r\n        matrix res(k);\r\n        for(int i=0;i<k;i++){\r\n        	for(int j=0;j<k;j++)\r\n	        	res.mat[i][j]= mat[i][j] - o.mat[i][j];\r\n	    }\r\n        return res;\r\n    }\r\n\r\n	void print(){\r\n		for(int i=0;i<k;i++){\r\n			for(int j=0;j<k;j++){\r\n				cout<<mat[i][j]<<\" \";\r\n			}\r\n\r\n		}\r\n	}\r\n};\r\n\r\nmatrix multiply(matrix A, matrix B, int n){\r\n	if(n==2){\r\n		matrix res(2);\r\n		res.mat[0][0] = A.mat[0][0]*B.mat[0][0] + A.mat[0][1]*B.mat[1][0];\r\n		res.mat[0][1] = A.mat[0][0]*B.mat[0][1] + A.mat[0][1]*B.mat[1][1];\r\n		res.mat[1][0] = A.mat[1][0]*B.mat[0][0] + A.mat[1][1]*B.mat[1][0];\r\n		res.mat[1][1] = A.mat[1][0]*B.mat[0][1] + A.mat[1][1]*B.mat[1][1];\r\n		return res;\r\n	}\r\n	if(n==1){\r\n		matrix res(1);\r\n		res.mat[0][0] = A.mat[0][0]*B.mat[0][0];\r\n		return res;\r\n	}\r\n	int h = n/2;\r\n	matrix A00(h), A01(h), A10(h), A11(h);\r\n	matrix B00(h), B01(h), B10(h), B11(h);\r\n	matrix C00(h), C01(h), C10(h), C11(h);\r\n	for(int i=0;i<h;i++){\r\n		for(int j=0;j<h;j++)\r\n		{\r\n			A00.mat[i][j] = A.mat[i][j];\r\n			B00.mat[i][j] = B.mat[i][j];\r\n			A01.mat[i][j] = A.mat[i][j+h];\r\n			B01.mat[i][j] = B.mat[i][j+h];\r\n			A10.mat[i][j] = A.mat[i+h][j];\r\n			B10.mat[i][j] = B.mat[i+h][j];\r\n			A11.mat[i][j] = A.mat[i+h][j+h];\r\n			B11.mat[i][j] = B.mat[i+h][j+h];\r\n		}\r\n	}\r\n	matrix M1(h), M2(h), M3(h), M4(h), M5(h), M6(h), M7(h);\r\n	M1 = multiply(A00 + A11, (B00 + B11), h);\r\n	M2 = multiply(A10 +  A11, B00, h);\r\n	M3 = multiply(A00, B01 - B11, h);\r\n	M4 = multiply(A11, B10 - B00, h);\r\n	M5 = multiply(A00 + A01, B11, h);\r\n	M6 = multiply(A10 - A00, B00 + B01, h);\r\n	M7 = multiply(A01 - A11, B10 + B11, h);\r\n	C00 = M1 + M4 - M5 + M7;\r\n	C01 = M3 + M5;\r\n	C10 = M2 + M4;\r\n	C11 = M1 - M2 + M3 + M6;\r\n	matrix C(n);\r\n	for(int i=0;i<h;i++){\r\n		for(int j=0;j<h;j++){\r\n			C.mat[i][j] = C00.mat[i][j];\r\n			C.mat[i][j+h] = C01.mat[i][j];\r\n			C.mat[i+h][j] = C10.mat[i][j];\r\n			C.mat[i+h][j+h] = C11.mat[i][j];\r\n		}\r\n	}\r\n	return C;\r\n}\r\n\r\nint main(){\r\n		int n;\r\n		cin>>n;\r\n		matrix E(n), F(n);\r\n		for(int i=0;i<n;i++){\r\n			for(int j=0;j<n;j++){\r\n				cin>>A[i][j];\r\n				E.mat[i][j] = A[i][j];\r\n			}\r\n		}\r\n		cout<<endl;\r\n		for(int i=0;i<n;i++){\r\n			for(int j=0;j<n;j++){\r\n				cin>>B[i][j];\r\n				F.mat[i][j] = B[i][j];\r\n			}\r\n		}\r\n\r\n\r\n		matrix_multiply(n);\r\n		cout<<endl;\r\n\r\n}\r\n', 0, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '\n-17 -4 -7 10 2 11 40 92 107 \n', 'void multiply(int A[][N], int B[][N], int C[][N]) \r\n{ \r\n    for (int i = 0; i < N; i++) \r\n    { \r\n        for (int j = 0; j < N; j++) \r\n        { \r\n            C[i][j] = 0; \r\n            for (int k = 0; k < N; k++) \r\n            { \r\n                C[i][j] += A[i][k]*B[k][j]; \r\n            } \r\n        } \r\n    } \r\n} ', '2020-05-25'),
(475, 5, 5601012018, '#include<iostream>\r\n#include<conio.h>\r\n#include<stdio.h>\r\nusing namespace std; \r\ntypedef long long lld; \r\ninline lld** MatrixMultiply(lld** a, lld** b, int n, \r\n                                      int l, int m) \r\n{ \r\n    lld** c = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        c[i] = new lld[m]; \r\n  \r\n    for (int i = 0; i < n; i++) { \r\n        for (int j = 0; j < m; j++) { \r\n            c[i][j] = 0; \r\n            for (int k = 0; k < l; k++) { \r\n                c[i][j] += a[i][k] * b[k][j]; \r\n            } \r\n        } \r\n    } \r\n    return c; \r\n} \r\n  \r\ninline lld** Strassen(lld** a, lld** b, int n,  \r\n                                int l, int m) \r\n{ \r\n    if (n == 1 || l == 1 || m == 1)  \r\n        return MatrixMultiply(a, b, n, l, m); \r\n  \r\n    lld** c = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        c[i] = new lld[m]; \r\n  \r\n    int adjN = (n >> 1) + (n & 1); \r\n    int adjL = (l >> 1) + (l & 1); \r\n    int adjM = (m >> 1) + (m & 1); \r\n  \r\n    lld**** As = new lld***[2]; \r\n    for (int x = 0; x < 2; x++) { \r\n        As[x] = new lld**[2]; \r\n        for (int y = 0; y < 2; y++) { \r\n            As[x][y] = new lld*[adjN]; \r\n            for (int i = 0; i < adjN; i++) { \r\n                As[x][y][i] = new lld[adjL]; \r\n                for (int j = 0; j < adjL; j++) { \r\n                    int I = i + (x & 1) * adjN; \r\n                    int J = j + (y & 1) * adjL; \r\n                    As[x][y][i][j] = (I < n && J < l) ? a[I][J] : 0; \r\n                } \r\n            } \r\n        } \r\n    } \r\n  \r\n    lld**** Bs = new lld***[2]; \r\n    for (int x = 0; x < 2; x++) { \r\n        Bs[x] = new lld**[2]; \r\n        for (int y = 0; y < 2; y++) { \r\n            Bs[x][y] = new lld*[adjN]; \r\n            for (int i = 0; i < adjL; i++) { \r\n                Bs[x][y][i] = new lld[adjM]; \r\n                for (int j = 0; j < adjM; j++) { \r\n                    int I = i + (x & 1) * adjL; \r\n                    int J = j + (y & 1) * adjM; \r\n                    Bs[x][y][i][j] = (I < l && J < m) ? b[I][J] : 0; \r\n                } \r\n            } \r\n        } \r\n    } \r\n  \r\n    lld*** s = new lld**[10]; \r\n    for (int i = 0; i < 10; i++) { \r\n        switch (i) { \r\n        case 0: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][1][j][k] - Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 1: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] + As[0][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 2: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[1][0][j][k] + As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 3: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[1][0][j][k] - Bs[0][0][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 4: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] + As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 5: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 6: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][1][j][k] - As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 7: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[1][0][j][k] + Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 8: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] - As[1][0][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 9: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[0][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        } \r\n    } \r\n  \r\n    lld*** p = new lld**[7]; \r\n    p[0] = Strassen(As[0][0], s[0], adjN, adjL, adjM); \r\n    p[1] = Strassen(s[1], Bs[1][1], adjN, adjL, adjM); \r\n    p[2] = Strassen(s[2], Bs[0][0], adjN, adjL, adjM); \r\n    p[3] = Strassen(As[1][1], s[3], adjN, adjL, adjM); \r\n    p[4] = Strassen(s[4], s[5], adjN, adjL, adjM); \r\n    p[5] = Strassen(s[6], s[7], adjN, adjL, adjM); \r\n    p[6] = Strassen(s[8], s[9], adjN, adjL, adjM); \r\n  \r\n    for (int i = 0; i < adjN; i++) { \r\n        for (int j = 0; j < adjM; j++) { \r\n            c[i][j] = p[4][i][j] + p[3][i][j] - p[1][i][j] + p[5][i][j]; \r\n            if (j + adjM < m) \r\n                c[i][j + adjM] = p[0][i][j] + p[1][i][j]; \r\n            if (i + adjN < n) \r\n                c[i + adjN][j] = p[2][i][j] + p[3][i][j]; \r\n            if (i + adjN < n && j + adjM < m) \r\n                c[i + adjN][j + adjM] = p[4][i][j] + p[0][i][j] - p[2][i][j] - p[6][i][j]; \r\n        } \r\n    } \r\n  \r\n    for (int x = 0; x < 2; x++) { \r\n        for (int y = 0; y < 2; y++) { \r\n            for (int i = 0; i < adjN; i++) { \r\n                delete[] As[x][y][i]; \r\n            } \r\n            delete[] As[x][y]; \r\n        } \r\n        delete[] As[x]; \r\n    } \r\n    delete[] As; \r\n  \r\n    for (int x = 0; x < 2; x++) { \r\n        for (int y = 0; y < 2; y++) { \r\n            for (int i = 0; i < adjL; i++) { \r\n                delete[] Bs[x][y][i]; \r\n            } \r\n            delete[] Bs[x][y]; \r\n        } \r\n        delete[] Bs[x]; \r\n    } \r\n    delete[] Bs; \r\n  \r\n    for (int i = 0; i < 10; i++) { \r\n        switch (i) { \r\n        case 0: \r\n        case 3: \r\n        case 5: \r\n        case 7: \r\n        case 9: \r\n            for (int j = 0; j < adjL; j++) { \r\n                delete[] s[i][j]; \r\n            } \r\n            break; \r\n        case 1: \r\n        case 2: \r\n        case 4: \r\n        case 6: \r\n        case 8: \r\n            for (int j = 0; j < adjN; j++) { \r\n                delete[] s[i][j]; \r\n            } \r\n            break; \r\n        } \r\n        delete[] s[i]; \r\n    } \r\n    delete[] s; \r\n  \r\n    for (int i = 0; i < 7; i++) { \r\n        for (int j = 0; j < (n >> 1); j++) { \r\n            delete[] p[i][j]; \r\n        } \r\n        delete[] p[i]; \r\n    } \r\n    delete[] p; \r\n  \r\n    return c; \r\n} \r\n  \r\nint main() \r\n{ \r\n    lld** matA; \r\n    matA = new lld*[2]; \r\n    for (int i = 0; i < 2; i++) \r\n        matA[i] = new lld[3]; \r\n    matA[0][0] = 1; \r\n    matA[0][1] = 2; \r\n    matA[0][2] = 3; \r\n    matA[1][0] = 4; \r\n    matA[1][1] = 5; \r\n    matA[1][2] = 6; \r\n  \r\n    lld** matB; \r\n    matB = new lld*[3]; \r\n    for (int i = 0; i < 3; i++) \r\n        matB[i] = new lld[2]; \r\n    matB[0][0] = 7; \r\n    matB[0][1] = 8; \r\n    matB[1][0] = 9; \r\n    matB[1][1] = 10; \r\n    matB[2][0] = 11; \r\n    matB[2][1] = 12; \r\n  \r\n    lld** matC = Strassen(matA, matB, 2, 3, 2); \r\n    for (int i = 0; i < 2; i++) { \r\n        for (int j = 0; j < 2; j++) { \r\n            printf(\"%lld \", matC[i][j]); \r\n        } \r\n        printf(\"\n\"); \r\n    } \r\n  \r\n    return 0; \r\n', 1000, '', '', 'void multiply(int A[][N], int B[][N], int C[][N]) \r\n{ \r\n    for (int i = 0; i < N; i++) \r\n    { \r\n        for (int j = 0; j < N; j++) \r\n        { \r\n            C[i][j] = 0; \r\n            for (int k = 0; k < N; k++) \r\n            { \r\n                C[i][j] += A[i][k]*B[k][j]; \r\n            } \r\n        } \r\n    } \r\n} ', '2020-05-25'),
(476, 16, 5601012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n\r\n#define d 256 \r\n\r\nvoid search(char pat[], char txt[], int q) \r\n{ \r\n	int M = strlen(pat); \r\n	int N = strlen(txt); \r\n	int i, j; \r\n	int p = 0; \r\n	int t = 0; \r\n	int h = 1; \r\n\r\n	for (i = 0; i < M - 1; i++) \r\n		h = (h * d) % q; \r\n\r\n	for (i = 0; i < M; i++) \r\n	{ \r\n		p = (d * p + pat[i]) % q; \r\n		t = (d * t + txt[i]) % q; \r\n	} \r\n\r\n	for (i = 0; i <= N - M; i++) \r\n	{ \r\n\r\n		if ( p == t ) \r\n		{ \r\n			for (j = 0; j < M; j++) \r\n			{ \r\n				if (txt[i+j] != pat[j]) \r\n					break; \r\n			} \r\n\r\n			if (j == M) \r\n				cout<<\"Pattern found at index\"<<\" \"<<i<<\" \"; \r\n		} \r\n\r\n		if ( i < N-M ) \r\n		{ \r\n			t = (d*(t - txt[i]*h) + txt[i+M])%q; \r\n\r\n			if (t < 0) \r\n			t = (t + q); \r\n		} \r\n	} \r\n} \r\n\r\nint main() \r\n{ \r\n	char txt[101]; \r\n	char pat[101]; \r\n	cin >> txt >> pat;\r\n	int q = 101; \r\n	search(pat, txt, q); \r\n	return 0; \r\n} \r\n\r\n', 1000, '', '', 'function RabinKarp(string s[1..n], string pattern[1..m])\r\n    hpattern := hash(pattern[1..m]);\r\n    for i from 1 to n-m+1\r\n        hs := hash(s[i..i+m-1])\r\n        if hs = hpattern\r\n            if s[i..i+m-1] = pattern[1..m]\r\n                return i\r\n    return not found', '2020-05-25'),
(477, 3, 5701012018, '#include <iostream>\r\nusing namespace std;\r\nvoid swap(int* a, int* b)\r\n{\r\n    int t = *a;\r\n    *a = *b;\r\n    *b = t;\r\n}\r\nint partition (int arr[], int low, int high)\r\n{\r\n    int pivot = arr[high];\r\n    int i = (low - 1);\r\n\r\n    for (int j = low; j <= high - 1; j++)\r\n    {\r\n        if (arr[j] < pivot)\r\n        {\r\n            i++;\r\n            swap(&arr[i], &arr[j]);\r\n        }\r\n    }\r\n    swap(&arr[i + 1], &arr[high]);\r\n    return (i + 1);\r\n}\r\nvoid quickSort(int arr[], int low, int high)\r\n{\r\n    if (low < high)\r\n    {\r\n        int pi = partition(arr, low, high);\r\n        quickSort(arr, low, pi - 1);\r\n        quickSort(arr, pi + 1, high);\r\n    }\r\n}\r\nvoid printArray(int arr[], int size)\r\n{\r\n    int i;\r\n    for (i = 0; i < size; i++)\r\n        cout << arr[i] << \" \";\r\n    cout << endl;\r\n}\r\nint main()\r\n{\r\n    int arr[50];\r\n    int n;\r\n    cin>>n;\r\n    for(int i=0;i<n;i++)\r\n    {\r\n        cin>>arr[i];\r\n    }\r\n    quickSort(arr, 0, n - 1);\r\n    printArray(arr, n);\r\n    return 0;\r\n}\r\n', 0, '1 2000', '2000 \n', 'Quick Sort Algorithm:\r\nThere are many different versions of quickSort that pick pivot in different ways.\r\n\r\nAlways pick first element as pivot.\r\nAlways pick last element as pivot.\r\nPick a random element as pivot.\r\nPick median as pivot.\r\nThe key process in quickSort is partition(). Target of partitions is, given an array and an element x of array as pivot, put x at its correct position in sorted array and put all smaller elements (smaller than x) before x, and put all greater elements (greater than x) after x. All this should be done in linear time.', '2020-05-25'),
(478, 7, 5701012018, '#include<iostream>\r\n#include<cstdlib>\r\nusing namespace std;\r\nvoid swap(int *a, int *b)\r\n{\r\n	int temp;\r\n	temp = *a;\r\n	*a = *b;\r\n	*b = temp;\r\n}\r\nint Partition(int a[], int low, int high)\r\n{\r\n	int pivot, index, i;\r\n	index = low;\r\n	pivot = high;\r\n	for(i=low; i < high; i++)\r\n	{\r\n		if(a[i] < a[pivot])\r\n		{\r\n			swap(&a[i], &a[index]);\r\n			index++;\r\n		}\r\n	}\r\n	swap(&a[pivot], &a[index]);\r\n\r\n	return index;\r\n}\r\n\r\nint RandomPivotPartition(int a[], int low, int high)\r\n{\r\n	int pvt, n, temp;\r\n	n = rand();\r\n	pvt = low + n%(high-low+1);\r\n	swap(&a[high], &a[pvt]);\r\n\r\n	return Partition(a, low, high);\r\n}\r\nint QuickSort(int a[], int low, int high)\r\n{\r\n	int pindex;\r\n	if(low < high)\r\n	{\r\n		pindex = RandomPivotPartition(a, low, high);\r\n		QuickSort(a, low, pindex-1);\r\n		QuickSort(a, pindex+1, high);\r\n	}\r\n	return 0;\r\n}\r\n\r\nint main()\r\n{\r\n	int n, i;\r\n	cin>>n;\r\n	int arr[n];\r\n	for(i = 0; i < n; i++)\r\n	{\r\n		cin>>arr[i];\r\n	}\r\n\r\n	QuickSort(arr, 0, n-1);\r\n	for (i = 0; i < n; i++)\r\n        	cout<<arr[i]<<\" \";\r\n	return 0;\r\n}\r\n', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', 'Quick Sort Algorithm:\r\nThere are many different versions of quickSort that pick pivot in different ways.\r\n\r\nAlways pick first element as pivot.\r\nAlways pick last element as pivot.\r\nPick a random element as pivot.\r\nPick median as pivot.\r\nThe key process in quickSort is partition(). Target of partitions is, given an array and an element x of array as pivot, put x at its correct position in sorted array and put all smaller elements (smaller than x) before x, and put all greater elements (greater than x) after x. All this should be done in linear time.', '2020-05-25'),
(479, 9, 5701012018, '\r\n#include <iostream> \r\nusing namespace std; \r\nclass DisjSet { \r\n	int *rank, *parent, n; \r\n\r\npublic: \r\n	\r\n	DisjSet(int n) \r\n	{ \r\n		rank = new int[n]; \r\n		parent = new int[n]; \r\n		this->n = n; \r\n		makeSet(); \r\n	} \r\n\r\n	\r\n	void makeSet() \r\n	{ \r\n		for (int i = 0; i < n; i++) { \r\n			parent[i] = i; \r\n		} \r\n	} \r\n\r\n	int find(int x) \r\n	{ \r\n		if (parent[x] != x) { \r\n\r\n			\r\n			parent[x] = find(parent[x]); \r\n\r\n			\r\n		} \r\n\r\n		return parent[x]; \r\n	} \r\n \r\n	void Union(int x, int y) \r\n	{ \r\n		int xset = find(x); \r\n		int yset = find(y); \r\n\r\n		if (xset == yset) \r\n			return; \r\n\r\n		if (rank[xset] < rank[yset]) { \r\n			parent[xset] = yset; \r\n		} \r\n		else if (rank[xset] > rank[yset]) { \r\n			parent[yset] = xset; \r\n		} \r\n\r\n		else { \r\n			parent[yset] = xset; \r\n			rank[xset] = rank[xset] + 1; \r\n		} \r\n	} \r\n}; \r\n\r\nint main() \r\n{ \r\n	DisjSet obj(5); \r\n	obj.Union(0, 2); \r\n	obj.Union(4, 2); \r\n	obj.Union(3, 1); \r\n	if (obj.find(4) == obj.find(0)) \r\n		cout << \"Yes\n\"; \r\n	else\r\n		cout << \"No\n\"; \r\n	if (obj.find(1) == obj.find(0)) \r\n		cout << \"Yes\n\"; \r\n	else\r\n		cout << \"No\n\"; \r\n\r\n	return 0; \r\n} \r\n', 1000, '', '', 'ALgorithm\r\nfind:\r\n\r\nint find(int i) \r\n{\r\n    \r\n    if (parent[i] == i) \r\n    {\r\n        return i;\r\n    }\r\n    else \r\n    {\r\n        return find(parent[i]);\r\n    }\r\n}\r\n\r\nunion:\r\n\r\n// Unites the set that includes i \r\n// and the set that includes j\r\nvoid union(int i, int j) \r\n{\r\n    // Find the representatives\r\n    // (or the root nodes) for the set\r\n    // that includes i\r\n    \r\n    int irep = this.Find(i),\r\n\r\n    // And do the same for the set \r\n    // that includes j    \r\n    int jrep = this.Find(j);\r\n\r\n    // Make the parent of i’s representative\r\n    // be j’s  representative effectively \r\n    // moving all of i’s set into j’s set)\r\n    this.Parent[irep] = jrep;\r\n}\r\n\r\npath compression:\r\n\r\n// Finds the representative of the set that i\r\n// is an element of.\r\nint find(int i) \r\n{\r\n    // If i is the parent of itself\r\n    if (Parent[i] == i) \r\n    {\r\n        // Then i is the representative \r\n        return i;\r\n    }\r\n    else\r\n    { \r\n        // Recursively find the representative.\r\n        int result = find(Parent[i]);\r\n\r\n        // We cache the result by moving i’s node \r\n        // directly under the representative of this\r\n        // set\r\n        Parent[i] = result;\r\n       \r\n        // And then we return the result\r\n        return result;\r\n     }\r\n}\r\n\r\nunion by rank:\r\n\r\nvoid union(int i, int j) \r\n{\r\n    // Find the representatives (or the root nodes) \r\n    // for the set that includes i\r\n    int irep = this.find(i);\r\n\r\n    // And do the same for the set that includes j\r\n    int jrep = this.Find(j);\r\n\r\n    // Elements are in same set, no need to \r\n    // unite anything.    \r\n    if (irep == jrep)\r\n        return;\r\n\r\n    // Get the rank of i’s tree\r\n    irank = Rank[irep],\r\n\r\n    // Get the rank of j’s tree\r\n    jrank = Rank[jrep];\r\n\r\n    // If i’s rank is less than j’s rank\r\n    if (irank < jrank) \r\n    {\r\n        // Then move i under j\r\n        this.parent[irep] = jrep;\r\n    } \r\n\r\n    // Else if j’s rank is less than i’s rank\r\n    else if (jrank < irank) \r\n    {\r\n        // Then move j under i\r\n        this.Parent[jrep] = irep;\r\n    } \r\n\r\n    // Else if their ranks are the same\r\n    else\r\n    {\r\n\r\n        // Then move i under j (doesn’t matter\r\n        // which one goes where)\r\n        this.Parent[irep] = jrep;\r\n\r\n        // And increment the result tree’s \r\n        // rank by 1\r\n        Rank[jrep]++;\r\n    }\r\n}\r\n', '2020-05-25'),
(480, 12, 5701012018, '\r\n#include <bits/stdc++.h> \r\nusing namespace std; \r\nclass Edge \r\n{ \r\n	public: \r\n	int src, dest, weight; \r\n}; \r\n\r\nclass Graph \r\n{ \r\n	public: \r\n	int V, E; \r\n	Edge* edge; \r\n}; \r\n\r\nGraph* createGraph(int V, int E) \r\n{ \r\n	Graph* graph = new Graph; \r\n	graph->V = V; \r\n	graph->E = E; \r\n\r\n	graph->edge = new Edge[E]; \r\n\r\n	return graph; \r\n} \r\n\r\n\r\nclass subset \r\n{ \r\n	public: \r\n	int parent; \r\n	int rank; \r\n}; \r\n\r\n\r\nint find(subset subsets[], int i) \r\n{ \r\n	// find root and make root as parent of i \r\n	// (path compression) \r\n	if (subsets[i].parent != i) \r\n		subsets[i].parent = find(subsets, subsets[i].parent); \r\n\r\n	return subsets[i].parent; \r\n} \r\n\r\nvoid Union(subset subsets[], int x, int y) \r\n{ \r\n	int xroot = find(subsets, x); \r\n	int yroot = find(subsets, y); \r\n\r\n	if (subsets[xroot].rank < subsets[yroot].rank) \r\n		subsets[xroot].parent = yroot; \r\n	else if (subsets[xroot].rank > subsets[yroot].rank) \r\n		subsets[yroot].parent = xroot; \r\n\r\n	else\r\n	{ \r\n		subsets[yroot].parent = xroot; \r\n		subsets[xroot].rank++; \r\n	} \r\n} \r\n\r\nint myComp(const void* a, const void* b) \r\n{ \r\n	Edge* a1 = (Edge*)a; \r\n	Edge* b1 = (Edge*)b; \r\n	return a1->weight > b1->weight; \r\n} \r\nvoid KruskalMST(Graph* graph) \r\n{ \r\n	int V = graph->V; \r\n	Edge result[V]; // Tnis will store the resultant MST \r\n	int e = 0; \r\n	int i = 0; \r\n\r\n	qsort(graph->edge, graph->E, sizeof(graph->edge[0]), myComp); \r\n\r\n	subset *subsets = new subset[( V * sizeof(subset) )]; \r\n\r\n	// Create V subsets with single elements \r\n	for (int v = 0; v < V; ++v) \r\n	{ \r\n		subsets[v].parent = v; \r\n		subsets[v].rank = 0; \r\n	} \r\n\r\n	// Number of edges to be taken is equal to V-1 \r\n	while (e < V - 1 && i < graph->E) \r\n	{ \r\n		\r\n		Edge next_edge = graph->edge[i++]; \r\n\r\n		int x = find(subsets, next_edge.src); \r\n		int y = find(subsets, next_edge.dest); \r\n\r\n		\r\n		// of result for next edge \r\n		if (x != y) \r\n		{ \r\n			result[e++] = next_edge; \r\n			Union(subsets, x, y); \r\n		} \r\n		// Else discard the next_edge \r\n	} \r\n\r\n	\r\n	for (i = 0; i < e; ++i) \r\n		cout<<result[i].src<<\" -- \"<<result[i].dest<<\" == \"<<result[i].weight<<endl; \r\n	return; \r\n} \r\n\r\nint main() \r\n{ \r\n	\r\n	int V = 4; \r\n	int E = 5; \r\n	Graph* graph = createGraph(V, E); \r\n\r\n\r\n	// add edge 0-1 \r\n	graph->edge[0].src = 0; \r\n	graph->edge[0].dest = 1; \r\n	graph->edge[0].weight = 10; \r\n\r\n	// add edge 0-2 \r\n	graph->edge[1].src = 0; \r\n	graph->edge[1].dest = 2; \r\n	graph->edge[1].weight = 6; \r\n\r\n	// add edge 0-3 \r\n	graph->edge[2].src = 0; \r\n	graph->edge[2].dest = 3; \r\n	graph->edge[2].weight = 5; \r\n\r\n	// add edge 1-3 \r\n	graph->edge[3].src = 1; \r\n	graph->edge[3].dest = 3; \r\n	graph->edge[3].weight = 15; \r\n\r\n	// add edge 2-3 \r\n	graph->edge[4].src = 2; \r\n	graph->edge[4].dest = 3; \r\n	graph->edge[4].weight = 4; \r\n\r\n	KruskalMST(graph); \r\n\r\n	return 0; \r\n} \r\n\r\n', 1000, '', '', '\r\nAlgorithm\r\n\r\n1. Sort all the edges in non-decreasing order of their weight.\r\n2. Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If cycle is not formed, include this edge. Else, discard it.\r\n3. Repeat step#2 until there are (V-1) edges in the spanning tree.', '2020-05-25'),
(481, 13, 5701012018, '#include <iostream>\r\n#include <vector>\r\n#include <queue>\r\n#include <functional>\r\n#include <utility>\r\n\r\nusing namespace std;\r\nconst int MAX = 1e4 + 5;\r\ntypedef pair<long long, int> PII;\r\nbool marked[MAX];\r\nvector <PII> adj[MAX];\r\n\r\nlong long prim(int x)\r\n{\r\n    priority_queue<PII, vector<PII>, greater<PII> > Q;\r\n    int y;\r\n    long long minimumCost = 0;\r\n    PII p;\r\n    Q.push(make_pair(0, x));\r\n    while(!Q.empty())\r\n    {\r\n\r\n        p = Q.top();\r\n        Q.pop();\r\n        x = p.second;\r\n\r\n        if(marked[x] == true)\r\n            continue;\r\n        minimumCost += p.first;\r\n        marked[x] = true;\r\n        for(int i = 0;i < adj[x].size();++i)\r\n        {\r\n            y = adj[x][i].second;\r\n            if(marked[y] == false)\r\n                Q.push(adj[x][i]);\r\n        }\r\n    }\r\n    return minimumCost;\r\n}\r\n\r\nint main()\r\n{\r\n    int nodes, edges, x, y;\r\n    long long weight, minimumCost;\r\n    cin >> nodes >> edges;\r\n    for(int i = 0;i < edges;++i)\r\n    {\r\n        cin >> x >> y >> weight;\r\n        adj[x].push_back(make_pair(weight, y));\r\n        adj[y].push_back(make_pair(weight, x));\r\n    }\r\n\r\n    minimumCost = prim(1);\r\n    cout << minimumCost << endl;\r\n    return 0;\r\n}\r\n', 1000, '', '', 'Algorithm\r\n1) Create a set mstSet that keeps track of vertices already included in MST.\r\n2) Assign a key value to all vertices in the input graph. Initialize all key values as INFINITE. Assign key value as 0 for the first vertex so that it is picked first.\r\n3) While mstSet doesn’t include all vertices\r\n….a) Pick a vertex u which is not there in mstSet and has minimum key value.\r\n….b) Include u to mstSet.\r\n….c) Update key value of all adjacent vertices of u. To update the key values, iterate through all adjacent vertices. For every adjacent vertex v, if weight of edge u-v is less than the previous key value of v, update the key value as weight of u-v.', '2020-05-25'),
(482, 14, 5701012018, '\r\n#include <bits/stdc++.h> \r\nstruct Edge { \r\n	int src, dest, weight; \r\n}; \r\n\r\n\r\nstruct Graph { \r\n	\r\n	int V, E; \r\n\r\n	struct Edge* edge; \r\n}; \r\n\r\nstruct Graph* createGraph(int V, int E) \r\n{ \r\n	struct Graph* graph = new Graph; \r\n	graph->V = V; \r\n	graph->E = E; \r\n	graph->edge = new Edge[E]; \r\n	return graph; \r\n} \r\n\r\n\r\nvoid printArr(int dist[], int n) \r\n{ \r\n	for (int i = 0; i < n; ++i) \r\n		printf(\"%d 		 %d\n\", i, dist[i]); \r\n} \r\n\r\n\r\nvoid BellmanFord(struct Graph* graph, int src) \r\n{ \r\n	int V = graph->V; \r\n	int E = graph->E; \r\n	int dist[V]; \r\n\r\n	for (int i = 0; i < V; i++) \r\n		dist[i] = INT_MAX; \r\n	dist[src] = 0; \r\n\r\n	\r\n	for (int i = 1; i <= V - 1; i++) { \r\n		for (int j = 0; j < E; j++) { \r\n			int u = graph->edge[j].src; \r\n			int v = graph->edge[j].dest; \r\n			int weight = graph->edge[j].weight; \r\n			if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) \r\n				dist[v] = dist[u] + weight; \r\n		} \r\n	} \r\n \r\n	for (int i = 0; i < E; i++) { \r\n		int u = graph->edge[i].src; \r\n		int v = graph->edge[i].dest; \r\n		int weight = graph->edge[i].weight; \r\n		if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) { \r\n			printf(\"Graph contains negative weight cycle\"); \r\n			return;  \r\n		} \r\n	} \r\n\r\n	printArr(dist, V); \r\n\r\n	return; \r\n} \r\n \r\nint main() \r\n{ \r\n	\r\n	int V = 5; // Number of vertices in graph \r\n	int E = 8; // Number of edges in graph \r\n	struct Graph* graph = createGraph(V, E); \r\n\r\n	// add edge 0-1 \r\n	graph->edge[0].src = 0; \r\n	graph->edge[0].dest = 1; \r\n	graph->edge[0].weight = -1; \r\n\r\n	// add edge 0-2 \r\n	graph->edge[1].src = 0; \r\n	graph->edge[1].dest = 2; \r\n	graph->edge[1].weight = 4; \r\n\r\n	// add edge 1-2  \r\n	graph->edge[2].src = 1; \r\n	graph->edge[2].dest = 2; \r\n	graph->edge[2].weight = 3; \r\n\r\n	// add edge 1-3 \r\n	graph->edge[3].dest = 3; \r\n	graph->edge[3].weight = 2; \r\n\r\n	// add edge 1-4 \r\n	graph->edge[4].src = 1; \r\n	graph->edge[4].dest = 4; \r\n	graph->edge[4].weight = 2; \r\n\r\n	// add edge 3-2\r\n	graph->edge[5].src = 3; \r\n	graph->edge[5].dest = 2; \r\n	graph->edge[5].weight = 5; \r\n\r\n	// add edge 3-1 \r\n	graph->edge[6].src = 3; \r\n	graph->edge[6].dest = 1; \r\n	graph->edge[6].weight = 1; \r\n\r\n	// add edge 4-3 \r\n	graph->edge[7].src = 4; \r\n	graph->edge[7].dest = 3; \r\n	graph->edge[7].weight = -3; \r\n\r\n	BellmanFord(graph, 0); \r\n\r\n	return 0; \r\n} \r\n', 1000, '', '', 'Algorithm\r\nFollowing are the detailed steps.\r\n \r\nInput: Graph and a source vertex src\r\nOutput: Shortest distance to all vertices from src. If there is a negative weight cycle, then shortest distances are not calculated, negative weight cycle is reported.\r\n \r\n \r\n \r\n \r\n1) This step initializes distances from source to all vertices as infinite and distance to source itself as 0. Create an array dist[] of size |V| with all values as infinite except dist[src] where src is source vertex.\r\n \r\n2) This step calculates shortest distances. Do following |V|-1 times where |V| is the number of vertices in given graph.\r\n…..a) Do following for each edge u-v\r\n………………If dist[v] > dist[u] + weight of edge uv, then update dist[v]\r\n………………….dist[v] = dist[u] + weight of edge uv\r\n \r\n3) This step reports if there is a negative weight cycle in graph. Do following for each edge u-v\r\n……If dist[v] > dist[u] + weight of edge uv, then “Graph contains negative weight cycle”\r\nThe idea of step 3 is, step 2 guarantees shortest distances if graph doesn’t contain negative weight cycle. If we iterate through all edges one more time and get a shorter path for any vertex, then there is a negative weight cycle', '2020-05-25'),
(483, 15, 5701012018, '#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint MatrixChainOrder(int p[], int i, int j)\r\n{\r\n    if(i == j)\r\n        return 0;\r\n    int k;\r\n    int min = INT_MAX;\r\n    int count;\r\n\r\n    for (k = i; k < j; k++)\r\n    {\r\n        count = MatrixChainOrder(p, i, k) +\r\n                MatrixChainOrder(p, k + 1, j) +\r\n                p[i - 1] * p[k] * p[j];\r\n\r\n        if (count < min)\r\n            min = count;\r\n    }\r\n\r\n    return min;\r\n}\r\n\r\nint main()\r\n{\r\n    int n=0;\r\n\r\n    cin>>n;\r\n\r\n    int arr[n];\r\n    for(int i=0;i<n;i++){\r\n        cin>>arr[i];\r\n    }\r\n\r\n\r\n         cout<< MatrixChainOrder(arr, 1, n - 1);\r\n}', 1000, '', '', 'Algorithm..\r\nMatrix-Multiply(A,B)\r\n1.If columns[A]!=rows[B]\r\n2. then error “incomplete dimensions”\r\n3. else for i = 1 to rows[A]\r\n4.        	do for j = 1 to columns[B]\r\n5.                        	do C[i,j] = 0\r\n6.                                        	for k = 1 to columns[A]\r\n7.                                                        	Do C[i,j]=C[i,j]+A[i,k]*B[k,j]\r\n8. Return C', '2020-05-25'),
(484, 8, 5701012018, '\r\n#include <iostream>\r\n#include <vector>\r\n#include <cmath>\r\n#include <algorithm>\r\nusing namespace std;\r\n\r\nint nextpowerof2(int k)\r\n{\r\n    return pow(2, int(ceil(log2(k))));\r\n}\r\nvoid display(vector< vector<int>> &matrix, int m, int n)\r\n{\r\n    for (int i = 0; i < m; i++)\r\n    {\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            cout << matrix[i][j]<<\" \";\r\n        }\r\n    }\r\n}\r\n\r\nvoid add(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\r\n{\r\n    int i, j;\r\n\r\n    for (i = 0; i < size; i++)\r\n    {\r\n        for (j = 0; j < size; j++)\r\n        {\r\n            C[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid sub(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\r\n{\r\n    int i, j;\r\n\r\n    for (i = 0; i < size; i++)\r\n    {\r\n        for (j = 0; j < size; j++)\r\n        {\r\n            C[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid STRASSEN_algorithmA(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\r\n{\r\n    //base case\r\n    if (size == 1)\r\n    {\r\n        C[0][0] = A[0][0] * B[0][0];\r\n        return;\r\n    }\r\n    else\r\n    {\r\n        int new_size = size / 2;\r\n        vector<int> z(new_size);\r\n        vector<vector<int>>\r\n            a11(new_size, z), a12(new_size, z), a21(new_size, z), a22(new_size, z),\r\n            b11(new_size, z), b12(new_size, z), b21(new_size, z), b22(new_size, z),\r\n            c11(new_size, z), c12(new_size, z), c21(new_size, z), c22(new_size, z),\r\n            p1(new_size, z), p2(new_size, z), p3(new_size, z), p4(new_size, z),\r\n            p5(new_size, z), p6(new_size, z), p7(new_size, z),\r\n            aResult(new_size, z), bResult(new_size, z);\r\n\r\nint i, j;\r\n\r\n//dividing the matrices into sub-matrices:\r\nfor (i = 0; i < new_size; i++)\r\n        {\r\n            for (j = 0; j < new_size; j++)\r\n            {\r\n                a11[i][j] = A[i][j];\r\n                a12[i][j] = A[i][j + new_size];\r\n                a21[i][j] = A[i + new_size][j];\r\n                a22[i][j] = A[i + new_size][j + new_size];\r\n\r\n                b11[i][j] = B[i][j];\r\n                b12[i][j] = B[i][j + new_size];\r\n                b21[i][j] = B[i + new_size][j];\r\n                b22[i][j] = B[i + new_size][j + new_size];\r\n            }\r\n}\r\n\r\n// Calculating p1 to p7:\r\n\r\n        add(a11, a22, aResult, new_size);     // a11 + a22\r\n        add(b11, b22, bResult, new_size);    // b11 + b22\r\n        STRASSEN_algorithmA(aResult, bResult, p1, new_size); \r\n        // p1 = (a11+a22) * (b11+b22)\r\n\r\n        add(a21, a22, aResult, new_size); // a21 + a22\r\n        STRASSEN_algorithmA(aResult, b11, p2, new_size);\r\n        // p2 = (a21+a22) * (b11)\r\n\r\n        sub(b12, b22, bResult, new_size);      // b12 - b22\r\n        STRASSEN_algorithmA(a11, bResult, p3, new_size);\r\n        // p3 = (a11) * (b12 - b22)\r\n\r\n        sub(b21, b11, bResult, new_size);       // b21 - b11\r\n        STRASSEN_algorithmA(a22, bResult, p4, new_size); \r\n        // p4 = (a22) * (b21 - b11)\r\n\r\n        add(a11, a12, aResult, new_size);      // a11 + a12\r\n        STRASSEN_algorithmA(aResult, b22, p5, new_size);\r\n        // p5 = (a11+a12) * (b22)\r\n\r\n        sub(a21, a11, aResult, new_size);      // a21 - a11\r\n        add(b11, b12, bResult, new_size);               \r\n        // b11 + b12\r\n        STRASSEN_algorithmA(aResult, bResult, p6, new_size);\r\n        // p6 = (a21-a11) * (b11+b12)\r\n\r\n        sub(a12, a22, aResult, new_size);      // a12 - a22\r\n        add(b21, b22, bResult, new_size);                \r\n        // b21 + b22\r\n        STRASSEN_algorithmA(aResult, bResult, p7, new_size);\r\n        // p7 = (a12-a22) * (b21+b22)\r\n\r\n        // calculating c21, c21, c11 e c22:\r\n\r\n        add(p3, p5, c12, new_size); // c12 = p3 + p5\r\n        add(p2, p4, c21, new_size); // c21 = p2 + p4\r\n\r\n        add(p1, p4, aResult, new_size);       // p1 + p4\r\n        add(aResult, p7, bResult, new_size);  // p1 + p4 + p7\r\n        sub(bResult, p5, c11, new_size); // c11 = p1 + p4 - p5 + p7\r\n\r\n        add(p1, p3, aResult, new_size);       // p1 + p3\r\n        add(aResult, p6, bResult, new_size);  // p1 + p3 + p6\r\n        sub(bResult, p2, c22, new_size); // c22 = p1 + p3 - p2 + p6\r\n\r\n        // Grouping the results obtained in a single matrix:\r\n        for (i = 0; i < new_size; i++)\r\n        {\r\n            for (j = 0; j < new_size; j++)\r\n            {\r\n                C[i][j] = c11[i][j];\r\n                C[i][j + new_size] = c12[i][j];\r\n                C[i + new_size][j] = c21[i][j];\r\n                C[i + new_size][j + new_size] = c22[i][j];\r\n            }\r\n        }\r\n    }\r\n}\r\nvoid STRASSEN_algorithm(vector<vector<int>> &A, vector<vector<int>> &B, int m, int n, int a, int b)\r\n{  \r\n/* Check to see if these matrices are already square and have dimensions of a power of 2. If not,\r\n * the matrices must be resized and padded with zeroes to meet this criteria. */\r\n    int k = max({m, n, a, b});\r\n\r\n    int s = nextpowerof2(k);\r\n\r\n    vector<int> z(s);\r\n    vector<vector<int>> Aa(s, z), Bb(s, z), Cc(s, z);\r\n\r\n    for (unsigned int i = 0; i < m; i++)\r\n    {\r\n        for (unsigned int j = 0; j < n; j++)\r\n        {\r\n            Aa[i][j] = A[i][j];\r\n        }\r\n    }\r\n    for (unsigned int i = 0; i < a; i++)\r\n    {\r\n        for (unsigned int j = 0; j < b; j++)\r\n        {\r\n            Bb[i][j] = B[i][j];\r\n        }\r\n    }\r\n    STRASSEN_algorithmA(Aa, Bb, Cc, s);\r\n    vector<int> temp1(b);\r\n    vector<vector<int>> C(m, temp1);\r\n    for (unsigned int i = 0; i < m; i++)\r\n    {\r\n        for (unsigned int j = 0; j < b; j++)\r\n        {\r\n            C[i][j] = Cc[i][j];\r\n        }\r\n    }\r\n    display(C, m, b);\r\n}\r\n\r\nbool check(int n, int a)\r\n{\r\n    if (n == a)\r\n        return true;\r\n    else\r\n        return false;\r\n}\r\n\r\nint main()\r\n{\r\n     int m, n, a, b;\r\n   // cout << \"Matrix Multiplication using Strassen algorithm\" << endl;\r\n//    cout << \"Enter rows and columns of first matrix\" << endl;\r\n    cin >> m;\r\n    n=m;\r\n    //cout << \"enter values into first matrix\" << endl;\r\n    vector<vector<int>> A;\r\n    //first matrix input\r\n    for (int i = 0; i < m; i++)\r\n    {\r\n        vector<int> temp;\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            int i;\r\n            cin >> i;\r\n            temp.push_back(i);\r\n        }\r\n        A.push_back(temp);\r\n    }\r\n    //cout << \"Enter rows and columns of second matrix\" << endl;\r\n     a=m;\r\n    b=a;\r\n    // cout << \"enter values into second matrix\" << endl;\r\n    vector<vector<int>> B;\r\n    //second matrix input\r\n    for (int i = 0; i < a; i++)\r\n    {\r\n        vector<int> temp;\r\n        for (int j = 0; j < b; j++)\r\n        {\r\n            int i;\r\n            cin >> i;\r\n            temp.push_back(i);\r\n        }\r\n        B.push_back(temp);\r\n    }\r\n    bool k = check(n, a);\r\n    if (k)\r\n    {\r\n        STRASSEN_algorithm(A, B, m, n, a, b);\r\n    }\r\n    else\r\n    {\r\n        cout << \"martrix multiplication not possible\";\r\n    }\r\n    return 0;\r\n}\r\n\r\n', 0, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '', 'Strassen’s Matrix multiplication can be performed only on square matrices where n is a power of 2. Order of both of the matrices are n × n.\r\n\r\nDivide X, Y and Z into four (n/2)×(n/2) matrices as represented below −\r\n\r\nZ=[IKJL] X=[ACBD] and Y=[EGFH]\r\n\r\nUsing Strassen’s Algorithm compute the following −\r\n\r\nM1:=(A+C)×(E+F)\r\nM2:=(B+D)×(G+H)\r\nM3:=(A−D)×(E+H)\r\nM4:=A×(F−H)\r\nM5:=(C+D)×(E)\r\nM6:=(A+B)×(H)\r\nM7:=D×(G−E)\r\nThen,\r\n\r\nI:=M2+M3−M6−M7\r\nJ:=M4+M6\r\nK:=M5+M7\r\nL:=M1−M3−M4−M5\r\nAnalysis\r\nT(n)={c7xT(n2)+dxn2ifn=1otherwise where c and d are constants\r\n\r\nUsing this recurrence relation, we get T(n)=O(nlog7)\r\nHence, the complexity of Strassen’s matrix multiplication algorithm is O(nlog7).', '2020-05-25'),
(485, 5, 5701012018, '\r\n#include <iostream>\r\n#include <vector>\r\n#include <cmath>\r\n#include <algorithm>\r\nusing namespace std;\r\n\r\nint nextpowerof2(int k)\r\n{\r\n    return pow(2, int(ceil(log2(k))));\r\n}\r\nvoid display(vector< vector<int>> &matrix, int m, int n)\r\n{\r\n    for (int i = 0; i < m; i++)\r\n    {\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            cout << matrix[i][j]<<\" \";\r\n        }\r\n    }\r\n}\r\n\r\nvoid add(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\r\n{\r\n    int i, j;\r\n\r\n    for (i = 0; i < size; i++)\r\n    {\r\n        for (j = 0; j < size; j++)\r\n        {\r\n            C[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid sub(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\r\n{\r\n    int i, j;\r\n\r\n    for (i = 0; i < size; i++)\r\n    {\r\n        for (j = 0; j < size; j++)\r\n        {\r\n            C[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid STRASSEN_algorithmA(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\r\n{\r\n    //base case\r\n    if (size == 1)\r\n    {\r\n        C[0][0] = A[0][0] * B[0][0];\r\n        return;\r\n    }\r\n    else\r\n    {\r\n        int new_size = size / 2;\r\n        vector<int> z(new_size);\r\n        vector<vector<int>>\r\n            a11(new_size, z), a12(new_size, z), a21(new_size, z), a22(new_size, z),\r\n            b11(new_size, z), b12(new_size, z), b21(new_size, z), b22(new_size, z),\r\n            c11(new_size, z), c12(new_size, z), c21(new_size, z), c22(new_size, z),\r\n            p1(new_size, z), p2(new_size, z), p3(new_size, z), p4(new_size, z),\r\n            p5(new_size, z), p6(new_size, z), p7(new_size, z),\r\n            aResult(new_size, z), bResult(new_size, z);\r\n\r\nint i, j;\r\n\r\n//dividing the matrices into sub-matrices:\r\nfor (i = 0; i < new_size; i++)\r\n        {\r\n            for (j = 0; j < new_size; j++)\r\n            {\r\n                a11[i][j] = A[i][j];\r\n                a12[i][j] = A[i][j + new_size];\r\n                a21[i][j] = A[i + new_size][j];\r\n                a22[i][j] = A[i + new_size][j + new_size];\r\n\r\n                b11[i][j] = B[i][j];\r\n                b12[i][j] = B[i][j + new_size];\r\n                b21[i][j] = B[i + new_size][j];\r\n                b22[i][j] = B[i + new_size][j + new_size];\r\n            }\r\n}\r\n\r\n// Calculating p1 to p7:\r\n\r\n        add(a11, a22, aResult, new_size);     // a11 + a22\r\n        add(b11, b22, bResult, new_size);    // b11 + b22\r\n        STRASSEN_algorithmA(aResult, bResult, p1, new_size); \r\n        // p1 = (a11+a22) * (b11+b22)\r\n\r\n        add(a21, a22, aResult, new_size); // a21 + a22\r\n        STRASSEN_algorithmA(aResult, b11, p2, new_size);\r\n        // p2 = (a21+a22) * (b11)\r\n\r\n        sub(b12, b22, bResult, new_size);      // b12 - b22\r\n        STRASSEN_algorithmA(a11, bResult, p3, new_size);\r\n        // p3 = (a11) * (b12 - b22)\r\n\r\n        sub(b21, b11, bResult, new_size);       // b21 - b11\r\n        STRASSEN_algorithmA(a22, bResult, p4, new_size); \r\n        // p4 = (a22) * (b21 - b11)\r\n\r\n        add(a11, a12, aResult, new_size);      // a11 + a12\r\n        STRASSEN_algorithmA(aResult, b22, p5, new_size);\r\n        // p5 = (a11+a12) * (b22)\r\n\r\n        sub(a21, a11, aResult, new_size);      // a21 - a11\r\n        add(b11, b12, bResult, new_size);               \r\n        // b11 + b12\r\n        STRASSEN_algorithmA(aResult, bResult, p6, new_size);\r\n        // p6 = (a21-a11) * (b11+b12)\r\n\r\n        sub(a12, a22, aResult, new_size);      // a12 - a22\r\n        add(b21, b22, bResult, new_size);                \r\n        // b21 + b22\r\n        STRASSEN_algorithmA(aResult, bResult, p7, new_size);\r\n        // p7 = (a12-a22) * (b21+b22)\r\n\r\n        // calculating c21, c21, c11 e c22:\r\n\r\n        add(p3, p5, c12, new_size); // c12 = p3 + p5\r\n        add(p2, p4, c21, new_size); // c21 = p2 + p4\r\n\r\n        add(p1, p4, aResult, new_size);       // p1 + p4\r\n        add(aResult, p7, bResult, new_size);  // p1 + p4 + p7\r\n        sub(bResult, p5, c11, new_size); // c11 = p1 + p4 - p5 + p7\r\n\r\n        add(p1, p3, aResult, new_size);       // p1 + p3\r\n        add(aResult, p6, bResult, new_size);  // p1 + p3 + p6\r\n        sub(bResult, p2, c22, new_size); // c22 = p1 + p3 - p2 + p6\r\n\r\n        // Grouping the results obtained in a single matrix:\r\n        for (i = 0; i < new_size; i++)\r\n        {\r\n            for (j = 0; j < new_size; j++)\r\n            {\r\n                C[i][j] = c11[i][j];\r\n                C[i][j + new_size] = c12[i][j];\r\n                C[i + new_size][j] = c21[i][j];\r\n                C[i + new_size][j + new_size] = c22[i][j];\r\n            }\r\n        }\r\n    }\r\n}\r\nvoid STRASSEN_algorithm(vector<vector<int>> &A, vector<vector<int>> &B, int m, int n, int a, int b)\r\n{  \r\n/* Check to see if these matrices are already square and have dimensions of a power of 2. If not,\r\n * the matrices must be resized and padded with zeroes to meet this criteria. */\r\n    int k = max({m, n, a, b});\r\n\r\n    int s = nextpowerof2(k);\r\n\r\n    vector<int> z(s);\r\n    vector<vector<int>> Aa(s, z), Bb(s, z), Cc(s, z);\r\n\r\n    for (unsigned int i = 0; i < m; i++)\r\n    {\r\n        for (unsigned int j = 0; j < n; j++)\r\n        {\r\n            Aa[i][j] = A[i][j];\r\n        }\r\n    }\r\n    for (unsigned int i = 0; i < a; i++)\r\n    {\r\n        for (unsigned int j = 0; j < b; j++)\r\n        {\r\n            Bb[i][j] = B[i][j];\r\n        }\r\n    }\r\n    STRASSEN_algorithmA(Aa, Bb, Cc, s);\r\n    vector<int> temp1(b);\r\n    vector<vector<int>> C(m, temp1);\r\n    for (unsigned int i = 0; i < m; i++)\r\n    {\r\n        for (unsigned int j = 0; j < b; j++)\r\n        {\r\n            C[i][j] = Cc[i][j];\r\n        }\r\n    }\r\n    display(C, m, b);\r\n}\r\n\r\nbool check(int n, int a)\r\n{\r\n    if (n == a)\r\n        return true;\r\n    else\r\n        return false;\r\n}\r\n\r\nint main()\r\n{\r\n    int m, n, a, b;\r\n   // cout << \"Matrix Multiplication using Strassen algorithm\" << endl;\r\n//    cout << \"Enter rows and columns of first matrix\" << endl;\r\n    m= 3 ;\r\n    n=m;\r\n    //cout << \"enter values into first matrix\" << endl;\r\n    vector<vector<int>> A;\r\n    //first matrix input\r\n            vector<int> temp;\r\n             temp.push_back(1);\r\n             temp.push_back(0);\r\n            temp.push_back(0);\r\n            A.push_back(temp);\r\n\r\n            vector<int> temp1;\r\n             temp1.push_back(0);\r\n             temp1.push_back(1);\r\n            temp1.push_back(0);\r\n            A.push_back(temp1);\r\n\r\n\r\n            vector<int> temp2;\r\n             temp2.push_back(0);\r\n             temp2.push_back(0);\r\n            temp2.push_back(1);\r\n            A.push_back(temp2);\r\n\r\n    \r\n   // cout << \"Enter rows and columns of second matrix\" << endl;\r\n    //cin >> a ;\r\n    //b=a;\r\n    //cout << \"enter values into second matrix\" << endl;\r\n    a=m;\r\n    b=m;\r\n    vector<vector<int>> B;\r\n    //second matrix input\r\n   \r\n    \r\n            vector<int> temp11;\r\n             temp11.push_back(1);\r\n             temp11.push_back(0);\r\n            temp11.push_back(0);\r\n            B.push_back(temp11);\r\n\r\n            vector<int> temp22;\r\n             temp22.push_back(0);\r\n             temp22.push_back(1);\r\n            temp22.push_back(0);\r\n            B.push_back(temp22);\r\n\r\n\r\n            vector<int> temp33;\r\n             temp33.push_back(0);\r\n             temp33.push_back(0);\r\n            temp33.push_back(1);\r\n            B.push_back(temp33);\r\n\r\n\r\n    bool k = check(n, a);\r\n    if (k)\r\n    {\r\n        STRASSEN_algorithm(A, B, m, n, a, b);\r\n    }\r\n    else\r\n    {\r\n        cout << \"martrix multiplication not possible\";\r\n    }\r\n    return 0;\r\n}\r\n\r\n', 1000, '', '', 'Strassen’s Matrix multiplication can be performed only on square matrices where n is a power of 2. Order of both of the matrices are n × n.\r\n\r\nDivide X, Y and Z into four (n/2)×(n/2) matrices as represented below −\r\n\r\nZ=[IKJL] X=[ACBD] and Y=[EGFH]\r\n\r\nUsing Strassen’s Algorithm compute the following −\r\n\r\nM1:=(A+C)×(E+F)\r\nM2:=(B+D)×(G+H)\r\nM3:=(A−D)×(E+H)\r\nM4:=A×(F−H)\r\nM5:=(C+D)×(E)\r\nM6:=(A+B)×(H)\r\nM7:=D×(G−E)\r\nThen,\r\n\r\nI:=M2+M3−M6−M7\r\nJ:=M4+M6\r\nK:=M5+M7\r\nL:=M1−M3−M4−M5\r\nAnalysis\r\nT(n)={c7xT(n2)+dxn2ifn=1otherwise where c and d are constants\r\n\r\nUsing this recurrence relation, we get T(n)=O(nlog7)\r\nHence, the complexity of Strassen’s matrix multiplication algorithm is O(nlog7).', '2020-05-25');
INSERT INTO `qtos_map` (`ID`, `Q_ID`, `ROLL`, `SUBMISSION`, `SCORE`, `INPUT`, `OP`, `ALGO`, `DATE`) VALUES
(486, 16, 5701012018, '#include <iostream>\r\n#include <cstdio>\r\n#include <string>\r\nusing namespace std;\r\n\r\nvoid rabinKarp(string str, string pat) {\r\n    if (str.size() && pat.size()) {          \r\n        int n = str.size();\r\n        int m = pat.size();\r\n        int i, j;                               \r\n        int s = 0, p = 0;                        \r\n        const int pm = 256;                      \r\n        const int q = 101;                       \r\n        int h = 1;                               \r\n        bool flag = false;\r\n        for (i = 0; i < m-1; i++)\r\n            h = (h * pm) % q;\r\n        for (i = 0; i < m; i++) {\r\n            s = (pm * s + str[i]) % q;\r\n            p = (pm * p + pat[i]) % q;\r\n        }\r\n        for (i = 0; i <= n-m; i++) {\r\n            if (s == p) {                       \r\n                for (j = 0; j < m; j++)\r\n                    if (str[i+j] != pat[j])\r\n                        break;\r\n                if (j == m) {\r\n                    cout<<\"Pattern found at index \"<<i+1<<endl;\r\n                    flag = true;\r\n                }\r\n            }\r\n            s = (pm * (s - h * str[i]) + str[i+m]) % q;\r\n            if (s < 0)         \r\n                s = s + q;\r\n        }\r\n        if (!flag)\r\n            cout<<\"Pattern not found..\"<<endl;\r\n        return;\r\n    }\r\n    cout<<\"Text or pattern cannot be empty..\"<<endl;\r\n    return;\r\n}\r\n\r\nint main() {\r\n    string str, pat;\r\n    getline(cin, str);\r\n    getline(cin, pat);\r\n    rabinKarp(str, pat);\r\n    return 0;\r\n}\r\n', 1000, '', '', 'Algorithm\r\n\r\nRABIN-KARP-MATCHER (T, P, d, q)\r\n 1. n ← length [T]\r\n 2. m  ← length [P]\r\n 3. h  ←  dm-1 mod q\r\n 4. p ←  0\r\n 5. t0 ←  0\r\n 6. for i ← 1 to m\r\n 7. do p ←  (dp + P[i]) mod q\r\n 8. t0 ← (dt0+T [i]) mod q\r\n 9. for s  ←  0 to n-m\r\n 10. do if p = ts\r\n 11. then if P [1.....m] = T [s+1.....s + m]\r\n 12. then \"Pattern occurs with shift\" s\r\n 13. If s < n-m\r\n 14. then ts+1 ←  (d (ts-T [s+1]h)+T [s+m+1])mod q', '2020-05-25'),
(487, 3, 5801012018, '#include<stdio.h> \r\n  \r\nvoid swap(int* a, int* b) \r\n{ \r\n    int t = *a; \r\n    *a = *b; \r\n    *b = t; \r\n} \r\n  \r\nint partition (int arr[], int low, int high) \r\n{ \r\n    int pivot = arr[high];     \r\n    int i = (low - 1);  \r\n  \r\n    for (int j = low; j <= high- 1; j++) \r\n    { \r\n        if (arr[j] < pivot) \r\n        { \r\n            i++;    \r\n            swap(&arr[i], &arr[j]); \r\n        } \r\n    } \r\n    swap(&arr[i + 1], &arr[high]); \r\n    return (i + 1); \r\n} \r\n  \r\nvoid quickSort(int arr[], int low, int high) \r\n{ \r\n    if (low < high) \r\n    { \r\n        int pi = partition(arr, low, high); \r\n  \r\n        quickSort(arr, low, pi - 1); \r\n        quickSort(arr, pi + 1, high); \r\n    } \r\n} \r\n  \r\nvoid printArray(int arr[], int size) \r\n{ \r\n    int i; \r\n    for (i=0; i < size; i++) \r\n        printf(\"%d \", arr[i]); \r\n} \r\n  \r\nint main() \r\n{  \r\n    int n;\r\n    scanf(\"%d\",&n);\r\n    int i,arr[n];\r\n    for(i=0;i<n;i++)\r\n        scanf(\"%d\",&arr[i]); \r\n    quickSort(arr, 0, n-1);  \r\n    printArray(arr, n); \r\n    return 0; \r\n}', 10, '1 2000', '2000 ', 'quickSort(array, leftmostIndex, rightmostIndex)\r\n  if (leftmostIndex < rightmostIndex)\r\n    pivotIndex <- partition(array,leftmostIndex, rightmostIndex)\r\n    quickSort(array, leftmostIndex, pivotIndex)\r\n    quickSort(array, pivotIndex + 1, rightmostIndex)\r\n\r\npartition(array, leftmostIndex, rightmostIndex)\r\n  set rightmostIndex as pivotIndex\r\n  storeIndex <- leftmostIndex - 1\r\n  for i <- leftmostIndex + 1 to rightmostIndex\r\n  if element[i] < pivotElement\r\n    swap element[i] and element[storeIndex]\r\n    storeIndex++\r\n  swap pivotElement and element[storeIndex+1]\r\nreturn storeIndex + 1', '2020-05-25'),
(488, 7, 5801012018, '#include <cstdlib> \r\n#include <stdio.h>\r\n#include <iostream> \r\nusing namespace std; \r\n  \r\nint partition(int arr[], int start, int end) \r\n{ \r\n    int pivot = arr[end]; \r\n    int i = (start - 1); \r\n  \r\n    for (int j = start; j <= end - 1; j++) { \r\n  \r\n        if (arr[j] <= pivot) { \r\n  \r\n            i++; \r\n            swap(arr[i], arr[j]); \r\n        } \r\n    } \r\n    swap(arr[i + 1], arr[end]); \r\n    return (i + 1); \r\n} \r\n  \r\nint random_partition(int arr[], int start, int end) \r\n{ \r\n   \r\n    int random = start + rand() % (end - start); \r\n  \r\n    swap(arr[random], arr[end]); \r\n  \r\n    return partition(arr, start, end); \r\n} \r\n  \r\nvoid quickSort(int arr[], int start, int end) \r\n{ \r\n    if (start < end) { \r\n  \r\n        int pi = random_partition(arr, start, end); \r\n  \r\n        quickSort(arr, start, pi - 1); \r\n        quickSort(arr, pi + 1, end); \r\n    } \r\n} \r\n  \r\nvoid printArray(int arr[], int size) \r\n{ \r\n    for (int i = 0; i < size; i++){ \r\n 	 cout<<arr[i]<<endl; \r\n    }\r\n   \r\n} \r\n  \r\nint main() \r\n{ \r\n    \r\n    int n;\r\n    cin >> n; \r\n    int arr[n];\r\n    for (int i = 0; i < n; ++i){\r\n	 cin >> arr[i];\r\n    }\r\n    quickSort(arr, 0, n - 1); \r\n    printArray(arr, n);   \r\n} ', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0\n1\n4\n5\n6\n6\n8\n8\n8\n9\n9\n1000\n14000\n', 'partition(arr[], lo, hi) \r\n    pivot = arr[hi]\r\n    i = lo     // place for swapping\r\n    for j := lo to hi – 1 do\r\n        if arr[j] <= pivot then\r\n            swap arr[i] with arr[j]\r\n            i = i + 1\r\n    swap arr[i] with arr[hi]\r\n    return i\r\n\r\npartition_r(arr[], lo, hi)\r\n    r = Random Number from lo to hi\r\n    Swap arr[r] and arr[hi]\r\n    return partition(arr, lo, hi)\r\n\r\nquicksort(arr[], lo, hi)\r\n    if lo < hi\r\n        p = partition_r(arr, lo, hi)\r\n        quicksort(arr, p-1, hi)\r\n        quicksort(arr, p+1, hi)\r\n ', '2020-05-25'),
(489, 9, 5801012018, '#include <iostream>\r\nusing namespace std;\r\nclass DisjSet {\r\n	int *rank, *parent, n;\r\n\r\npublic:\r\n	DisjSet(int n)\r\n	{\r\n		rank = new int[n];\r\n		parent = new int[n];\r\n		this->n = n;\r\n		makeSet();\r\n	}\r\n\r\n	void makeSet()\r\n	{\r\n		for (int i = 0; i < n; i++) {\r\n			parent[i] = i;\r\n		}\r\n	}\r\n\r\n	int find(int x)\r\n	{\r\n		if (parent[x] != x) {\r\n\r\n			parent[x] = find(parent[x]);\r\n		}\r\n\r\n		return parent[x];\r\n	}\r\n\r\n	void Union(int x, int y)\r\n	{\r\n		int xset = find(x);\r\n		int yset = find(y);\r\n\r\n		if (xset == yset)\r\n			return;\r\n\r\n		if (rank[xset] < rank[yset]) {\r\n			parent[xset] = yset;\r\n		}\r\n		else if (rank[xset] > rank[yset]) {\r\n			parent[yset] = xset;\r\n		}\r\n		else {\r\n			parent[yset] = xset;\r\n			rank[xset] = rank[xset] + 1;\r\n		}\r\n	}\r\n};\r\n\r\nint main()\r\n{\r\n	DisjSet obj(5);\r\n    obj.Union(0, 2);\r\n    obj.Union(4, 2);\r\n    obj.Union(3, 1);\r\n    if (obj.find(4) == obj.find(0))\r\n        cout << \"Yes\n\";\r\n    else\r\n        cout << \"No\n\";\r\n    if (obj.find(1) == obj.find(0))\r\n        cout << \"Yes\n\";\r\n    else\r\n        cout << \"No\n\";\r\n\r\n    return 0;\r\n}\r\n', 1000, '', '', 'Begin\r\n   Assume k is the element\r\n   makeset(k):\r\n      k.parent = k.\r\n   Find(x):\r\n   If k.parent == k\r\n      return k.\r\n   else\r\n   return Find(k.parent)\r\n   Union (a,b):\r\n      Take two set a and b as input.\r\n      aroot = Find(a)\r\n      broot = Find(b)\r\n      aroot.parent = broot\r\nEnd', '2020-05-25'),
(490, 10, 5801012018, 'import java.io.*;\r\nimport java.util.*;\r\n\r\npublic class Main {\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        Scanner scn = new Scanner(System.in);\r\n        int n = scn.nextInt();\r\n	int cap = scn.nextInt();\r\n        int[] weight = new int[n];\r\n        int[] price = new int[n];\r\n        for (int i = 0; i < n; i++) {\r\n            price[i] = scn.nextInt();\r\n        }\r\n        for (int i = 0; i < n; i++) {\r\n            weight[i] = scn.nextInt();\r\n        }      \r\n        System.out.println(knapsack(weight, price, cap));\r\n    }\r\n\r\n    public static int knapsack(int[] weight, int[] price, int cap) {\r\n        int[][] dp = new int[price.length][cap + 1];\r\n        \r\n        for (int i = 0; i < dp[0].length; i++) {\r\n            if (weight[0] <= cap && i >= weight[0]) {\r\n                dp[0][i] = price[0];\r\n            }\r\n        }\r\n        for (int i = 1; i < dp.length; i++) {\r\n            for (int j = 1; j < dp[0].length; j++) {\r\n                int val = weight[i];\r\n                if (j - val >= 0) {\r\n                    dp[i][j] = Math.max(dp[i - 1][j], price[i] + dp[i - 1][j - val]);\r\n                } else {\r\n                    dp[i][j] = dp[i - 1][j];\r\n                }\r\n            }\r\n        }\r\n        return dp[dp.length-1][dp[0].length-1];\r\n    }\r\n}', 0, '5 15 4 2 1 2 10 12 2 1 1 4', '15\n', '??G\0r\0e\0e\0d\0y\0-\0F\0r\0a\0c\0t\0i\0o\0n\0a\0l\0-\0K\0n\0a\0p\0s\0a\0c\0k\0 \0(\0w\0[\01\0.\0.\0n\0]\0,\0 \0p\0[\01\0.\0.\0n\0]\0,\0 \0W\0)\0 \0\r\0\n\0f\0o\0r\0 \0i\0 \0=\0 \01\0 \0t\0o\0 \0n\0 \0\r\0\n\0 \0 \0 \0d\0o\0 \0x\0[\0i\0]\0 \0=\0 \00\0 \0\r\0\n\0w\0e\0i\0g\0h\0t\0 \0=\0 \00\0 \0\r\0\n\0f\0o\0r\0 \0i\0 \0=\0 \01\0 \0t\0o\0 \0n\0 \0\r\0\n\0 \0 \0 \0i\0f\0 \0w\0e\0i\0g\0h\0t\0 \0+\0 \0w\0[\0i\0]\0 \0d\" \0W\0 \0t\0h\0e\0n\0 \0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0x\0[\0i\0]\0 \0=\0 \01\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0w\0e\0i\0g\0h\0t\0 \0=\0 \0w\0e\0i\0g\0h\0t\0 \0+\0 \0w\0[\0i\0]\0 \0\r\0\n\0 \0 \0 \0e\0l\0s\0e\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0x\0[\0i\0]\0 \0=\0 \0(\0W\0 \0-\0 \0w\0e\0i\0g\0h\0t\0)\0 \0/\0 \0w\0[\0i\0]\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0w\0e\0i\0g\0h\0t\0 \0=\0 \0W\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0b\0r\0e\0a\0k\0 \0\r\0\n\0r\0e\0t\0u\0r\0n\0 \0x\0', '2020-05-25'),
(491, 12, 5801012018, '#include<iostream>\r\n#include<algorithm>\r\nusing namespace std;\r\n\r\nclass Edge\r\n{\r\n	public:\r\n	int source;\r\n	int dest;\r\n	int weight;\r\n};\r\n\r\nbool compare(Edge e1,Edge e2){\r\n    return e1.weight< e2.weight;\r\n}\r\nint findParent(int v,int *parent){\r\n    if(parent[v]==v){\r\n        return v;\r\n    }\r\n    return findParent(parent[v],parent);\r\n}\r\nvoid Kruskals(Edge *input,int n,int E){\r\n    sort(input,input+E,compare);\r\n    Edge *output=new Edge[n-1];\r\n    int *parent= new int[n];\r\n    for(int i=0;i<n;i++){\r\n        parent[i]=i;\r\n    }\r\n    int count=0;\r\n    int i=0;\r\n    while(count!=n-1){\r\n        Edge currentEdge = input[i];\r\n        int sourceParent = findParent(currentEdge.source,parent);\r\n        int destParent = findParent(currentEdge.dest,parent);\r\n\r\n        if(sourceParent!=destParent){\r\n            output[count]=currentEdge;\r\n            count++;\r\n            parent[sourceParent]=destParent;\r\n        }\r\n        i++;\r\n    }\r\n    for(int i=0;i<n-1;i++){\r\n        if(output[i].source<output[i].dest){\r\n            cout<<output[i].source<<\"---\"<<output[i].dest<<\"==>\"<<output[i].weight<<\" \";\r\n        }else{\r\n            cout<<output[i].dest<<\"---\"<<output[i].source<<\"==>\"<<output[i].weight<<\" \";\r\n        }\r\n    }\r\n}\r\n\r\nint main(){\r\n    int n=4;\r\n    int E=4;\r\n    Edge *input=new Edge[E];\r\n        input[0].source=0;\r\n        input[0].dest=1;\r\n        input[0].weight=3;\r\n        input[1].source=0;\r\n        input[1].dest=3;\r\n        input[1].weight=5;\r\n        input[2].source=1;\r\n        input[2].dest=2;\r\n        input[2].weight=1;\r\n        input[3].source=2;\r\n        input[3].dest=3;\r\n        input[3].weight=8;\r\n    Kruskals(input,n,E);\r\n}\r\n', 1000, '', '', '??G\0r\0e\0e\0d\0y\0-\0F\0r\0a\0c\0t\0i\0o\0n\0a\0l\0-\0K\0n\0a\0p\0s\0a\0c\0k\0 \0(\0w\0[\01\0.\0.\0n\0]\0,\0 \0p\0[\01\0.\0.\0n\0]\0,\0 \0W\0)\0 \0\r\0\n\0f\0o\0r\0 \0i\0 \0=\0 \01\0 \0t\0o\0 \0n\0 \0\r\0\n\0 \0 \0 \0d\0o\0 \0x\0[\0i\0]\0 \0=\0 \00\0 \0\r\0\n\0w\0e\0i\0g\0h\0t\0 \0=\0 \00\0 \0\r\0\n\0f\0o\0r\0 \0i\0 \0=\0 \01\0 \0t\0o\0 \0n\0 \0\r\0\n\0 \0 \0 \0i\0f\0 \0w\0e\0i\0g\0h\0t\0 \0+\0 \0w\0[\0i\0]\0 \0d\" \0W\0 \0t\0h\0e\0n\0 \0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0x\0[\0i\0]\0 \0=\0 \01\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0w\0e\0i\0g\0h\0t\0 \0=\0 \0w\0e\0i\0g\0h\0t\0 \0+\0 \0w\0[\0i\0]\0 \0\r\0\n\0 \0 \0 \0e\0l\0s\0e\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0x\0[\0i\0]\0 \0=\0 \0(\0W\0 \0-\0 \0w\0e\0i\0g\0h\0t\0)\0 \0/\0 \0w\0[\0i\0]\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0w\0e\0i\0g\0h\0t\0 \0=\0 \0W\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0b\0r\0e\0a\0k\0 \0\r\0\n\0r\0e\0t\0u\0r\0n\0 \0x\0', '2020-05-25'),
(492, 13, 5801012018, '#include <iostream>\r\n#include <vector>\r\n#include <queue>\r\n#include <functional>\r\n#include <utility>\r\n\r\nusing namespace std;\r\nconst int MAX = 1e4 + 5;\r\ntypedef pair<long long, int> PII;\r\nbool marked[MAX];\r\nvector <PII> adj[MAX];\r\n\r\nlong long prim(int x)\r\n{\r\n    priority_queue<PII, vector<PII>, greater<PII> > Q;\r\n    int y;\r\n    long long minimumCost = 0;\r\n    PII p;\r\n    Q.push(make_pair(0, x));\r\n    while(!Q.empty())\r\n    {\r\n        p = Q.top();\r\n        Q.pop();\r\n        x = p.second;\r\n        if(marked[x] == true)\r\n            continue;\r\n        minimumCost += p.first;\r\n        marked[x] = true;\r\n        for(int i = 0;i < adj[x].size();++i)\r\n        {\r\n            y = adj[x][i].second;\r\n            if(marked[y] == false)\r\n                Q.push(adj[x][i]);\r\n        }\r\n    }\r\n    return minimumCost;\r\n}\r\n\r\nint main()\r\n{\r\n    int nodes, edges, x, y;\r\n    long long weight, minimumCost;\r\n    cin >> nodes >> edges;\r\n    for(int i = 0;i < edges;++i)\r\n    {\r\n        cin >> x >> y >> weight;\r\n        adj[x].push_back(make_pair(weight, y));\r\n        adj[y].push_back(make_pair(weight, x));\r\n    }\r\n    minimumCost = prim(1);\r\n    cout << minimumCost << endl;\r\n    return 0;\r\n}', 1000, '', '', 'Algorithm\r\n1) Create a set mstSet that keeps track of vertices already included in MST.\r\n2) Assign a key value to all vertices in the input graph. Initialize all key values as INFINITE. Assign key value as 0 for the first vertex so that it is picked first.\r\n3) While mstSet doesn’t include all vertices\r\n….a) Pick a vertex u which is not there in mstSet and has minimum key value.\r\n….b) Include u to mstSet.\r\n….c) Update key value of all adjacent vertices of u. To update the key values, iterate through all adjacent vertices. For every adjacent vertex v, if weight of edge u-v is less than the previous key value of v, update the key value as weight of u-v', '2020-05-25'),
(493, 14, 5801012018, '#include<iostream>\r\n#include<conio.h>\r\n#include<stdio.h>\r\nstruct Edge {\r\n    int src, dest, weight;\r\n};\r\n\r\nstruct Graph\r\n{\r\n    int V, E;\r\n    struct Edge* edge;\r\n};\r\nstruct Graph* createGraph(int V, int E)\r\n{\r\n    struct Graph* graph = new Graph;\r\n    graph->V = V;\r\n    graph->E = E;\r\n    graph->edge = new Edge[E];\r\n    return graph;\r\n}\r\nvoid printArr(int dist[], int n)\r\n{\r\n    for (int i = 0; i < n; ++i)\r\n        printf(\"%d %d \", i, dist[i]);\r\n}\r\n\r\nvoid BellmanFord(struct Graph* graph, int src)\r\n{\r\n    int V = graph->V;\r\n    int E = graph->E;\r\n    int dist[V];\r\n\r\n    for (int i = 0; i < V; i++)\r\n        dist[i] = INT_MAX;\r\n    dist[src] = 0;\r\n\r\n    for (int i = 1; i <= V - 1; i++) {\r\n        for (int j = 0; j < E; j++) {\r\n            int u = graph->edge[j].src;\r\n            int v = graph->edge[j].dest;\r\n            int weight = graph->edge[j].weight;\r\n            if (dist[u] != INT_MAX && dist[u] + weight < dist[v])\r\n                dist[v] = dist[u] + weight;\r\n        }\r\n    }\r\n     for (int i = 0; i < E; i++) {\r\n        int u = graph->edge[i].src;\r\n        int v = graph->edge[i].dest;\r\n        int weight = graph->edge[i].weight;\r\n        if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {\r\n            printf(\"Graph contains negative weight cycle\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printArr(dist, V);\r\n\r\n    return;\r\n}\r\n\r\nint main()\r\n{\r\n    int V = 5;\r\n    int E = 8;\r\n    struct Graph* graph = createGraph(V, E);\r\n\r\n\r\n    graph->edge[0].src = 0;\r\n    graph->edge[0].dest = 1;\r\n    graph->edge[0].weight = -1;\r\n\r\n\r\n    graph->edge[1].src = 0;\r\n    graph->edge[1].dest = 2;\r\n    graph->edge[1].weight = 4;\r\n\r\n\r\n    graph->edge[2].src = 1;\r\n    graph->edge[2].dest = 2;\r\n    graph->edge[2].weight = 3;\r\n\r\n\r\n    graph->edge[3].src = 1;\r\n    graph->edge[3].dest = 3;\r\n    graph->edge[3].weight = 2;\r\n\r\n\r\n    graph->edge[4].src = 1;\r\n    graph->edge[4].dest = 4;\r\n    graph->edge[4].weight = 2;\r\n\r\n\r\n    graph->edge[5].src = 3;\r\n    graph->edge[5].dest = 2;\r\n    graph->edge[5].weight = 5;\r\n\r\n\r\n    graph->edge[6].src = 3;\r\n    graph->edge[6].dest = 1;\r\n    graph->edge[6].weight = 1;\r\n\r\n\r\n    graph->edge[7].src = 4;\r\n    graph->edge[7].dest = 3;\r\n    graph->edge[7].weight = -3;\r\n\r\n    BellmanFord(graph, 0);\r\n\r\n    return 0;\r\n}\r\n', 1000, '', '', 'Algorithm\r\nFollowing are the detailed steps.\r\n\r\nInput: Graph and a source vertex src\r\nOutput: Shortest distance to all vertices from src. If there is a negative weight cycle, then shortest distances are not calculated, negative weight cycle is reported.\r\n\r\n\r\n\r\n\r\n1) This step initializes distances from source to all vertices as infinite and distance to source itself as 0. Create an array dist[] of size |V| with all values as infinite except dist[src] where src is source vertex.\r\n\r\n2) This step calculates shortest distances. Do following |V|-1 times where |V| is the number of vertices in given graph.\r\n…..a) Do following for each edge u-v\r\n………………If dist[v] > dist[u] + weight of edge uv, then update dist[v]\r\n………………….dist[v] = dist[u] + weight of edge uv\r\n\r\n3) This step reports if there is a negative weight cycle in graph. Do following for each edge u-v\r\n……If dist[v] > dist[u] + weight of edge uv, then “Graph contains negative weight cycle”\r\nThe idea of step 3 is, step 2 guarantees shortest distances if graph doesn’t contain negative weight cycle. If we iterate through all edges one more time and get a shorter path for any vertex, then there is a negative weight cycle', '2020-05-25'),
(494, 15, 5801012018, '#include<iostream>\r\nusing namespace std;\r\n\r\nint matrix_chain(int array[], int n) {\r\n   int minMul[n][n];\r\n   for (int i=1; i<n; i++)\r\n      minMul[i][i] = 0;\r\n\r\n   for (int length=2; length<n; length++) {\r\n      for (int i=1; i<n-length+1; i++) {\r\n         int j = i+length-1;\r\n         minMul[i][j] = INT_MAX;\r\n         for (int k=i; k<=j-1; k++) {\r\n            int q = minMul[i][k] + minMul[k+1][j] + array[i- 1]*array[k]*array[j];\r\n            if (q < minMul[i][j])\r\n               minMul[i][j] = q;\r\n         }\r\n        }\r\n   }\r\n   return minMul[1][n-1];\r\n}\r\n\r\nint main() {\r\n    int n;\r\n    cin>>n;\r\n    int arr[n];\r\n    for(int i=0;i<n;i++){\r\n        cin>>arr[i];\r\n    }\r\n   cout <<matrix_chain(arr, n);\r\n}\r\n', 1000, '', '', 'Algorithm of Matrix Chain Multiplication\r\nMATRIX-CHAIN-ORDER (p)\r\n\r\n\r\n 1. n   length[p]-1\r\n 2. for i ← 1 to n\r\n 3. do m [i, i] ← 0\r\n 4. for l ← 2 to n    // l is the chain length\r\n 5. do for i ← 1 to n-l + 1\r\n 6. do j ← i+ l -1\r\n 7. m[i,j] ←  ∞\r\n 8. for k  ← i to j-1\r\n 9. do q  ← m [i, k] + m [k + 1, j] + pi-1 pk pj	\r\n 10. If q < m [i,j]\r\n 11. then m [i,j] ← q\r\n 12. s [i,j] ← k\r\n 13. return m and s.  ', '2020-05-25'),
(495, 4, 5801012018, '#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nclass Pair{\r\npublic:\r\n	int min;\r\n	int max;\r\n};\r\n\r\nPair MaxMin(int arr[], int start, int end){\r\n	Pair mxMn;\r\n	if (end == start){\r\n		mxMn.min = arr[start];\r\n		mxMn.max = arr[start];\r\n		return mxMn;\r\n	}\r\n\r\n	if (end - start == 1){\r\n		if (arr[start] < arr[end]){\r\n			mxMn.min = arr[start];\r\n			mxMn.max = arr[end];\r\n		}\r\n		else {\r\n			mxMn.min = arr[end];\r\n			mxMn.max = arr[start];\r\n		}\r\n		return mxMn;\r\n	}\r\n\r\n	int mid = (start + end) / 2;\r\n\r\n	Pair ml = MaxMin(arr, start, mid);\r\n	Pair mr = MaxMin(arr, mid + 1, end);\r\n\r\n	if (ml.min > mr.min) mxMn.min = mr.min;\r\n	else mxMn.min = ml.min;\r\n\r\n	if (ml.max > mr.max) mxMn.max = ml.max;\r\n	else mxMn.max = mr.max;\r\n	return mxMn;\r\n}\r\n\r\nint main(){\r\n	int n=6;\r\n	int arr[] = {10, 37, 194, 365, 82, 55};\r\n	Pair mxMn = MaxMin(arr, 0, n - 1);\r\n	cout << mxMn.min << \" \" << mxMn.max;\r\n}\r\n', 0, '6 1000 11 445 1 330 3000', '10 365', 'Algorithm: Max-Min-Element (numbers[]) \r\nmax := numbers[1] \r\nmin := numbers[1] \r\n\r\nfor i = 2 to n do \r\n   if numbers[i] > max then  \r\n      max := numbers[i] \r\n   if numbers[i] < min then  \r\n      min := numbers[i] \r\nreturn (max, min) ', '2020-05-25'),
(496, 8, 5801012018, '#include<bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nconst int N = 10000 + 5;\r\n\r\nint A[N][N];\r\nint B[N][N];\r\nint D[N][N];\r\n\r\nvoid matrix_multiply(int n){\r\n	for(int i=0;i<n;i++){\r\n		for(int j=0;j<n;j++){\r\n			D[i][j] = 0;\r\n			for(int k=0;k<n;k++)\r\n				D[i][j] += A[i][k]*B[k][j];\r\n				cout << D[i][j] << \" \";\r\n		}\r\n\r\n	}\r\n}\r\n\r\nstruct matrix{\r\n	int k;\r\n	vector<vector<int> > mat;\r\n\r\n	matrix(int sz){\r\n		k=sz;\r\n		mat.resize(sz);\r\n		for(int i=0;i<sz;i++)\r\n			mat[i].resize(sz);\r\n	}\r\n\r\n	matrix operator + (const matrix &o){\r\n        matrix res(k);\r\n        for(int i=0;i<k;i++){\r\n        	for(int j=0;j<k;j++)\r\n	        	res.mat[i][j]=o.mat[i][j] + mat[i][j];\r\n	    }\r\n        return res;\r\n    }\r\n\r\n    matrix operator - (const matrix &o){\r\n        matrix res(k);\r\n        for(int i=0;i<k;i++){\r\n        	for(int j=0;j<k;j++)\r\n	        	res.mat[i][j]= mat[i][j] - o.mat[i][j];\r\n	    }\r\n        return res;\r\n    }\r\n\r\n	void print(){\r\n		for(int i=0;i<k;i++){\r\n			for(int j=0;j<k;j++){\r\n				cout<<mat[i][j]<<\" \";\r\n			}\r\n\r\n		}\r\n	}\r\n};\r\n\r\nmatrix multiply(matrix A, matrix B, int n){\r\n	if(n==2){\r\n		matrix res(2);\r\n		res.mat[0][0] = A.mat[0][0]*B.mat[0][0] + A.mat[0][1]*B.mat[1][0];\r\n		res.mat[0][1] = A.mat[0][0]*B.mat[0][1] + A.mat[0][1]*B.mat[1][1];\r\n		res.mat[1][0] = A.mat[1][0]*B.mat[0][0] + A.mat[1][1]*B.mat[1][0];\r\n		res.mat[1][1] = A.mat[1][0]*B.mat[0][1] + A.mat[1][1]*B.mat[1][1];\r\n		return res;\r\n	}\r\n	if(n==1){\r\n		matrix res(1);\r\n		res.mat[0][0] = A.mat[0][0]*B.mat[0][0];\r\n		return res;\r\n	}\r\n	int h = n/2;\r\n	matrix A00(h), A01(h), A10(h), A11(h);\r\n	matrix B00(h), B01(h), B10(h), B11(h);\r\n	matrix C00(h), C01(h), C10(h), C11(h);\r\n	for(int i=0;i<h;i++){\r\n		for(int j=0;j<h;j++)\r\n		{\r\n			A00.mat[i][j] = A.mat[i][j];\r\n			B00.mat[i][j] = B.mat[i][j];\r\n			A01.mat[i][j] = A.mat[i][j+h];\r\n			B01.mat[i][j] = B.mat[i][j+h];\r\n			A10.mat[i][j] = A.mat[i+h][j];\r\n			B10.mat[i][j] = B.mat[i+h][j];\r\n			A11.mat[i][j] = A.mat[i+h][j+h];\r\n			B11.mat[i][j] = B.mat[i+h][j+h];\r\n		}\r\n	}\r\n	matrix M1(h), M2(h), M3(h), M4(h), M5(h), M6(h), M7(h);\r\n	M1 = multiply(A00 + A11, (B00 + B11), h);\r\n	M2 = multiply(A10 +  A11, B00, h);\r\n	M3 = multiply(A00, B01 - B11, h);\r\n	M4 = multiply(A11, B10 - B00, h);\r\n	M5 = multiply(A00 + A01, B11, h);\r\n	M6 = multiply(A10 - A00, B00 + B01, h);\r\n	M7 = multiply(A01 - A11, B10 + B11, h);\r\n	C00 = M1 + M4 - M5 + M7;\r\n	C01 = M3 + M5;\r\n	C10 = M2 + M4;\r\n	C11 = M1 - M2 + M3 + M6;\r\n	matrix C(n);\r\n	for(int i=0;i<h;i++){\r\n		for(int j=0;j<h;j++){\r\n			C.mat[i][j] = C00.mat[i][j];\r\n			C.mat[i][j+h] = C01.mat[i][j];\r\n			C.mat[i+h][j] = C10.mat[i][j];\r\n			C.mat[i+h][j+h] = C11.mat[i][j];\r\n		}\r\n	}\r\n	return C;\r\n}\r\n\r\nint main(){\r\n		int n;\r\n		cin>>n;\r\n		matrix E(n), F(n);\r\n		for(int i=0;i<n;i++){\r\n			for(int j=0;j<n;j++){\r\n				cin>>A[i][j];\r\n				E.mat[i][j] = A[i][j];\r\n			}\r\n		}\r\n		cout<<endl;\r\n		for(int i=0;i<n;i++){\r\n			for(int j=0;j<n;j++){\r\n				cin>>B[i][j];\r\n				F.mat[i][j] = B[i][j];\r\n			}\r\n		}\r\n\r\n\r\n		matrix_multiply(n);\r\n		cout<<endl;\r\n\r\n}\r\n', 0, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '\n-17 -4 -7 10 2 11 40 92 107 \n', 'void multiply(int A[][N], int B[][N], int C[][N]) \r\n{ \r\n    for (int i = 0; i < N; i++) \r\n    { \r\n        for (int j = 0; j < N; j++) \r\n        { \r\n            C[i][j] = 0; \r\n            for (int k = 0; k < N; k++) \r\n            { \r\n                C[i][j] += A[i][k]*B[k][j]; \r\n            } \r\n        } \r\n    } \r\n} ', '2020-05-25'),
(497, 5, 5801012018, '#include<iostream>\r\n#include<conio.h>\r\n#include<stdio.h>\r\nusing namespace std; \r\ntypedef long long lld; \r\ninline lld** MatrixMultiply(lld** a, lld** b, int n, \r\n                                      int l, int m) \r\n{ \r\n    lld** c = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        c[i] = new lld[m]; \r\n  \r\n    for (int i = 0; i < n; i++) { \r\n        for (int j = 0; j < m; j++) { \r\n            c[i][j] = 0; \r\n            for (int k = 0; k < l; k++) { \r\n                c[i][j] += a[i][k] * b[k][j]; \r\n            } \r\n        } \r\n    } \r\n    return c; \r\n} \r\n  \r\ninline lld** Strassen(lld** a, lld** b, int n,  \r\n                                int l, int m) \r\n{ \r\n    if (n == 1 || l == 1 || m == 1)  \r\n        return MatrixMultiply(a, b, n, l, m); \r\n  \r\n    lld** c = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        c[i] = new lld[m]; \r\n  \r\n    int adjN = (n >> 1) + (n & 1); \r\n    int adjL = (l >> 1) + (l & 1); \r\n    int adjM = (m >> 1) + (m & 1); \r\n  \r\n    lld**** As = new lld***[2]; \r\n    for (int x = 0; x < 2; x++) { \r\n        As[x] = new lld**[2]; \r\n        for (int y = 0; y < 2; y++) { \r\n            As[x][y] = new lld*[adjN]; \r\n            for (int i = 0; i < adjN; i++) { \r\n                As[x][y][i] = new lld[adjL]; \r\n                for (int j = 0; j < adjL; j++) { \r\n                    int I = i + (x & 1) * adjN; \r\n                    int J = j + (y & 1) * adjL; \r\n                    As[x][y][i][j] = (I < n && J < l) ? a[I][J] : 0; \r\n                } \r\n            } \r\n        } \r\n    } \r\n  \r\n    lld**** Bs = new lld***[2]; \r\n    for (int x = 0; x < 2; x++) { \r\n        Bs[x] = new lld**[2]; \r\n        for (int y = 0; y < 2; y++) { \r\n            Bs[x][y] = new lld*[adjN]; \r\n            for (int i = 0; i < adjL; i++) { \r\n                Bs[x][y][i] = new lld[adjM]; \r\n                for (int j = 0; j < adjM; j++) { \r\n                    int I = i + (x & 1) * adjL; \r\n                    int J = j + (y & 1) * adjM; \r\n                    Bs[x][y][i][j] = (I < l && J < m) ? b[I][J] : 0; \r\n                } \r\n            } \r\n        } \r\n    } \r\n  \r\n    lld*** s = new lld**[10]; \r\n    for (int i = 0; i < 10; i++) { \r\n        switch (i) { \r\n        case 0: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][1][j][k] - Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 1: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] + As[0][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 2: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[1][0][j][k] + As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 3: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[1][0][j][k] - Bs[0][0][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 4: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] + As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 5: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 6: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][1][j][k] - As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 7: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[1][0][j][k] + Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 8: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] - As[1][0][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 9: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[0][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        } \r\n    } \r\n  \r\n    lld*** p = new lld**[7]; \r\n    p[0] = Strassen(As[0][0], s[0], adjN, adjL, adjM); \r\n    p[1] = Strassen(s[1], Bs[1][1], adjN, adjL, adjM); \r\n    p[2] = Strassen(s[2], Bs[0][0], adjN, adjL, adjM); \r\n    p[3] = Strassen(As[1][1], s[3], adjN, adjL, adjM); \r\n    p[4] = Strassen(s[4], s[5], adjN, adjL, adjM); \r\n    p[5] = Strassen(s[6], s[7], adjN, adjL, adjM); \r\n    p[6] = Strassen(s[8], s[9], adjN, adjL, adjM); \r\n  \r\n    for (int i = 0; i < adjN; i++) { \r\n        for (int j = 0; j < adjM; j++) { \r\n            c[i][j] = p[4][i][j] + p[3][i][j] - p[1][i][j] + p[5][i][j]; \r\n            if (j + adjM < m) \r\n                c[i][j + adjM] = p[0][i][j] + p[1][i][j]; \r\n            if (i + adjN < n) \r\n                c[i + adjN][j] = p[2][i][j] + p[3][i][j]; \r\n            if (i + adjN < n && j + adjM < m) \r\n                c[i + adjN][j + adjM] = p[4][i][j] + p[0][i][j] - p[2][i][j] - p[6][i][j]; \r\n        } \r\n    } \r\n  \r\n    for (int x = 0; x < 2; x++) { \r\n        for (int y = 0; y < 2; y++) { \r\n            for (int i = 0; i < adjN; i++) { \r\n                delete[] As[x][y][i]; \r\n            } \r\n            delete[] As[x][y]; \r\n        } \r\n        delete[] As[x]; \r\n    } \r\n    delete[] As; \r\n  \r\n    for (int x = 0; x < 2; x++) { \r\n        for (int y = 0; y < 2; y++) { \r\n            for (int i = 0; i < adjL; i++) { \r\n                delete[] Bs[x][y][i]; \r\n            } \r\n            delete[] Bs[x][y]; \r\n        } \r\n        delete[] Bs[x]; \r\n    } \r\n    delete[] Bs; \r\n  \r\n    for (int i = 0; i < 10; i++) { \r\n        switch (i) { \r\n        case 0: \r\n        case 3: \r\n        case 5: \r\n        case 7: \r\n        case 9: \r\n            for (int j = 0; j < adjL; j++) { \r\n                delete[] s[i][j]; \r\n            } \r\n            break; \r\n        case 1: \r\n        case 2: \r\n        case 4: \r\n        case 6: \r\n        case 8: \r\n            for (int j = 0; j < adjN; j++) { \r\n                delete[] s[i][j]; \r\n            } \r\n            break; \r\n        } \r\n        delete[] s[i]; \r\n    } \r\n    delete[] s; \r\n  \r\n    for (int i = 0; i < 7; i++) { \r\n        for (int j = 0; j < (n >> 1); j++) { \r\n            delete[] p[i][j]; \r\n        } \r\n        delete[] p[i]; \r\n    } \r\n    delete[] p; \r\n  \r\n    return c; \r\n} \r\n  \r\nint main() \r\n{ \r\n    lld** matA; \r\n    matA = new lld*[2]; \r\n    for (int i = 0; i < 2; i++) \r\n        matA[i] = new lld[3]; \r\n    matA[0][0] = 1; \r\n    matA[0][1] = 2; \r\n    matA[0][2] = 3; \r\n    matA[1][0] = 4; \r\n    matA[1][1] = 5; \r\n    matA[1][2] = 6; \r\n  \r\n    lld** matB; \r\n    matB = new lld*[3]; \r\n    for (int i = 0; i < 3; i++) \r\n        matB[i] = new lld[2]; \r\n    matB[0][0] = 7; \r\n    matB[0][1] = 8; \r\n    matB[1][0] = 9; \r\n    matB[1][1] = 10; \r\n    matB[2][0] = 11; \r\n    matB[2][1] = 12; \r\n  \r\n    lld** matC = Strassen(matA, matB, 2, 3, 2); \r\n    for (int i = 0; i < 2; i++) { \r\n        for (int j = 0; j < 2; j++) { \r\n            printf(\"%lld \", matC[i][j]); \r\n        } \r\n        printf(\"\n\"); \r\n    } \r\n  \r\n    return 0; \r\n', 1000, '', '', 'void multiply(int A[][N], int B[][N], int C[][N]) \r\n{ \r\n    for (int i = 0; i < N; i++) \r\n    { \r\n        for (int j = 0; j < N; j++) \r\n        { \r\n            C[i][j] = 0; \r\n            for (int k = 0; k < N; k++) \r\n            { \r\n                C[i][j] += A[i][k]*B[k][j]; \r\n            } \r\n        } \r\n    } \r\n} ', '2020-05-25'),
(498, 16, 5801012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n\r\n#define d 256 \r\n\r\nvoid search(char pat[], char txt[], int q) \r\n{ \r\n	int M = strlen(pat); \r\n	int N = strlen(txt); \r\n	int i, j; \r\n	int p = 0; \r\n	int t = 0; \r\n	int h = 1; \r\n\r\n	for (i = 0; i < M - 1; i++) \r\n		h = (h * d) % q; \r\n\r\n	for (i = 0; i < M; i++) \r\n	{ \r\n		p = (d * p + pat[i]) % q; \r\n		t = (d * t + txt[i]) % q; \r\n	} \r\n\r\n	for (i = 0; i <= N - M; i++) \r\n	{ \r\n\r\n		if ( p == t ) \r\n		{ \r\n			for (j = 0; j < M; j++) \r\n			{ \r\n				if (txt[i+j] != pat[j]) \r\n					break; \r\n			} \r\n\r\n			if (j == M) \r\n				cout<<\"Pattern found at index\"<<\" \"<<i<<\" \"; \r\n		} \r\n\r\n		if ( i < N-M ) \r\n		{ \r\n			t = (d*(t - txt[i]*h) + txt[i+M])%q; \r\n\r\n			if (t < 0) \r\n			t = (t + q); \r\n		} \r\n	} \r\n} \r\n\r\nint main() \r\n{ \r\n	char txt[101]; \r\n	char pat[101]; \r\n	cin >> txt >> pat;\r\n	int q = 101; \r\n	search(pat, txt, q); \r\n	return 0; \r\n} \r\n\r\n', 1000, '', '', 'function RabinKarp(string s[1..n], string pattern[1..m])\r\n    hpattern := hash(pattern[1..m]);\r\n    for i from 1 to n-m+1\r\n        hs := hash(s[i..i+m-1])\r\n        if hs = hpattern\r\n            if s[i..i+m-1] = pattern[1..m]\r\n                return i\r\n    return not found', '2020-05-25'),
(499, 9, 5901012018, '﻿#include <iostream>\r\nusing namespace std;\r\nclass DisjSet {\r\n    int *rank, *parent, n;\r\n  \r\npublic:\r\n        DisjSet(int n)\r\n    {\r\n        rank = new int[n];\r\n        parent = new int[n];\r\n        this->n = n;\r\n        makeSet();\r\n    }\r\n  \r\n      void makeSet()\r\n    {\r\n        for (int i = 0; i < n; i++) {\r\n            parent[i] = i;\r\n        }\r\n    }\r\n  \r\n      int find(int x)\r\n    {\r\n                if (parent[x] != x) {\r\n  \r\n                       parent[x] = find(parent[x]);\r\n  \r\n                }\r\n  \r\n        return parent[x];\r\n    }\r\n  \r\n       void Union(int x, int y)\r\n    {\r\n               int xset = find(x);\r\n        int yset = find(y);\r\n  \r\n               if (xset == yset)\r\n            return;\r\n  \r\n                if (rank[xset] < rank[yset]) {\r\n            parent[xset] = yset;\r\n        }\r\n        else if (rank[xset] > rank[yset]) {\r\n            parent[yset] = xset;\r\n        }\r\n  \r\n                else {\r\n            parent[yset] = xset;\r\n            rank[xset] = rank[xset] + 1;\r\n        }\r\n    }\r\n};\r\n  \r\nint main()\r\n{\r\n    DisjSet obj(5);\r\n    obj.Union(0, 2);\r\n    obj.Union(4, 2);\r\n    obj.Union(3, 1);\r\n    if (obj.find(4) == obj.find(0))\r\n        cout << \"Yes\n\";\r\n    else\r\n        cout << \"No\n\";\r\n    if (obj.find(1) == obj.find(0))\r\n        cout << \"Yes\n\";\r\n    else\r\n        cout << \"No\n\";\r\n  \r\n    return 0;\r\n}', 1000, '', '', '﻿Following are the steps involved in quick sort algorithm:\r\n1. After selecting an element as pivot, which is the last index of the array in our case, we divide the array for the first time.\r\n2. In quick sort, we call this partitioning. It is not simple breaking down of array into 2 subarrays, but in case of partitioning, the array elements are so positioned that all the elements smaller than the pivot will be on the left side of the pivot and all the elements greater than the pivot will be on the right side of it.\r\n3. And the pivot element will be at its final sorted position.\r\n4. The elements to the left and right, may not be sorted.\r\n5. Then we pick subarrays, elements on the left of pivot and elements on the right of pivot, and we perform partitioning on them by choosing a pivot in the subarrays.', '2020-05-25'),
(500, 12, 5901012018, '#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n\r\nclass Edge\r\n{\r\n	public:\r\n	int src, dest, weight;\r\n};\r\n\r\nclass Graph\r\n{\r\n	public:\r\n\r\n	int V, E;\r\n\r\n	Edge* edge;\r\n};\r\n\r\n\r\nGraph* createGraph(int V, int E)\r\n{\r\n	Graph* graph = new Graph;\r\n	graph->V = V;\r\n	graph->E = E;\r\n\r\n	graph->edge = new Edge[E];\r\n\r\n	return graph;\r\n}\r\n\r\n\r\nclass subset\r\n{\r\n	public:\r\n	int parent;\r\n	int rank;\r\n};\r\n\r\n\r\nint find(subset subsets[], int i)\r\n{\r\n\r\n	if (subsets[i].parent != i)\r\n		subsets[i].parent = find(subsets, subsets[i].parent);\r\n\r\n	return subsets[i].parent;\r\n}\r\n\r\n\r\nvoid Union(subset subsets[], int x, int y)\r\n{\r\n	int xroot = find(subsets, x);\r\n	int yroot = find(subsets, y);\r\n\r\n\r\n	if (subsets[xroot].rank < subsets[yroot].rank)\r\n		subsets[xroot].parent = yroot;\r\n	else if (subsets[xroot].rank > subsets[yroot].rank)\r\n		subsets[yroot].parent = xroot;\r\n\r\n\r\n	else\r\n	{\r\n		subsets[yroot].parent = xroot;\r\n		subsets[xroot].rank++;\r\n	}\r\n}\r\n\r\n\r\nint myComp(const void* a, const void* b)\r\n{\r\n	Edge* a1 = (Edge*)a;\r\n	Edge* b1 = (Edge*)b;\r\n	return a1->weight > b1->weight;\r\n}\r\n\r\nvoid KruskalMST(Graph* graph)\r\n{\r\n	int V = graph->V;\r\n	Edge result[V];\r\n	int e = 0;\r\n	int i = 0;\r\n\r\n\r\n	qsort(graph->edge, graph->E, sizeof(graph->edge[0]), myComp);\r\n\r\n\r\n	subset *subsets = new subset[( V * sizeof(subset) )];\r\n\r\n\r\n	for (int v = 0; v < V; ++v)\r\n	{\r\n		subsets[v].parent = v;\r\n		subsets[v].rank = 0;\r\n	}\r\n\r\n	while (e < V - 1 && i < graph->E)\r\n	{\r\n\r\n		Edge next_edge = graph->edge[i++];\r\n\r\n		int x = find(subsets, next_edge.src);\r\n		int y = find(subsets, next_edge.dest);\r\n\r\n\r\n		if (x != y)\r\n		{\r\n			result[e++] = next_edge;\r\n			Union(subsets, x, y);\r\n		}\r\n\r\n	}\r\n\r\n	cout<<\"(Edge ==> Wt)\"<<endl;\r\n	for (i = 0; i < e; ++i)\r\n		cout<<result[i].src<<\"---\"<<result[i].dest<<\" ==> \"<<result[i].weight<<\" \"<<endl;\r\n	return;\r\n}\r\n\r\n\r\nint main()\r\n{\r\n\r\n	int V=4,E=5;\r\n	//cin>>V>>E;\r\n	//v=4,e=5\r\n\r\n	Graph* graph = createGraph(V, E);\r\n\r\n\r\n	//0 1 10 0 2 6 0 3 5 1 3 15 2 3 4\r\n\r\n    graph->edge[0].src = 0;\r\n    graph->edge[0].dest = 1;\r\n    graph->edge[0].weight = 10;\r\n\r\n\r\n    graph->edge[1].src = 0;\r\n    graph->edge[1].dest = 2;\r\n    graph->edge[1].weight = 6;\r\n\r\n\r\n    graph->edge[2].src = 0;\r\n    graph->edge[2].dest = 3;\r\n    graph->edge[2].weight = 5;\r\n\r\n    graph->edge[3].src = 1;\r\n    graph->edge[3].dest = 3;\r\n    graph->edge[3].weight = 15;\r\n\r\n\r\n    graph->edge[4].src = 2;\r\n    graph->edge[4].dest = 3;\r\n    graph->edge[4].weight = 4;\r\n\r\n\r\n\r\n\r\n	KruskalMST(graph);\r\n\r\n	return 0;\r\n}\r\n\r\n\r\n', 1000, '', '', 'Compute the value per pound Fractional Knapsack Problem for each item.\r\nObeying a Greedy Strategy, we take as possible of the item with the highest value per pound.\r\nIf the supply of that element is exhausted and we can still carry more, we take as much as possible of the element with the next value per pound.\r\nSorting, the items by value per pound, the greedy algorithm run in O (n log n) time.\r\nFractional Knapsack (Array v, Array w, int W)\r\n1. for i= 1 to size (v)\r\n2. do p [i] = v [i] / w [i]\r\n3. Sort-Descending (p)\r\n4. i ← 1\r\n5. while (W>0)\r\n6. do amount = min (W, w [i])\r\n7. solution [i] = amount\r\n8. W= W-amount\r\n9. i ← i+1\r\n10. return solution\r\nExample: Consider 5 items along their respective weights and values: -\r\n\r\n\r\nI = (I1,I2,I3,I4,I5)\r\n\r\nw = (5, 10, 20, 30, 40)\r\n\r\nv = (30, 20, 100, 90,160)\r\n\r\nThe capacity of knapsack W = 60\r\n\r\nNow fill the knapsack according to the decreasing value of pi.\r\n\r\nFirst, we choose the item Ii whose weight is 5.\r\n\r\nThen choose item I3 whose weight is 20. Now,the total weight of knapsack is 20 + 5 = 25\r\n\r\nNow the next item is I5, and its weight is 40, but we want only 35, so we chose the fractional part of it,\r\n\r\nFractional Knapsack Problem', '2020-05-25'),
(501, 13, 5901012018, '#include <iostream>\r\n#include <vector>\r\n#include <queue>\r\n#include <functional>\r\n#include <utility>\r\n\r\nusing namespace std;\r\nconst int MAX = 1e4 + 5;\r\ntypedef pair<long long, int> PII;\r\nbool marked[MAX];\r\nvector <PII> adj[MAX];\r\n\r\nlong long prim(int x)\r\n{\r\n    priority_queue<PII, vector<PII>, greater<PII> > Q;\r\n    int y;\r\n    long long minimumCost = 0;\r\n    PII p;\r\n    Q.push(make_pair(0, x));\r\n    while(!Q.empty())\r\n    {\r\n\r\n        p = Q.top();\r\n        Q.pop();\r\n        x = p.second;\r\n\r\n        if(marked[x] == true)\r\n            continue;\r\n        minimumCost += p.first;\r\n        marked[x] = true;\r\n        for(int i = 0;i < adj[x].size();++i)\r\n        {\r\n            y = adj[x][i].second;\r\n            if(marked[y] == false)\r\n                Q.push(adj[x][i]);\r\n        }\r\n    }\r\n    return minimumCost;\r\n}\r\n\r\nint main()\r\n{\r\n    int nodes, edges, x, y;\r\n    long long weight, minimumCost;\r\n    cin >> nodes >> edges;\r\n    for(int i = 0;i < edges;++i)\r\n    {\r\n        cin >> x >> y >> weight;\r\n        adj[x].push_back(make_pair(weight, y));\r\n        adj[y].push_back(make_pair(weight, x));\r\n    }\r\n\r\n    minimumCost = prim(1);\r\n    cout << minimumCost << endl;\r\n    return 0;\r\n}\r\n', 1000, '', '', 'Input is an array of unique characters along with their frequency of occurrences and output is Huffman Tree.\r\n \r\n1. Create a leaf node for each unique character and build a min heap of all leaf nodes (Min Heap is used as a priority queue. The value of frequency field is used to compare two nodes in min heap. Initially, the least frequent character is at root)\r\n \r\n2. Extract two nodes with the minimum frequency from the min heap.\r\n \r\n3. Create a new internal node with a frequency equal to the sum of the two nodes frequencies. Make the first extracted node as its left child and the other extracted node as its right child. Add this node to the min heap.\r\n \r\n4. Repeat steps#2 and #3 until the heap contains only one node. The remaining node is the root node and the tree is complete.\r\n', '2020-05-25'),
(502, 14, 5901012018, '#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nstruct Edge {\r\n	int src, dest, weight;\r\n};\r\n\r\nstruct Graph {\r\n\r\n	int V, E;\r\n\r\n	struct Edge* edge;\r\n};\r\n\r\nstruct Graph* createGraph(int V, int E)\r\n{\r\n	struct Graph* graph = new Graph;\r\n	graph->V = V;\r\n	graph->E = E;\r\n	graph->edge = new Edge[E];\r\n	return graph;\r\n}\r\n\r\n\r\nvoid printArr(int dist[], int n)\r\n{\r\n	printf(\"Vertex Distance from Source\n\");\r\n	for (int i = 0; i < n; ++i)\r\n		printf(\"%d     %d \n\", i, dist[i]);\r\n}\r\n\r\nvoid BellmanFord(struct Graph* graph, int src)\r\n{\r\n	int V = graph->V;\r\n	int E = graph->E;\r\n	int dist[V];\r\n\r\n	for (int i = 0; i < V; i++)\r\n		dist[i] = INT_MAX;\r\n	dist[src] = 0;\r\n\r\n	for (int i = 1; i <= V - 1; i++) {\r\n		for (int j = 0; j < E; j++) {\r\n			int u = graph->edge[j].src;\r\n			int v = graph->edge[j].dest;\r\n			int weight = graph->edge[j].weight;\r\n			if (dist[u] != INT_MAX && dist[u] + weight < dist[v])\r\n				dist[v] = dist[u] + weight;\r\n		}\r\n	}\r\n\r\n	for (int i = 0; i < E; i++) {\r\n		int u = graph->edge[i].src;\r\n		int v = graph->edge[i].dest;\r\n		int weight = graph->edge[i].weight;\r\n		if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {\r\n			printf(\"Graph contains negative weight cycle\");\r\n			return;\r\n		}\r\n	}\r\n\r\n	printArr(dist, V);\r\n\r\n	return;\r\n}\r\n\r\n\r\nint main()\r\n{\r\n\r\n	int V=5,E=8;\r\n	//v=5,e=8\r\n\r\n	//cin>>V>>E;\r\n\r\n    struct Graph* graph = createGraph(V, E);\r\n\r\n    graph->edge[0].src = 0;\r\n    graph->edge[0].dest = 1;\r\n    graph->edge[0].weight = -1;\r\n\r\n\r\n    graph->edge[1].src = 0;\r\n    graph->edge[1].dest = 2;\r\n    graph->edge[1].weight = 4;\r\n\r\n    graph->edge[2].src = 1;\r\n    graph->edge[2].dest = 2;\r\n    graph->edge[2].weight = 3;\r\n\r\n    graph->edge[3].src = 1;\r\n    graph->edge[3].dest = 3;\r\n    graph->edge[3].weight = 2;\r\n\r\n\r\n    graph->edge[4].src = 1;\r\n    graph->edge[4].dest = 4;\r\n    graph->edge[4].weight = 2;\r\n\r\n\r\n    graph->edge[5].src = 3;\r\n    graph->edge[5].dest = 2;\r\n    graph->edge[5].weight = 5;\r\n\r\n\r\n    graph->edge[6].src = 3;\r\n    graph->edge[6].dest = 1;\r\n    graph->edge[6].weight = 1;\r\n\r\n\r\n    graph->edge[7].src = 4;\r\n    graph->edge[7].dest = 3;\r\n    graph->edge[7].weight = -3;\r\n    BellmanFord(graph, 0);\r\n\r\n	return 0;\r\n\r\n}\r\n', 1000, '', '', '1. Sort all the edges in non-decreasing order of their weight.\r\n2. Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If cycle is not formed, include this edge. Else, discard it.\r\n3. Repeat step#2 until there are (V-1) edges in the spanning tree.\r\n', '2020-05-25');
INSERT INTO `qtos_map` (`ID`, `Q_ID`, `ROLL`, `SUBMISSION`, `SCORE`, `INPUT`, `OP`, `ALGO`, `DATE`) VALUES
(503, 8, 5901012018, '#include<iostream>\r\n#include<vector>\r\n#include<cmath>\r\n#include<algorithm>\r\nusing namespace std;\r\n\r\nint nextpowerof2(int k)\r\n{\r\n    return pow(2, int(ceil(log2(k))));\r\n}\r\nvoid display(vector<vector<int> > &matrix, int m, int n)\r\n{\r\n    for (int i = 0; i < m; i++)\r\n    {\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            if (j != 0)\r\n            {\r\n                cout <<\" \";\r\n            }\r\n            cout << matrix[i][j];\r\n        }\r\n        cout <<endl;\r\n    }\r\n}\r\n\r\nvoid add(vector<vector<int> > &A, vector<vector<int> > &B, vector<vector<int> > &C, int size)\r\n{\r\n    int i, j;\r\n\r\n    for (i = 0; i < size; i++)\r\n    {\r\n        for (j = 0; j < size; j++)\r\n        {\r\n            C[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid sub(vector<vector<int> > &A, vector<vector<int> > &B, vector<vector<int> > &C, int size)\r\n{\r\n    int i, j;\r\n\r\n    for (i = 0; i < size; i++)\r\n    {\r\n        for (j = 0; j < size; j++)\r\n        {\r\n            C[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid STRASSEN_algorithmA(vector<vector<int> > &A, vector<vector<int> > &B, vector<vector<int> > &C, int size)\r\n{\r\n    if (size == 1)\r\n    {\r\n        C[0][0] = A[0][0] * B[0][0];\r\n        return;\r\n    }\r\n    else\r\n    {\r\n        int new_size = size / 2;\r\n        vector<int> z(new_size);\r\n        vector<vector<int> >\r\n            a11(new_size, z), a12(new_size, z), a21(new_size, z), a22(new_size, z),\r\n            b11(new_size, z), b12(new_size, z), b21(new_size, z), b22(new_size, z),\r\n            c11(new_size, z), c12(new_size, z), c21(new_size, z), c22(new_size, z),\r\n            p1(new_size, z), p2(new_size, z), p3(new_size, z), p4(new_size, z),\r\n            p5(new_size, z), p6(new_size, z), p7(new_size, z),\r\n            aResult(new_size, z), bResult(new_size, z);\r\n\r\nint i, j;\r\nfor (i = 0; i < new_size; i++)\r\n        {\r\n            for (j = 0; j < new_size; j++)\r\n            {\r\n                a11[i][j] = A[i][j];\r\n                a12[i][j] = A[i][j + new_size];\r\n                a21[i][j] = A[i + new_size][j];\r\n                a22[i][j] = A[i + new_size][j + new_size];\r\n\r\n                b11[i][j] = B[i][j];\r\n                b12[i][j] = B[i][j + new_size];\r\n                b21[i][j] = B[i + new_size][j];\r\n                b22[i][j] = B[i + new_size][j + new_size];\r\n            }\r\n}\r\n\r\n        add(a11, a22, aResult, new_size);\r\n        add(b11, b22, bResult, new_size);\r\n        STRASSEN_algorithmA(aResult, bResult, p1, new_size);\r\n\r\n        add(a21, a22, aResult, new_size);\r\n        STRASSEN_algorithmA(aResult, b11, p2, new_size);\r\n\r\n        sub(b12, b22, bResult, new_size);\r\n        STRASSEN_algorithmA(a11, bResult, p3, new_size);\r\n\r\n\r\n        sub(b21, b11, bResult, new_size);\r\n        STRASSEN_algorithmA(a22, bResult, p4, new_size);\r\n        add(a11, a12, aResult, new_size);\r\n        STRASSEN_algorithmA(aResult, b22, p5, new_size);\r\n\r\n        sub(a21, a11, aResult, new_size);\r\n        add(b11, b12, bResult, new_size);\r\n        STRASSEN_algorithmA(aResult, bResult, p6, new_size);\r\n\r\n        sub(a12, a22, aResult, new_size);\r\n        add(b21, b22, bResult, new_size);\r\n        STRASSEN_algorithmA(aResult, bResult, p7, new_size);\r\n\r\n        add(p3, p5, c12, new_size);\r\n        add(p2, p4, c21, new_size);\r\n\r\n        add(p1, p4, aResult, new_size);\r\n        add(aResult, p7, bResult, new_size);\r\n        sub(bResult, p5, c11, new_size);\r\n\r\n        add(p1, p3, aResult, new_size);\r\n        add(aResult, p6, bResult, new_size);\r\n        sub(bResult, p2, c22, new_size);\r\n        for (i = 0; i < new_size; i++)\r\n        {\r\n            for (j = 0; j < new_size; j++)\r\n            {\r\n                C[i][j] = c11[i][j];\r\n                C[i][j + new_size] = c12[i][j];\r\n                C[i + new_size][j] = c21[i][j];\r\n                C[i + new_size][j + new_size] = c22[i][j];\r\n            }\r\n        }\r\n    }\r\n}\r\nvoid STRASSEN_algorithm(vector<vector<int> > &A, vector<vector<int> > &B, int m, int n, int a, int b)\r\n{\r\n    int c1=std::max(a,b);\r\n    int c2=std::max(c1,m);\r\n    int c3=std::max(c1,n);\r\n    int k = c3;\r\n\r\n    int s = nextpowerof2(k);\r\n\r\n    vector<int> z(s);\r\n    vector<vector<int> > Aa(s,z),Bb(s,z),Cc(s,z);\r\n\r\n    for (unsigned int i = 0; i < m; i++)\r\n    {\r\n        for (unsigned int j = 0; j < n; j++)\r\n        {\r\n            Aa[i][j] = A[i][j];\r\n        }\r\n    }\r\n    for (unsigned int i = 0; i < a; i++)\r\n    {\r\n        for (unsigned int j = 0; j < b; j++)\r\n        {\r\n            Bb[i][j] = B[i][j];\r\n        }\r\n    }\r\n    STRASSEN_algorithmA(Aa,Bb,Cc,s);\r\n    vector<int> temp1(b);\r\n    vector<vector<int> > C(m, temp1);\r\n    for (unsigned int i = 0; i < m; i++)\r\n    {\r\n        for (unsigned int j = 0; j < b; j++)\r\n        {\r\n            C[i][j] = Cc[i][j];\r\n        }\r\n    }\r\n    display(C, m, b);\r\n}\r\n\r\nbool check(int n, int a)\r\n{\r\n    if (n == a)\r\n        return true;\r\n    else\r\n        return false;\r\n}\r\n\r\nint main()\r\n{\r\n    int n, a, b;\r\n    cin >> n;\r\n\r\n    vector<vector<int> > A;\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        vector<int> temp;\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            int i;\r\n            cin >> i;\r\n            temp.push_back(i);\r\n        }\r\n        A.push_back(temp);\r\n    }\r\n\r\n    vector<vector<int> > B;\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        vector<int> temp;\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            int i;\r\n            cin >> i;\r\n            temp.push_back(i);\r\n        }\r\n        B.push_back(temp);\r\n    }\r\n\r\n\r\n        STRASSEN_algorithm(A,B,n,n,n,n);\r\n\r\n    return 0;\r\n}\r\n\r\n', 0, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '-17 -4 -7\n10 2 11\n40 92 107\n', 'Algorithm..\r\nMatrix-Multiply(A,B)\r\n1.If columns[A]!=rows[B]\r\n2. then error “incomplete dimensions”\r\n3. else for i = 1 to rows[A]\r\n4.        	do for j = 1 to columns[B]\r\n5.                        	do C[i,j] = 0\r\n6.                                        	for k = 1 to columns[A]\r\n7.                                                        	Do C[i,j]=C[i,j]+A[i,k]*B[k,j]\r\n8. Return C\r\n', '2020-05-25'),
(504, 5, 5901012018, '#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\n\r\ninline ll** MatrixMultiply(ll** a, ll** b, int n, int l, int m)\r\n{\r\n    ll** c = new ll*[n];\r\n    for (int i = 0; i < n; i++)\r\n        c[i] = new ll[m];\r\n\r\n    for (int i = 0; i < n; i++) {\r\n        for (int j = 0; j < m; j++) {\r\n            c[i][j] = 0;\r\n            for (int k = 0; k < l; k++) {\r\n                c[i][j] += a[i][k] * b[k][j];\r\n            }\r\n        }\r\n    }\r\n    return c;\r\n}\r\n\r\ninline ll** Strassen(ll** a, ll** b, int n, int l, int m)\r\n{\r\n    if (n == 1 || l == 1 || m == 1)\r\n        return MatrixMultiply(a, b, n, l, m);\r\n\r\n    ll** c = new ll*[n];\r\n    for (int i = 0; i < n; i++)\r\n        c[i] = new ll[m];\r\n\r\n    int adjN = (n >> 1) + (n & 1);\r\n    int adjL = (l >> 1) + (l & 1);\r\n    int adjM = (m >> 1) + (m & 1);\r\n\r\n    ll**** As = new ll***[2];\r\n    for (int x = 0; x < 2; x++) {\r\n        As[x] = new ll**[2];\r\n        for (int y = 0; y < 2; y++) {\r\n            As[x][y] = new ll*[adjN];\r\n            for (int i = 0; i < adjN; i++) {\r\n                As[x][y][i] = new ll[adjL];\r\n                for (int j = 0; j < adjL; j++) {\r\n                    int I = i + (x & 1) * adjN;\r\n                    int J = j + (y & 1) * adjL;\r\n                    As[x][y][i][j] = (I < n && J < l) ? a[I][J] : 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    ll**** Bs = new ll***[2];\r\n    for (int x = 0; x < 2; x++) {\r\n        Bs[x] = new ll**[2];\r\n        for (int y = 0; y < 2; y++) {\r\n            Bs[x][y] = new ll*[adjN];\r\n            for (int i = 0; i < adjL; i++) {\r\n                Bs[x][y][i] = new ll[adjM];\r\n                for (int j = 0; j < adjM; j++) {\r\n                    int I = i + (x & 1) * adjL;\r\n                    int J = j + (y & 1) * adjM;\r\n                    Bs[x][y][i][j] = (I < l && J < m) ? b[I][J] : 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    ll*** s = new ll**[10];\r\n    for (int i = 0; i < 10; i++) {\r\n        switch (i) {\r\n        case 0:\r\n            s[i] = new ll*[adjL];\r\n            for (int j = 0; j < adjL; j++) {\r\n                s[i][j] = new ll[adjM];\r\n                for (int k = 0; k < adjM; k++) {\r\n                    s[i][j][k] = Bs[0][1][j][k] - Bs[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 1:\r\n            s[i] = new ll*[adjN];\r\n            for (int j = 0; j < adjN; j++) {\r\n                s[i][j] = new ll[adjL];\r\n                for (int k = 0; k < adjL; k++) {\r\n                    s[i][j][k] = As[0][0][j][k] + As[0][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 2:\r\n            s[i] = new ll*[adjN];\r\n            for (int j = 0; j < adjN; j++) {\r\n                s[i][j] = new ll[adjL];\r\n                for (int k = 0; k < adjL; k++) {\r\n                    s[i][j][k] = As[1][0][j][k] + As[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 3:\r\n            s[i] = new ll*[adjL];\r\n            for (int j = 0; j < adjL; j++) {\r\n                s[i][j] = new ll[adjM];\r\n                for (int k = 0; k < adjM; k++) {\r\n                    s[i][j][k] = Bs[1][0][j][k] - Bs[0][0][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 4:\r\n            s[i] = new ll*[adjN];\r\n            for (int j = 0; j < adjN; j++) {\r\n                s[i][j] = new ll[adjL];\r\n                for (int k = 0; k < adjL; k++) {\r\n                    s[i][j][k] = As[0][0][j][k] + As[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 5:\r\n            s[i] = new ll*[adjL];\r\n            for (int j = 0; j < adjL; j++) {\r\n                s[i][j] = new ll[adjM];\r\n                for (int k = 0; k < adjM; k++) {\r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 6:\r\n            s[i] = new ll*[adjN];\r\n            for (int j = 0; j < adjN; j++) {\r\n                s[i][j] = new ll[adjL];\r\n                for (int k = 0; k < adjL; k++) {\r\n                    s[i][j][k] = As[0][1][j][k] - As[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 7:\r\n            s[i] = new ll*[adjL];\r\n            for (int j = 0; j < adjL; j++) {\r\n                s[i][j] = new ll[adjM];\r\n                for (int k = 0; k < adjM; k++) {\r\n                    s[i][j][k] = Bs[1][0][j][k] + Bs[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 8:\r\n            s[i] = new ll*[adjN];\r\n            for (int j = 0; j < adjN; j++) {\r\n                s[i][j] = new ll[adjL];\r\n                for (int k = 0; k < adjL; k++) {\r\n                    s[i][j][k] = As[0][0][j][k] - As[1][0][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 9:\r\n            s[i] = new ll*[adjL];\r\n            for (int j = 0; j < adjL; j++) {\r\n                s[i][j] = new ll[adjM];\r\n                for (int k = 0; k < adjM; k++) {\r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[0][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    }\r\n\r\n    ll*** p = new ll**[7];\r\n    p[0] = Strassen(As[0][0], s[0], adjN, adjL, adjM);\r\n    p[1] = Strassen(s[1], Bs[1][1], adjN, adjL, adjM);\r\n    p[2] = Strassen(s[2], Bs[0][0], adjN, adjL, adjM);\r\n    p[3] = Strassen(As[1][1], s[3], adjN, adjL, adjM);\r\n    p[4] = Strassen(s[4], s[5], adjN, adjL, adjM);\r\n    p[5] = Strassen(s[6], s[7], adjN, adjL, adjM);\r\n    p[6] = Strassen(s[8], s[9], adjN, adjL, adjM);\r\n\r\n    for (int i = 0; i < adjN; i++) {\r\n        for (int j = 0; j < adjM; j++) {\r\n            c[i][j] = p[4][i][j] + p[3][i][j] - p[1][i][j] + p[5][i][j];\r\n            if (j + adjM < m)\r\n                c[i][j + adjM] = p[0][i][j] + p[1][i][j];\r\n            if (i + adjN < n)\r\n                c[i + adjN][j] = p[2][i][j] + p[3][i][j];\r\n            if (i + adjN < n && j + adjM < m)\r\n                c[i + adjN][j + adjM] = p[4][i][j] + p[0][i][j] - p[2][i][j] - p[6][i][j];\r\n        }\r\n    }\r\n\r\n    for (int x = 0; x < 2; x++) {\r\n        for (int y = 0; y < 2; y++) {\r\n            for (int i = 0; i < adjN; i++) {\r\n                delete[] As[x][y][i];\r\n            }\r\n            delete[] As[x][y];\r\n        }\r\n        delete[] As[x];\r\n    }\r\n    delete[] As;\r\n\r\n    for (int x = 0; x < 2; x++) {\r\n        for (int y = 0; y < 2; y++) {\r\n            for (int i = 0; i < adjL; i++) {\r\n                delete[] Bs[x][y][i];\r\n            }\r\n            delete[] Bs[x][y];\r\n        }\r\n        delete[] Bs[x];\r\n    }\r\n    delete[] Bs;\r\n\r\n    for (int i = 0; i < 10; i++) {\r\n        switch (i) {\r\n        case 0:\r\n        case 3:\r\n        case 5:\r\n        case 7:\r\n        case 9:\r\n            for (int j = 0; j < adjL; j++) {\r\n                delete[] s[i][j];\r\n            }\r\n            break;\r\n        case 1:\r\n        case 2:\r\n        case 4:\r\n        case 6:\r\n        case 8:\r\n            for (int j = 0; j < adjN; j++) {\r\n                delete[] s[i][j];\r\n            }\r\n            break;\r\n        }\r\n        delete[] s[i];\r\n    }\r\n    delete[] s;\r\n\r\n    for (int i = 0; i < 7; i++) {\r\n        for (int j = 0; j < (n >> 1); j++) {\r\n            delete[] p[i][j];\r\n        }\r\n        delete[] p[i];\r\n    }\r\n    delete[] p;\r\n\r\n    return c;\r\n}\r\n\r\nint main()\r\n{\r\nint n=3;\r\n    //cin>>n;\r\n    int mat1_m=n,mat1_n=n,mat2_m=n,mat2_n=n;\r\n\r\n    ll** mat1 =new ll*[mat1_m];\r\n\r\n\r\n    for(int i=0;i<mat1_m;i++)\r\n    {\r\n        mat1[i]=new ll[mat1_n];\r\n\r\n    }\r\n    mat1[0][0]=1;\r\n    mat1[0][1]=0;\r\n    mat1[0][2]=0;\r\n    mat1[1][0]=0;\r\n    mat1[1][1]=1;\r\n    mat1[1][2]=0;\r\n    mat1[2][0]=0;\r\n    mat1[2][1]=0;\r\n    mat1[2][2]=1;\r\n    //mat1[10][10]={{1,0,0},{0,1,0},{0,0,1}};\r\n\r\n    ll**mat2 =new ll*[mat2_m];\r\n\r\n    for(int i=0;i<mat2_m;i++)\r\n    {\r\n        mat2[i]=new ll[mat2_n];\r\n\r\n\r\n    }\r\n     mat2[0][0]=1;\r\n    mat2[0][1]=0;\r\n    mat2[0][2]=0;\r\n    mat2[1][0]=0;\r\n    mat2[1][1]=1;\r\n    mat2[1][2]=0;\r\n    mat2[2][0]=0;\r\n    mat2[2][1]=0;\r\n    mat2[2][2]=1;\r\n\r\n    ll** mat3 = Strassen(mat1, mat2, mat1_m, mat1_n, mat2_n);\r\n    for (int i = 0; i < mat1_m; i++)\r\n    {\r\n        for (int j = 0; j < mat2_n; j++)\r\n        {\r\n            cout<<mat3[i][j]<<\" \";\r\n        }\r\n        cout<<\"\n\";\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n', 1000, '', '', 'MaxMin(i, j, max, min)\r\n{\r\n 	if (i=j) then max := min := a[i];\r\n 	else if (i=j-1) then\r\n      	{\r\n            	if (a[i] < a[j]) then max := a[j]; min := a[i];\r\n         	   else max := a[i]; min := a[j];\r\n      	}\r\n 	else\r\n 	{\r\n    	\r\n       	mid := ( i + j )/2;\r\n       	MaxMin( i, mid, max, min );\r\n       	MaxMin( mid+1, j, max1, min1 );\r\n       	if (max < max1) then max := max1;\r\n       	if (min > min1) then min := min1;\r\n 	}\r\n}\r\n', '2020-05-25'),
(505, 16, 5901012018, '#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define d 256\r\n\r\n\r\nvoid search(char pat[], char txt[], int q,int l1,int l2)\r\n{\r\n    int M = l2;\r\n    int N = l1;\r\n    int i, j;\r\n    int p = 0;\r\n    int t = 0;\r\n    int h = 1;\r\n\r\n\r\n    for (i = 0; i < M - 1; i++)\r\n        h = (h * d) % q;\r\n\r\n\r\n    for (i = 0; i < M; i++)\r\n    {\r\n        p = (d * p + pat[i]) % q;\r\n        t = (d * t + txt[i]) % q;\r\n    }\r\n\r\n\r\n    for (i = 0; i <= N - M; i++)\r\n    {\r\n\r\n\r\n        if ( p == t )\r\n        {\r\n\r\n            for (j = 0; j < M; j++)\r\n            {\r\n                if (txt[i+j] != pat[j])\r\n                    break;\r\n            }\r\n\r\n\r\n            if (j == M)\r\n                cout<<\"Pattern found at index \"<< i<<endl;\r\n        }\r\n\r\n\r\n        if ( i < N-M )\r\n        {\r\n            t = (d*(t - txt[i]*h) + txt[i+M])%q;\r\n\r\n            if (t < 0)\r\n            t = (t + q);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nint main()\r\n{\r\n\r\n    string s1;\r\n    getline(cin,s1);\r\n    int l1=s1.length();\r\n     char txt[l1];\r\n    for(int i=0;i<l1;i++){\r\n        txt[i]=s1[i];\r\n    }\r\n\r\n\r\n\r\n    string s2;\r\n    getline(cin,s2);\r\n    int l2=s2.length();\r\n    char pat[l2];\r\n\r\n    for(int i=0;i<l2;i++){\r\n        pat[i]=s2[i];\r\n    }\r\n\r\n\r\n    int q = 101;\r\n\r\n    search(pat, txt, q,l1,l2);\r\n    return 0;\r\n}\r\n\r\n\r\n', 1000, '', '', '\r\n\r\nFormulas for Stassen?s matrix multiplication\r\nIn Strassen?s matrix multiplication there are seven multiplication and four addition, subtraction in total.\r\n\r\n    1.	D1 =  (a11 + a22) (b11 + b22)\r\n    2.	D2 =  (a21 + a22).b11\r\n    3.	D3 =  (b12 ? b22).a11\r\n    4.	D4 =  (b21 ? b11).a22\r\n    5.	D5 =  (a11 + a12).b22\r\n    6.	D6 =  (a21 ? a11) . (b11 + b12)\r\n    7.	D7 =  (a12 ? a22) . (b21 + b22)\r\n\r\n    C11 = d1 + d4 ? d5 + d7\r\n    C12 = d3 + d5\r\n    C21 = d2 + d4\r\n    C22 = d1 + d3 ? d2 ? d6\r\nAlgorithm for Strassen?s matrix multiplication\r\nAlgorithm Strassen(n, a, b, d)\r\n\r\nbegin \r\n	If n = threshold then compute\r\n		C = a * b is a conventional matrix.\r\n	Else\r\n		Partition a into four sub matrices  a11, a12, a21, a22.\r\n		Partition b into four sub matrices b11, b12, b21, b22.\r\n		Strassen ( n/2, a11 + a22, b11 + b22, d1)\r\n		Strassen ( n/2, a21 + a22, b11, d2)\r\n		Strassen ( n/2, a11, b12 ? b22, d3)\r\n		Strassen ( n/2, a22, b21 ? b11, d4)\r\n		Strassen ( n/2, a11 + a12, b22, d5)\r\n		Strassen (n/2, a21 ? a11, b11 + b22, d6)\r\n		Strassen (n/2, a12 ? a22, b21 + b22, d7)\r\n\r\n		C = d1+d4-d5+d7     d3+d5\r\n		    d2+d4           d1+d3-d2-d6  \r\n		\r\n	end if\r\n	\r\n	return (C)\r\nend.\r\n', '2020-05-25'),
(506, 9, 6001012018, '﻿#include <iostream>\r\nusing namespace std;\r\nclass DisjSet {\r\n    int *rank, *parent, n;\r\n  \r\npublic:\r\n        DisjSet(int n)\r\n    {\r\n        rank = new int[n];\r\n        parent = new int[n];\r\n        this->n = n;\r\n        makeSet();\r\n    }\r\n  \r\n      void makeSet()\r\n    {\r\n        for (int i = 0; i < n; i++) {\r\n            parent[i] = i;\r\n        }\r\n    }\r\n  \r\n      int find(int x)\r\n    {\r\n                if (parent[x] != x) {\r\n  \r\n                       parent[x] = find(parent[x]);\r\n  \r\n                }\r\n  \r\n        return parent[x];\r\n    }\r\n  \r\n       void Union(int x, int y)\r\n    {\r\n               int xset = find(x);\r\n        int yset = find(y);\r\n  \r\n               if (xset == yset)\r\n            return;\r\n  \r\n                if (rank[xset] < rank[yset]) {\r\n            parent[xset] = yset;\r\n        }\r\n        else if (rank[xset] > rank[yset]) {\r\n            parent[yset] = xset;\r\n        }\r\n  \r\n                else {\r\n            parent[yset] = xset;\r\n            rank[xset] = rank[xset] + 1;\r\n        }\r\n    }\r\n};\r\n  \r\nint main()\r\n{\r\n    DisjSet obj(5);\r\n    obj.Union(0, 2);\r\n    obj.Union(4, 2);\r\n    obj.Union(3, 1);\r\n    if (obj.find(4) == obj.find(0))\r\n        cout << \"Yes\n\";\r\n    else\r\n        cout << \"No\n\";\r\n    if (obj.find(1) == obj.find(0))\r\n        cout << \"Yes\n\";\r\n    else\r\n        cout << \"No\n\";\r\n  \r\n    return 0;\r\n}', 1000, '', '', '﻿procedure mergesort( var a as array )\r\n   if ( n == 1 ) return a\r\n\r\n\r\n   var l1 as array = a[0] ... a[n/2]\r\n   var l2 as array = a[n/2+1] ... a[n]\r\n\r\n\r\n   l1 = mergesort( l1 )\r\n   l2 = mergesort( l2 )\r\n\r\n\r\n   return merge( l1, l2 )\r\nend procedure\r\n\r\n\r\nprocedure merge( var a as array, var b as array )\r\n\r\n\r\n   var c as array\r\n   while ( a and b have elements )\r\n      if ( a[0] > b[0] )\r\n         add b[0] to the end of c\r\n         remove b[0] from b\r\n      else\r\n         add a[0] to the end of c\r\n         remove a[0] from a\r\n      end if\r\n   end while\r\n   \r\n   while ( a has elements )\r\n      add a[0] to the end of c\r\n      remove a[0] from a\r\n   end while\r\n   \r\n   while ( b has elements )\r\n      add b[0] to the end of c\r\n      remove b[0] from b\r\n   end while\r\n   \r\n   return c\r\n        \r\nend procedure', '2020-05-25'),
(507, 13, 6001012018, '#include <iostream>\r\n#include <vector>\r\n#include <queue>\r\n#include <functional>\r\n#include <utility>\r\n\r\nusing namespace std;\r\nconst int MAX = 1e4 + 5;\r\ntypedef pair<long long, int> PII;\r\nbool marked[MAX];\r\nvector <PII> adj[MAX];\r\n\r\nlong long prim(int x)\r\n{\r\n    priority_queue<PII, vector<PII>, greater<PII> > Q;\r\n    int y;\r\n    long long minimumCost = 0;\r\n    PII p;\r\n    Q.push(make_pair(0, x));\r\n    while(!Q.empty())\r\n    {\r\n\r\n        p = Q.top();\r\n        Q.pop();\r\n        x = p.second;\r\n\r\n        if(marked[x] == true)\r\n            continue;\r\n        minimumCost += p.first;\r\n        marked[x] = true;\r\n        for(int i = 0;i < adj[x].size();++i)\r\n        {\r\n            y = adj[x][i].second;\r\n            if(marked[y] == false)\r\n                Q.push(adj[x][i]);\r\n        }\r\n    }\r\n    return minimumCost;\r\n}\r\n\r\nint main()\r\n{\r\n    int nodes, edges, x, y;\r\n    long long weight, minimumCost;\r\n    cin >> nodes >> edges;\r\n    for(int i = 0;i < edges;++i)\r\n    {\r\n        cin >> x >> y >> weight;\r\n        adj[x].push_back(make_pair(weight, y));\r\n        adj[y].push_back(make_pair(weight, x));\r\n    }\r\n\r\n    minimumCost = prim(1);\r\n    cout << minimumCost << endl;\r\n    return 0;\r\n}\r\n', 1000, '', '', '﻿void initialize( int Arr[ ], int N)\r\n{\r\n    for(int i = 0;i<N;i++)\r\n    Arr[ i ] = i ;\r\n}\r\n bool find( int Arr[ ], int A, int B)                           \r\n{\r\nif(Arr[ A ] == Arr[ B ])\r\nreturn true;\r\nelse\r\nreturn false;   \r\n}\r\n//change all entries from Arr[ A ] to Arr[ B ].\r\nvoid union(int Arr[ ], int N, int A, int B)\r\n{\r\n    int TEMP = Arr[ A ];\r\nfor(int i = 0; i < N;i++)\r\n    {\r\n    if(Arr[ i ] == TEMP)\r\n    Arr[ i ] = Arr[ B ]; \r\n    }\r\n}', '2020-05-25'),
(508, 14, 6001012018, '#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nstruct Edge {\r\n	int src, dest, weight;\r\n};\r\n\r\nstruct Graph {\r\n\r\n	int V, E;\r\n\r\n	struct Edge* edge;\r\n};\r\n\r\nstruct Graph* createGraph(int V, int E)\r\n{\r\n	struct Graph* graph = new Graph;\r\n	graph->V = V;\r\n	graph->E = E;\r\n	graph->edge = new Edge[E];\r\n	return graph;\r\n}\r\n\r\n\r\nvoid printArr(int dist[], int n)\r\n{\r\n	printf(\"Vertex Distance from Source\n\");\r\n	for (int i = 0; i < n; ++i)\r\n		printf(\"%d     %d \n\", i, dist[i]);\r\n}\r\n\r\nvoid BellmanFord(struct Graph* graph, int src)\r\n{\r\n	int V = graph->V;\r\n	int E = graph->E;\r\n	int dist[V];\r\n\r\n	for (int i = 0; i < V; i++)\r\n		dist[i] = INT_MAX;\r\n	dist[src] = 0;\r\n\r\n	for (int i = 1; i <= V - 1; i++) {\r\n		for (int j = 0; j < E; j++) {\r\n			int u = graph->edge[j].src;\r\n			int v = graph->edge[j].dest;\r\n			int weight = graph->edge[j].weight;\r\n			if (dist[u] != INT_MAX && dist[u] + weight < dist[v])\r\n				dist[v] = dist[u] + weight;\r\n		}\r\n	}\r\n\r\n	for (int i = 0; i < E; i++) {\r\n		int u = graph->edge[i].src;\r\n		int v = graph->edge[i].dest;\r\n		int weight = graph->edge[i].weight;\r\n		if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {\r\n			printf(\"Graph contains negative weight cycle\");\r\n			return;\r\n		}\r\n	}\r\n\r\n	printArr(dist, V);\r\n\r\n	return;\r\n}\r\n\r\n\r\nint main()\r\n{\r\n\r\n	int V=5,E=8;\r\n	//v=5,e=8\r\n\r\n	//cin>>V>>E;\r\n\r\n    struct Graph* graph = createGraph(V, E);\r\n\r\n    graph->edge[0].src = 0;\r\n    graph->edge[0].dest = 1;\r\n    graph->edge[0].weight = -1;\r\n\r\n\r\n    graph->edge[1].src = 0;\r\n    graph->edge[1].dest = 2;\r\n    graph->edge[1].weight = 4;\r\n\r\n    graph->edge[2].src = 1;\r\n    graph->edge[2].dest = 2;\r\n    graph->edge[2].weight = 3;\r\n\r\n    graph->edge[3].src = 1;\r\n    graph->edge[3].dest = 3;\r\n    graph->edge[3].weight = 2;\r\n\r\n\r\n    graph->edge[4].src = 1;\r\n    graph->edge[4].dest = 4;\r\n    graph->edge[4].weight = 2;\r\n\r\n\r\n    graph->edge[5].src = 3;\r\n    graph->edge[5].dest = 2;\r\n    graph->edge[5].weight = 5;\r\n\r\n\r\n    graph->edge[6].src = 3;\r\n    graph->edge[6].dest = 1;\r\n    graph->edge[6].weight = 1;\r\n\r\n\r\n    graph->edge[7].src = 4;\r\n    graph->edge[7].dest = 3;\r\n    graph->edge[7].weight = -3;\r\n    BellmanFord(graph, 0);\r\n\r\n	return 0;\r\n\r\n}\r\n', 1000, '', '', '??D\0y\0n\0a\0m\0i\0c\0-\00\0-\01\0-\0k\0n\0a\0p\0s\0a\0c\0k\0 \0(\0v\0,\0 \0w\0,\0 \0n\0,\0 \0W\0)\0\r\0\n\0f\0o\0r\0 \0w\0 \0=\0 \00\0 \0t\0o\0 \0W\0 \0d\0o\0\r\0\n\0 \0 \0 \0c\0[\00\0,\0 \0w\0]\0 \0=\0 \00\0\r\0\n\0f\0o\0r\0 \0i\0 \0=\0 \01\0 \0t\0o\0 \0n\0 \0d\0o\0 \0 \0\r\0\n\0 \0 \0 \0c\0[\0i\0,\0 \00\0]\0 \0=\0 \00\0\r\0\n\0 \0 \0 \0f\0o\0r\0 \0w\0 \0=\0 \01\0 \0t\0o\0 \0W\0 \0d\0o\0\r\0\n\0 \0 \0	\0i\0f\0 \0w\0i\0 \0d\" \0w\0 \0t\0h\0e\0n\0\r\0\n\0 \0 \0 \0 \0 \0	\0i\0f\0 \0v\0i\0 \0+\0 \0c\0[\0i\0-\01\0,\0 \0w\0-\0w\0i\0]\0 \0t\0h\0e\0n\0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0	\0c\0[\0i\0,\0 \0w\0]\0 \0=\0 \0v\0i\0 \0+\0 \0c\0[\0i\0-\01\0,\0 \0w\0-\0w\0i\0]\0\r\0\n\0 \0 \0 \0 \0 \0	\0e\0l\0s\0e\0 \0c\0[\0i\0,\0 \0w\0]\0 \0=\0 \0c\0[\0i\0-\01\0,\0 \0w\0]\0\r\0\n\0 \0 \0	\0e\0l\0s\0e\0\r\0\n\0 \0 \0 \0 \0 \0	\0c\0[\0i\0,\0 \0w\0]\0 \0=\0 \0c\0[\0i\0-\01\0,\0 \0w\0]\0', '2020-05-25'),
(509, 15, 6001012018, '#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint MatrixChainOrder(int p[], int i, int j)\r\n{\r\n    if(i == j)\r\n        return 0;\r\n    int k;\r\n    int min = INT_MAX;\r\n    int count;\r\n\r\n    for (k = i; k < j; k++)\r\n    {\r\n        count = MatrixChainOrder(p, i, k) +\r\n                MatrixChainOrder(p, k + 1, j) +\r\n                p[i - 1] * p[k] * p[j];\r\n\r\n        if (count < min)\r\n            min = count;\r\n    }\r\n\r\n    return min;\r\n}\r\n\r\nint main()\r\n{\r\n    int n=0;\r\n\r\n    cin>>n;\r\n\r\n    int arr[n];\r\n    for(int i=0;i<n;i++){\r\n        cin>>arr[i];\r\n    }\r\n\r\n\r\n         cout<< MatrixChainOrder(arr, 1, n - 1);\r\n}\r\n', 1000, '', '', 'Input is an array of unique characters along with their frequency of occurrences and output is Huffman Tree.\r\n \r\n1. Create a leaf node for each unique character and build a min heap of all leaf nodes (Min Heap is used as a priority queue. The value of frequency field is used to compare two nodes in min heap. Initially, the least frequent character is at root)\r\n \r\n2. Extract two nodes with the minimum frequency from the min heap.\r\n \r\n3. Create a new internal node with a frequency equal to the sum of the two nodes frequencies. Make the first extracted node as its left child and the other extracted node as its right child. Add this node to the min heap.\r\n \r\n4. Repeat steps#2 and #3 until the heap contains only one node. The remaining node is the root node and the tree is complete.\r\n', '2020-05-25'),
(510, 5, 6001012018, '#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\n\r\ninline ll** MatrixMultiply(ll** a, ll** b, int n, int l, int m)\r\n{\r\n    ll** c = new ll*[n];\r\n    for (int i = 0; i < n; i++)\r\n        c[i] = new ll[m];\r\n\r\n    for (int i = 0; i < n; i++) {\r\n        for (int j = 0; j < m; j++) {\r\n            c[i][j] = 0;\r\n            for (int k = 0; k < l; k++) {\r\n                c[i][j] += a[i][k] * b[k][j];\r\n            }\r\n        }\r\n    }\r\n    return c;\r\n}\r\n\r\ninline ll** Strassen(ll** a, ll** b, int n, int l, int m)\r\n{\r\n    if (n == 1 || l == 1 || m == 1)\r\n        return MatrixMultiply(a, b, n, l, m);\r\n\r\n    ll** c = new ll*[n];\r\n    for (int i = 0; i < n; i++)\r\n        c[i] = new ll[m];\r\n\r\n    int adjN = (n >> 1) + (n & 1);\r\n    int adjL = (l >> 1) + (l & 1);\r\n    int adjM = (m >> 1) + (m & 1);\r\n\r\n    ll**** As = new ll***[2];\r\n    for (int x = 0; x < 2; x++) {\r\n        As[x] = new ll**[2];\r\n        for (int y = 0; y < 2; y++) {\r\n            As[x][y] = new ll*[adjN];\r\n            for (int i = 0; i < adjN; i++) {\r\n                As[x][y][i] = new ll[adjL];\r\n                for (int j = 0; j < adjL; j++) {\r\n                    int I = i + (x & 1) * adjN;\r\n                    int J = j + (y & 1) * adjL;\r\n                    As[x][y][i][j] = (I < n && J < l) ? a[I][J] : 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    ll**** Bs = new ll***[2];\r\n    for (int x = 0; x < 2; x++) {\r\n        Bs[x] = new ll**[2];\r\n        for (int y = 0; y < 2; y++) {\r\n            Bs[x][y] = new ll*[adjN];\r\n            for (int i = 0; i < adjL; i++) {\r\n                Bs[x][y][i] = new ll[adjM];\r\n                for (int j = 0; j < adjM; j++) {\r\n                    int I = i + (x & 1) * adjL;\r\n                    int J = j + (y & 1) * adjM;\r\n                    Bs[x][y][i][j] = (I < l && J < m) ? b[I][J] : 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    ll*** s = new ll**[10];\r\n    for (int i = 0; i < 10; i++) {\r\n        switch (i) {\r\n        case 0:\r\n            s[i] = new ll*[adjL];\r\n            for (int j = 0; j < adjL; j++) {\r\n                s[i][j] = new ll[adjM];\r\n                for (int k = 0; k < adjM; k++) {\r\n                    s[i][j][k] = Bs[0][1][j][k] - Bs[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 1:\r\n            s[i] = new ll*[adjN];\r\n            for (int j = 0; j < adjN; j++) {\r\n                s[i][j] = new ll[adjL];\r\n                for (int k = 0; k < adjL; k++) {\r\n                    s[i][j][k] = As[0][0][j][k] + As[0][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 2:\r\n            s[i] = new ll*[adjN];\r\n            for (int j = 0; j < adjN; j++) {\r\n                s[i][j] = new ll[adjL];\r\n                for (int k = 0; k < adjL; k++) {\r\n                    s[i][j][k] = As[1][0][j][k] + As[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 3:\r\n            s[i] = new ll*[adjL];\r\n            for (int j = 0; j < adjL; j++) {\r\n                s[i][j] = new ll[adjM];\r\n                for (int k = 0; k < adjM; k++) {\r\n                    s[i][j][k] = Bs[1][0][j][k] - Bs[0][0][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 4:\r\n            s[i] = new ll*[adjN];\r\n            for (int j = 0; j < adjN; j++) {\r\n                s[i][j] = new ll[adjL];\r\n                for (int k = 0; k < adjL; k++) {\r\n                    s[i][j][k] = As[0][0][j][k] + As[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 5:\r\n            s[i] = new ll*[adjL];\r\n            for (int j = 0; j < adjL; j++) {\r\n                s[i][j] = new ll[adjM];\r\n                for (int k = 0; k < adjM; k++) {\r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 6:\r\n            s[i] = new ll*[adjN];\r\n            for (int j = 0; j < adjN; j++) {\r\n                s[i][j] = new ll[adjL];\r\n                for (int k = 0; k < adjL; k++) {\r\n                    s[i][j][k] = As[0][1][j][k] - As[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 7:\r\n            s[i] = new ll*[adjL];\r\n            for (int j = 0; j < adjL; j++) {\r\n                s[i][j] = new ll[adjM];\r\n                for (int k = 0; k < adjM; k++) {\r\n                    s[i][j][k] = Bs[1][0][j][k] + Bs[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 8:\r\n            s[i] = new ll*[adjN];\r\n            for (int j = 0; j < adjN; j++) {\r\n                s[i][j] = new ll[adjL];\r\n                for (int k = 0; k < adjL; k++) {\r\n                    s[i][j][k] = As[0][0][j][k] - As[1][0][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 9:\r\n            s[i] = new ll*[adjL];\r\n            for (int j = 0; j < adjL; j++) {\r\n                s[i][j] = new ll[adjM];\r\n                for (int k = 0; k < adjM; k++) {\r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[0][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    }\r\n\r\n    ll*** p = new ll**[7];\r\n    p[0] = Strassen(As[0][0], s[0], adjN, adjL, adjM);\r\n    p[1] = Strassen(s[1], Bs[1][1], adjN, adjL, adjM);\r\n    p[2] = Strassen(s[2], Bs[0][0], adjN, adjL, adjM);\r\n    p[3] = Strassen(As[1][1], s[3], adjN, adjL, adjM);\r\n    p[4] = Strassen(s[4], s[5], adjN, adjL, adjM);\r\n    p[5] = Strassen(s[6], s[7], adjN, adjL, adjM);\r\n    p[6] = Strassen(s[8], s[9], adjN, adjL, adjM);\r\n\r\n    for (int i = 0; i < adjN; i++) {\r\n        for (int j = 0; j < adjM; j++) {\r\n            c[i][j] = p[4][i][j] + p[3][i][j] - p[1][i][j] + p[5][i][j];\r\n            if (j + adjM < m)\r\n                c[i][j + adjM] = p[0][i][j] + p[1][i][j];\r\n            if (i + adjN < n)\r\n                c[i + adjN][j] = p[2][i][j] + p[3][i][j];\r\n            if (i + adjN < n && j + adjM < m)\r\n                c[i + adjN][j + adjM] = p[4][i][j] + p[0][i][j] - p[2][i][j] - p[6][i][j];\r\n        }\r\n    }\r\n\r\n    for (int x = 0; x < 2; x++) {\r\n        for (int y = 0; y < 2; y++) {\r\n            for (int i = 0; i < adjN; i++) {\r\n                delete[] As[x][y][i];\r\n            }\r\n            delete[] As[x][y];\r\n        }\r\n        delete[] As[x];\r\n    }\r\n    delete[] As;\r\n\r\n    for (int x = 0; x < 2; x++) {\r\n        for (int y = 0; y < 2; y++) {\r\n            for (int i = 0; i < adjL; i++) {\r\n                delete[] Bs[x][y][i];\r\n            }\r\n            delete[] Bs[x][y];\r\n        }\r\n        delete[] Bs[x];\r\n    }\r\n    delete[] Bs;\r\n\r\n    for (int i = 0; i < 10; i++) {\r\n        switch (i) {\r\n        case 0:\r\n        case 3:\r\n        case 5:\r\n        case 7:\r\n        case 9:\r\n            for (int j = 0; j < adjL; j++) {\r\n                delete[] s[i][j];\r\n            }\r\n            break;\r\n        case 1:\r\n        case 2:\r\n        case 4:\r\n        case 6:\r\n        case 8:\r\n            for (int j = 0; j < adjN; j++) {\r\n                delete[] s[i][j];\r\n            }\r\n            break;\r\n        }\r\n        delete[] s[i];\r\n    }\r\n    delete[] s;\r\n\r\n    for (int i = 0; i < 7; i++) {\r\n        for (int j = 0; j < (n >> 1); j++) {\r\n            delete[] p[i][j];\r\n        }\r\n        delete[] p[i];\r\n    }\r\n    delete[] p;\r\n\r\n    return c;\r\n}\r\n\r\nint main()\r\n{\r\nint n=3;\r\n    //cin>>n;\r\n    int mat1_m=n,mat1_n=n,mat2_m=n,mat2_n=n;\r\n\r\n    ll** mat1 =new ll*[mat1_m];\r\n\r\n\r\n    for(int i=0;i<mat1_m;i++)\r\n    {\r\n        mat1[i]=new ll[mat1_n];\r\n\r\n    }\r\n    mat1[0][0]=1;\r\n    mat1[0][1]=0;\r\n    mat1[0][2]=0;\r\n    mat1[1][0]=0;\r\n    mat1[1][1]=1;\r\n    mat1[1][2]=0;\r\n    mat1[2][0]=0;\r\n    mat1[2][1]=0;\r\n    mat1[2][2]=1;\r\n    //mat1[10][10]={{1,0,0},{0,1,0},{0,0,1}};\r\n\r\n    ll**mat2 =new ll*[mat2_m];\r\n\r\n    for(int i=0;i<mat2_m;i++)\r\n    {\r\n        mat2[i]=new ll[mat2_n];\r\n\r\n\r\n    }\r\n     mat2[0][0]=1;\r\n    mat2[0][1]=0;\r\n    mat2[0][2]=0;\r\n    mat2[1][0]=0;\r\n    mat2[1][1]=1;\r\n    mat2[1][2]=0;\r\n    mat2[2][0]=0;\r\n    mat2[2][1]=0;\r\n    mat2[2][2]=1;\r\n\r\n    ll** mat3 = Strassen(mat1, mat2, mat1_m, mat1_n, mat2_n);\r\n    for (int i = 0; i < mat1_m; i++)\r\n    {\r\n        for (int j = 0; j < mat2_n; j++)\r\n        {\r\n            cout<<mat3[i][j]<<\" \";\r\n        }\r\n        cout<<\"\n\";\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n', 1000, '', '', 'Algorithm\r\nFollowing are the detailed steps.\r\n \r\nInput: Graph and a source vertex src\r\nOutput: Shortest distance to all vertices from src. If there is a negative weight cycle, then shortest distances are not calculated, negative weight cycle is reported.\r\n \r\n \r\n \r\n \r\n1) This step initializes distances from source to all vertices as infinite and distance to source itself as 0. Create an array dist[] of size |V| with all values as infinite except dist[src] where src is source vertex.\r\n \r\n2) This step calculates shortest distances. Do following |V|-1 times where |V| is the number of vertices in given graph.\r\n…..a) Do following for each edge u-v\r\n………………If dist[v] > dist[u] + weight of edge uv, then update dist[v]\r\n………………….dist[v] = dist[u] + weight of edge uv\r\n \r\n3) This step reports if there is a negative weight cycle in graph. Do following for each edge u-v\r\n……If dist[v] > dist[u] + weight of edge uv, then “Graph contains negative weight cycle”\r\nThe idea of step 3 is, step 2 guarantees shortest distances if graph doesn’t contain negative weight cycle. If we iterate through all edges one more time and get a shorter path for any vertex, then there is a negative weight cycle\r\n', '2020-05-25'),
(511, 16, 6001012018, '#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define d 256\r\n\r\n\r\nvoid search(char pat[], char txt[], int q,int l1,int l2)\r\n{\r\n    int M = l2;\r\n    int N = l1;\r\n    int i, j;\r\n    int p = 0;\r\n    int t = 0;\r\n    int h = 1;\r\n\r\n\r\n    for (i = 0; i < M - 1; i++)\r\n        h = (h * d) % q;\r\n\r\n\r\n    for (i = 0; i < M; i++)\r\n    {\r\n        p = (d * p + pat[i]) % q;\r\n        t = (d * t + txt[i]) % q;\r\n    }\r\n\r\n\r\n    for (i = 0; i <= N - M; i++)\r\n    {\r\n\r\n\r\n        if ( p == t )\r\n        {\r\n\r\n            for (j = 0; j < M; j++)\r\n            {\r\n                if (txt[i+j] != pat[j])\r\n                    break;\r\n            }\r\n\r\n\r\n            if (j == M)\r\n                cout<<\"Pattern found at index \"<< i<<endl;\r\n        }\r\n\r\n\r\n        if ( i < N-M )\r\n        {\r\n            t = (d*(t - txt[i]*h) + txt[i+M])%q;\r\n\r\n            if (t < 0)\r\n            t = (t + q);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nint main()\r\n{\r\n\r\n    string s1;\r\n    getline(cin,s1);\r\n    int l1=s1.length();\r\n     char txt[l1];\r\n    for(int i=0;i<l1;i++){\r\n        txt[i]=s1[i];\r\n    }\r\n\r\n\r\n\r\n    string s2;\r\n    getline(cin,s2);\r\n    int l2=s2.length();\r\n    char pat[l2];\r\n\r\n    for(int i=0;i<l2;i++){\r\n        pat[i]=s2[i];\r\n    }\r\n\r\n\r\n    int q = 101;\r\n\r\n    search(pat, txt, q,l1,l2);\r\n    return 0;\r\n}\r\n\r\n\r\n', 1000, '', '', 'Algorithm..\r\nMatrix-Multiply(A,B)\r\n1.If columns[A]!=rows[B]\r\n2. then error “incomplete dimensions”\r\n3. else for i = 1 to rows[A]\r\n4.        	do for j = 1 to columns[B]\r\n5.                        	do C[i,j] = 0\r\n6.                                        	for k = 1 to columns[A]\r\n7.                                                        	Do C[i,j]=C[i,j]+A[i,k]*B[k,j]\r\n8. Return C\r\n', '2020-05-25'),
(512, 9, 6101012018, '#include <iostream> \r\nusing namespace std; \r\nclass DisjSet { \r\n	int *rank, *parent, n; \r\n\r\npublic: \r\n\r\n	DisjSet(int n) \r\n	{ \r\n		rank = new int[n]; \r\n		parent = new int[n]; \r\n		this->n = n; \r\n		makeSet(); \r\n	} \r\n\r\n	void makeSet() \r\n	{ \r\n		for (int i = 0; i < n; i++) { \r\n			parent[i] = i; \r\n		} \r\n	} \r\n\r\n	\r\n	int find(int x) \r\n	{ \r\n		if (parent[x] != x) { \r\n\r\n			parent[x] = find(parent[x]); \r\n\r\n		} \r\n\r\n		return parent[x]; \r\n	} \r\n\r\n	void Union(int x, int y) \r\n	{ \r\n		int xset = find(x); \r\n		int yset = find(y); \r\n\r\n		if (xset == yset) \r\n			return; \r\n\r\n		if (rank[xset] < rank[yset]) { \r\n			parent[xset] = yset; \r\n		} \r\n		else if (rank[xset] > rank[yset]) { \r\n			parent[yset] = xset; \r\n		} \r\n \r\n		else { \r\n			parent[yset] = xset; \r\n			rank[xset] = rank[xset] + 1; \r\n		} \r\n	} \r\n}; \r\n\r\nint main() \r\n{ \r\n	DisjSet obj(5); \r\n	obj.Union(0, 2); \r\n	obj.Union(4, 2); \r\n	obj.Union(3, 1); \r\n	if (obj.find(4) == obj.find(0)) \r\n		cout << \"Yes\n\"; \r\n	else\r\n		cout << \"No\n\"; \r\n	if (obj.find(1) == obj.find(0)) \r\n		cout << \"Yes\n\"; \r\n	else\r\n		cout << \"No\n\"; \r\n\r\n	return 0; \r\n}\r\n', 1000, '', '', '\r\nBegin\r\n   Assume k is the element\r\n   makeset(k):\r\n      k.parent = k.\r\n   Find(x):\r\n   If k.parent == k\r\n      return k.\r\n   else\r\n   return Find(k.parent)\r\n   Union (a,b):\r\n      Take two set a and b as input.\r\n      aroot = Find(a)\r\n      broot = Find(b)\r\n      aroot.parent = broot\r\nEnd\r\n', '2020-05-25'),
(513, 13, 6101012018, '#include<iostream>\r\n#include<climits>\r\nusing namespace std;\r\n\r\nint findMinVertex(int* weights, bool* visited, int n){\r\n\r\n	int minVertex = -1;\r\n	for(int i = 0; i < n; i++){\r\n		if(!visited[i] && (minVertex == - 1 || weights[i] < weights[minVertex])){\r\n			minVertex = i;\r\n		}\r\n	}\r\n	return minVertex;\r\n}\r\n\r\n\r\nvoid prims(int** edges, int n){\r\n\r\n	int* parent = new int[n];\r\n	int* weights = new int[n];\r\n	bool* visited = new bool[n];\r\n\r\n	for(int i = 0; i < n; i++){\r\n		visited[i] = false;\r\n		weights[i] = INT_MAX;\r\n	}\r\n	parent[0] = -1;\r\n	weights[0] = 0;\r\n\r\n	for(int i = 0; i < n - 1; i++){\r\n		// Find Min Vertex\r\n		int minVertex = findMinVertex(weights, visited, n);\r\n		visited[minVertex] = true;\r\n		// Explore un visted neighbours\r\n		for(int j = 0; j < n; j++){\r\n			if(edges[minVertex][j] != 0 && !visited[j]){\r\n				if(edges[minVertex][j] < weights[j]){\r\n					weights[j] = edges[minVertex][j];\r\n					parent[j] = minVertex;\r\n				}\r\n			}\r\n		}\r\n	}\r\n\r\n	for(int i = 1; i < n; i++){\r\n		if(parent[i] < i){\r\n			cout << parent[i] << \" “ << i << \" \" << weights[i] << endl;\r\n		}else{\r\n			cout << i << \" \" << parent[i] << \" \" << weights[i] << endl;\r\n		}\r\n	}\r\n}\r\n\r\nint main() {\r\n	int n;\r\n	int e;\r\n	cin >> n >> e;\r\n	int** edges = new int*[n];\r\n	for (int i = 0; i < n; i++) {\r\n		edges[i] = new int[n];\r\n		for (int j = 0; j < n; j++) {\r\n			edges[i][j] = 0;\r\n		}\r\n	}\r\n\r\n	for (int i = 0; i < e; i++) {\r\n		int f, s, weight;\r\n		cin >> f >> s >> weight;\r\n		edges[f][s] = weight;\r\n		edges[s][f] = weight;\r\n	}\r\n	cout << endl;\r\n	prims(edges, n);\r\n\r\n	for (int i = 0; i < n; i++) {\r\n		delete [] edges[i];\r\n	}\r\n	delete [] edges;\r\n}\r\n\r\n\r\n\r\n\r\n', 1000, '', '', 'prims(InputGraph, vertices, startVertex, MST)\r\n    initialise visited array to false\r\n    count = 0   // counts vertices visited\r\n \r\n    while count < vertices // there are vertices to visit\r\n        if current node not visited\r\n            mark it visited\r\n            push all its edges to the PriorityQueue\r\n            extract the minimum edge from PriorityQueue\r\n \r\n            if the minimum edge leads to an unvisited vertex\r\n                add it to MST\r\n \r\n            current = newVertex\r\n            ++count\r\n        else\r\n            extract the minimum edge from PriorityQueue again\r\n \r\n            if the minimum edge leads to an unvisited vertex\r\n                add it to MST\r\n \r\n            current = newVertex\r\n', '2020-05-25'),
(514, 14, 6101012018, '#include <bits/stdc++.h> \r\nstruct Edge { \r\n	int src, dest, weight; \r\n}; \r\n\r\nstruct Graph { \r\n	int V, E; \r\n	struct Edge* edge; \r\n}; \r\n\r\nstruct Graph* createGraph(int V, int E) \r\n{ \r\n	struct Graph* graph = new Graph; \r\n	graph->V = V; \r\n	graph->E = E; \r\n	graph->edge = new Edge[E]; \r\n	return graph; \r\n} \r\n\r\nvoid printArr(int dist[], int n) \r\n{ \r\n	printf(\"Vertex Distance from Source\n\"); \r\n	for (int i = 0; i < n; ++i) \r\n		printf(\"%d 		 %d\n\", i, dist[i]); \r\n} \r\n\r\nvoid BellmanFord(struct Graph* graph, int src) \r\n{ \r\n	int V = graph->V; \r\n	int E = graph->E; \r\n	int dist[V]; \r\n	for (int i = 0; i < V; i++) \r\n		dist[i] = INT_MAX; \r\n	dist[src] = 0; \r\n	for (int i = 1; i <= V - 1; i++) { \r\n		for (int j = 0; j < E; j++) { \r\n			int u = graph->edge[j].src; \r\n			int v = graph->edge[j].dest; \r\n			int weight = graph->edge[j].weight; \r\n			if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) \r\n				dist[v] = dist[u] + weight; \r\n		} \r\n	} \r\n\r\n	for (int i = 0; i < E; i++) { \r\n		int u = graph->edge[i].src; \r\n		int v = graph->edge[i].dest; \r\n		int weight = graph->edge[i].weight; \r\n		if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) { \r\n			printf(\"Graph contains negative weight cycle\"); \r\n			return; // If negative cycle is detected, simply return \r\n		} \r\n	} \r\n\r\n	printArr(dist, V); \r\n\r\n	return; \r\n} \r\n \r\nint main() \r\n{ \r\n	\r\n	int V = 5;\r\n	int E = 8; \r\n	struct Graph* graph = createGraph(V, E); \r\n	graph->edge[0].src = 0; \r\n	graph->edge[0].dest = 1; \r\n	graph->edge[0].weight = -1; \r\n\r\n	\r\n	graph->edge[1].src = 0; \r\n	graph->edge[1].dest = 2; \r\n	graph->edge[1].weight = 4; \r\n\r\n	graph->edge[2].src = 1; \r\n	graph->edge[2].dest = 2; \r\n	graph->edge[2].weight = 3; \r\n \r\n	graph->edge[3].src = 1; \r\n	graph->edge[3].dest = 3; \r\n	graph->edge[3].weight = 2; \r\n \r\n	graph->edge[4].src = 1; \r\n	graph->edge[4].dest = 4; \r\n	graph->edge[4].weight = 2; \r\n\r\n	graph->edge[5].src = 3; \r\n	graph->edge[5].dest = 2; \r\n	graph->edge[5].weight = 5; \r\n\r\n	graph->edge[6].src = 3; \r\n	graph->edge[6].dest = 1; \r\n	graph->edge[6].weight = 1; \r\n \r\n	graph->edge[7].src = 4; \r\n	graph->edge[7].dest = 3; \r\n	graph->edge[7].weight = -3; \r\n\r\n	BellmanFord(graph, 0); \r\n\r\n	return 0; \r\n}\r\n', 1000, '', '', 'Algorithm:\r\nInput: Graph and a source vertex src\r\nOutput: Shortest distance to all vertices from src. If there is a negative weight cycle, then shortest distances are not calculated, negative weight cycle is reported.\r\n1) This step initializes distances from the source to all vertices as infinite and distance to the source itself as 0. Create an array dist[] of size |V| with all values as infinite except dist[src] where src is source vertex.\r\n2) This step calculates shortest distances. Do following |V|-1 times where |V| is the number of vertices in given graph.\r\n…..a) Do following for each edge u-v\r\n………………If dist[v] > dist[u] + weight of edge uv, then update dist[v]\r\n………………….dist[v] = dist[u] + weight of edge uv\r\n3) This step reports if there is a negative weight cycle in graph. Do following for each edge u-v\r\n……If dist[v] > dist[u] + weight of edge uv, then “Graph contains negative weight cycle”\r\nThe idea of step 3 is, step 2 guarantees the shortest distances if the graph doesn’t contain a negative weight cycle. If we iterate through all edges one more time and get a shorter path for any vertex, then there is a negative weight cycle\r\n', '2020-05-25'),
(515, 15, 6101012018, '#include <iostream>\r\n#include <climits>\r\nusing namespace std;\r\n\r\nint MatrixChainMultiplication(int dims[], int n)\r\n{\r\n	int c[n + 1][n + 1];\r\n\r\n	for (int i = 1; i <= n; i++)\r\n		c[i][i] = 0;\r\n\r\n	for (int len = 2; len <= n; len++) {\r\n		for (int i = 1; i <= n - len + 1; i++)\r\n		{\r\n			int j = i + len - 1;\r\n			c[i][j] = INT_MAX;\r\n\r\n			for (int k = i; j < n && k <= j - 1; k++)\r\n			{\r\n				int cost = c[i][k] + c[k + 1][j] +\r\n							dims[i - 1]*dims[k]*dims[j];\r\n\r\n				if (cost < c[i][j])\r\n					c[i][j] = cost;\r\n			}\r\n		}\r\n	}\r\n	return c[1][n - 1];\r\n}\r\n\r\n\r\nint main()\r\n{\r\n	int m;\r\n	cin>>m;\r\n	int dims[m];\r\n	for(int l=0;l<m;l++){\r\n	cin>>dims[l];\r\n	}\r\n	int n = sizeof(dims) / sizeof(dims[0]);\r\n\r\n	cout << \"Minimum cost is \" << MatrixChainMultiplication(dims, n);\r\n\r\n	return 0;\r\n}\r\n', 1000, '', '', 'Begin\r\n   define table c of size n x n, initially fill with all 0s\r\n   for length := 2 to n, do\r\n      for i:=1 to n-length, do\r\n         j := i + length ? 1\r\n         c[i, j] := 8(infinity)\r\n         for k := i to j-1, do\r\n            cost := c[i, k] + c[k+1, j] + dims[i-1]*dims[k]*dims[j]\r\n            if cost < c[i, j], then c[i, j] := cost\r\n         done\r\n      done\r\n   done\r\n   return c[1, n-1]\r\nEnd\r\n', '2020-05-25');
INSERT INTO `qtos_map` (`ID`, `Q_ID`, `ROLL`, `SUBMISSION`, `SCORE`, `INPUT`, `OP`, `ALGO`, `DATE`) VALUES
(516, 8, 6101012018, '#include<iostream>\r\nUsing namespace std;\r\n\r\nclass Strassen\r\n{\r\n            int i,j,a[2][2],b[2][2],c[2][2],p1,p2,p3,p4,p5,p6,p7;\r\n            public:\r\n             Strassen(){\r\n               p1=0,p2=0,p3=0,p4=0,p5=0,p6=0,p7=0;\r\n               for(i=0;i<2;i++){\r\n               for(j=0;j<2;j++){\r\n                       a[i][j] = 0;\r\n                       b[i][j] = 0;\r\n                       c[i][j] = 0;\r\n                }\r\n               }\r\n              }\r\n\r\n             void read(){\r\n              cout<<\"Matrix 1 : \"<<endl;\r\n              for(i=0;i<2;i++){\r\n              for(j=0;j<2;j++){\r\n                cin>>a[i][j];\r\n               }\r\n              }\r\n              cout<<\"Matrix 2 : \"<<endl;\r\n              for(i=0;i<2;i++){\r\n              for(j=0;j<2;j++){\r\n               cin>>b[i][j];\r\n                }\r\n               }\r\n              }\r\n\r\n              void cal(){\r\n               p1 = (a[0][0] + a[1][1])*(b[0][0] + b[1][1]);\r\n               p2 = (a[1][0] + a[1][1])*b[0][0];\r\n               p3 = a[0][0]*(b[0][1] - b[1][1]);\r\n               p4 = a[1][1]*(b[1][0] - b[0][0]);\r\n               p5 = (a[0][0] + a[0][1])*b[1][1];\r\n               p6 = (a[1][0] - a[0][0])*(b[0][0] + b[0][1]);\r\n               p7 = (a[0][1] - a[1][1])*(b[1][0] + b[1][1]);\r\n               c[0][0] = p1 + p4 + - p5 + p7;\r\n               c[0][1] = p3 + p5;\r\n               c[1][0] = p2 + p4;\r\n               c[1][1] = p1 + p3 - p2 + p6;\r\n              }\r\n\r\n              void print(){\r\n               cout<<\"Resultant Matrix : \"<<endl;\r\n                for(i=0;i<2;i++){\r\n                for(j=0;j<2;j++){\r\n                cout<<c[i][j]<<\"	\";\r\n                }\r\n                cout<<endl;\r\n                }\r\n            }\r\n};\r\n\r\n    int main(){\r\n            Strassen s;\r\n            cout<<\"Enter the Matrix\"<<endl;\r\n            s.read();\r\n            s.cal();\r\n            s.print();\r\n            }\r\n', 0, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '', 'begin \r\n	If n = threshold then compute\r\n		c = a * b is a conventional matrix.\r\n	Else\r\n		Partition a into four sub matrices  a11, a12, a21, a22.\r\n		Partition b into four sub matrices b11, b12, b21, b22.\r\n		Strassen ( n/2, a11 + a22, b11 + b22, d1)\r\n		Strassen ( n/2, a21 + a22, b11, d2)\r\n		Strassen ( n/2, a11, b12 – b22, d3)\r\n		Strassen ( n/2, a22, b21 – b11, d4)\r\n		Strassen ( n/2, a11 + a12, b22, d5)\r\n		Strassen (n/2, a21 – a11, b11 + b22, d6)\r\n		Strassen (n/2, a12 – a22, b21 + b22, d7)\r\n\r\n		c = d1+d4-d5+d7     d3+d5\r\n		    d2+d4           d1+d3-d2-d6  \r\n		\r\n	end if\r\n	return (c)\r\nend.\r\n', '2020-05-25'),
(517, 5, 6101012018, '#include<iostream>\r\nUsing namespace std;\r\n\r\nclass Strassen\r\n{\r\n            int i,j,a[2][2],b[2][2],c[2][2],p1,p2,p3,p4,p5,p6,p7;\r\n            public:\r\n             Strassen(){\r\n               p1=0,p2=0,p3=0,p4=0,p5=0,p6=0,p7=0;\r\n               for(i=0;i<2;i++){\r\n               for(j=0;j<2;j++){\r\n                       a[i][j] = 0;\r\n                       b[i][j] = 0;\r\n                       c[i][j] = 0;\r\n                }\r\n               }\r\n              }\r\n\r\n             void read(){\r\n              cout<<\"Matrix 1 : \"<<endl;\r\n              for(i=0;i<2;i++){\r\n              for(j=0;j<2;j++){\r\n                cin>>a[i][j];\r\n               }\r\n              }\r\n              cout<<\"Matrix 2 : \"<<endl;\r\n              for(i=0;i<2;i++){\r\n              for(j=0;j<2;j++){\r\n               cin>>b[i][j];\r\n                }\r\n               }\r\n              }\r\n\r\n              void cal(){\r\n               p1 = (a[0][0] + a[1][1])*(b[0][0] + b[1][1]);\r\n               p2 = (a[1][0] + a[1][1])*b[0][0];\r\n               p3 = a[0][0]*(b[0][1] - b[1][1]);\r\n               p4 = a[1][1]*(b[1][0] - b[0][0]);\r\n               p5 = (a[0][0] + a[0][1])*b[1][1];\r\n               p6 = (a[1][0] - a[0][0])*(b[0][0] + b[0][1]);\r\n               p7 = (a[0][1] - a[1][1])*(b[1][0] + b[1][1]);\r\n               c[0][0] = p1 + p4 + - p5 + p7;\r\n               c[0][1] = p3 + p5;\r\n               c[1][0] = p2 + p4;\r\n               c[1][1] = p1 + p3 - p2 + p6;\r\n              }\r\n\r\n              void print(){\r\n               cout<<\"Resultant Matrix : \"<<endl;\r\n                for(i=0;i<2;i++){\r\n                for(j=0;j<2;j++){\r\n                cout<<c[i][j]<<\"	\";\r\n                }\r\n                cout<<endl;\r\n                }\r\n            }\r\n};\r\n\r\n    int main(){\r\n            Strassen s;\r\n            cout<<\"Enter the Matrix\"<<endl;\r\n            s.read();\r\n            s.cal();\r\n            s.print();\r\n            }\r\n', 1000, '', '', 'begin \r\n	If n = threshold then compute\r\n		c = a * b is a conventional matrix.\r\n	Else\r\n		Partition a into four sub matrices  a11, a12, a21, a22.\r\n		Partition b into four sub matrices b11, b12, b21, b22.\r\n		Strassen ( n/2, a11 + a22, b11 + b22, d1)\r\n		Strassen ( n/2, a21 + a22, b11, d2)\r\n		Strassen ( n/2, a11, b12 – b22, d3)\r\n		Strassen ( n/2, a22, b21 – b11, d4)\r\n		Strassen ( n/2, a11 + a12, b22, d5)\r\n		Strassen (n/2, a21 – a11, b11 + b22, d6)\r\n		Strassen (n/2, a12 – a22, b21 + b22, d7)\r\n\r\n		c = d1+d4-d5+d7     d3+d5\r\n		    d2+d4           d1+d3-d2-d6  \r\n		\r\n	end if\r\n	return (c)\r\nend.\r\n', '2020-05-25'),
(518, 16, 6101012018, '#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define d 256\r\n\r\nvoid search(char pat[], char txt[], int q)\r\n{\r\n    int M = strlen(pat);\r\n    int N = strlen(txt);\r\n    int i, j;\r\n    int p = 0; // hash value for pattern\r\n    int t = 0; // hash value for txt\r\n    int h = 1;\r\n\r\n\r\n    for (i = 0; i < M - 1; i++)\r\n        h = (h * d) % q;\r\n\r\n\r\n    for (i = 0; i < M; i++)\r\n    {\r\n        p = (d * p + pat[i]) % q;\r\n        t = (d * t + txt[i]) % q;\r\n    }\r\n\r\n\r\n    for (i = 0; i <= N - M; i++)\r\n    {\r\n\r\n\r\n\r\n        if ( p == t )\r\n        {\r\n\r\n            for (j = 0; j < M; j++)\r\n            {\r\n                if (txt[i+j] != pat[j])\r\n                    break;\r\n            }\r\n\r\n\r\n            if (j == M)\r\n                cout<<\"Pattern found at index \"<< i<<endl;\r\n        }\r\n\r\n\r\n\r\n        if ( i < N-M )\r\n        {\r\n            t = (d*(t - txt[i]*h) + txt[i+M])%q;\r\n\r\n\r\n            if (t < 0)\r\n            t = (t + q);\r\n        }\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    char txt[100];\r\n    char pat[100];\r\n    cin.getline(txt,100);\r\n    cin.getline(pat,100);\r\n\r\n    int q = 101;\r\n    search(pat, txt, q);\r\n    return 0;\r\n}\r\n', 1000, '', '', 'RABIN-KARP-MATCHER (T, P, d, q)\r\n 1. n ? length [T]\r\n 2. m  ? length [P]\r\n 3. h  ?  dm-1 mod q\r\n 4. p ?  0\r\n 5. t0 ?  0\r\n 6. for i ? 1 to m\r\n 7. do p ?  (dp + P[i]) mod q\r\n 8. t0 ? (dt0+T [i]) mod q\r\n 9. for s  ?  0 to n-m\r\n 10. do if p = ts\r\n 11. then if P [1.....m] = T [s+1.....s + m]\r\n 12. then \"Pattern occurs with shift\" s\r\n 13. If s < n-m\r\n 14. then ts+1 ?  (d (ts-T [s+1]h)+T [s+m+1])mod q\r\n', '2020-05-25'),
(519, 9, 6201012018, '#include <iostream>\r\nusing namespace std;\r\nclass DisjSet {\r\n    int *rank, *parent, n;\r\n  \r\npublic:\r\n        DisjSet(int n)\r\n    {\r\n        rank = new int[n];\r\n        parent = new int[n];\r\n        this->n = n;\r\n        makeSet();\r\n    }\r\n  \r\n      void makeSet()\r\n    {\r\n        for (int i = 0; i < n; i++) {\r\n            parent[i] = i;\r\n        }\r\n    }\r\n  \r\n      int find(int x)\r\n    {\r\n                if (parent[x] != x) {\r\n  \r\n                       parent[x] = find(parent[x]);\r\n  \r\n                }\r\n  \r\n        return parent[x];\r\n    }\r\n  \r\n       void Union(int x, int y)\r\n    {\r\n               int xset = find(x);\r\n        int yset = find(y);\r\n  \r\n               if (xset == yset)\r\n            return;\r\n  \r\n                if (rank[xset] < rank[yset]) {\r\n            parent[xset] = yset;\r\n        }\r\n        else if (rank[xset] > rank[yset]) {\r\n            parent[yset] = xset;\r\n        }\r\n  \r\n                else {\r\n            parent[yset] = xset;\r\n            rank[xset] = rank[xset] + 1;\r\n        }\r\n    }\r\n};\r\n  \r\nint main()\r\n{\r\n    DisjSet obj(5);\r\n    obj.Union(0, 2);\r\n    obj.Union(4, 2);\r\n    obj.Union(3, 1);\r\n    if (obj.find(4) == obj.find(0))\r\n        cout << \"Yes\n\";\r\n    else\r\n        cout << \"No\n\";\r\n    if (obj.find(1) == obj.find(0))\r\n        cout << \"Yes\n\";\r\n    else\r\n        cout << \"No\n\";\r\n  \r\n    return 0;\r\n}\r\n\r\n', 1000, '', '', '﻿Following are the steps involved in quick sort algorithm:\r\n1. After selecting an element as pivot, which is the last index of the array in our case, we divide the array for the first time.\r\n2. In quick sort, we call this partitioning. It is not simple breaking down of array into 2 subarrays, but in case of partitioning, the array elements are so positioned that all the elements smaller than the pivot will be on the left side of the pivot and all the elements greater than the pivot will be on the right side of it.\r\n3. And the pivot element will be at its final sorted position.\r\n4. The elements to the left and right, may not be sorted.\r\n5. Then we pick subarrays, elements on the left of pivot and elements on the right of pivot, and we perform partitioning on them by choosing a pivot in the subarrays.', '2020-05-25'),
(520, 12, 6201012018, '#include<bits/stdc++.h>\r\nusing namespace std;\r\ntypedef pair<int, int> iPair;\r\n\r\nstruct Graph\r\n{\r\n	int V, E;\r\n	vector< pair<int, iPair> > edges;\r\n\r\n\r\n	Graph(int V, int E)\r\n	{\r\n		this->V = V;\r\n		this->E = E;\r\n	}\r\n\r\n\r\n	void addEdge(int u, int v, int w)\r\n	{\r\n		edges.push_back({w, {u, v}});\r\n	}\r\n\r\n	int kruskalMST();\r\n};\r\n\r\n\r\nstruct DisjointSets\r\n{\r\n	int *parent, *rnk;\r\n	int n;\r\n\r\n	DisjointSets(int n)\r\n	{\r\n\r\n		this->n = n;\r\n		parent = new int[n+1];\r\n		rnk = new int[n+1];\r\n\r\n\r\n		for (int i = 0; i <= n; i++)\r\n		{\r\n			rnk[i] = 0;\r\n\r\n\r\n			parent[i] = i;\r\n		}\r\n	}\r\n\r\n\r\n	int find(int u)\r\n	{\r\n\r\n		if (u != parent[u])\r\n			parent[u] = find(parent[u]);\r\n		return parent[u];\r\n	}\r\n\r\n	void merge(int x, int y)\r\n	{\r\n		x = find(x), y = find(y);\r\n\r\n		if (rnk[x] > rnk[y])\r\n			parent[y] = x;\r\n		else\r\n			parent[x] = y;\r\n\r\n		if (rnk[x] == rnk[y])\r\n			rnk[y]++;\r\n	}\r\n};\r\n\r\n\r\n\r\nint Graph::kruskalMST()\r\n{\r\n	int mst_wt = 0;\r\n	sort(edges.begin(), edges.end());\r\n\r\n\r\n	DisjointSets ds(V);\r\n\r\n	vector< pair<int, iPair> >::iterator it;\r\n	for (it=edges.begin(); it!=edges.end(); it++)\r\n	{\r\n		int u = it->second.first;\r\n		int v = it->second.second;\r\n\r\n		int set_u = ds.find(u);\r\n		int set_v = ds.find(v);\r\n\r\n		if (set_u != set_v)\r\n		{\r\n\r\n			cout << u << \" - \" << v << endl;\r\n\r\n\r\n			mst_wt += it->first;\r\n\r\n\r\n			ds.merge(set_u, set_v);\r\n		}\r\n	}\r\n\r\n	return mst_wt;\r\n}\r\n\r\n\r\nint main()\r\n{\r\n\r\n	int V = 9, E = 14;\r\n    Graph g(V, E);\r\n\r\n    g.addEdge(0, 1, 4);\r\n    g.addEdge(0, 7, 8);\r\n    g.addEdge(1, 2, 8);\r\n    g.addEdge(1, 7, 11);\r\n    g.addEdge(2, 3, 7);\r\n    g.addEdge(2, 8, 2);\r\n    g.addEdge(2, 5, 4);\r\n    g.addEdge(3, 4, 9);\r\n    g.addEdge(3, 5, 14);\r\n    g.addEdge(4, 5, 10);\r\n    g.addEdge(5, 6, 2);\r\n    g.addEdge(6, 7, 1);\r\n    g.addEdge(6, 8, 6);\r\n    g.addEdge(7, 8, 7);\r\n\r\n	cout << \"Edges of MST are \n\";\r\n	int mst_wt = g.kruskalMST();\r\n\r\n	cout << \"\nWeight of MST is \" << mst_wt;\r\n\r\n	return 0;\r\n}\r\n\r\n', 1000, '', '', 'void initialize( int Arr[ ], int N)\r\n{\r\n    for(int i = 0;i<N;i++)\r\n    Arr[ i ] = i ;\r\n}\r\n bool find( int Arr[ ], int A, int B)                           \r\n{\r\nif(Arr[ A ] == Arr[ B ])\r\nreturn true;\r\nelse\r\nreturn false;   \r\n}\r\n\r\nvoid union(int Arr[ ], int N, int A, int B)\r\n{\r\n    int TEMP = Arr[ A ];\r\nfor(int i = 0; i < N;i++)\r\n    {\r\n    if(Arr[ i ] == TEMP)\r\n    Arr[ i ] = Arr[ B ]; \r\n    }\r\n}\r\n\r\n\r\n', '2020-05-25'),
(521, 13, 6201012018, '#include<iostream>\r\n#include<climits>\r\nusing namespace std;\r\n\r\nint findMinVertex(int* weights, bool* visited, int n){\r\n\r\n	int minVertex = -1;\r\n	for(int i = 0; i < n; i++){\r\n		if(!visited[i] && (minVertex == - 1 || weights[i] < weights[minVertex])){\r\n			minVertex = i;\r\n		}\r\n	}\r\n	return minVertex;\r\n}\r\n\r\n\r\nvoid prims(int** edges, int n){\r\n\r\n	int* parent = new int[n];\r\n	int* weights = new int[n];\r\n	bool* visited = new bool[n];\r\n\r\n	for(int i = 0; i < n; i++){\r\n		visited[i] = false;\r\n		weights[i] = INT_MAX;\r\n	}\r\n	parent[0] = -1;\r\n	weights[0] = 0;\r\n\r\n	for(int i = 0; i < n - 1; i++){\r\n		int minVertex = findMinVertex(weights, visited, n);\r\n		visited[minVertex] = true;\r\n		for(int j = 0; j < n; j++){\r\n			if(edges[minVertex][j] != 0 && !visited[j]){\r\n				if(edges[minVertex][j] < weights[j]){\r\n					weights[j] = edges[minVertex][j];\r\n					parent[j] = minVertex;\r\n				}\r\n			}\r\n		}\r\n	}\r\n\r\n\r\n	int ans=0;\r\n	for(int i = 1; i < n; i++)\r\n    {\r\n			ans+= weights[i];\r\n\r\n	}\r\n	cout<<ans;\r\n}\r\n\r\nint main() {\r\n	int n;\r\n	int e;\r\n	cin >> n >> e;\r\n	int** edges = new int*[n];\r\n	for (int i = 0; i < n; i++) {\r\n		edges[i] = new int[n];\r\n		for (int j = 0; j < n; j++) {\r\n			edges[i][j] = 0;\r\n		}\r\n	}\r\n\r\n	for (int i = 0; i < e; i++) {\r\n		int f, s, weight;\r\n		cin >> f >> s >> weight;\r\n		edges[f][s] = weight;\r\n		edges[s][f] = weight;\r\n	}\r\n\r\n	prims(edges, n);\r\n\r\n}\r\n\r\n', 1000, '', '', '??D\0y\0n\0a\0m\0i\0c\0-\00\0-\01\0-\0k\0n\0a\0p\0s\0a\0c\0k\0 \0(\0v\0,\0 \0w\0,\0 \0n\0,\0 \0W\0)\0\r\0\n\0f\0o\0r\0 \0w\0 \0=\0 \00\0 \0t\0o\0 \0W\0 \0d\0o\0\r\0\n\0 \0 \0 \0c\0[\00\0,\0 \0w\0]\0 \0=\0 \00\0\r\0\n\0f\0o\0r\0 \0i\0 \0=\0 \01\0 \0t\0o\0 \0n\0 \0d\0o\0 \0 \0\r\0\n\0 \0 \0 \0c\0[\0i\0,\0 \00\0]\0 \0=\0 \00\0\r\0\n\0 \0 \0 \0f\0o\0r\0 \0w\0 \0=\0 \01\0 \0t\0o\0 \0W\0 \0d\0o\0\r\0\n\0 \0 \0	\0i\0f\0 \0w\0i\0 \0d\" \0w\0 \0t\0h\0e\0n\0\r\0\n\0 \0 \0 \0 \0 \0	\0i\0f\0 \0v\0i\0 \0+\0 \0c\0[\0i\0-\01\0,\0 \0w\0-\0w\0i\0]\0 \0t\0h\0e\0n\0\r\0\n\0 \0 \0 \0 \0 \0 \0 \0 \0	\0c\0[\0i\0,\0 \0w\0]\0 \0=\0 \0v\0i\0 \0+\0 \0c\0[\0i\0-\01\0,\0 \0w\0-\0w\0i\0]\0\r\0\n\0 \0 \0 \0 \0 \0	\0e\0l\0s\0e\0 \0c\0[\0i\0,\0 \0w\0]\0 \0=\0 \0c\0[\0i\0-\01\0,\0 \0w\0]\0\r\0\n\0 \0 \0	\0e\0l\0s\0e\0\r\0\n\0 \0 \0 \0 \0 \0	\0c\0[\0i\0,\0 \0w\0]\0 \0=\0 \0c\0[\0i\0-\01\0,\0 \0w\0]\0', '2020-05-25'),
(522, 14, 6201012018, '#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nstruct Edge {\r\n    int src, dest, weight;\r\n};\r\n\r\n\r\nstruct Graph {\r\n\r\n    int V, E;\r\n\r\n\r\n    struct Edge* edge;\r\n};\r\n\r\nstruct Graph* createGraph(int V, int E)\r\n{\r\n    struct Graph* graph = new Graph;\r\n    graph->V = V;\r\n    graph->E = E;\r\n    graph->edge = new Edge[E];\r\n    return graph;\r\n}\r\n\r\nvoid printArr(int dist[], int n)\r\n{\r\n    printf(\"Vertex   Distance from Source\n\");\r\n    for (int i = 0; i < n; ++i)\r\n        printf(\"%d 		 %d\n\", i, dist[i]);\r\n}\r\n\r\nvoid BellmanFord(struct Graph* graph, int src)\r\n{\r\n    int V = graph->V;\r\n    int E = graph->E;\r\n    int dist[V];\r\n\r\n\r\n    for (int i = 0; i < V; i++)\r\n        dist[i] = INT_MAX;\r\n    dist[src] = 0;\r\n\r\n\r\n    for (int i = 1; i <= V - 1; i++) {\r\n        for (int j = 0; j < E; j++) {\r\n            int u = graph->edge[j].src;\r\n            int v = graph->edge[j].dest;\r\n            int weight = graph->edge[j].weight;\r\n            if (dist[u] != INT_MAX && dist[u] + weight < dist[v])\r\n                dist[v] = dist[u] + weight;\r\n        }\r\n    }\r\n\r\n\r\n    for (int i = 0; i < E; i++) {\r\n        int u = graph->edge[i].src;\r\n        int v = graph->edge[i].dest;\r\n        int weight = graph->edge[i].weight;\r\n        if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {\r\n            printf(\"Graph contains negative weight cycle\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printArr(dist, V);\r\n\r\n    return;\r\n}\r\n\r\nint main()\r\n{\r\n    int V = 5, E=8;\r\n    struct Graph* graph = createGraph(V, E);\r\n\r\n    graph->edge[0].src = 0;\r\n    graph->edge[0].dest = 1;\r\n    graph->edge[0].weight = -1;\r\n\r\n    graph->edge[1].src = 0;\r\n    graph->edge[1].dest = 2;\r\n    graph->edge[1].weight = 4;\r\n\r\n    graph->edge[2].src = 1;\r\n    graph->edge[2].dest = 2;\r\n    graph->edge[2].weight = 3;\r\n\r\n    graph->edge[3].src = 1;\r\n    graph->edge[3].dest = 3;\r\n    graph->edge[3].weight = 2;\r\n\r\n    graph->edge[4].src = 1;\r\n    graph->edge[4].dest = 4;\r\n    graph->edge[4].weight = 2;\r\n\r\n    graph->edge[5].src = 3;\r\n    graph->edge[5].dest = 2;\r\n    graph->edge[5].weight = 5;\r\n\r\n    graph->edge[6].src = 3;\r\n    graph->edge[6].dest = 1;\r\n    graph->edge[6].weight = 1;\r\n\r\n    graph->edge[7].src = 4;\r\n    graph->edge[7].dest = 3;\r\n    graph->edge[7].weight = -3;\r\n\r\n    BellmanFord(graph, 0);\r\n\r\n    return 0;\r\n}\r\n', 1000, '', '', 'Input is an array of unique characters along with their frequency of occurrences and output is Huffman Tree.\r\n \r\n1. Create a leaf node for each unique character and build a min heap of all leaf nodes (Min Heap is used as a priority queue. The value of frequency field is used to compare two nodes in min heap. Initially, the least frequent character is at root)\r\n \r\n2. Extract two nodes with the minimum frequency from the min heap.\r\n \r\n3. Create a new internal node with a frequency equal to the sum of the two nodes frequencies. Make the first extracted node as its left child and the other extracted node as its right child. Add this node to the min heap.\r\n \r\n4. Repeat steps#2 and #3 until the heap contains only one node. The remaining node is the root node and the tree is complete.\r\n', '2020-05-25'),
(523, 15, 6201012018, '#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint MatrixChainOrder(int p[], int i, int j)\r\n{\r\n    if(i == j)\r\n        return 0;\r\n    int k;\r\n    int min = INT_MAX;\r\n    int count;\r\n\r\n    for (k = i; k < j; k++)\r\n    {\r\n        count = MatrixChainOrder(p, i, k) +\r\n                MatrixChainOrder(p, k + 1, j) +\r\n                p[i - 1] * p[k] * p[j];\r\n\r\n        if (count < min)\r\n            min = count;\r\n    }\r\n\r\n    return min;\r\n}\r\n\r\nint main()\r\n{\r\n    int n=0;\r\n\r\n    cin>>n;\r\n\r\n    int arr[n];\r\n    for(int i=0;i<n;i++){\r\n        cin>>arr[i];\r\n    }\r\n\r\n\r\n         cout<< MatrixChainOrder(arr, 1, n - 1);\r\n}\r\n', 1000, '', '', '1. Sort all the edges in non-decreasing order of their weight.\r\n2. Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If cycle is not formed, include this edge. Else, discard it.\r\n3. Repeat step#2 until there are (V-1) edges in the spanning tree.\r\n', '2020-05-25'),
(524, 16, 6201012018, '#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define d 256\r\n\r\n\r\nvoid search(char pat[], char txt[], int q,int l1,int l2)\r\n{\r\n    int M = l2;\r\n    int N = l1;\r\n    int i, j;\r\n    int p = 0;\r\n    int t = 0;\r\n    int h = 1;\r\n\r\n\r\n    for (i = 0; i < M - 1; i++)\r\n        h = (h * d) % q;\r\n\r\n\r\n    for (i = 0; i < M; i++)\r\n    {\r\n        p = (d * p + pat[i]) % q;\r\n        t = (d * t + txt[i]) % q;\r\n    }\r\n\r\n\r\n    for (i = 0; i <= N - M; i++)\r\n    {\r\n\r\n\r\n        if ( p == t )\r\n        {\r\n\r\n            for (j = 0; j < M; j++)\r\n            {\r\n                if (txt[i+j] != pat[j])\r\n                    break;\r\n            }\r\n\r\n\r\n            if (j == M)\r\n                cout<<\"Pattern found at index \"<< i<<endl;\r\n        }\r\n\r\n\r\n        if ( i < N-M )\r\n        {\r\n            t = (d*(t - txt[i]*h) + txt[i+M])%q;\r\n\r\n            if (t < 0)\r\n            t = (t + q);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nint main()\r\n{\r\n\r\n    string s1;\r\n    getline(cin,s1);\r\n    int l1=s1.length();\r\n     char txt[l1];\r\n    for(int i=0;i<l1;i++){\r\n        txt[i]=s1[i];\r\n    }\r\n\r\n\r\n\r\n    string s2;\r\n    getline(cin,s2);\r\n    int l2=s2.length();\r\n    char pat[l2];\r\n\r\n    for(int i=0;i<l2;i++){\r\n        pat[i]=s2[i];\r\n    }\r\n\r\n\r\n    int q = 101;\r\n\r\n    search(pat, txt, q,l1,l2);\r\n    return 0;\r\n}\r\n\r\n\r\n', 1000, '', '', 'MaxMin(i, j, max, min)\r\n{\r\n 	if (i=j) then max := min := a[i];\r\n 	else if (i=j-1) then\r\n      	{\r\n            	if (a[i] < a[j]) then max := a[j]; min := a[i];\r\n         	   else max := a[i]; min := a[j];\r\n      	}\r\n 	else\r\n 	{\r\n    	\r\n       	mid := ( i + j )/2;\r\n       	MaxMin( i, mid, max, min );\r\n       	MaxMin( mid+1, j, max1, min1 );\r\n       	if (max < max1) then max := max1;\r\n       	if (min > min1) then min := min1;\r\n 	}\r\n}\r\n', '2020-05-25'),
(525, 9, 6301012018, '#include <iostream> \nusing namespace std; \nclass createset { \n	int *rank, *parent, n; \n\npublic: \n\n	void makeset() \n	{ \n		for(int i=0;i<n;i++)\n                 {\n                  parent[i]=i;	} \n}\n\n	createset(int n) \n	{ \n		rank = new int[n]; \n		parent = new int[n]; \n		this->n = n; \n		makeset(); \n	} \n\n\n\n	int findset(int x) \n	{ \n		if (parent[x] != x) { \n			parent[x] = findset(parent[x]); \n		} \n\n		return parent[x]; \n	} \n\n\n	void mergeset(int x, int y) \n	{ \n		int xset = findset(x); \n		int yset = findset(y); \n\n		if (xset == yset) \n			return; \n\n		if (rank[xset] < rank[yset]) { \n			parent[xset] = yset; \n		} \n		else if (rank[xset] > rank[yset]) { \n			parent[yset] = xset; \n		} \n\n		else { \n			parent[yset] = xset; \n			rank[xset] = rank[xset] + 1; \n		} \n	} \n}; \n\nint main() \n{ \n    \n	createset obj(6);\n	\n	obj.mergeset(4,5);\n	obj.mergeset(0, 2); \n	obj.mergeset(5, 3); \n	obj.mergeset(3, 1);\n	\n	if (obj.findset(4) == obj.findset(5)) \n		cout << \"Yes\n\"; \n	else\n		cout << \"No\n\"; \n	if (obj.findset(1) == obj.findset(3)) \n		cout << \"Yes\n\"; \n	else\n		cout << \"No\n\"; \n\n	return 0; \n} \n\n', 1000, '', '', 'function MakeSet(x)\r\n   x.parent = x\r\n\r\nfunction Find(x)\r\n   if x.parent == x\r\n      return x\r\n   else\r\n      return Find(x.parent)\r\n\r\nfunction Union(x,y)\r\n   xRoot = Find(x)\r\n   yRoot = Find(y)\r\n   xRoot.parent = yRoot', '2020-05-25'),
(526, 12, 6301012018, '﻿#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n\r\nclass Edge\r\n{\r\n    public:\r\n    int src, dest, weight;\r\n};\r\n\r\n\r\nclass Graph\r\n{\r\n    public:\r\n\r\n\r\n    int V, E;\r\n\r\n\r\n    Edge* edge;\r\n};\r\n\r\n\r\n\r\n\r\nGraph* createGraph(int V, int E)\r\n{\r\n    Graph* graph = new Graph;\r\n    graph->V = V;\r\n    graph->E = E;\r\n\r\n\r\n    graph->edge = new Edge[E];\r\n\r\n\r\n    return graph;\r\n}\r\n\r\n\r\nclass subset\r\n{\r\n    public:\r\n    int parent;\r\n    int rank;\r\n};\r\n\r\n\r\n\r\n\r\nint find(subset subsets[], int i)\r\n{\r\n    if (subsets[i].parent != i)\r\n        subsets[i].parent = find(subsets, subsets[i].parent);\r\n\r\n\r\n    return subsets[i].parent;\r\n}\r\n\r\n\r\n\r\n\r\nvoid Union(subset subsets[], int x, int y)\r\n{\r\n    int xroot = find(subsets, x);\r\n    int yroot = find(subsets, y);\r\n\r\n\r\n\r\n\r\n    if (subsets[xroot].rank < subsets[yroot].rank)\r\n        subsets[xroot].parent = yroot;\r\n    else if (subsets[xroot].rank > subsets[yroot].rank)\r\n        subsets[yroot].parent = xroot;\r\n\r\n\r\n    else\r\n    {\r\n        subsets[yroot].parent = xroot;\r\n        subsets[xroot].rank++;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\nint myComp(const void* a, const void* b)\r\n{\r\n    Edge* a1 = (Edge*)a;\r\n    Edge* b1 = (Edge*)b;\r\n    return a1->weight > b1->weight;\r\n}\r\n\r\n\r\n\r\n\r\nvoid KruskalMST(Graph* graph)\r\n{\r\n    int V = graph->V;\r\n    Edge result[V];\r\n    int e = 0;\r\n    int i = 0;\r\n\r\n\r\n    qsort(graph->edge, graph->E, sizeof(graph->edge[0]), myComp);\r\n\r\n\r\n\r\n\r\n    subset *subsets = new subset[( V * sizeof(subset) )];\r\n\r\n\r\n    for (int v = 0; v < V; ++v)\r\n    {\r\n        subsets[v].parent = v;\r\n        subsets[v].rank = 0;\r\n    }\r\n\r\n\r\n\r\n\r\n    while (e < V - 1 && i < graph->E)\r\n    {\r\n        Edge next_edge = graph->edge[i++];\r\n\r\n\r\n        int x = find(subsets, next_edge.src);\r\n        int y = find(subsets, next_edge.dest);\r\n\r\n\r\n        if (x != y)\r\n        {\r\n            result[e++] = next_edge;\r\n            Union(subsets, x, y);\r\n        }\r\n\r\n\r\n    }\r\n\r\n    for (i = 0; i < e; ++i)\r\n        cout<<result[i].src<<\" --- \"<<result[i].dest<<\" ==> \"<<result[i].weight<<endl;\r\n    return;\r\n}\r\n\r\n\r\n\r\n\r\nint main()\r\n{\r\n    int V = 4;\r\n    int E = 5;\r\n    Graph* graph = createGraph(V, E);\r\n\r\n\r\n    graph->edge[0].src = 0;\r\n    graph->edge[0].dest = 1;\r\n    graph->edge[0].weight = 10;\r\n\r\n\r\n    graph->edge[1].src = 0;\r\n    graph->edge[1].dest = 2;\r\n    graph->edge[1].weight = 6;\r\n\r\n\r\n\r\n\r\n    graph->edge[2].src = 0;\r\n    graph->edge[2].dest = 3;\r\n    graph->edge[2].weight = 5;\r\n\r\n\r\n\r\n\r\n    graph->edge[3].src = 1;\r\n    graph->edge[3].dest = 3;\r\n    graph->edge[3].weight = 15;\r\n\r\n\r\n\r\n\r\n    graph->edge[4].src = 2;\r\n    graph->edge[4].dest = 3;\r\n    graph->edge[4].weight = 4;\r\n\r\n\r\n    KruskalMST(graph);\r\n\r\n\r\n    return 0;\r\n}', 1000, '', '', '﻿1. Sort all the edges in non-decreasing order of their weight.\r\n2. Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If a cycle is not formed, include this edge. Else, discard it.\r\n3. Repeat step#2 until there are (V-1) edges in the spanning tree.', '2020-05-25'),
(527, 13, 6301012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n\r\nint minKey(int V,int key[], bool mstSet[]) \r\n{ \r\n	int min = INT_MAX, min_index; \r\n	for (int v = 1; v <= V; v++) \r\n		if (mstSet[v] == false && key[v] < min) \r\n			min = key[v], min_index = v; \r\n\r\n	return min_index; \r\n} \r\n\r\n\r\nvoid printMST(int V,int parent[], int graph[100][100]) \r\n{ \r\n	 \r\n	int sum=0;\r\n	for (int i = 1; i <= V; i++) \r\n	{sum+=graph[i][parent[i]];\r\n		 }\r\n		cout<<sum<<endl;\r\n} \r\n\r\n\r\nvoid primMST(int V,int graph[100][100]) \r\n{ \r\n	 \r\n	int parent[V+1]; \r\n	int key[V+1]; \r\n	bool mstSet[V+1]; \r\n\r\n	for (int i = 1; i <= V; i++) \r\n		key[i] = INT_MAX, mstSet[i] = false; \r\n\r\n	key[1] = 0; \r\n	parent[1] = -1;  \r\n	for (int count = 1; count < V; count++) \r\n	{ \r\n		int u = minKey(V,key, mstSet);\r\n		mstSet[u] = true; \r\n		for (int v = 1; v <= V; v++) \r\n			if (graph[u][v] && mstSet[v] == false && graph[u][v] < key[v]) \r\n				parent[v] = u, key[v] = graph[u][v]; \r\n	} \r\n	printMST( V,parent, graph); \r\n} \r\n\r\n\r\nint main() \r\n{ \r\n	\r\nint V,E;\r\ncin>>V;\r\ncin>>E;\r\n\r\nint graph[100][100];\r\n	\r\n      for(int i=0;i<=V;i++)\r\n       for(int j=0;j<=V;j++)\r\n        {\r\n        graph[i][j]=0;\r\n       }\r\n       int a,b,w;\r\n      for(int i=0;i<E;i++)\r\n       {\r\n       cin>>a>>b>>w;\r\n       graph[a][b]=w;\r\n       graph[b][a]=w;\r\n       }\r\n	primMST(V,graph); \r\n\r\n	return 0; \r\n} ', 1000, '', '', '﻿1. Associate with each vertex v of the graph a number C[v] (the cheapest cost of a connection to v) and an edge E[v] (the edge providing that cheapest connection). To initialize these values, set all values of C[v] to +∞ (or to any number larger than the maximum edge weight) and set each E[v] to a special flag value indicating that there is no edge connecting v to earlier vertices.\r\n2. Initialize an empty forest F and a set Q of vertices that have not yet been included in F (initially, all vertices).\r\n3. Repeat the following steps until Q is empty:\r\n   1. Find and remove a vertex v from Q having the minimum possible value of C[v]\r\n   2. Add v to F and, if E[v] is not the special flag value, also add E[v] to F\r\n   3. Loop over the edges vw connecting v to other vertices w. For each such edge, if w still belongs to Q and vw has smaller weight than C[w], perform the following steps:\r\n      1. Set C[w] to the cost of edge vw\r\n      2. Set E[w] to point to edge vw.\r\n4. Return F', '2020-05-25'),
(528, 14, 6301012018, '﻿#include <bits/stdc++.h>\r\nstruct Edge {\r\n    int src, dest, weight;\r\n};\r\nstruct Graph {\r\n       int V, E;\r\n      struct Edge* edge;\r\n};\r\nstruct Graph* createGraph(int V, int E)\r\n{\r\n    struct Graph* graph = new Graph;\r\n    graph->V = V;\r\n    graph->E = E;\r\n    graph->edge = new Edge[E];\r\n    return graph;\r\n}\r\nvoid printArr(int dist[], int n)\r\n{\r\n    printf(\"Vertex   Distance from Source\n\");\r\n    for (int i = 0; i < n; ++i)\r\n        printf(\"%d 		 %d\n\", i, dist[i]);\r\n}\r\nvoid BellmanFord(struct Graph* graph, int src)\r\n{\r\n    int V = graph->V;\r\n    int E = graph->E;\r\n    int dist[V];\r\n      for (int i = 0; i < V; i++)\r\n        dist[i] = INT_MAX;\r\n    dist[src] = 0;\r\n      for (int i = 1; i <= V - 1; i++) {\r\n        for (int j = 0; j < E; j++) {\r\n            int u = graph->edge[j].src;\r\n            int v = graph->edge[j].dest;\r\n            int weight = graph->edge[j].weight;\r\n            if (dist[u] != INT_MAX && dist[u] + weight < dist[v])\r\n                dist[v] = dist[u] + weight;\r\n        }\r\n    }\r\n      for (int i = 0; i < E; i++) {\r\n        int u = graph->edge[i].src;\r\n        int v = graph->edge[i].dest;\r\n        int weight = graph->edge[i].weight;\r\n        if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {\r\n            printf(\"Graph contains negative weight cycle\");\r\n            return; // If negative cycle is detected, simply return\r\n        }\r\n    }\r\n    printArr(dist, V);\r\n    return;\r\n}\r\n  \r\nint main()\r\n{\r\n    int V = 5; // Number of vertices in graph\r\n    int E = 8; // Number of edges in graph\r\n    struct Graph* graph = createGraph(V, E);\r\n \r\n    graph->edge[0].src = 0;\r\n    graph->edge[0].dest = 1;\r\n    graph->edge[0].weight = -1;\r\n    graph->edge[1].src = 0;\r\n    graph->edge[1].dest = 2;\r\n    graph->edge[1].weight = 4;\r\n    graph->edge[2].src = 1;\r\n    graph->edge[2].dest = 2;\r\n    graph->edge[2].weight = 3;\r\n    graph->edge[3].src = 1;\r\n    graph->edge[3].dest = 3;\r\n    graph->edge[3].weight = 2;\r\n    graph->edge[4].src = 1;\r\n    graph->edge[4].dest = 4;\r\n    graph->edge[4].weight = 2;\r\n    graph->edge[5].src = 3;\r\n    graph->edge[5].dest = 2;\r\n    graph->edge[5].weight = 5;\r\n  \r\n \r\n    graph->edge[6].src = 3;\r\n    graph->edge[6].dest = 1;\r\n    graph->edge[6].weight = 1;\r\n    graph->edge[7].src = 4;\r\n    graph->edge[7].dest = 3;\r\n    graph->edge[7].weight = -3;\r\n  \r\n    BellmanFord(graph, 0);\r\n  \r\n    return 0;\r\n}', 1000, '', '', '﻿function BellmanFord(list vertices, list edges, vertex source) is\r\n    ::distance[], predecessor[]\r\n\r\n\r\n    // This implementation takes in a graph, represented as\r\n    // lists of vertices and edges, and fills two arrays\r\n    // (distance and predecessor) about the shortest path\r\n    // from the source to each vertex\r\n\r\n\r\n    // Step 1: initialize graph\r\n    for each vertex v in vertices do\r\n        distance[v] := inf             // Initialize the distance to all vertices to infinity\r\n        predecessor[v] := null         // And having a null predecessor\r\n    \r\n    distance[source] := 0              // The distance from the source to itself is, of course, zero\r\n    // Step 2: relax edges repeatedly\r\n    for i from 1 to size(vertices)−1 do //just |V|−1 repetitions; i is never referenced\r\n        for each edge (u, v) with weight w in edges do\r\n            if distance[u] + w < distance[v] then\r\n                distance[v] := distance[u] + w\r\n                predecessor[v] := u\r\n\r\n\r\n    // Step 3: check for negative-weight cycles\r\n    for each edge (u, v) with weight w in edges do\r\n        if distance[u] + w < distance[v] then\r\n            error \"Graph contains a negative-weight cycle\"\r\n\r\n\r\n    return distance[], predecessor[]', '2020-05-25'),
(529, 15, 6301012018, '﻿#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\n\r\nint MatrixChainOrder(int p[], int n)\r\n{\r\n\r\n\r\n    int m[n][n];\r\n\r\n\r\n    int i, j, k, L, q;\r\n\r\n\r\n\r\n\r\n    for (i = 1; i < n; i++)\r\n        m[i][i] = 0;\r\n\r\n\r\n    for (L = 2; L < n; L++)\r\n    {\r\n        for (i = 1; i < n - L + 1; i++)\r\n        {\r\n            j = i + L - 1;\r\n            m[i][j] = INT_MAX;\r\n            for (k = i; k <= j - 1; k++)\r\n            {\r\n\r\n\r\n                q = m[i][k] + m[k + 1][j] +\r\n                    p[i - 1] * p[k] * p[j];\r\n                if (q < m[i][j])\r\n                    m[i][j] = q;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    return m[1][n - 1];\r\n}\r\n\r\n\r\n\r\n\r\nint main()\r\n{\r\n    int n; cin>>n;\r\n    int* arr = new int[n];\r\n    for(int i = 0; i < n; i++)\r\n        cin>>arr[i];\r\n\r\n\r\n    int size = n;\r\n       cout<< MatrixChainOrder(arr, size);\r\n\r\n\r\n    getchar();\r\n    return 0;\r\n}', 1000, '', '', '﻿In general, we can find the minimum cost using the following recursive algorithm:\r\n* Take the sequence of matrices and separate it into two subsequences.\r\n* Find the minimum cost of multiplying out each subsequence.\r\n* Add these costs together, and add in the cost of multiplying the two result matrices.\r\n* Do this for each possible position at which the sequence of matrices can be split, and take the minimum over all of them.\r\n\r\n\r\nMatrixChainOrder(int dims[])\r\n{\r\n    // length[dims] = n + 1\r\n    n = dims.length - 1;\r\n    // m[i,j] = Minimum number of scalar multiplications (i.e., cost)\r\n    // needed to compute the matrix A[i]A[i+1]...A[j] = A[i..j]\r\n    // The cost is zero when multiplying one matrix\r\n    for (i = 1; i <= n; i++)\r\n        m[i, i] = 0;\r\n\r\n\r\n    for (len = 2; len <= n; len++) { // Subsequence lengths\r\n        for (i = 1; i <= n - len + 1; i++) {\r\n            j = i + len - 1;\r\n            m[i, j] = MAXINT;\r\n            for (k = i; k <= j - 1; k++) {\r\n                cost = m[i, k] + m[k+1, j] + dims[i-1]*dims[k]*dims[j];\r\n                if (cost < m[i, j]) {\r\n                    m[i, j] = cost;\r\n                    s[i, j] = k; // Index of the subsequence split that achieved minimal cost\r\n                }\r\n            }\r\n        }\r\n    }\r\n}', '2020-05-25'),
(530, 8, 6301012018, '#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint nextpowerof2(int k)\n{\n    return pow(2, int(ceil(log2(k))));\n}\nvoid display(vector< vector<int>> &matrix, int m, int n)\n{\n    for (int i = 0; i < m; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (j != 0)\n            {\n                cout <<\" \";\n            }\n            cout << matrix[i][j];\n        }\n        cout << endl;\n    }\n}\n\nvoid add(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n    int i, j;\n\n    for (i = 0; i < size; i++)\n    {\n        for (j = 0; j < size; j++)\n        {\n            C[i][j] = A[i][j] + B[i][j];\n        }\n    }\n}\n\nvoid sub(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n    int i, j;\n\n    for (i = 0; i < size; i++)\n    {\n        for (j = 0; j < size; j++)\n        {\n            C[i][j] = A[i][j] - B[i][j];\n        }\n    }\n}\n\nvoid STRASSEN_algorithmA(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n    if (size == 1)\n    {\n        C[0][0] = A[0][0] * B[0][0];\n        return;\n    }\n    else\n    {\n        int new_size = size / 2;\n        vector<int> z(new_size);\n        vector<vector<int>>\n            a11(new_size, z), a12(new_size, z), a21(new_size, z), a22(new_size, z),\n            b11(new_size, z), b12(new_size, z), b21(new_size, z), b22(new_size, z),\n            c11(new_size, z), c12(new_size, z), c21(new_size, z), c22(new_size, z),\n            p1(new_size, z), p2(new_size, z), p3(new_size, z), p4(new_size, z),\n            p5(new_size, z), p6(new_size, z), p7(new_size, z),\n            aResult(new_size, z), bResult(new_size, z);\n\nint i, j;\nfor (i = 0; i < new_size; i++)\n        {\n            for (j = 0; j < new_size; j++)\n            {\n                a11[i][j] = A[i][j];\n                a12[i][j] = A[i][j + new_size];\n                a21[i][j] = A[i + new_size][j];\n                a22[i][j] = A[i + new_size][j + new_size];\n\n                b11[i][j] = B[i][j];\n                b12[i][j] = B[i][j + new_size];\n                b21[i][j] = B[i + new_size][j];\n                b22[i][j] = B[i + new_size][j + new_size];\n            }\n}\n\n        add(a11, a22, aResult, new_size);\n        add(b11, b22, bResult, new_size);\n        STRASSEN_algorithmA(aResult, bResult, p1, new_size);\n\n        add(a21, a22, aResult, new_size);\n        STRASSEN_algorithmA(aResult, b11, p2, new_size);\n\n        sub(b12, b22, bResult, new_size);\n        STRASSEN_algorithmA(a11, bResult, p3, new_size);\n\n\n        sub(b21, b11, bResult, new_size);\n        STRASSEN_algorithmA(a22, bResult, p4, new_size);\n        add(a11, a12, aResult, new_size);\n        STRASSEN_algorithmA(aResult, b22, p5, new_size);\n\n        sub(a21, a11, aResult, new_size);\n        add(b11, b12, bResult, new_size);\n        STRASSEN_algorithmA(aResult, bResult, p6, new_size);\n\n        sub(a12, a22, aResult, new_size);\n        add(b21, b22, bResult, new_size);\n        STRASSEN_algorithmA(aResult, bResult, p7, new_size);\n\n        add(p3, p5, c12, new_size);\n        add(p2, p4, c21, new_size);\n\n        add(p1, p4, aResult, new_size);\n        add(aResult, p7, bResult, new_size);\n        sub(bResult, p5, c11, new_size);\n\n        add(p1, p3, aResult, new_size);\n        add(aResult, p6, bResult, new_size);\n        sub(bResult, p2, c22, new_size);\n        for (i = 0; i < new_size; i++)\n        {\n            for (j = 0; j < new_size; j++)\n            {\n                C[i][j] = c11[i][j];\n                C[i][j + new_size] = c12[i][j];\n                C[i + new_size][j] = c21[i][j];\n                C[i + new_size][j + new_size] = c22[i][j];\n            }\n        }\n    }\n}\nvoid STRASSEN_algorithm(vector<vector<int>> &A, vector<vector<int>> &B, int m, int n, int a, int b)\n{\n    int k = max({m, n, a, b});\n\n    int s = nextpowerof2(k);\n\n    vector<int> z(s);\n    vector<vector<int>> Aa(s, z), Bb(s, z), Cc(s, z);\n\n    for (unsigned int i = 0; i < m; i++)\n    {\n        for (unsigned int j = 0; j < n; j++)\n        {\n            Aa[i][j] = A[i][j];\n        }\n    }\n    for (unsigned int i = 0; i < a; i++)\n    {\n        for (unsigned int j = 0; j < b; j++)\n        {\n            Bb[i][j] = B[i][j];\n        }\n    }\n    STRASSEN_algorithmA(Aa, Bb, Cc, s);\n    vector<int> temp1(b);\n    vector<vector<int>> C(m, temp1);\n    for (unsigned int i = 0; i < m; i++)\n    {\n        for (unsigned int j = 0; j < b; j++)\n        {\n            C[i][j] = Cc[i][j];\n        }\n    }\n    display(C, m, b);\n}\n\nbool check(int n, int a)\n{\n    if (n == a)\n        return true;\n    else\n        return false;\n}\n\nint main()\n{\n    int n, a, b;\n    cin >> n;\n\n    vector<vector<int>> A;\n    for (int i = 0; i < n; i++)\n    {\n        vector<int> temp;\n        for (int j = 0; j < n; j++)\n        {\n            int i;\n            cin >> i;\n            temp.push_back(i);\n        }\n        A.push_back(temp);\n    }\n\n    vector<vector<int>> B;\n    for (int i = 0; i < n; i++)\n    {\n        vector<int> temp;\n        for (int j = 0; j < n; j++)\n        {\n            int i;\n            cin >> i;\n            temp.push_back(i);\n        }\n        B.push_back(temp);\n    }\n\n\n        STRASSEN_algorithm(A, B, n, n, n, n);\n\n    return 0;\n}\n\n', 0, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '', '1)Divide matrices A and B in 4 sub-matrices of size N/2 x N/2. \r\n2)Calculate the 7 matrix multiplications recursively.\r\n3)Compute the submatricies of C.\r\n4)Combine these submatricies into our new matrix C', '2020-05-25'),
(531, 5, 6301012018, '#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nint nextpowerof2(int k)\n{\n    return pow(2, int(ceil(log2(k))));\n}\nvoid display(vector< vector<int>> &matrix, int m, int n)\n{\n    for (int i = 0; i < m; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (j != 0)\n            {\n                cout << \"	\";\n            }\n            cout << matrix[i][j];\n        }\n        cout << endl;\n    }\n}\n\nvoid add(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n    int i, j;\n\n    for (i = 0; i < size; i++)\n    {\n        for (j = 0; j < size; j++)\n        {\n            C[i][j] = A[i][j] + B[i][j];\n        }\n    }\n}\n\nvoid sub(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n    int i, j;\n\n    for (i = 0; i < size; i++)\n    {\n        for (j = 0; j < size; j++)\n        {\n            C[i][j] = A[i][j] - B[i][j];\n        }\n    }\n}\n\nvoid STRASSEN_algorithmA(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n   \n    if (size == 1)\n    {\n        C[0][0] = A[0][0] * B[0][0];\n        return;\n    }\n    else\n    {\n        int new_size = size / 2;\n        vector<int> z(new_size);\n        vector<vector<int>>\n            a11(new_size, z), a12(new_size, z), a21(new_size, z), a22(new_size, z),\n            b11(new_size, z), b12(new_size, z), b21(new_size, z), b22(new_size, z),\n            c11(new_size, z), c12(new_size, z), c21(new_size, z), c22(new_size, z),\n            p1(new_size, z), p2(new_size, z), p3(new_size, z), p4(new_size, z),\n            p5(new_size, z), p6(new_size, z), p7(new_size, z),\n            aResult(new_size, z), bResult(new_size, z);\n\nint i, j;\n\nfor (i = 0; i < new_size; i++)\n        {\n            for (j = 0; j < new_size; j++)\n            {\n                a11[i][j] = A[i][j];\n                a12[i][j] = A[i][j + new_size];\n                a21[i][j] = A[i + new_size][j];\n                a22[i][j] = A[i + new_size][j + new_size];\n\n                b11[i][j] = B[i][j];\n                b12[i][j] = B[i][j + new_size];\n                b21[i][j] = B[i + new_size][j];\n                b22[i][j] = B[i + new_size][j + new_size];\n            }\n}\n\n\n        add(a11, a22, aResult, new_size);    \n        add(b11, b22, bResult, new_size);    \n        STRASSEN_algorithmA(aResult, bResult, p1, new_size); \n\n        add(a21, a22, aResult, new_size); \n        STRASSEN_algorithmA(aResult, b11, p2, new_size);\n\n        sub(b12, b22, bResult, new_size);      \n        STRASSEN_algorithmA(a11, bResult, p3, new_size);\n\n        sub(b21, b11, bResult, new_size);     \n        STRASSEN_algorithmA(a22, bResult, p4, new_size); \n\n        add(a11, a12, aResult, new_size);     \n        STRASSEN_algorithmA(aResult, b22, p5, new_size);\n\n        sub(a21, a11, aResult, new_size);      \n        add(b11, b12, bResult, new_size);               \n      \n        STRASSEN_algorithmA(aResult, bResult, p6, new_size);\n\n        sub(a12, a22, aResult, new_size);      \n        add(b21, b22, bResult, new_size);                \n        \n        STRASSEN_algorithmA(aResult, bResult, p7, new_size);\n        \n\n        add(p3, p5, c12, new_size); \n        add(p2, p4, c21, new_size); \n\n        add(p1, p4, aResult, new_size);      \n        add(aResult, p7, bResult, new_size); \n        sub(bResult, p5, c11, new_size); \n\n        add(p1, p3, aResult, new_size);     \n        add(aResult, p6, bResult, new_size);  \n        sub(bResult, p2, c22, new_size); \n\n        for (i = 0; i < new_size; i++)\n        {\n            for (j = 0; j < new_size; j++)\n            {\n                C[i][j] = c11[i][j];\n                C[i][j + new_size] = c12[i][j];\n                C[i + new_size][j] = c21[i][j];\n                C[i + new_size][j + new_size] = c22[i][j];\n            }\n        }\n    }\n}\nvoid STRASSEN_algorithm(vector<vector<int>> &A, vector<vector<int>> &B, int m, int n, int a, int b)\n{  \n    int k = max({m, n, a, b});\n\n    int s = nextpowerof2(k);\n\n    vector<int> z(s);\n    vector<vector<int>> Aa(s, z), Bb(s, z), Cc(s, z);\n\n    for (unsigned int i = 0; i < m; i++)\n    {\n        for (unsigned int j = 0; j < n; j++)\n        {\n            Aa[i][j] = A[i][j];\n        }\n    }\n    for (unsigned int i = 0; i < a; i++)\n    {\n        for (unsigned int j = 0; j < b; j++)\n        {\n            Bb[i][j] = B[i][j];\n        }\n    }\n    STRASSEN_algorithmA(Aa, Bb, Cc, s);\n    vector<int> temp1(b);\n    vector<vector<int>> C(m, temp1);\n    for (unsigned int i = 0; i < m; i++)\n    {\n        for (unsigned int j = 0; j < b; j++)\n        {\n            C[i][j] = Cc[i][j];\n        }\n    }\n    display(C, m, b);\n}\n\nbool check(int n, int a)\n{\n    if (n == a)\n        return true;\n    else\n        return false;\n}\n\nint main()\n{\n    \n   int m=3;\n   int n=3;\n   int a=3;\n   int b=3;\n   \n    vector<vector<int>> A{ { 1, 2, 3 }, \n                               { 4, 5, 6 }, \n                               { 7, 8, 9 } }; \n  \n   \n   \n    \n    vector<vector<int>> B{{1,1,2},\n                            {1,3,4},\n                            {2,3,1}};\n    \n    \n    \n     display(A,3,3);\n     cout<<endl;\n     display(B,3,3);\n   \n    bool k = check(n, a);\n    if (k)\n    {\n        cout<<\"ANS\"<<endl; STRASSEN_algorithm(A, B, m, n, a, b);\n    }\n    else\n    {\n        cout << \"CANNOT MULTIPLY\";\n    }\n    return 0;\n}\n\n\n', 1000, '', '', 'function Strassen(M,N)\r\nif M is 1 ? 1 then\r\nreturn M11N11\r\nend if\r\nLet M =  A B\r\n         C D \r\nand N =  E F\r\n         G H \r\nSet S1 = Strassen(B - D, G + H)\r\nSet S2 = Strassen(A + D, E + H)\r\nSet S3 = Strassen(A - C, E + F)\r\nSet S4 = Strassen(A + B, H)\r\nSet S5 = Strassen(A, F - H)\r\nSet S6 = Strassen(D, G - E)\r\nSet S7 = Strassen(C + D, E)\r\nreturn (\r\nS1 + S2 - S4 + S6    S4 + S5\r\nS6 + S7              S2 - S3 + S5 - S7\r\n)\r\nend function\r\n', '2020-05-25'),
(532, 16, 6301012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n\r\n#define d 256 \r\n\r\nvoid search(char pat[], char txt[],int q) \r\n{ \r\n	int M = strlen(pat); \r\n	int N = strlen(txt); \r\n	int i, j; \r\n	int p = 0; \r\n	int t = 0;  \r\n	int h = 1; \r\n\r\n	for (i = 0; i < M - 1; i++) \r\n		h = (h * d) % q; \r\n\r\n	for (i = 0; i < M; i++) \r\n	{ \r\n		p = (d * p + pat[i]) % q; \r\n		t = (d * t + txt[i]) % q; \r\n	} \r\n\r\n	for (i = 0; i <= N - M; i++) \r\n	{ \r\n		if ( p == t ) \r\n		{ \r\n			for (j = 0; j < M; j++) \r\n			{ \r\n				if (txt[i+j] != pat[j]) \r\n					break; \r\n			} \r\n\r\n			if (j == M) \r\n				cout<<\"Pattern found at index \"<< i<<endl; \r\n		} \r\n\r\n		if ( i < N-M ) \r\n		{ \r\n			t = (d*(t - txt[i]*h) + txt[i+M])%q; \r\n\r\n			if (t < 0) \r\n			t = (t + q); \r\n		} \r\n	} \r\n} \r\n\r\nint main() \r\n{ \r\n	char txt[100000];\r\n        cin>>txt;\r\n	char pat[100000];\r\n        cin>>pat;\r\n	int q = 101;  \r\n	search(pat, txt, q); \r\n	return 0; \r\n} \r\n\r\n', 1000, '', '', '\r\n// Rabin Karp Algorithm\r\n\r\nfunction RabinKarp(string s[1..n], string pattern[1..m])\r\n    hpattern := hash(pattern[1..m]);\r\n    for i from 1 to n-m+1\r\n        hs := hash(s[i..i+m-1])\r\n        if hs = hpattern\r\n            if s[i..i+m-1] = pattern[1..m]\r\n                return i\r\n    return not found', '2020-05-25');
INSERT INTO `qtos_map` (`ID`, `Q_ID`, `ROLL`, `SUBMISSION`, `SCORE`, `INPUT`, `OP`, `ALGO`, `DATE`) VALUES
(533, 3, 6401012018, '#include <bits/stdc++.h> \r\nusing namespace std;  \r\n  \r\n// A utility function to swap two elements  \r\nvoid swap(int* a, int* b)  \r\n{  \r\n    int t = *a;  \r\n    *a = *b;  \r\n    *b = t;  \r\n}  \r\n  \r\n\r\nint partition (int arr[], int low, int high)  \r\n{  \r\n    int pivot = arr[high]; // pivot  \r\n    int i = (low - 1); // Index of smaller element  \r\n  \r\n    for (int j = low; j <= high - 1; j++)  \r\n    {  \r\n        // If current element is smaller than the pivot  \r\n        if (arr[j] < pivot)  \r\n        {  \r\n            i++; // increment index of smaller element  \r\n            swap(&arr[i], &arr[j]);  \r\n        }  \r\n    }  \r\n    swap(&arr[i + 1], &arr[high]);  \r\n    return (i + 1);  \r\n}  \r\n \r\nvoid quickSort(int arr[], int low, int high)  \r\n{  \r\n    if (low < high)  \r\n    {  \r\n       \r\n        int pi = partition(arr, low, high);  \r\n  \r\n        quickSort(arr, low, pi - 1);  \r\n        quickSort(arr, pi + 1, high);  \r\n    }  \r\n}  \r\n  \r\nvoid printArray(int arr[], int size)  \r\n{  \r\n    int i;  \r\n    for (i = 0; i < size; i++)  \r\n        cout << arr[i] << \" \";  \r\n\r\n}  \r\n  \r\n// Driver Code \r\nint main()  \r\n{  \r\n\r\n	int n;\r\n	cin>>n;\r\n	int arr[n];\r\n	for(int i=0;i<n;i++)\r\n	{\r\n	cin>>arr[i];\r\n	} \r\n    quickSort(arr, 0, n - 1);  \r\n    printArray(arr, n);  \r\n    return 0;  \r\n}', 10, '1 2000', '2000 ', 'quickSort(arr[], low, high)\r\n{\r\n	if (low < high)\r\n	{\r\n    	\r\n    	pi = partition(arr, low, high);\r\n \r\n    	quickSort(arr, low, pi - 1);  // Before pi\r\n    	quickSort(arr, pi + 1, high); // After pi\r\n	}\r\n}\r\nPseudo code for partition()\r\n \r\npartition (arr[], low, high)\r\n{\r\n    	pivot = arr[high]; \r\n \r\n	i = (low – 1)\r\n	for (j = low; j <= high- 1; j++)\r\n	{\r\n            	if (arr[j] < pivot)\r\n    	{\r\n        	i++;	\r\n        	swap arr[i] and arr[j]\r\n    	}\r\n	}\r\n	swap arr[i + 1] and arr[high])\r\n	return (i + 1)\r\n}\r\n', '2020-05-25'),
(534, 9, 6401012018, '#include <iostream> \nusing namespace std; \nclass createset { \n	int *rank, *parent, n; \n\npublic: \n\n	void makeset() \n	{ \n		for(int i=0;i<n;i++)\n                 {\n                  parent[i]=i;	} \n}\n\n	createset(int n) \n	{ \n		rank = new int[n]; \n		parent = new int[n]; \n		this->n = n; \n		makeset(); \n	} \n\n\n\n	int findset(int x) \n	{ \n		if (parent[x] != x) { \n			parent[x] = findset(parent[x]); \n		} \n\n		return parent[x]; \n	} \n\n\n	void mergeset(int x, int y) \n	{ \n		int xset = findset(x); \n		int yset = findset(y); \n\n		if (xset == yset) \n			return; \n\n		if (rank[xset] < rank[yset]) { \n			parent[xset] = yset; \n		} \n		else if (rank[xset] > rank[yset]) { \n			parent[yset] = xset; \n		} \n\n		else { \n			parent[yset] = xset; \n			rank[xset] = rank[xset] + 1; \n		} \n	} \n}; \n\nint main() \n{ \n    \n	createset obj(6);\n	\n	obj.mergeset(4,5);\n	obj.mergeset(0, 2); \n	obj.mergeset(5, 3); \n	obj.mergeset(3, 1);\n	\n	if (obj.findset(4) == obj.findset(5)) \n		cout << \"Yes\n\"; \n	else\n		cout << \"No\n\"; \n	if (obj.findset(1) == obj.findset(3)) \n		cout << \"Yes\n\"; \n	else\n		cout << \"No\n\"; \n\n	return 0; \n} \n\n', 1000, '', '', 'function MakeSet(x)\r\n   x.parent = x\r\n\r\nfunction Find(x)\r\n   if x.parent == x\r\n      return x\r\n   else\r\n      return Find(x.parent)\r\n\r\nfunction Union(x,y)\r\n   xRoot = Find(x)\r\n   yRoot = Find(y)\r\n   xRoot.parent = yRoot', '2020-05-25'),
(535, 10, 6401012018, '﻿\r\n#include<iostream>\r\nusing namespace std;\r\n  \r\n \r\nint max(int a, int b) { return (a > b)? a : b; } \r\n  \r\n \r\nint knapSack(int W, int wt[], int val[], int n) \r\n{ \r\n   int i, w; \r\n   int K[n+1][W+1]; \r\n  \r\n \r\n   for (i = 0; i <= n; i++) \r\n   { \r\n       for (w = 0; w <= W; w++) \r\n       { \r\n           if (i==0 || w==0) \r\n               K[i][w] = 0; \r\n           else if (wt[i-1] <= w) \r\n                 K[i][w] = max(val[i-1] + K[i-1][w-wt[i-1]],  K[i-1][w]); \r\n           else\r\n                 K[i][w] = K[i-1][w]; \r\n       } \r\n   } \r\n  \r\n   return K[n][W]; \r\n} \r\n  \r\nint main() \r\n{ \r\n    int n,w;\r\n    cin>>n>>w;\r\n    int val[n];\r\n    int wt[n];\r\n    for(int i=0;i<n;i++)\r\n    {\r\n        cin>>val[i];\r\n    } \r\n    for(int i=0;i<n;i++)\r\n    {\r\n        cin>>wt[i];\r\n    } \r\n\r\n    cout<<knapSack(w, wt, val, n); \r\n    return 0; \r\n} ', 10, '5 15 4 2 1 2 10 12 2 1 1 4', '15', '﻿An efficient solution is to use the Greedy approach. The basic idea of the greedy approach is to calculate the ratio value/weight for each item and sort the item on the basis of this ratio. Then take the item with the highest ratio and add them until we can’t add the next item as a whole and at the end add the next item as much as we can. Which will always be the optimal solution to this problem.\r\n\r\n\r\nAlgorithm: Greedy-Fractional-Knapsack (w[1..n], p[1..n], W) \r\nfor i = 1 to n \r\n   do x[i] = 0 \r\nweight = 0 \r\nfor i = 1 to n \r\n   if weight + w[i] ≤ W then  \r\n      x[i] = 1 \r\n      weight = weight + w[i] \r\n   else \r\n      x[i] = (W - weight) / w[i] \r\n      weight = W \r\n      break \r\nreturn x', '2020-05-25'),
(536, 12, 6401012018, '﻿#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n\r\nclass Edge\r\n{\r\n    public:\r\n    int src, dest, weight;\r\n};\r\n\r\n\r\nclass Graph\r\n{\r\n    public:\r\n\r\n\r\n    int V, E;\r\n\r\n\r\n    Edge* edge;\r\n};\r\n\r\n\r\n\r\n\r\nGraph* createGraph(int V, int E)\r\n{\r\n    Graph* graph = new Graph;\r\n    graph->V = V;\r\n    graph->E = E;\r\n\r\n\r\n    graph->edge = new Edge[E];\r\n\r\n\r\n    return graph;\r\n}\r\n\r\n\r\nclass subset\r\n{\r\n    public:\r\n    int parent;\r\n    int rank;\r\n};\r\n\r\n\r\n\r\n\r\nint find(subset subsets[], int i)\r\n{\r\n    if (subsets[i].parent != i)\r\n        subsets[i].parent = find(subsets, subsets[i].parent);\r\n\r\n\r\n    return subsets[i].parent;\r\n}\r\n\r\n\r\n\r\n\r\nvoid Union(subset subsets[], int x, int y)\r\n{\r\n    int xroot = find(subsets, x);\r\n    int yroot = find(subsets, y);\r\n\r\n\r\n\r\n\r\n    if (subsets[xroot].rank < subsets[yroot].rank)\r\n        subsets[xroot].parent = yroot;\r\n    else if (subsets[xroot].rank > subsets[yroot].rank)\r\n        subsets[yroot].parent = xroot;\r\n\r\n\r\n    else\r\n    {\r\n        subsets[yroot].parent = xroot;\r\n        subsets[xroot].rank++;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\nint myComp(const void* a, const void* b)\r\n{\r\n    Edge* a1 = (Edge*)a;\r\n    Edge* b1 = (Edge*)b;\r\n    return a1->weight > b1->weight;\r\n}\r\n\r\n\r\n\r\n\r\nvoid KruskalMST(Graph* graph)\r\n{\r\n    int V = graph->V;\r\n    Edge result[V];\r\n    int e = 0;\r\n    int i = 0;\r\n\r\n\r\n    qsort(graph->edge, graph->E, sizeof(graph->edge[0]), myComp);\r\n\r\n\r\n\r\n\r\n    subset *subsets = new subset[( V * sizeof(subset) )];\r\n\r\n\r\n    for (int v = 0; v < V; ++v)\r\n    {\r\n        subsets[v].parent = v;\r\n        subsets[v].rank = 0;\r\n    }\r\n\r\n\r\n\r\n\r\n    while (e < V - 1 && i < graph->E)\r\n    {\r\n        Edge next_edge = graph->edge[i++];\r\n\r\n\r\n        int x = find(subsets, next_edge.src);\r\n        int y = find(subsets, next_edge.dest);\r\n\r\n\r\n        if (x != y)\r\n        {\r\n            result[e++] = next_edge;\r\n            Union(subsets, x, y);\r\n        }\r\n\r\n\r\n    }\r\n\r\n    for (i = 0; i < e; ++i)\r\n        cout<<result[i].src<<\" --- \"<<result[i].dest<<\" ==> \"<<result[i].weight<<endl;\r\n    return;\r\n}\r\n\r\n\r\n\r\n\r\nint main()\r\n{\r\n    int V = 4;\r\n    int E = 5;\r\n    Graph* graph = createGraph(V, E);\r\n\r\n\r\n    graph->edge[0].src = 0;\r\n    graph->edge[0].dest = 1;\r\n    graph->edge[0].weight = 10;\r\n\r\n\r\n    graph->edge[1].src = 0;\r\n    graph->edge[1].dest = 2;\r\n    graph->edge[1].weight = 6;\r\n\r\n\r\n\r\n\r\n    graph->edge[2].src = 0;\r\n    graph->edge[2].dest = 3;\r\n    graph->edge[2].weight = 5;\r\n\r\n\r\n\r\n\r\n    graph->edge[3].src = 1;\r\n    graph->edge[3].dest = 3;\r\n    graph->edge[3].weight = 15;\r\n\r\n\r\n\r\n\r\n    graph->edge[4].src = 2;\r\n    graph->edge[4].dest = 3;\r\n    graph->edge[4].weight = 4;\r\n\r\n\r\n    KruskalMST(graph);\r\n\r\n\r\n    return 0;\r\n}', 1000, '', '', '﻿1. Sort all the edges in non-decreasing order of their weight.\r\n2. Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If a cycle is not formed, include this edge. Else, discard it.\r\n3. Repeat step#2 until there are (V-1) edges in the spanning tree.', '2020-05-25'),
(537, 13, 6401012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n\r\nint minKey(int V,int key[], bool mstSet[]) \r\n{ \r\n	int min = INT_MAX, min_index; \r\n	for (int v = 1; v <= V; v++) \r\n		if (mstSet[v] == false && key[v] < min) \r\n			min = key[v], min_index = v; \r\n\r\n	return min_index; \r\n} \r\n\r\n\r\nvoid printMST(int V,int parent[], int graph[100][100]) \r\n{ \r\n	 \r\n	int sum=0;\r\n	for (int i = 1; i <= V; i++) \r\n	{sum+=graph[i][parent[i]];\r\n		 }\r\n		cout<<sum<<endl;\r\n} \r\n\r\n\r\nvoid primMST(int V,int graph[100][100]) \r\n{ \r\n	 \r\n	int parent[V+1]; \r\n	int key[V+1]; \r\n	bool mstSet[V+1]; \r\n\r\n	for (int i = 1; i <= V; i++) \r\n		key[i] = INT_MAX, mstSet[i] = false; \r\n\r\n	key[1] = 0; \r\n	parent[1] = -1;  \r\n	for (int count = 1; count < V; count++) \r\n	{ \r\n		int u = minKey(V,key, mstSet);\r\n		mstSet[u] = true; \r\n		for (int v = 1; v <= V; v++) \r\n			if (graph[u][v] && mstSet[v] == false && graph[u][v] < key[v]) \r\n				parent[v] = u, key[v] = graph[u][v]; \r\n	} \r\n	printMST( V,parent, graph); \r\n} \r\n\r\n\r\nint main() \r\n{ \r\n	\r\nint V,E;\r\ncin>>V;\r\ncin>>E;\r\n\r\nint graph[100][100];\r\n	\r\n      for(int i=0;i<=V;i++)\r\n       for(int j=0;j<=V;j++)\r\n        {\r\n        graph[i][j]=0;\r\n       }\r\n       int a,b,w;\r\n      for(int i=0;i<E;i++)\r\n       {\r\n       cin>>a>>b>>w;\r\n       graph[a][b]=w;\r\n       graph[b][a]=w;\r\n       }\r\n	primMST(V,graph); \r\n\r\n	return 0; \r\n} ', 1000, '', '', '﻿1. Associate with each vertex v of the graph a number C[v] (the cheapest cost of a connection to v) and an edge E[v] (the edge providing that cheapest connection). To initialize these values, set all values of C[v] to +∞ (or to any number larger than the maximum edge weight) and set each E[v] to a special flag value indicating that there is no edge connecting v to earlier vertices.\r\n2. Initialize an empty forest F and a set Q of vertices that have not yet been included in F (initially, all vertices).\r\n3. Repeat the following steps until Q is empty:\r\n   1. Find and remove a vertex v from Q having the minimum possible value of C[v]\r\n   2. Add v to F and, if E[v] is not the special flag value, also add E[v] to F\r\n   3. Loop over the edges vw connecting v to other vertices w. For each such edge, if w still belongs to Q and vw has smaller weight than C[w], perform the following steps:\r\n      1. Set C[w] to the cost of edge vw\r\n      2. Set E[w] to point to edge vw.\r\n4. Return F', '2020-05-25'),
(538, 14, 6401012018, '﻿#include <bits/stdc++.h>\r\nstruct Edge {\r\n    int src, dest, weight;\r\n};\r\nstruct Graph {\r\n       int V, E;\r\n      struct Edge* edge;\r\n};\r\nstruct Graph* createGraph(int V, int E)\r\n{\r\n    struct Graph* graph = new Graph;\r\n    graph->V = V;\r\n    graph->E = E;\r\n    graph->edge = new Edge[E];\r\n    return graph;\r\n}\r\nvoid printArr(int dist[], int n)\r\n{\r\n    printf(\"Vertex   Distance from Source\n\");\r\n    for (int i = 0; i < n; ++i)\r\n        printf(\"%d 		 %d\n\", i, dist[i]);\r\n}\r\nvoid BellmanFord(struct Graph* graph, int src)\r\n{\r\n    int V = graph->V;\r\n    int E = graph->E;\r\n    int dist[V];\r\n      for (int i = 0; i < V; i++)\r\n        dist[i] = INT_MAX;\r\n    dist[src] = 0;\r\n      for (int i = 1; i <= V - 1; i++) {\r\n        for (int j = 0; j < E; j++) {\r\n            int u = graph->edge[j].src;\r\n            int v = graph->edge[j].dest;\r\n            int weight = graph->edge[j].weight;\r\n            if (dist[u] != INT_MAX && dist[u] + weight < dist[v])\r\n                dist[v] = dist[u] + weight;\r\n        }\r\n    }\r\n      for (int i = 0; i < E; i++) {\r\n        int u = graph->edge[i].src;\r\n        int v = graph->edge[i].dest;\r\n        int weight = graph->edge[i].weight;\r\n        if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {\r\n            printf(\"Graph contains negative weight cycle\");\r\n            return; // If negative cycle is detected, simply return\r\n        }\r\n    }\r\n    printArr(dist, V);\r\n    return;\r\n}\r\n  \r\nint main()\r\n{\r\n    int V = 5; // Number of vertices in graph\r\n    int E = 8; // Number of edges in graph\r\n    struct Graph* graph = createGraph(V, E);\r\n \r\n    graph->edge[0].src = 0;\r\n    graph->edge[0].dest = 1;\r\n    graph->edge[0].weight = -1;\r\n    graph->edge[1].src = 0;\r\n    graph->edge[1].dest = 2;\r\n    graph->edge[1].weight = 4;\r\n    graph->edge[2].src = 1;\r\n    graph->edge[2].dest = 2;\r\n    graph->edge[2].weight = 3;\r\n    graph->edge[3].src = 1;\r\n    graph->edge[3].dest = 3;\r\n    graph->edge[3].weight = 2;\r\n    graph->edge[4].src = 1;\r\n    graph->edge[4].dest = 4;\r\n    graph->edge[4].weight = 2;\r\n    graph->edge[5].src = 3;\r\n    graph->edge[5].dest = 2;\r\n    graph->edge[5].weight = 5;\r\n  \r\n \r\n    graph->edge[6].src = 3;\r\n    graph->edge[6].dest = 1;\r\n    graph->edge[6].weight = 1;\r\n    graph->edge[7].src = 4;\r\n    graph->edge[7].dest = 3;\r\n    graph->edge[7].weight = -3;\r\n  \r\n    BellmanFord(graph, 0);\r\n  \r\n    return 0;\r\n}', 1000, '', '', '﻿function BellmanFord(list vertices, list edges, vertex source) is\r\n    ::distance[], predecessor[]\r\n\r\n\r\n    // This implementation takes in a graph, represented as\r\n    // lists of vertices and edges, and fills two arrays\r\n    // (distance and predecessor) about the shortest path\r\n    // from the source to each vertex\r\n\r\n\r\n    // Step 1: initialize graph\r\n    for each vertex v in vertices do\r\n        distance[v] := inf             // Initialize the distance to all vertices to infinity\r\n        predecessor[v] := null         // And having a null predecessor\r\n    \r\n    distance[source] := 0              // The distance from the source to itself is, of course, zero\r\n    // Step 2: relax edges repeatedly\r\n    for i from 1 to size(vertices)−1 do //just |V|−1 repetitions; i is never referenced\r\n        for each edge (u, v) with weight w in edges do\r\n            if distance[u] + w < distance[v] then\r\n                distance[v] := distance[u] + w\r\n                predecessor[v] := u\r\n\r\n\r\n    // Step 3: check for negative-weight cycles\r\n    for each edge (u, v) with weight w in edges do\r\n        if distance[u] + w < distance[v] then\r\n            error \"Graph contains a negative-weight cycle\"\r\n\r\n\r\n    return distance[], predecessor[]', '2020-05-25'),
(539, 15, 6401012018, '﻿#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\n\r\nint MatrixChainOrder(int p[], int n)\r\n{\r\n\r\n\r\n    int m[n][n];\r\n\r\n\r\n    int i, j, k, L, q;\r\n\r\n\r\n\r\n\r\n    for (i = 1; i < n; i++)\r\n        m[i][i] = 0;\r\n\r\n\r\n    for (L = 2; L < n; L++)\r\n    {\r\n        for (i = 1; i < n - L + 1; i++)\r\n        {\r\n            j = i + L - 1;\r\n            m[i][j] = INT_MAX;\r\n            for (k = i; k <= j - 1; k++)\r\n            {\r\n\r\n\r\n                q = m[i][k] + m[k + 1][j] +\r\n                    p[i - 1] * p[k] * p[j];\r\n                if (q < m[i][j])\r\n                    m[i][j] = q;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    return m[1][n - 1];\r\n}\r\n\r\n\r\n\r\n\r\nint main()\r\n{\r\n    int n; cin>>n;\r\n    int* arr = new int[n];\r\n    for(int i = 0; i < n; i++)\r\n        cin>>arr[i];\r\n\r\n\r\n    int size = n;\r\n       cout<< MatrixChainOrder(arr, size);\r\n\r\n\r\n    getchar();\r\n    return 0;\r\n}', 1000, '', '', '﻿In general, we can find the minimum cost using the following recursive algorithm:\r\n* Take the sequence of matrices and separate it into two subsequences.\r\n* Find the minimum cost of multiplying out each subsequence.\r\n* Add these costs together, and add in the cost of multiplying the two result matrices.\r\n* Do this for each possible position at which the sequence of matrices can be split, and take the minimum over all of them.\r\n\r\n\r\nMatrixChainOrder(int dims[])\r\n{\r\n    // length[dims] = n + 1\r\n    n = dims.length - 1;\r\n    // m[i,j] = Minimum number of scalar multiplications (i.e., cost)\r\n    // needed to compute the matrix A[i]A[i+1]...A[j] = A[i..j]\r\n    // The cost is zero when multiplying one matrix\r\n    for (i = 1; i <= n; i++)\r\n        m[i, i] = 0;\r\n\r\n\r\n    for (len = 2; len <= n; len++) { // Subsequence lengths\r\n        for (i = 1; i <= n - len + 1; i++) {\r\n            j = i + len - 1;\r\n            m[i, j] = MAXINT;\r\n            for (k = i; k <= j - 1; k++) {\r\n                cost = m[i, k] + m[k+1, j] + dims[i-1]*dims[k]*dims[j];\r\n                if (cost < m[i, j]) {\r\n                    m[i, j] = cost;\r\n                    s[i, j] = k; // Index of the subsequence split that achieved minimal cost\r\n                }\r\n            }\r\n        }\r\n    }\r\n}', '2020-05-25'),
(540, 8, 6401012018, '#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint nextpowerof2(int k)\n{\n    return pow(2, int(ceil(log2(k))));\n}\nvoid display(vector< vector<int>> &matrix, int m, int n)\n{\n    for (int i = 0; i < m; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (j != 0)\n            {\n                cout <<\" \";\n            }\n            cout << matrix[i][j];\n        }\n        cout << endl;\n    }\n}\n\nvoid add(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n    int i, j;\n\n    for (i = 0; i < size; i++)\n    {\n        for (j = 0; j < size; j++)\n        {\n            C[i][j] = A[i][j] + B[i][j];\n        }\n    }\n}\n\nvoid sub(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n    int i, j;\n\n    for (i = 0; i < size; i++)\n    {\n        for (j = 0; j < size; j++)\n        {\n            C[i][j] = A[i][j] - B[i][j];\n        }\n    }\n}\n\nvoid STRASSEN_algorithmA(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n    if (size == 1)\n    {\n        C[0][0] = A[0][0] * B[0][0];\n        return;\n    }\n    else\n    {\n        int new_size = size / 2;\n        vector<int> z(new_size);\n        vector<vector<int>>\n            a11(new_size, z), a12(new_size, z), a21(new_size, z), a22(new_size, z),\n            b11(new_size, z), b12(new_size, z), b21(new_size, z), b22(new_size, z),\n            c11(new_size, z), c12(new_size, z), c21(new_size, z), c22(new_size, z),\n            p1(new_size, z), p2(new_size, z), p3(new_size, z), p4(new_size, z),\n            p5(new_size, z), p6(new_size, z), p7(new_size, z),\n            aResult(new_size, z), bResult(new_size, z);\n\nint i, j;\nfor (i = 0; i < new_size; i++)\n        {\n            for (j = 0; j < new_size; j++)\n            {\n                a11[i][j] = A[i][j];\n                a12[i][j] = A[i][j + new_size];\n                a21[i][j] = A[i + new_size][j];\n                a22[i][j] = A[i + new_size][j + new_size];\n\n                b11[i][j] = B[i][j];\n                b12[i][j] = B[i][j + new_size];\n                b21[i][j] = B[i + new_size][j];\n                b22[i][j] = B[i + new_size][j + new_size];\n            }\n}\n\n        add(a11, a22, aResult, new_size);\n        add(b11, b22, bResult, new_size);\n        STRASSEN_algorithmA(aResult, bResult, p1, new_size);\n\n        add(a21, a22, aResult, new_size);\n        STRASSEN_algorithmA(aResult, b11, p2, new_size);\n\n        sub(b12, b22, bResult, new_size);\n        STRASSEN_algorithmA(a11, bResult, p3, new_size);\n\n\n        sub(b21, b11, bResult, new_size);\n        STRASSEN_algorithmA(a22, bResult, p4, new_size);\n        add(a11, a12, aResult, new_size);\n        STRASSEN_algorithmA(aResult, b22, p5, new_size);\n\n        sub(a21, a11, aResult, new_size);\n        add(b11, b12, bResult, new_size);\n        STRASSEN_algorithmA(aResult, bResult, p6, new_size);\n\n        sub(a12, a22, aResult, new_size);\n        add(b21, b22, bResult, new_size);\n        STRASSEN_algorithmA(aResult, bResult, p7, new_size);\n\n        add(p3, p5, c12, new_size);\n        add(p2, p4, c21, new_size);\n\n        add(p1, p4, aResult, new_size);\n        add(aResult, p7, bResult, new_size);\n        sub(bResult, p5, c11, new_size);\n\n        add(p1, p3, aResult, new_size);\n        add(aResult, p6, bResult, new_size);\n        sub(bResult, p2, c22, new_size);\n        for (i = 0; i < new_size; i++)\n        {\n            for (j = 0; j < new_size; j++)\n            {\n                C[i][j] = c11[i][j];\n                C[i][j + new_size] = c12[i][j];\n                C[i + new_size][j] = c21[i][j];\n                C[i + new_size][j + new_size] = c22[i][j];\n            }\n        }\n    }\n}\nvoid STRASSEN_algorithm(vector<vector<int>> &A, vector<vector<int>> &B, int m, int n, int a, int b)\n{\n    int k = max({m, n, a, b});\n\n    int s = nextpowerof2(k);\n\n    vector<int> z(s);\n    vector<vector<int>> Aa(s, z), Bb(s, z), Cc(s, z);\n\n    for (unsigned int i = 0; i < m; i++)\n    {\n        for (unsigned int j = 0; j < n; j++)\n        {\n            Aa[i][j] = A[i][j];\n        }\n    }\n    for (unsigned int i = 0; i < a; i++)\n    {\n        for (unsigned int j = 0; j < b; j++)\n        {\n            Bb[i][j] = B[i][j];\n        }\n    }\n    STRASSEN_algorithmA(Aa, Bb, Cc, s);\n    vector<int> temp1(b);\n    vector<vector<int>> C(m, temp1);\n    for (unsigned int i = 0; i < m; i++)\n    {\n        for (unsigned int j = 0; j < b; j++)\n        {\n            C[i][j] = Cc[i][j];\n        }\n    }\n    display(C, m, b);\n}\n\nbool check(int n, int a)\n{\n    if (n == a)\n        return true;\n    else\n        return false;\n}\n\nint main()\n{\n    int n, a, b;\n    cin >> n;\n\n    vector<vector<int>> A;\n    for (int i = 0; i < n; i++)\n    {\n        vector<int> temp;\n        for (int j = 0; j < n; j++)\n        {\n            int i;\n            cin >> i;\n            temp.push_back(i);\n        }\n        A.push_back(temp);\n    }\n\n    vector<vector<int>> B;\n    for (int i = 0; i < n; i++)\n    {\n        vector<int> temp;\n        for (int j = 0; j < n; j++)\n        {\n            int i;\n            cin >> i;\n            temp.push_back(i);\n        }\n        B.push_back(temp);\n    }\n\n\n        STRASSEN_algorithm(A, B, n, n, n, n);\n\n    return 0;\n}\n\n', 0, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '', '1)Divide matrices A and B in 4 sub-matrices of size N/2 x N/2. \r\n2)Calculate the 7 matrix multiplications recursively.\r\n3)Compute the submatricies of C.\r\n4)Combine these submatricies into our new matrix C', '2020-05-25'),
(541, 5, 6401012018, '#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nint nextpowerof2(int k)\n{\n    return pow(2, int(ceil(log2(k))));\n}\nvoid display(vector< vector<int>> &matrix, int m, int n)\n{\n    for (int i = 0; i < m; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (j != 0)\n            {\n                cout << \"	\";\n            }\n            cout << matrix[i][j];\n        }\n        cout << endl;\n    }\n}\n\nvoid add(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n    int i, j;\n\n    for (i = 0; i < size; i++)\n    {\n        for (j = 0; j < size; j++)\n        {\n            C[i][j] = A[i][j] + B[i][j];\n        }\n    }\n}\n\nvoid sub(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n    int i, j;\n\n    for (i = 0; i < size; i++)\n    {\n        for (j = 0; j < size; j++)\n        {\n            C[i][j] = A[i][j] - B[i][j];\n        }\n    }\n}\n\nvoid STRASSEN_algorithmA(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n   \n    if (size == 1)\n    {\n        C[0][0] = A[0][0] * B[0][0];\n        return;\n    }\n    else\n    {\n        int new_size = size / 2;\n        vector<int> z(new_size);\n        vector<vector<int>>\n            a11(new_size, z), a12(new_size, z), a21(new_size, z), a22(new_size, z),\n            b11(new_size, z), b12(new_size, z), b21(new_size, z), b22(new_size, z),\n            c11(new_size, z), c12(new_size, z), c21(new_size, z), c22(new_size, z),\n            p1(new_size, z), p2(new_size, z), p3(new_size, z), p4(new_size, z),\n            p5(new_size, z), p6(new_size, z), p7(new_size, z),\n            aResult(new_size, z), bResult(new_size, z);\n\nint i, j;\n\nfor (i = 0; i < new_size; i++)\n        {\n            for (j = 0; j < new_size; j++)\n            {\n                a11[i][j] = A[i][j];\n                a12[i][j] = A[i][j + new_size];\n                a21[i][j] = A[i + new_size][j];\n                a22[i][j] = A[i + new_size][j + new_size];\n\n                b11[i][j] = B[i][j];\n                b12[i][j] = B[i][j + new_size];\n                b21[i][j] = B[i + new_size][j];\n                b22[i][j] = B[i + new_size][j + new_size];\n            }\n}\n\n\n        add(a11, a22, aResult, new_size);    \n        add(b11, b22, bResult, new_size);    \n        STRASSEN_algorithmA(aResult, bResult, p1, new_size); \n\n        add(a21, a22, aResult, new_size); \n        STRASSEN_algorithmA(aResult, b11, p2, new_size);\n\n        sub(b12, b22, bResult, new_size);      \n        STRASSEN_algorithmA(a11, bResult, p3, new_size);\n\n        sub(b21, b11, bResult, new_size);     \n        STRASSEN_algorithmA(a22, bResult, p4, new_size); \n\n        add(a11, a12, aResult, new_size);     \n        STRASSEN_algorithmA(aResult, b22, p5, new_size);\n\n        sub(a21, a11, aResult, new_size);      \n        add(b11, b12, bResult, new_size);               \n      \n        STRASSEN_algorithmA(aResult, bResult, p6, new_size);\n\n        sub(a12, a22, aResult, new_size);      \n        add(b21, b22, bResult, new_size);                \n        \n        STRASSEN_algorithmA(aResult, bResult, p7, new_size);\n        \n\n        add(p3, p5, c12, new_size); \n        add(p2, p4, c21, new_size); \n\n        add(p1, p4, aResult, new_size);      \n        add(aResult, p7, bResult, new_size); \n        sub(bResult, p5, c11, new_size); \n\n        add(p1, p3, aResult, new_size);     \n        add(aResult, p6, bResult, new_size);  \n        sub(bResult, p2, c22, new_size); \n\n        for (i = 0; i < new_size; i++)\n        {\n            for (j = 0; j < new_size; j++)\n            {\n                C[i][j] = c11[i][j];\n                C[i][j + new_size] = c12[i][j];\n                C[i + new_size][j] = c21[i][j];\n                C[i + new_size][j + new_size] = c22[i][j];\n            }\n        }\n    }\n}\nvoid STRASSEN_algorithm(vector<vector<int>> &A, vector<vector<int>> &B, int m, int n, int a, int b)\n{  \n    int k = max({m, n, a, b});\n\n    int s = nextpowerof2(k);\n\n    vector<int> z(s);\n    vector<vector<int>> Aa(s, z), Bb(s, z), Cc(s, z);\n\n    for (unsigned int i = 0; i < m; i++)\n    {\n        for (unsigned int j = 0; j < n; j++)\n        {\n            Aa[i][j] = A[i][j];\n        }\n    }\n    for (unsigned int i = 0; i < a; i++)\n    {\n        for (unsigned int j = 0; j < b; j++)\n        {\n            Bb[i][j] = B[i][j];\n        }\n    }\n    STRASSEN_algorithmA(Aa, Bb, Cc, s);\n    vector<int> temp1(b);\n    vector<vector<int>> C(m, temp1);\n    for (unsigned int i = 0; i < m; i++)\n    {\n        for (unsigned int j = 0; j < b; j++)\n        {\n            C[i][j] = Cc[i][j];\n        }\n    }\n    display(C, m, b);\n}\n\nbool check(int n, int a)\n{\n    if (n == a)\n        return true;\n    else\n        return false;\n}\n\nint main()\n{\n    \n   int m=3;\n   int n=3;\n   int a=3;\n   int b=3;\n   \n    vector<vector<int>> A{ { 1, 2, 3 }, \n                               { 4, 5, 6 }, \n                               { 7, 8, 9 } }; \n  \n   \n   \n    \n    vector<vector<int>> B{{1,1,2},\n                            {1,3,4},\n                            {2,3,1}};\n    \n    \n    \n     display(A,3,3);\n     cout<<endl;\n     display(B,3,3);\n   \n    bool k = check(n, a);\n    if (k)\n    {\n        cout<<\"ANS\"<<endl; STRASSEN_algorithm(A, B, m, n, a, b);\n    }\n    else\n    {\n        cout << \"CANNOT MULTIPLY\";\n    }\n    return 0;\n}\n\n\n', 1000, '', '', 'function Strassen(M,N)\r\nif M is 1 ? 1 then\r\nreturn M11N11\r\nend if\r\nLet M =  A B\r\n         C D \r\nand N =  E F\r\n         G H \r\nSet S1 = Strassen(B - D, G + H)\r\nSet S2 = Strassen(A + D, E + H)\r\nSet S3 = Strassen(A - C, E + F)\r\nSet S4 = Strassen(A + B, H)\r\nSet S5 = Strassen(A, F - H)\r\nSet S6 = Strassen(D, G - E)\r\nSet S7 = Strassen(C + D, E)\r\nreturn (\r\nS1 + S2 - S4 + S6    S4 + S5\r\nS6 + S7              S2 - S3 + S5 - S7\r\n)\r\nend function\r\n', '2020-05-25'),
(542, 16, 6401012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n\r\n#define d 256 \r\n\r\nvoid search(char pat[], char txt[],int q) \r\n{ \r\n	int M = strlen(pat); \r\n	int N = strlen(txt); \r\n	int i, j; \r\n	int p = 0; \r\n	int t = 0;  \r\n	int h = 1; \r\n\r\n	for (i = 0; i < M - 1; i++) \r\n		h = (h * d) % q; \r\n\r\n	for (i = 0; i < M; i++) \r\n	{ \r\n		p = (d * p + pat[i]) % q; \r\n		t = (d * t + txt[i]) % q; \r\n	} \r\n\r\n	for (i = 0; i <= N - M; i++) \r\n	{ \r\n		if ( p == t ) \r\n		{ \r\n			for (j = 0; j < M; j++) \r\n			{ \r\n				if (txt[i+j] != pat[j]) \r\n					break; \r\n			} \r\n\r\n			if (j == M) \r\n				cout<<\"Pattern found at index \"<< i<<endl; \r\n		} \r\n\r\n		if ( i < N-M ) \r\n		{ \r\n			t = (d*(t - txt[i]*h) + txt[i+M])%q; \r\n\r\n			if (t < 0) \r\n			t = (t + q); \r\n		} \r\n	} \r\n} \r\n\r\nint main() \r\n{ \r\n	char txt[100000];\r\n        cin>>txt;\r\n	char pat[100000];\r\n        cin>>pat;\r\n	int q = 101;  \r\n	search(pat, txt, q); \r\n	return 0; \r\n} \r\n\r\n', 1000, '', '', '\r\n// Rabin Karp Algorithm\r\n\r\nfunction RabinKarp(string s[1..n], string pattern[1..m])\r\n    hpattern := hash(pattern[1..m]);\r\n    for i from 1 to n-m+1\r\n        hs := hash(s[i..i+m-1])\r\n        if hs = hpattern\r\n            if s[i..i+m-1] = pattern[1..m]\r\n                return i\r\n    return not found', '2020-05-25'),
(543, 3, 6501012018, 'public class Main \r\n{ \r\n    public static int partition(int arr[], int low, int high) \r\n    { \r\n        int pivot = arr[high];  \r\n        int i = (low-1); // index of smaller element \r\n        for (int j=low; j<high; j++) \r\n        { \r\n            if (arr[j] < pivot) \r\n            { \r\n                i++; \r\n                int temp = arr[i]; \r\n                arr[i] = arr[j]; \r\n                arr[j] = temp; \r\n            } \r\n        } \r\n        int temp = arr[i+1]; \r\n        arr[i+1] = arr[high]; \r\n        arr[high] = temp; \r\n  \r\n        return i+1; \r\n    } \r\n  \r\n   public static void sort(int arr[], int low, int high) \r\n    { \r\n        if (low < high) \r\n        { \r\n            int pi = partition(arr, low, high); \r\n  \r\n            sort(arr, low, pi-1); \r\n            sort(arr, pi+1, high); \r\n        } \r\n    } \r\n  \r\n   public static void printArray(int arr[]) \r\n    { \r\n        int n = arr.length; \r\n        for (int i=0; i<n; ++i) \r\n            System.out.print(arr[i]+\" \"); \r\n     //   System.out.println(); \r\n    } \r\n    public static void main(String args[]) \r\n    { \r\n  Scanner s=new Scanner(System.in);\r\nint n=s.nextInt();\r\nint []arr=new int[n];\r\nfor(int i=0;i<n;i++)arr[i]=s.nextInt();\r\n\r\n        sort(arr, 0, n-1); \r\n        printArray(arr); \r\n    } \r\n} ', 0, '1 2000', '', 'Algorithm:\r\n\r\nfunction partitionFunc(left, right, pivot)\r\n   leftPointer = left\r\n   rightPointer = right - 1\r\n\r\n   while True do\r\n      while A[++leftPointer] < pivot do\r\n         //do-nothing            \r\n      end while\r\n		\r\n      while rightPointer > 0 && A[--rightPointer] > pivot do\r\n         //do-nothing         \r\n      end while\r\n		\r\n      if leftPointer >= rightPointer\r\n         break\r\n      else                \r\n         swap leftPointer,rightPointer\r\n      end if\r\n		\r\n   end while \r\n	\r\n   swap leftPointer,right\r\n   return leftPointer\r\n	\r\nend function\r\n\r\nprocedure quickSort(left, right)\r\n\r\n   if right-left <= 0\r\n      return\r\n   else     \r\n      pivot = A[right]\r\n      partition = partitionFunc(left, right, pivot)\r\n      quickSort(left,partition-1)\r\n      quickSort(partition+1,right)    \r\n   end if		\r\n   \r\nend procedure', '2020-05-25'),
(544, 7, 6501012018, 'import java.lang.*;\r\n import java.util.*;\r\n \r\n \r\n \r\n public class Main{\r\n \r\n public static void random(int low,int high,int []arr) \r\n    { \r\n      \r\n        Random rand= new Random(); \r\n        int pivot = rand.nextInt(high-low) + low; \r\n          \r\n        int temp1=arr[pivot]; \r\n        arr[pivot]=arr[high]; \r\n        arr[high]=temp1; \r\n    } \r\n  \r\n      \r\n   public static int partition(int arr[], int low, int high)  \r\n    {  \r\n        int pivot = arr[high];  \r\n      \r\n  \r\n        int i = (low-1);  \r\n        for (int j = low; j < high; j++)  \r\n        {  \r\n            \r\n            if (arr[j] <= pivot)  \r\n            {  \r\n                i++;  \r\n  \r\n                int temp = arr[i];  \r\n                arr[i] = arr[j];  \r\n                arr[j] = temp;  \r\n            }  \r\n        }  \r\n  \r\n        int temp = arr[i+1];  \r\n        arr[i+1] = arr[high];  \r\n        arr[high] = temp;  \r\n  \r\n        return i+1;  \r\n    }  \r\n  \r\n  \r\n    \r\n   public static void sort(int arr[], int low, int high)  \r\n    {  \r\n        if (low < high)  \r\n        {  \r\n              int pi = partition(arr, low, high);  \r\n  \r\n             sort(arr, low, pi-1);  \r\n            sort(arr, pi+1, high);  \r\n        }  \r\n    }  \r\n  \r\n    static void printArray(int arr[])  \r\n    {  \r\n        int n = arr.length;  \r\n        for (int i = 0; i < n; ++i)  \r\n            System.out.print(arr[i]+\" \");  \r\n    }\r\n    \r\n    \r\n    \r\n  public static void main(String[]args){\r\n      Scanner s=new Scanner(System.in);\r\n      int n=s.nextInt();\r\n      int []arr=new int[n];\r\n      for(int i=0;i<n;i++)arr[i]=s.nextInt();\r\n      sort(arr,0,n-1);\r\n      printArray(arr);\r\n      \r\n      \r\n  } \r\n\r\n} \r\n    ', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', 'Algorithm:\r\n\r\npartition(arr[], lo, hi) \r\n    pivot = arr[hi]\r\n    i = lo     // place for swapping\r\n    for j := lo to hi – 1 do\r\n        if arr[j] <= pivot then\r\n            swap arr[i] with arr[j]\r\n            i = i + 1\r\n    swap arr[i] with arr[hi]\r\n    return i\r\n\r\npartition_r(arr[], lo, hi)\r\n    r = Random Number from lo to hi\r\n    Swap arr[r] and arr[hi]\r\n    return partition(arr, lo, hi)\r\n\r\nquicksort(arr[], lo, hi)\r\n    if lo < hi\r\n        p = partition_r(arr, lo, hi)\r\n        quicksort(arr, p-1, hi)\r\n        quicksort(arr, p+1, hi)\r\n ', '2020-05-25'),
(545, 11, 6501012018, '0', 0, '8 a b c d e f g h 1 1 2 3 5 8 13 21', 'h:0\ng:10\nf:110\ne:1110\nd:11110\nc:111110\na:1111110\nb:1111111\n', 'Algo:\r\n\r\nSteps to build Huffman Tree\r\nInput is an array of unique characters along with their frequency of occurrences and output is Huffman Tree.\r\n\r\n1. Create a leaf node for each unique character and build a min heap of all leaf nodes (Min Heap is used as a priority queue. The value of frequency field is used to compare two nodes in min heap. Initially, the least frequent character is at root)\r\n\r\n2. Extract two nodes with the minimum frequency from the min heap.\r\n\r\n3. Create a new internal node with a frequency equal to the sum of the two nodes frequencies. Make the first extracted node as its left child and the other extracted node as its right child. Add this node to the min heap.\r\n\r\n4. Repeat steps#2 and #3 until the heap contains only one node. The remaining node is the root node and the tree is complete.', '2020-05-25'),
(546, 12, 6501012018, '#include <bits/stdc++.h> \r\nusing namespace std;  \r\nclass Edge \r\n{ \r\n	public: \r\n	int src, dest, weight; \r\n}; \r\nclass Graph \r\n{ \r\n	public:  \r\n	int V, E; \r\n \r\n	Edge* edge; \r\n}; \r\n\r\nGraph* createGraph(int V, int E) \r\n{ \r\n	Graph* graph = new Graph; \r\n	graph->V = V; \r\n	graph->E = E; \r\n\r\n	graph->edge = new Edge[E]; \r\n\r\n	return graph; \r\n} \r\n \r\nclass subset \r\n{ \r\n	public: \r\n	int parent; \r\n	int rank; \r\n}; \r\n\r\nint find(subset subsets[], int i) \r\n{ \r\n	if (subsets[i].parent != i) \r\n		subsets[i].parent = find(subsets, subsets[i].parent); \r\n\r\n	return subsets[i].parent; \r\n} \r\n\r\nvoid Union(subset subsets[], int x, int y) \r\n{ \r\n	int xroot = find(subsets, x); \r\n	int yroot = find(subsets, y); \r\n\r\n	if (subsets[xroot].rank < subsets[yroot].rank) \r\n		subsets[xroot].parent = yroot; \r\n	else if (subsets[xroot].rank > subsets[yroot].rank) \r\n		subsets[yroot].parent = xroot; \r\n\r\n	else\r\n	{ \r\n		subsets[yroot].parent = xroot; \r\n		subsets[xroot].rank++; \r\n	} \r\n} \r\n\r\nint myComp(const void* a, const void* b) \r\n{ \r\n	Edge* a1 = (Edge*)a; \r\n	Edge* b1 = (Edge*)b; \r\n	return a1->weight > b1->weight; \r\n} \r\n\r\nvoid KruskalMST(Graph* graph) \r\n{ \r\n	int V = graph->V; \r\n	Edge result[V]; \r\n	int e = 0; \r\n	int i = 0; \r\n	qsort(graph->edge, graph->E, sizeof(graph->edge[0]), myComp); \r\n\r\n	subset *subsets = new subset[( V * sizeof(subset) )]; \r\n\r\n	for (int v = 0; v < V; ++v) \r\n	{ \r\n		subsets[v].parent = v; \r\n		subsets[v].rank = 0; \r\n	} \r\n \r\n	while (e < V - 1 && i < graph->E) \r\n	{ \r\n\r\n		Edge next_edge = graph->edge[i++]; \r\n\r\n		int x = find(subsets, next_edge.src); \r\n		int y = find(subsets, next_edge.dest); \r\n\r\n		if (x != y) \r\n		{ \r\n			result[e++] = next_edge; \r\n			Union(subsets, x, y); \r\n		} \r\n		\r\n	} \r\n\r\n	\r\n	cout<<\"Following are the edges in the constructed MST\n\"; \r\n	for (i = 0; i < e; ++i) \r\n		cout<<result[i].src<<\" -- \"<<result[i].dest<<\" == \"<<result[i].weight<<endl; \r\n	return; \r\n} \r\n\r\n\r\nint main() \r\n{ \r\n	int V = 4; \r\n	int E = 5; \r\n	Graph* graph = createGraph(V, E); \r\n\r\n	graph->edge[0].src = 0; \r\n	graph->edge[0].dest = 1; \r\n	graph->edge[0].weight = 10; \r\n\r\n	graph->edge[1].src = 0; \r\n	graph->edge[1].dest = 2; \r\n	graph->edge[1].weight = 6; \r\n\r\n	graph->edge[2].src = 0; \r\n	graph->edge[2].dest = 3; \r\n	graph->edge[2].weight = 5; \r\n\r\n	graph->edge[3].src = 1; \r\n	graph->edge[3].dest = 3; \r\n	graph->edge[3].weight = 15; \r\n\r\n	graph->edge[4].src = 2; \r\n	graph->edge[4].dest = 3; \r\n	graph->edge[4].weight = 4; \r\n\r\n	KruskalMST(graph); \r\n\r\n	return 0; \r\n} \r\n\r\n\r\n', 1000, '', '', 'Algorithm:\r\n1.	Sort all the edges in non-decreasing order of their weight.\r\n2.	Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If cycle is not formed, include this edge. Else, discard it.\r\n3.	Repeat step 2 until there are (V-1) edges in the spanning tree.\r\n', '2020-05-25'),
(547, 13, 6501012018, 'import java.util.*; \r\nimport java.lang.*; \r\nimport java.io.*; \r\n  \r\npublic class Main { \r\n    private static final int V = 5; \r\n  \r\n    int minKey(int key[], Boolean mstSet[]) \r\n    { \r\n        int min = Integer.MAX_VALUE, min_index = -1; \r\n  \r\n        for (int v = 0; v < V; v++) \r\n            if (mstSet[v] == false && key[v] < min) { \r\n                min = key[v]; \r\n                min_index = v; \r\n            } \r\n  \r\n        return min_index; \r\n    } \r\n  \r\n    void printMST(int parent[], int graph[][]) \r\n    { \r\n        int ans=0;\r\n        for (int i = 1; i < V; i++) \r\n            ans+=graph[i][parent[i]];\r\n            System.out.print(ans);\r\n    } \r\n    void primMST(int graph[][]) \r\n    { \r\n        int parent[] = new int[V]; \r\n        int key[] = new int[V]; \r\n  \r\n        Boolean mstSet[] = new Boolean[V]; \r\n  \r\n        for (int i = 0; i < V; i++) { \r\n            key[i] = Integer.MAX_VALUE; \r\n            mstSet[i] = false; \r\n        } \r\n  \r\n        key[0] = 0; // Make key 0 so that this vertex is \r\n        parent[0] = -1; // First node is always root of MST \r\n  \r\n        for (int count = 0; count < V - 1; count++) { \r\n            int u = minKey(key, mstSet); \r\n  \r\n            mstSet[u] = true; \r\n  \r\n            for (int v = 0; v < V; v++) \r\n   \r\n                if (graph[u][v] != 0 && mstSet[v] == false && graph[u][v] < key[v]) { \r\n                    parent[v] = u; \r\n                    key[v] = graph[u][v]; \r\n                } \r\n        } \r\n  \r\n        printMST(parent, graph); \r\n    } \r\n  \r\n    public static void main(String[] args) \r\n    { \r\n        Main t = new Main(); \r\n        Scanner s=new Scanner(System.in);\r\n        int n=s.nextInt();\r\n        int e=s.nextInt();\r\n        int [][]graph=new int[n][n];\r\n        for(int i=0;i<e;i++){\r\n            int n1=s.nextInt();\r\n            int n2=s.nextInt();\r\n            int w=s.nextInt();\r\n           graph[n1-1][n2-1]=w;\r\n           graph[n2-1][n1-1]=w;        \r\n        }\r\n        t.primMST(graph); \r\n    } \r\n} ', 1000, '', '', 'Algorithm\r\n1) Create a set mstSet that keeps track of vertices already included in MST.\r\n2) Assign a key value to all vertices in the input graph. Initialize all key values as INFINITE. Assign key value as 0 for the first vertex so that it is picked first.\r\n3) While mstSet doesn’t include all vertices\r\n….a) Pick a vertex u which is not there in mstSet and has minimum key value.\r\n….b) Include u to mstSet.\r\n….c) Update key value of all adjacent vertices of u. To update the key values, iterate through all adjacent vertices. For every adjacent vertex v, if weight of edge u-v is less than the previous key value of v, update the key value as weight of u-v', '2020-05-25'),
(548, 14, 6501012018, '#include <bits/stdc++.h> \r\nstruct Edge { \r\n	int src, dest, weight; \r\n}; \r\n\r\nstruct Graph { \r\n	int V, E; \r\n	struct Edge* edge; \r\n}; \r\n\r\nstruct Graph* createGraph(int V, int E) \r\n{ \r\n	struct Graph* graph = new Graph; \r\n	graph->V = V; \r\n	graph->E = E; \r\n	graph->edge = new Edge[E]; \r\n	return graph; \r\n} \r\n\r\nvoid printArr(int dist[], int n) \r\n{ \r\n	printf(\"Vertex Distance from Source\n\"); \r\n	for (int i = 0; i < n; ++i) \r\n		printf(\"%d 		 %d\n\", i, dist[i]); \r\n} \r\n\r\nvoid BellmanFord(struct Graph* graph, int src) \r\n{ \r\n	int V = graph->V; \r\n	int E = graph->E; \r\n	int dist[V]; \r\n	for (int i = 0; i < V; i++) \r\n		dist[i] = INT_MAX; \r\n	dist[src] = 0; \r\n	for (int i = 1; i <= V - 1; i++) { \r\n		for (int j = 0; j < E; j++) { \r\n			int u = graph->edge[j].src; \r\n			int v = graph->edge[j].dest; \r\n			int weight = graph->edge[j].weight; \r\n			if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) \r\n				dist[v] = dist[u] + weight; \r\n		} \r\n	} \r\n\r\n	for (int i = 0; i < E; i++) { \r\n		int u = graph->edge[i].src; \r\n		int v = graph->edge[i].dest; \r\n		int weight = graph->edge[i].weight; \r\n		if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) { \r\n			printf(\"Graph contains negative weight cycle\"); \r\n			return; // If negative cycle is detected, simply return \r\n		} \r\n	} \r\n\r\n	printArr(dist, V); \r\n\r\n	return; \r\n} \r\n \r\nint main() \r\n{ \r\n	\r\n	int V = 5;\r\n	int E = 8; \r\n	struct Graph* graph = createGraph(V, E); \r\n	graph->edge[0].src = 0; \r\n	graph->edge[0].dest = 1; \r\n	graph->edge[0].weight = -1; \r\n\r\n	\r\n	graph->edge[1].src = 0; \r\n	graph->edge[1].dest = 2; \r\n	graph->edge[1].weight = 4; \r\n\r\n	graph->edge[2].src = 1; \r\n	graph->edge[2].dest = 2; \r\n	graph->edge[2].weight = 3; \r\n \r\n	graph->edge[3].src = 1; \r\n	graph->edge[3].dest = 3; \r\n	graph->edge[3].weight = 2; \r\n \r\n	graph->edge[4].src = 1; \r\n	graph->edge[4].dest = 4; \r\n	graph->edge[4].weight = 2; \r\n\r\n	graph->edge[5].src = 3; \r\n	graph->edge[5].dest = 2; \r\n	graph->edge[5].weight = 5; \r\n\r\n	graph->edge[6].src = 3; \r\n	graph->edge[6].dest = 1; \r\n	graph->edge[6].weight = 1; \r\n \r\n	graph->edge[7].src = 4; \r\n	graph->edge[7].dest = 3; \r\n	graph->edge[7].weight = -3; \r\n\r\n	BellmanFord(graph, 0); \r\n\r\n	return 0; \r\n} \r\n', 1000, '', '', 'Algorithm:\r\nInput: Graph and a source vertex src\r\nOutput: Shortest distance to all vertices from src. If there is a negative weight cycle, then shortest distances are not calculated, negative weight cycle is reported.\r\n1) This step initializes distances from the source to all vertices as infinite and distance to the source itself as 0. Create an array dist[] of size |V| with all values as infinite except dist[src] where src is source vertex.\r\n2) This step calculates shortest distances. Do following |V|-1 times where |V| is the number of vertices in given graph.\r\n…..a) Do following for each edge u-v\r\n………………If dist[v] > dist[u] + weight of edge uv, then update dist[v]\r\n………………….dist[v] = dist[u] + weight of edge uv\r\n3) This step reports if there is a negative weight cycle in graph. Do following for each edge u-v\r\n……If dist[v] > dist[u] + weight of edge uv, then “Graph contains negative weight cycle”\r\nThe idea of step 3 is, step 2 guarantees the shortest distances if the graph doesn’t contain a negative weight cycle. If we iterate through all edges one more time and get a shorter path for any vertex, then there is a negative weight cycle\r\n', '2020-05-25'),
(549, 15, 6501012018, 'import java.util.Scanner\r\npublic class Main\r\n{\r\n	public static void main(String[] args)\r\n	{\r\n		Scanner sc=new Scanner(System.in);\r\n		int n=sc.nextInt();\r\n		int[] arr=new int[n];\r\n		for(int i=0;i<n;i++)\r\n		{\r\n			arr[i]=sc.nextInt();\r\n		}\r\n		int[][] dp=new int[n][n];\r\n		System.out.println(multiplicationDP(arr,dp));\r\n	}\r\n	public static int multiplicationDP(int[] arr, int[][] dp)  {\r\n		for(int gap=1; gap<arr.length; gap++)  {\r\n			for(int start=0, end=gap; end < arr.length; start++, end++)  {\r\n				if(start + 1 == end)  {\r\n					dp[start][end] = 0;\r\n					continue;\r\n				}\r\n				int min = Integer.MAX_VALUE;\r\n				for(int cut = start+1; cut < end; cut++)  {\r\n					int leftPart = dp[start][cut];\r\n					int rightPart = dp[cut][end]; \r\n					int cost = arr[start] * arr[cut] * arr[end] + leftPart + rightPart;\r\n					min = Math.min(cost, min);\r\n				}\r\n				dp[start][end] = min;\r\n			}\r\n		}\r\n		return dp[0][arr.length-1];\r\n	}\r\n\r\n}\r\n', 1000, '', '', 'Algorithm:\r\n1.	Take the sequence of matrices and separate it into two subsequences.\r\n2.	Find the minimum cost of multiplying out each subsequence.\r\n3.	Add these costs together, and add in the cost of multiplying the two result matrices.\r\n4.	Do this for each possible position at which the sequence of matrices can be split, and take the minimum over all of them.\r\n', '2020-05-25'),
(550, 4, 6501012018, 'import java.util.Scanner;\r\n\r\nclass Pair   {\r\n	public int max, min;\r\n	public Pair(int max, int min) {\r\n		this.max = max;\r\n		this.min = min;\r\n	}\r\n}\r\npublic class Main{\r\n	public static void findMinAndMax(int[] A, int left, int right, Pair p)    {\r\n		if (left == right)   {\r\n			if (p.max < A[left]) \r\n				p.max = A[left];\r\n			if (p.min > A[right])   \r\n				p.min = A[right];\r\n			return;\r\n		}\r\n		if (right - left == 1)      {\r\n			if (A[left] < A[right])    {\r\n				if (p.min > A[left])   \r\n					p.min = A[left];\r\n				if (p.max < A[right]) \r\n					p.max = A[right];\r\n			}\r\n			else {\r\n				if (p.min > A[right])   \r\n					p.min = A[right];\r\n\r\n				if (p.max < A[left]) \r\n					p.max = A[left];\r\n			}  \r\n			return;\r\n		}\r\n		int mid = (left + right) / 2;\r\n		findMinAndMax(A, left, mid, p);\r\n		findMinAndMax(A, mid + 1, right, p);\r\n	}\r\n\r\n//	public static Scanner s = new Scanner(System.in);\r\n\r\n	public static int[] takeInput() {\r\n		int n= 7;\r\n		int[] arr = new int[n];\r\n	    arr[0]=7;\r\n	     arr[1]=5;\r\n	      arr[2]=9;\r\n	       arr[3]=22;\r\n	        arr[4]=1;\r\n	         arr[5]=11;\r\n	          arr[6]=45;\r\n\r\n		return arr;\r\n	}\r\n	public static void main(String[] args)  {\r\n		int[] arr = takeInput();\r\n		Pair ans = new Pair(Integer.MIN_VALUE, Integer.MAX_VALUE);\r\n		findMinAndMax(arr, 0, arr.length-1, ans);\r\n		System.out.print(ans.max + \" \" + ans.min);\r\n	}\r\n}\r\n', 0, '6 1000 11 445 1 330 3000', '45 1', 'Algorithm: Max - Min(x, y) \r\nif y – x ≤ 1 then  \r\n   return (max(numbers[x], numbers[y]), min((numbers[x], numbers[y])) \r\nelse \r\n   (max1, min1):= maxmin(x, ⌊((x + y)/2)⌋) \r\n   (max2, min2):= maxmin(⌊((x + y)/2) + 1)⌋,y) \r\nreturn (max(max1, max2), min(min1, min2)) \r\n\r\n', '2020-05-25');
INSERT INTO `qtos_map` (`ID`, `Q_ID`, `ROLL`, `SUBMISSION`, `SCORE`, `INPUT`, `OP`, `ALGO`, `DATE`) VALUES
(551, 5, 6501012018, '\r\n#include <iostream>\r\n#include <vector>\r\n#include <cmath>\r\n#include <algorithm>\r\nusing namespace std;\r\n\r\nint nextpowerof2(int k)\r\n{\r\n    return pow(2, int(ceil(log2(k))));\r\n}\r\nvoid display(vector< vector<int>> &matrix, int m, int n)\r\n{\r\n    for (int i = 0; i < m; i++)\r\n    {\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            if (j != 0)\r\n            {\r\n                cout << \"	\";\r\n            }\r\n            cout << matrix[i][j];\r\n        }\r\n        cout << endl;\r\n    }\r\n}\r\n\r\nvoid add(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\r\n{\r\n    int i, j;\r\n\r\n    for (i = 0; i < size; i++)\r\n    {\r\n        for (j = 0; j < size; j++)\r\n        {\r\n            C[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid sub(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\r\n{\r\n    int i, j;\r\n\r\n    for (i = 0; i < size; i++)\r\n    {\r\n        for (j = 0; j < size; j++)\r\n        {\r\n            C[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid STRASSEN_algorithmA(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\r\n{\r\n    //base case\r\n    if (size == 1)\r\n    {\r\n        C[0][0] = A[0][0] * B[0][0];\r\n        return;\r\n    }\r\n    else\r\n    {\r\n        int new_size = size / 2;\r\n        vector<int> z(new_size);\r\n        vector<vector<int>>\r\n            a11(new_size, z), a12(new_size, z), a21(new_size, z), a22(new_size, z),\r\n            b11(new_size, z), b12(new_size, z), b21(new_size, z), b22(new_size, z),\r\n            c11(new_size, z), c12(new_size, z), c21(new_size, z), c22(new_size, z),\r\n            p1(new_size, z), p2(new_size, z), p3(new_size, z), p4(new_size, z),\r\n            p5(new_size, z), p6(new_size, z), p7(new_size, z),\r\n            aResult(new_size, z), bResult(new_size, z);\r\n\r\nint i, j;\r\n\r\n//dividing the matrices into sub-matrices:\r\nfor (i = 0; i < new_size; i++)\r\n        {\r\n            for (j = 0; j < new_size; j++)\r\n            {\r\n                a11[i][j] = A[i][j];\r\n                a12[i][j] = A[i][j + new_size];\r\n                a21[i][j] = A[i + new_size][j];\r\n                a22[i][j] = A[i + new_size][j + new_size];\r\n\r\n                b11[i][j] = B[i][j];\r\n                b12[i][j] = B[i][j + new_size];\r\n                b21[i][j] = B[i + new_size][j];\r\n                b22[i][j] = B[i + new_size][j + new_size];\r\n            }\r\n}\r\n\r\n// Calculating p1 to p7:\r\n\r\n        add(a11, a22, aResult, new_size);     // a11 + a22\r\n        add(b11, b22, bResult, new_size);    // b11 + b22\r\n        STRASSEN_algorithmA(aResult, bResult, p1, new_size); \r\n        // p1 = (a11+a22) * (b11+b22)\r\n\r\n        add(a21, a22, aResult, new_size); // a21 + a22\r\n        STRASSEN_algorithmA(aResult, b11, p2, new_size);\r\n        // p2 = (a21+a22) * (b11)\r\n\r\n        sub(b12, b22, bResult, new_size);      // b12 - b22\r\n        STRASSEN_algorithmA(a11, bResult, p3, new_size);\r\n        // p3 = (a11) * (b12 - b22)\r\n\r\n        sub(b21, b11, bResult, new_size);       // b21 - b11\r\n        STRASSEN_algorithmA(a22, bResult, p4, new_size); \r\n        // p4 = (a22) * (b21 - b11)\r\n\r\n        add(a11, a12, aResult, new_size);      // a11 + a12\r\n        STRASSEN_algorithmA(aResult, b22, p5, new_size);\r\n        // p5 = (a11+a12) * (b22)\r\n\r\n        sub(a21, a11, aResult, new_size);      // a21 - a11\r\n        add(b11, b12, bResult, new_size);               \r\n        // b11 + b12\r\n        STRASSEN_algorithmA(aResult, bResult, p6, new_size);\r\n        // p6 = (a21-a11) * (b11+b12)\r\n\r\n        sub(a12, a22, aResult, new_size);      // a12 - a22\r\n        add(b21, b22, bResult, new_size);                \r\n        // b21 + b22\r\n        STRASSEN_algorithmA(aResult, bResult, p7, new_size);\r\n        // p7 = (a12-a22) * (b21+b22)\r\n\r\n        // calculating c21, c21, c11 e c22:\r\n\r\n        add(p3, p5, c12, new_size); // c12 = p3 + p5\r\n        add(p2, p4, c21, new_size); // c21 = p2 + p4\r\n\r\n        add(p1, p4, aResult, new_size);       // p1 + p4\r\n        add(aResult, p7, bResult, new_size);  // p1 + p4 + p7\r\n        sub(bResult, p5, c11, new_size); // c11 = p1 + p4 - p5 + p7\r\n\r\n        add(p1, p3, aResult, new_size);       // p1 + p3\r\n        add(aResult, p6, bResult, new_size);  // p1 + p3 + p6\r\n        sub(bResult, p2, c22, new_size); // c22 = p1 + p3 - p2 + p6\r\n\r\n        // Grouping the results obtained in a single matrix:\r\n        for (i = 0; i < new_size; i++)\r\n        {\r\n            for (j = 0; j < new_size; j++)\r\n            {\r\n                C[i][j] = c11[i][j];\r\n                C[i][j + new_size] = c12[i][j];\r\n                C[i + new_size][j] = c21[i][j];\r\n                C[i + new_size][j + new_size] = c22[i][j];\r\n            }\r\n        }\r\n    }\r\n}\r\nvoid STRASSEN_algorithm(vector<vector<int>> &A, vector<vector<int>> &B, int m, int n, int a, int b)\r\n{  \r\n/* Check to see if these matrices are already square and have dimensions of a power of 2. If not,\r\n * the matrices must be resized and padded with zeroes to meet this criteria. */\r\n    int k = max({m, n, a, b});\r\n\r\n    int s = nextpowerof2(k);\r\n\r\n    vector<int> z(s);\r\n    vector<vector<int>> Aa(s, z), Bb(s, z), Cc(s, z);\r\n\r\n    for (unsigned int i = 0; i < m; i++)\r\n    {\r\n        for (unsigned int j = 0; j < n; j++)\r\n        {\r\n            Aa[i][j] = A[i][j];\r\n        }\r\n    }\r\n    for (unsigned int i = 0; i < a; i++)\r\n    {\r\n        for (unsigned int j = 0; j < b; j++)\r\n        {\r\n            Bb[i][j] = B[i][j];\r\n        }\r\n    }\r\n    STRASSEN_algorithmA(Aa, Bb, Cc, s);\r\n    vector<int> temp1(b);\r\n    vector<vector<int>> C(m, temp1);\r\n    for (unsigned int i = 0; i < m; i++)\r\n    {\r\n        for (unsigned int j = 0; j < b; j++)\r\n        {\r\n            C[i][j] = Cc[i][j];\r\n        }\r\n    }\r\n    display(C, m, b);\r\n}\r\n\r\nbool check(int n, int a)\r\n{\r\n    if (n == a)\r\n        return true;\r\n    else\r\n        return false;\r\n}\r\n\r\nint main()\r\n{\r\n    int m, n, a, b;\r\n   // cout << \"Matrix Multiplication using Strassen algorithm\" << endl;\r\n//    cout << \"Enter rows and columns of first matrix\" << endl;\r\n    m= 3 ;\r\n    n=m;\r\n    //cout << \"enter values into first matrix\" << endl;\r\n    vector<vector<int>> A;\r\n    //first matrix input\r\n            vector<int> temp;\r\n             temp.push_back(1);\r\n             temp.push_back(0);\r\n            temp.push_back(0);\r\n            A.push_back(temp);\r\n\r\n            vector<int> temp1;\r\n             temp1.push_back(0);\r\n             temp1.push_back(1);\r\n            temp1.push_back(0);\r\n            A.push_back(temp1);\r\n\r\n\r\n            vector<int> temp2;\r\n             temp2.push_back(0);\r\n             temp2.push_back(0);\r\n            temp2.push_back(1);\r\n            A.push_back(temp2);\r\n\r\n    \r\n   // cout << \"Enter rows and columns of second matrix\" << endl;\r\n    //cin >> a ;\r\n    //b=a;\r\n    //cout << \"enter values into second matrix\" << endl;\r\n    a=m;\r\n    b=m;\r\n    vector<vector<int>> B;\r\n    //second matrix input\r\n   \r\n    \r\n            vector<int> temp11;\r\n             temp11.push_back(1);\r\n             temp11.push_back(0);\r\n            temp11.push_back(0);\r\n            B.push_back(temp11);\r\n\r\n            vector<int> temp22;\r\n             temp22.push_back(0);\r\n             temp22.push_back(1);\r\n            temp22.push_back(0);\r\n            B.push_back(temp22);\r\n\r\n\r\n            vector<int> temp33;\r\n             temp33.push_back(0);\r\n             temp33.push_back(0);\r\n            temp33.push_back(1);\r\n            B.push_back(temp33);\r\n\r\n\r\n    bool k = check(n, a);\r\n    if (k)\r\n    {\r\n        STRASSEN_algorithm(A, B, m, n, a, b);\r\n    }\r\n    else\r\n    {\r\n        cout << \"martrix multiplication not possible\";\r\n    }\r\n    return 0;\r\n}\r\n\r\n', 1000, '', '', '1.	Divide a matrix of order of 2*2 recursively till we get the matrix of 2*2.\r\n2.	Use the previous set of formulas to carry out 2*2 matrix multiplication.\r\n3.	In this eight multiplication and four additions, subtraction are performed.\r\n4.	Combine the result of two matrixes to find the final product or final matrix.\r\nFormulas:\r\nIn Strassen’s matrix multiplication there are seven multiplication and four addition, subtraction in total.\r\n    1.	D1 =  (a11 + a22) (b11 + b22)\r\n    2.	D2 =  (a21 + a22).b11\r\n    3.	D3 =  (b12 – b22).a11\r\n    4.	D4 =  (b21 – b11).a22\r\n    5.	D5 =  (a11 + a12).b22\r\n    6.	D6 =  (a21 – a11) . (b11 + b12)\r\n    7.	D7 =  (a12 – a22) . (b21 + b22)\r\n\r\n    C11 = d1 + d4 – d5 + d7\r\n    C12 = d3 + d5\r\n    C21 = d2 + d4\r\n    C22 = d1 + d3 – d2 – d6\r\nAlgorithm Strassen(n, a, b, d)\r\nbegin \r\n	If n = threshold then compute\r\n		C = a * b is a conventional matrix.\r\n	Else\r\n		Partition a into four sub matrices  a11, a12, a21, a22.\r\n		Partition b into four sub matrices b11, b12, b21, b22.\r\n		Strassen ( n/2, a11 + a22, b11 + b22, d1)\r\n		Strassen ( n/2, a21 + a22, b11, d2)\r\n		Strassen ( n/2, a11, b12 – b22, d3)\r\n		Strassen ( n/2, a22, b21 – b11, d4)\r\n		Strassen ( n/2, a11 + a12, b22, d5)\r\n		Strassen (n/2, a21 – a11, b11 + b22, d6)\r\n		Strassen (n/2, a12 – a22, b21 + b22, d7)\r\n\r\n		C = d1+d4-d5+d7     d3+d5\r\n		d2+d4           d1+d3-d2-d6  \r\n		\r\n	end if\r\n	\r\n	return (C)\r\nend.\r\n\r\n', '2020-05-25'),
(552, 16, 6501012018, 'import java.util.*;\r\n\r\npublic class Main{\r\n\r\n	static int ch = 256; // no. of different characters in the input\r\n\r\n	public static void rabinKarp(String pattern, String text, int prime) {\r\n		int i = 0, j = 0; // indexes of text and pattern\r\n		int pat = 0, txt = 0; // hash values of pattern and text\r\n		int m = pattern.length();\r\n		int n = text.length();\r\n		int hash = 1; // hash value of m-1 length string\r\n		// this hash is needed to caculate hash value of string (i+1, i+m+1) from string(i, i+m)\r\n		// value of hash is Math.pow(ch, m-1)%prime\r\n		for (i = 0; i < m - 1; i++)\r\n			hash = (hash * ch) % prime;\r\n		// calculate hash value of pattern and first window of text of length m\r\n		// this is our hash code. we can also define some other hashcode as well\r\n		for (i = 0; i < m; i++) {\r\n			pat = (ch * pat + pattern.charAt(i)) % prime;\r\n			txt = (ch * txt + text.charAt(i)) % prime;\r\n		}\r\n		// slide on text string to find pattern\r\n		for (i = 0; i < n - m; i++) {\r\n			// if the hashcode of text and pattern match then only we will iterate on them to check are\r\n			// they same. if the hashcodes are not same then there is no point of checking\r\n			if (pat == txt) {\r\n				for (j = 0; j < m; j++) {\r\n					if (text.charAt(i + j) != pattern.charAt(j))\r\n						break;\r\n				}\r\n				if (j == m)\r\n					System.out.println(\"pattern found at index \" + i);\r\n			}\r\n			// Calculate hash value for next window of text: Remove leading digit, add trailing digit\r\n			if (i < n - m) {\r\n				txt = (ch * (txt - text.charAt(i) * hash) + text.charAt(i + m)) % prime;\r\n				//since we want to remove the value of char at index i of text we multiply its value by\r\n				//hash to remove its contribution completely\r\n				if (txt < 0)  //txt value may now reduce to less than 0 so add prime to it\r\n					txt += prime;\r\n			}\r\n		}\r\n	}\r\n\r\n	//best case O(n+m)  //O(m) for generating hashcode\r\n	//worst case O(nm) when every substring of text has same hashcode value as pattern\r\n	public static void main(String[] args) {\r\n		Scanner s = new Scanner(System.in);\r\n		String text = s.nextLine(); \r\n        		String pattern =s.nextLine(); \r\n        		int q = 101;\r\n        		rabinKarp(pattern, text, q);\r\n\r\n	}\r\n\r\n}\r\n', 1000, '', '', 'RABIN-KARP-MATCHER (T, P, d, q)\r\n 1. n ← length [T]\r\n 2. m  ← length [P]\r\n 3. h  ←  dm-1 mod q\r\n 4. p ←  0\r\n 5. t0 ←  0\r\n 6. for i ← 1 to m\r\n 7. do p ←  (dp + P[i]) mod q\r\n 8. t0 ← (dt0+T [i]) mod q\r\n 9. for s  ←  0 to n-m\r\n 10. do if p = ts\r\n 11. then if P [1.....m] = T [s+1.....s + m]\r\n 12. then \"Pattern occurs with shift\" s\r\n 13. If s < n-m\r\n 14. then ts+1 ←  (d (ts-T [s+1]h)+T [s+m+1])mod q', '2020-05-25'),
(553, 9, 6601012018, '#include <iostream> \nusing namespace std; \nclass DisjSet { \n	int *rank, *parent, n; \n\npublic: \n	DisjSet(int n) \n	{ \n		rank = new int[n]; \n		parent = new int[n]; \n		this->n = n; \n		makeSet(); \n	} \n\n	void makeSet() \n	{ \n		for (int i = 0; i < n; i++) { \n			parent[i] = i; \n		} \n	} \n\n	int find(int x) \n	{ \n		if (parent[x] != x) { \n			parent[x] = find(parent[x]); \n		} \n\n		return parent[x]; \n	} \n\n\n	void Union(int x, int y) \n	{ \n		int xset = find(x); \n		int yset = find(y); \n\n		if (xset == yset) \n			return; \n\n		if (rank[xset] < rank[yset]) { \n			parent[xset] = yset; \n		} \n		else if (rank[xset] > rank[yset]) { \n			parent[yset] = xset; \n		} \n\n		else { \n			parent[yset] = xset; \n			rank[xset] = rank[xset] + 1; \n		} \n	} \n}; \n\nint main() \n{ \n    \n	DisjSet obj(6);\n	\n	obj.Union(4,5);\n	obj.Union(0, 2); \n	obj.Union(5, 3); \n	obj.Union(3, 1); \n	if (obj.find(4) == obj.find(5)) \n		cout << \"Yes\n\"; \n	else\n		cout << \"No\n\"; \n	if (obj.find(1) == obj.find(3)) \n		cout << \"Yes\n\"; \n	else\n		cout << \"No\n\"; \n\n	return 0; \n} \n\n', 1000, '', '', 'function MakeSet(x)\r\n   x.parent = x\r\n\r\nfunction Find(x)\r\n   if x.parent == x\r\n      return x\r\n   else\r\n      return Find(x.parent)\r\n\r\nfunction Union(x,y)\r\n   xRoot = Find(x)\r\n   yRoot = Find(y)\r\n   xRoot.parent = yRoot', '2020-05-25'),
(554, 13, 6601012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n\r\nint minKey(int V,int key[], bool mstSet[]) \r\n{ \r\n	int min = INT_MAX, min_index; \r\n	for (int v = 1; v <= V; v++) \r\n		if (mstSet[v] == false && key[v] < min) \r\n			min = key[v], min_index = v; \r\n\r\n	return min_index; \r\n} \r\n\r\n\r\nvoid printMST(int V,int parent[], int graph[100][100]) \r\n{ \r\n	 \r\n	int sum=0;\r\n	for (int i = 1; i <= V; i++) \r\n	{sum+=graph[i][parent[i]];\r\n		 }\r\n		cout<<sum<<endl;\r\n} \r\n\r\n\r\nvoid primMST(int V,int graph[100][100]) \r\n{ \r\n	 \r\n	int parent[V+1]; \r\n	int key[V+1]; \r\n	bool mstSet[V+1]; \r\n\r\n	for (int i = 1; i <= V; i++) \r\n		key[i] = INT_MAX, mstSet[i] = false; \r\n\r\n	key[1] = 0; \r\n	parent[1] = -1;  \r\n	for (int count = 1; count < V; count++) \r\n	{ \r\n		int u = minKey(V,key, mstSet);\r\n		mstSet[u] = true; \r\n		for (int v = 1; v <= V; v++) \r\n			if (graph[u][v] && mstSet[v] == false && graph[u][v] < key[v]) \r\n				parent[v] = u, key[v] = graph[u][v]; \r\n	} \r\n	printMST( V,parent, graph); \r\n} \r\n\r\n\r\nint main() \r\n{ \r\n	\r\nint V,E;\r\ncin>>V;\r\ncin>>E;\r\n\r\nint graph[100][100];\r\n	\r\n      for(int i=0;i<=V;i++)\r\n       for(int j=0;j<=V;j++)\r\n        {\r\n        graph[i][j]=0;\r\n       }\r\n       int a,b,w;\r\n      for(int i=0;i<E;i++)\r\n       {\r\n       cin>>a>>b>>w;\r\n       graph[a][b]=w;\r\n       graph[b][a]=w;\r\n       }\r\n	primMST(V,graph); \r\n\r\n	return 0; \r\n} ', 1000, '', '', '﻿1. Associate with each vertex v of the graph a number C[v] (the cheapest cost of a connection to v) and an edge E[v] (the edge providing that cheapest connection). To initialize these values, set all values of C[v] to +∞ (or to any number larger than the maximum edge weight) and set each E[v] to a special flag value indicating that there is no edge connecting v to earlier vertices.\r\n2. Initialize an empty forest F and a set Q of vertices that have not yet been included in F (initially, all vertices).\r\n3. Repeat the following steps until Q is empty:\r\n   1. Find and remove a vertex v from Q having the minimum possible value of C[v]\r\n   2. Add v to F and, if E[v] is not the special flag value, also add E[v] to F\r\n   3. Loop over the edges vw connecting v to other vertices w. For each such edge, if w still belongs to Q and vw has smaller weight than C[w], perform the following steps:\r\n      1. Set C[w] to the cost of edge vw\r\n      2. Set E[w] to point to edge vw.\r\n4. Return F', '2020-05-25'),
(555, 14, 6601012018, '﻿#include <bits/stdc++.h>\r\nstruct Edge {\r\n    int src, dest, weight;\r\n};\r\nstruct Graph {\r\n       int V, E;\r\n      struct Edge* edge;\r\n};\r\nstruct Graph* createGraph(int V, int E)\r\n{\r\n    struct Graph* graph = new Graph;\r\n    graph->V = V;\r\n    graph->E = E;\r\n    graph->edge = new Edge[E];\r\n    return graph;\r\n}\r\nvoid printArr(int dist[], int n)\r\n{\r\n    printf(\"Vertex   Distance from Source\n\");\r\n    for (int i = 0; i < n; ++i)\r\n        printf(\"%d 		 %d\n\", i, dist[i]);\r\n}\r\nvoid BellmanFord(struct Graph* graph, int src)\r\n{\r\n    int V = graph->V;\r\n    int E = graph->E;\r\n    int dist[V];\r\n      for (int i = 0; i < V; i++)\r\n        dist[i] = INT_MAX;\r\n    dist[src] = 0;\r\n      for (int i = 1; i <= V - 1; i++) {\r\n        for (int j = 0; j < E; j++) {\r\n            int u = graph->edge[j].src;\r\n            int v = graph->edge[j].dest;\r\n            int weight = graph->edge[j].weight;\r\n            if (dist[u] != INT_MAX && dist[u] + weight < dist[v])\r\n                dist[v] = dist[u] + weight;\r\n        }\r\n    }\r\n      for (int i = 0; i < E; i++) {\r\n        int u = graph->edge[i].src;\r\n        int v = graph->edge[i].dest;\r\n        int weight = graph->edge[i].weight;\r\n        if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {\r\n            printf(\"Graph contains negative weight cycle\");\r\n            return; // If negative cycle is detected, simply return\r\n        }\r\n    }\r\n    printArr(dist, V);\r\n    return;\r\n}\r\n  \r\nint main()\r\n{\r\n    int V = 5; // Number of vertices in graph\r\n    int E = 8; // Number of edges in graph\r\n    struct Graph* graph = createGraph(V, E);\r\n \r\n    graph->edge[0].src = 0;\r\n    graph->edge[0].dest = 1;\r\n    graph->edge[0].weight = -1;\r\n    graph->edge[1].src = 0;\r\n    graph->edge[1].dest = 2;\r\n    graph->edge[1].weight = 4;\r\n    graph->edge[2].src = 1;\r\n    graph->edge[2].dest = 2;\r\n    graph->edge[2].weight = 3;\r\n    graph->edge[3].src = 1;\r\n    graph->edge[3].dest = 3;\r\n    graph->edge[3].weight = 2;\r\n    graph->edge[4].src = 1;\r\n    graph->edge[4].dest = 4;\r\n    graph->edge[4].weight = 2;\r\n    graph->edge[5].src = 3;\r\n    graph->edge[5].dest = 2;\r\n    graph->edge[5].weight = 5;\r\n  \r\n \r\n    graph->edge[6].src = 3;\r\n    graph->edge[6].dest = 1;\r\n    graph->edge[6].weight = 1;\r\n    graph->edge[7].src = 4;\r\n    graph->edge[7].dest = 3;\r\n    graph->edge[7].weight = -3;\r\n  \r\n    BellmanFord(graph, 0);\r\n  \r\n    return 0;\r\n}', 1000, '', '', '﻿function BellmanFord(list vertices, list edges, vertex source) is\r\n    ::distance[], predecessor[]\r\n\r\n\r\n    // This implementation takes in a graph, represented as\r\n    // lists of vertices and edges, and fills two arrays\r\n    // (distance and predecessor) about the shortest path\r\n    // from the source to each vertex\r\n\r\n\r\n    // Step 1: initialize graph\r\n    for each vertex v in vertices do\r\n        distance[v] := inf             // Initialize the distance to all vertices to infinity\r\n        predecessor[v] := null         // And having a null predecessor\r\n    \r\n    distance[source] := 0              // The distance from the source to itself is, of course, zero\r\n    // Step 2: relax edges repeatedly\r\n    for i from 1 to size(vertices)−1 do //just |V|−1 repetitions; i is never referenced\r\n        for each edge (u, v) with weight w in edges do\r\n            if distance[u] + w < distance[v] then\r\n                distance[v] := distance[u] + w\r\n                predecessor[v] := u\r\n\r\n\r\n    // Step 3: check for negative-weight cycles\r\n    for each edge (u, v) with weight w in edges do\r\n        if distance[u] + w < distance[v] then\r\n            error \"Graph contains a negative-weight cycle\"\r\n\r\n\r\n    return distance[], predecessor[]', '2020-05-25'),
(556, 15, 6601012018, '﻿#include<bits/stdc++.h>\r\nusing namespace std;\r\nint MatrixChainOrder(int p[], int n)\r\n{\r\n	int m[n][n];\r\n	int i, j, k, L, q;\r\n	for (i = 1; i < n; i++)\r\n    m[i][i] = 0;\r\n	for (L = 2; L < n; L++)\r\n	{\r\n		for (i = 1; i < n - L + 1; i++)\r\n		{\r\n			j = i + L - 1;\r\n			m[i][j] = INT_MAX;\r\n			for (k = i; k <= j - 1; k++)\r\n			{\r\n				q = m[i][k] + m[k + 1][j] +\r\n					p[i - 1] * p[k] * p[j];\r\n				if (q < m[i][j])\r\n					m[i][j] = q;\r\n			}\r\n		}\r\n	}\r\n	return m[1][n - 1];\r\n}\r\nint main()\r\n{\r\n    int n;\r\n    cin>>n;\r\n	int arr[n];\r\n	for(int i=0;i<n;i++)\r\n        cin>>arr[i];\r\n    cout<< MatrixChainOrder(arr,n);\r\n	return 0;\r\n}\r\n', 1000, '', '', '﻿Begin\r\n   define table minMul of size n x n, initially fill with all 0s\r\n   for length := 2 to n, do\r\n      fir i:=1 to n-length, do\r\n         j := i + length – 1\r\n         minMul[i, j] := ∞\r\n         for k := i to j-1, do\r\n            q := minMul[i, k] + minMul[k+1, j] + array[i-1]*array[k]*array[j]\r\n            if q < minMul[i, j], then minMul[i, j] := q\r\n         done\r\n      done\r\n   done\r\n   return minMul[1, n-1]\r\nEnd\r\n\r\n', '2020-05-25'),
(557, 4, 6601012018, '#include<stdio.h> \r\nstruct pair  \r\n{ \r\n  int min; \r\n  int max; \r\n};   \r\n  \r\nstruct pair getMinMax(int arr[], int low, int high) \r\n{ \r\n  struct pair minmax, mml, mmr;        \r\n  int mid; \r\n    \r\n  if (low == high) \r\n  { \r\n     minmax.max = arr[low]; \r\n     minmax.min = arr[low];      \r\n     return minmax; \r\n  }     \r\n    \r\n  if (high == low + 1) \r\n  {   \r\n     if (arr[low] > arr[high])   \r\n     { \r\n        minmax.max = arr[low]; \r\n        minmax.min = arr[high]; \r\n     }   \r\n     else\r\n     { \r\n        minmax.max = arr[high]; \r\n        minmax.min = arr[low]; \r\n     }   \r\n     return minmax; \r\n  } \r\n    \r\n  mid = (low + high)/2;   \r\n  mml = getMinMax(arr, low, mid); \r\n  mmr = getMinMax(arr, mid+1, high);   \r\n    \r\n  if (mml.min < mmr.min) \r\n    minmax.min = mml.min; \r\n  else\r\n    minmax.min = mmr.min;      \r\n  \r\n  if (mml.max > mmr.max) \r\n    minmax.max = mml.max; \r\n  else\r\n    minmax.max = mmr.max;      \r\n   \r\n  return minmax; \r\n} \r\n  \r\nint main() \r\n{ \r\n  int n=6;\r\n  int arr[n]={1, 5 ,7, 14, 19, 26};\r\n  struct pair minmax = getMinMax(arr, 0, n-1); \r\n  printf(\"\nMinimum element is %d\", minmax.min); \r\n  printf(\"\nMaximum element is %d\", minmax.max); \r\n  getchar(); \r\n}\r\n', 0, '6 1000 11 445 1 330 3000', '', '\r\nALGO: SIMULATANEOUS MAX_MIN (DIVIDE AND CONQUER)\r\n\r\nDivide the array into two parts and compare the maximums and minimums of the two parts to get the maximum and the minimum of the whole array.\r\n\r\nfindMinAndMax(array, array_size)\r\n   if array_size = 1\r\n      return element as both max and min\r\n   else if arry_size = 2\r\n      one comparison to determine max and min\r\n      return that pair\r\n   else    /* array_size  > 2 */\r\n      recur for max and min of left half\r\n      recur for max and min of right half\r\n      one comparison determines true max of the two candidates\r\n      one comparison determines true min of the two candidates\r\n      return the pair of max and min\r\n', '2020-05-25'),
(558, 8, 6601012018, '#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint nextpowerof2(int k)\n{\n    return pow(2, int(ceil(log2(k))));\n}\nvoid display(vector< vector<int>> &matrix, int m, int n)\n{\n    for (int i = 0; i < m; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (j != 0)\n            {\n                cout << \" \";\n            }\n            cout << matrix[i][j];\n        }\n        cout << endl;\n    }\n}\n\nvoid add(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n    int i, j;\n\n    for (i = 0; i < size; i++)\n    {\n        for (j = 0; j < size; j++)\n        {\n            C[i][j] = A[i][j] + B[i][j];\n        }\n    }\n}\n\nvoid sub(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n    int i, j;\n\n    for (i = 0; i < size; i++)\n    {\n        for (j = 0; j < size; j++)\n        {\n            C[i][j] = A[i][j] - B[i][j];\n        }\n    }\n}\n\nvoid STRASSEN_algorithmA(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n   \n    if (size == 1)\n    {\n        C[0][0] = A[0][0] * B[0][0];\n        return;\n    }\n    else\n    {\n        int new_size = size / 2;\n        vector<int> z(new_size);\n        vector<vector<int>>\n            a11(new_size, z), a12(new_size, z), a21(new_size, z), a22(new_size, z),\n            b11(new_size, z), b12(new_size, z), b21(new_size, z), b22(new_size, z),\n            c11(new_size, z), c12(new_size, z), c21(new_size, z), c22(new_size, z),\n            p1(new_size, z), p2(new_size, z), p3(new_size, z), p4(new_size, z),\n            p5(new_size, z), p6(new_size, z), p7(new_size, z),\n            aResult(new_size, z), bResult(new_size, z);\n\nint i, j;\n\nfor (i = 0; i < new_size; i++)\n        {\n            for (j = 0; j < new_size; j++)\n            {\n                a11[i][j] = A[i][j];\n                a12[i][j] = A[i][j + new_size];\n                a21[i][j] = A[i + new_size][j];\n                a22[i][j] = A[i + new_size][j + new_size];\n\n                b11[i][j] = B[i][j];\n                b12[i][j] = B[i][j + new_size];\n                b21[i][j] = B[i + new_size][j];\n                b22[i][j] = B[i + new_size][j + new_size];\n            }\n}\n\n\n        add(a11, a22, aResult, new_size);    \n        add(b11, b22, bResult, new_size);    \n        STRASSEN_algorithmA(aResult, bResult, p1, new_size); \n\n        add(a21, a22, aResult, new_size); \n        STRASSEN_algorithmA(aResult, b11, p2, new_size);\n\n        sub(b12, b22, bResult, new_size);      \n        STRASSEN_algorithmA(a11, bResult, p3, new_size);\n\n        sub(b21, b11, bResult, new_size);     \n        STRASSEN_algorithmA(a22, bResult, p4, new_size); \n\n        add(a11, a12, aResult, new_size);     \n        STRASSEN_algorithmA(aResult, b22, p5, new_size);\n\n        sub(a21, a11, aResult, new_size);      \n        add(b11, b12, bResult, new_size);               \n      \n        STRASSEN_algorithmA(aResult, bResult, p6, new_size);\n\n        sub(a12, a22, aResult, new_size);      \n        add(b21, b22, bResult, new_size);                \n        \n        STRASSEN_algorithmA(aResult, bResult, p7, new_size);\n        \n\n        add(p3, p5, c12, new_size); \n        add(p2, p4, c21, new_size); \n\n        add(p1, p4, aResult, new_size);      \n        add(aResult, p7, bResult, new_size); \n        sub(bResult, p5, c11, new_size); \n\n        add(p1, p3, aResult, new_size);     \n        add(aResult, p6, bResult, new_size);  \n        sub(bResult, p2, c22, new_size); \n\n        for (i = 0; i < new_size; i++)\n        {\n            for (j = 0; j < new_size; j++)\n            {\n                C[i][j] = c11[i][j];\n                C[i][j + new_size] = c12[i][j];\n                C[i + new_size][j] = c21[i][j];\n                C[i + new_size][j + new_size] = c22[i][j];\n            }\n        }\n    }\n}\nvoid STRASSEN_algorithm(vector<vector<int>> &A, vector<vector<int>> &B, int m, int n, int a, int b)\n{  \n    int k = max({m, n, a, b});\n\n    int s = nextpowerof2(k);\n\n    vector<int> z(s);\n    vector<vector<int>> Aa(s, z), Bb(s, z), Cc(s, z);\n\n    for (unsigned int i = 0; i < m; i++)\n    {\n        for (unsigned int j = 0; j < n; j++)\n        {\n            Aa[i][j] = A[i][j];\n        }\n    }\n    for (unsigned int i = 0; i < a; i++)\n    {\n        for (unsigned int j = 0; j < b; j++)\n        {\n            Bb[i][j] = B[i][j];\n        }\n    }\n    STRASSEN_algorithmA(Aa, Bb, Cc, s);\n    vector<int> temp1(b);\n    vector<vector<int>> C(m, temp1);\n    for (unsigned int i = 0; i < m; i++)\n    {\n        for (unsigned int j = 0; j < b; j++)\n        {\n            C[i][j] = Cc[i][j];\n        }\n    }\n    display(C, m, b);\n}\n\nbool check(int n, int a)\n{\n    if (n == a)\n        return true;\n    else\n        return false;\n}\n\nint main()\n{\n    int m = 3, n=4, a=4, b=3;\n    vector<vector<int>> A;\n    A = {{1,2,3,4},{4,5,6,1},{7,8,9,2}};\n\n    vector<vector<int>> B;\n    B = {{1,2,3},{5,7,2},{6,3,2},{1,9,2}};\n\n    bool k = check(n, a);\n    if (k)\n    {\n        STRASSEN_algorithm(A, B, m, n, a, b);\n    }\n    else\n    {\n        cout << \"-1\";\n    }\n    return 0;\n}\n\n\n', 0, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '', '1)Divide matrices A and B in 4 sub-matrices of size N/2 x N/2. \r\n2)Calculate the 7 matrix multiplications recursively.\r\n3)Compute the submatricies of C.\r\n4)Combine these submatricies into our new matrix C', '2020-05-25'),
(559, 5, 6601012018, '#include<iostream>\n#include<vector>\nusing namespace std;\nvoid stras(vector<vector<int>> &x,vector<vector<int>> &y)\n{\n    int a,b,c,d,e,f,g,h,m1,m2,m3,m4,m5,m6,m7,m8;\n    vector<vector<int>> q(2, vector<int> (2,0));\n    a=x[0][0];\n    b=x[0][1];\n    c=x[1][0];\n    d=x[1][1];\n    e=y[0][0];\n    f=y[0][1];\n    g=y[1][0];\n    h=y[1][1];\n    m1=(a+c)*(e+f);\n    m2=(b+d)*(g+h);\n    m3=(a-d)*(e+h);\n    m4=a*(f-h);\n    m5=(c+d)*e;\n    m6=(a+b)*h;\n    m7=d*(g-e);\n    q[0][0]=m2+m3-m6-m7;\n    q[0][1]=m4+m6;\n    q[1][0]=m5+m7;\n    q[1][1]=m1-m3-m4-m5;\n    for(int i=0;i<2;i++)\n    {\n        for (int j=0;j<2;j++)\n        {\n            cout<<q[i][j]<<\" \";\n        }\n    }\n}\nint main(int args, char ** argv)\n{\n    int n=2;\n    vector<vector<int>> x(n,vector<int>(n,1)); \n    vector<vector<int>> y(n,vector<int>(n,1));\n    stras(x,y);\n    return 0;\n}', 1000, '', '', 'function Strassen(M,N)\r\nif M is 1 × 1 then\r\nreturn M11N11\r\nend if\r\nLet M =  A B\r\n         C D \r\nand N =  E F\r\n         G H \r\nSet S1 = Strassen(B - D, G + H)\r\nSet S2 = Strassen(A + D, E + H)\r\nSet S3 = Strassen(A - C, E + F)\r\nSet S4 = Strassen(A + B, H)\r\nSet S5 = Strassen(A, F - H)\r\nSet S6 = Strassen(D, G - E)\r\nSet S7 = Strassen(C + D, E)\r\nreturn (\r\nS1 + S2 - S4 + S6    S4 + S5\r\nS6 + S7              S2 - S3 + S5 - S7\r\n)\r\nend function\r\n', '2020-05-25'),
(560, 16, 6601012018, '#include <string.h>\n#include <iostream>\nusing namespace std;\n\n#define d 10\n\nvoid rabinKarp(char pattern[], char text[], int q)\n{\n	int m = strlen(pattern);\n	int n = strlen(text);\n	int i, j;\n	int p = 0;\n	int t = 0;\n	int h = 1;\n\n	for (i = 0; i < m - 1; i++)\n		h = (h * d) % q;\n\n	for (i = 0; i < m; i++)\n	{\n		p = (d * p + pattern[i]) % q;\n		t = (d * t + text[i]) % q;\n	}\n\n	for (i = 0; i <= n - m; i++)\n	{\n		if (p == t)\n		{\n			for (j = 0; j < m; j++)\n			{\n				if (text[i + j] != pattern[j])\n					break;\n			}\n\n			if (j == m)\n				cout << \"Pattern found at index \" << i  << endl;\n		}\n\n		if (i < n - m)\n		{\n			t = (d * (t - text[i] * h) + text[i + m]) % q;\n\n			if (t < 0)\n				t = (t + q);\n		}\n	}\n}\n\nint main()\n{\n	char text[100];\n	char pattern[100];\n	int q = 13;\n    cin>>text;\n    cin>>pattern;\n	rabinKarp(pattern, text, q);\n}\n', 1000, '', '', 'Begin\r\n   patLen := pattern Length\r\n   strLen := string Length\r\n   patHash := 0 and strHash := 0, h := 1\r\n   maxChar := total number of characters in character set\r\n\r\n   for index i of all character in pattern, do\r\n      h := (h*maxChar) mod prime\r\n   done\r\n\r\n   for all character index i of pattern, do\r\n      patHash := (maxChar*patHash + pattern[i]) mod prime\r\n      strHash := (maxChar*strHash + text[i]) mod prime\r\n   done\r\n\r\n   for i := 0 to (strLen - patLen), do\r\n      if patHash = strHash, then\r\n         for charIndex := 0 to patLen -1, do\r\n            if text[i+charIndex] ? pattern[charIndex], then\r\n               break the loop\r\n         done\r\n\r\n         if charIndex = patLen, then\r\n            print the location i as pattern found at i position.\r\n      if i < (strLen - patLen), then\r\n         strHash := (maxChar*(strHash ? text[i]*h)+text[i+patLen]) mod prime, then\r\n      if strHash < 0, then\r\n         strHash := strHash + prime\r\n   done\r\nEnd', '2020-05-25'),
(561, 3, 6701012018, 'import java.util.*;\r\npublic class Main {\r\nint partition(int arr[], int low, int high) \r\n    { \r\n        int pivot = arr[high];  \r\n        int i = (low-1); \r\n        for (int j=low; j<high; j++) \r\n        { \r\n            if (arr[j] < pivot) \r\n            { \r\n                i++; \r\n                int temp = arr[i]; \r\n                arr[i] = arr[j]; \r\n                arr[j] = temp; \r\n            } \r\n        } \r\n        int temp = arr[i+1]; \r\n        arr[i+1] = arr[high]; \r\n        arr[high] = temp; \r\n  \r\n        return i+1; \r\n    } \r\n\r\n    void sort(int arr[], int low, int high) \r\n    { \r\n        if (low < high) \r\n        { \r\n            int pi = partition(arr, low, high); \r\n            sort(arr, low, pi-1); \r\n            sort(arr, pi+1, high); \r\n        } \r\n    } \r\n  \r\n    static void printArray(int arr[]) \r\n    { \r\n        int n = arr.length; \r\n        for (int i=0; i<n; ++i) \r\n            System.out.print(arr[i]+\" \"); \r\n        System.out.println(); \r\n    } \r\n  public static void main(String args[]) {\r\n		Scanner sc = new Scanner(System.in);\r\n		int n = sc.nextInt();\r\n		int arr[] = new int[n];\r\n		for(int i=0;i<n;i++)\r\n		{\r\n			arr[i] = sc.nextInt();\r\n		}\r\n		quicksort(arr,0,n-1);\r\n		for(int i=0;i<n;i++)\r\n		{\r\n			System.out.print(arr[i] + \" \");\r\n		}\r\n\r\n	}\r\n} ', 0, '1 2000', '', '', '2020-05-25'),
(562, 7, 6701012018, 'import java.util.*; \r\n\r\npublic class Main \r\n{ \r\n	void random(int low,int high) \r\n	{ \r\n	\r\n		Random rand= new Random(); \r\n		int pivot = rand.nextInt(high-low) + low; \r\n		int temp1=arr[pivot]; \r\n		arr[pivot]=arr[high]; \r\n		arr[high]=temp1; \r\n	} \r\n	\r\n	int partition(int arr[], int low, int high) \r\n	{ \r\n		int pivot = arr[high]; \r\n		int i = (low-1);\r\n		for (int j = low; j < high; j++) \r\n		{ \r\n			if (arr[j] <= pivot) \r\n			{ \r\n				i++; \r\n				int temp = arr[i]; \r\n				arr[i] = arr[j]; \r\n				arr[j] = temp; \r\n			} \r\n		} \r\n		int temp = arr[i+1]; \r\n		arr[i+1] = arr[high]; \r\n		arr[high] = temp; \r\n\r\n		return i+1; \r\n	} \r\n	void sort(int arr[], int low, int high) \r\n	{ \r\n		if (low < high) \r\n		{ \r\n			int pi = partition(arr, low, high); \r\n			sort(arr, low, pi-1); \r\n			sort(arr, pi+1, high); \r\n		} \r\n	} \r\n	public static void main(String args[]) \r\n	{ \r\n		Scanner sc = new Scanner(System.in);\r\n		int n = sc.nextInt();\r\n		int arr[] = new int [n];\r\n		for(int i=0;i<n;i++)\r\n		arr[i] = sc.nextInt();\r\n		RQuickSort ob = new RQuickSort(); \r\n		ob.sort(arr, 0, n-1); \r\n		for(int i=0;i<n;i++)\r\n		System.out.print(arr[i]+\" \");\r\n	} \r\n} ', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '', '', '2020-05-25'),
(563, 9, 6701012018, '#include <iostream> \r\nusing namespace std; \r\nclass DisjSet { \r\n	int *rank, *parent, n; \r\n\r\npublic: \r\n	DisjSet(int n) \r\n	{ \r\n		rank = new int[n]; \r\n		parent = new int[n]; \r\n		this->n = n; \r\n		makeSet(); \r\n	} \r\n	void CreateSet() \r\n	{ \r\n		for (int i = 0; i < n; i++) { \r\n			parent[i] = i; \r\n		} \r\n	} \r\n	int FindSet(int x) \r\n	{ \r\n		if (parent[x] != x) { \r\n			parent[x] = find(parent[x]); \r\n		} \r\n\r\n		return parent[x]; \r\n	} \r\n	void MergeSet(int x, int y) \r\n	{ \r\n		int xset = find(x); \r\n		int yset = find(y); \r\n		if (xset == yset) \r\n			return; \r\n		if (rank[xset] < rank[yset]) { \r\n			parent[xset] = yset; \r\n		} \r\n		else if (rank[xset] > rank[yset]) { \r\n			parent[yset] = xset; \r\n		}\r\n		else { \r\n			parent[yset] = xset; \r\n			rank[xset] = rank[xset] + 1; \r\n		} \r\n	} \r\n}; \r\n\r\nint main() \r\n{ \r\n	DisjSet obj(5); \r\n	obj.MergeSet(0, 2); \r\n	obj.MergeSet(4, 2); \r\n	obj.MergeSet(3, 1); \r\n	return 0; \r\n} \r\n', 1000, '', '', '', '2020-05-25'),
(564, 10, 6701012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n  \r\nint max(int a, int b) { return (a > b)? a : b; }  \r\nint knapSack(int W, int wt[], int val[], int n)  \r\n{  \r\n \r\nif (n == 0 || W == 0)  \r\n    return 0;  \r\n \r\nif (wt[n-1] > W)  \r\n    return knapSack(W, wt, val, n-1);  \r\n\r\nelse return max( val[n-1] + knapSack(W-wt[n-1], wt, val, n-1),  \r\n                    knapSack(W, wt, val, n-1) );  \r\n}  \r\n \r\nint main()  \r\n{  \r\n    int n;\r\n    cin>>n;\r\n    int W ;\r\n    cin>>W;  \r\n    int val[n];\r\n    int wt[n];\r\n    for(int i=0;i<n;i++)\r\n	cin>>val[i];\r\n   for(int i=0;i<n;i++)\r\n	cin>>wt[i];\r\n    cout<<knapSack(W, wt, val, n);  \r\n    return 0;  \r\n}', 10, '5 15 4 2 1 2 10 12 2 1 1 4', '15', '', '2020-05-25'),
(565, 12, 6701012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\nclass Edge \r\n{ \r\n	public: \r\n	int src, dest, weight; \r\n}; \r\nclass Graph \r\n{ \r\n	public: \r\n	int V, E; \r\n	Edge* edge; \r\n}; \r\nGraph* createGraph(int V, int E) \r\n{ \r\n	Graph* graph = new Graph; \r\n	graph->V = V; \r\n	graph->E = E; \r\n\r\n	graph->edge = new Edge[E]; \r\n\r\n	return graph; \r\n} \r\nclass subset \r\n{ \r\n	public: \r\n	int parent; \r\n	int rank; \r\n}; \r\nint find(subset subsets[], int i) \r\n{ \r\n	if (subsets[i].parent != i) \r\n	subsets[i].parent = find(subsets, subsets[i].parent); \r\n\r\n	return subsets[i].parent; \r\n} \r\nvoid MergeSet(subset subsets[], int x, int y) \r\n{ \r\n	int xroot = find(subsets, x); \r\n	int yroot = find(subsets, y); \r\n\r\n	if (subsets[xroot].rank < subsets[yroot].rank) \r\n		subsets[xroot].parent = yroot; \r\n	else if (subsets[xroot].rank > subsets[yroot].rank) \r\n		subsets[yroot].parent = xroot; \r\n	else\r\n	{ \r\n		subsets[yroot].parent = xroot; \r\n		subsets[xroot].rank++; \r\n	} \r\n} \r\nint compare(const void* a, const void* b) \r\n{ \r\n	Edge* a1 = (Edge*)a; \r\n	Edge* b1 = (Edge*)b; \r\n	return a1->weight > b1->weight; \r\n} \r\nvoid KruskalMST(Graph* graph) \r\n{ \r\n	int V = graph->V; \r\n	Edge result[V]; \r\n	int e = 0;  \r\n	int i = 0; \r\n	qsort(graph->edge, graph->E, sizeof(graph->edge[0]), compare); \r\n\r\n	subset *subsets = new subset[( V * sizeof(subset) )]; \r\n \r\n	for (int v = 0; v < V; ++v) \r\n	{ \r\n		subsets[v].parent = v; \r\n		subsets[v].rank = 0; \r\n	} \r\n\r\n	while (e < V - 1 && i < graph->E) \r\n	{ \r\n		Edge next_edge = graph->edge[i++]; \r\n\r\n		int x = find(subsets, next_edge.src); \r\n		int y = find(subsets, next_edge.dest); \r\n		if (x != y) \r\n		{ \r\n			result[e++] = next_edge; \r\n			MergeSet(subsets, x, y); \r\n		} \r\n	} \r\n	cout<<\"Following are the edges in the constructed MST\n\"; \r\n	for (i = 0; i < e; ++i) \r\n		cout<<result[i].src<<\" -- \"<<result[i].dest<<\" == \"<<result[i].weight<<endl; \r\n	return; \r\n} \r\n\r\nint main() \r\n{ \r\n	int V = 4; \r\n	int E = 5;  \r\n	Graph* graph = createGraph(V, E); \r\n	graph->edge[0].src = 0; \r\n	graph->edge[0].dest = 1; \r\n	graph->edge[0].weight = 10; \r\n	\r\n	graph->edge[1].src = 0; \r\n	graph->edge[1].dest = 2; \r\n	graph->edge[1].weight = 9; \r\n\r\n	graph->edge[2].src = 2; \r\n	graph->edge[2].dest = 3; \r\n	graph->edge[2].weight = 6; \r\n\r\n	graph->edge[3].src = 1; \r\n	graph->edge[3].dest = 3; \r\n	graph->edge[3].weight = 13; \r\n\r\n	graph->edge[4].src = 1; \r\n	graph->edge[4].dest = 2; \r\n	graph->edge[4].weight = 5; \r\n\r\n	KruskalMST(graph); \r\n\r\n	return 0; \r\n} ', 1000, '', '', '', '2020-05-25'),
(566, 13, 6701012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n#define V 5 \r\nint minKey(int key[], bool mstSet[]) \r\n{ \r\n	int min = INT_MAX, min_index; \r\n	for (int v = 0; v < V; v++) \r\n		if (mstSet[v] == false && key[v] < min) \r\n			min = key[v], min_index = v; \r\n\r\n	return min_index; \r\n} \r\nvoid print(int parent[], int graph[V][V]) \r\n{ \r\n	cout<<\"Edge 	Weight\n\"; \r\n	for (int i = 1; i < V; i++) \r\n		cout<<parent[i]<<\" - \"<<i<<\" 	\"<<graph[i][parent[i]]<<\" \n\"; \r\n} \r\nvoid Prims(int graph[V][V]) \r\n{ \r\n	int parent[V]; \r\n	int key[V]; \r\n	bool mstSet[V];\r\n	for (int i = 0; i < V; i++) \r\n		key[i] = INT_MAX, mstSet[i] = false; \r\n	key[0] = 0; \r\n	parent[0] = -1; \r\n	for (int count = 0; count < V - 1; count++) \r\n	{  \r\n		int u = minKey(key, mstSet); \r\n		mstSet[u] = true; \r\n		for (int v = 0; v < V; v++) \r\n			if (graph[u][v] && mstSet[v] == false && graph[u][v] < key[v]) \r\n				parent[v] = u, key[v] = graph[u][v]; \r\n	} 	\r\n	print(parent, graph); \r\n} \r\nint main() \r\n{ \r\n	int graph[V][V] = { 	{ 0, 1, 1, 3, 0 }, \r\n			{ 3, 0, 3, 6, 4 }, \r\n			{ 1, 2, 0, 0, 7 }, \r\n			{ 6, 8, 0, 0, 9 }, \r\n			{ 0, 5, 7, 9, 0 } }; \r\n\r\n	Prims(graph); \r\n	return 0; \r\n} \r\n', 1000, '', '', '', '2020-05-25'),
(567, 14, 6701012018, '#include <stdio.h>\r\n#include <stdlib.h>\r\n#define INFINITY 99999\r\nstruct Edge {\r\n	int u;	\r\n	int v;	\r\n	int w;\r\n};\r\n\r\nstruct Graph {\r\n	int V;	\r\n	int E;	\r\n	struct Edge *edge;	\r\n};\r\n\r\nvoid bellmanford(struct Graph *g, int source);\r\nvoid print(int arr[], int size);\r\nvoid bellmanford(struct Graph *g, int source) {\r\n	int i, j, u, v, w;\r\n	int tV = g->V;\r\n	int tE = g->E;\r\n	int d[tV];\r\n	int p[tV];\r\n	for (i = 0; i < tV; i++) {\r\n		d[i] = INFINITY;\r\n		p[i] = 0;\r\n	}\r\n	d[source] = 0;\r\n	for(i = 1; i <= tV-1; i++) {\r\n		for(j = 0; j < tE; j++) {\r\n			u = g->edge[j].u;\r\n			v = g->edge[j].v;\r\n			w = g->edge[j].w;\r\n			\r\n			if(d[u] != INFINITY && d[v] > d[u] + w) {\r\n				d[v] = d[u] + w;\r\n				p[v] = u;\r\n			}\r\n		}\r\n	}\r\n	for(i = 0; i < tE; i++) {\r\n		u = g->edge[i].u;\r\n		v = g->edge[i].v;\r\n		w = g->edge[i].w;\r\n		if(d[u] != INFINITY && d[v] > d[u] + w) {\r\n			printf(\"Negative weight cycle detected!\n\");\r\n			return;\r\n		}\r\n	}\r\n	printf(\"Distance array: \");\r\n	print(d, tV);\r\n	printf(\"Predecessor array: \");\r\n	print(p, tV);\r\n}\r\n\r\nvoid print(int arr[], int size) {\r\n	int i;\r\n	for(i = 0; i < size; i ++) {\r\n		printf(\"%d \", arr[i]);\r\n	}\r\n	printf(\"\n\");\r\nint main(void) {\r\n	struct Graph *g = (struct Graph*)malloc(sizeof(struct Graph));\r\n	g->V = 4;	\r\n	g->E = 5;	\r\n	g->edge = (struct Edge*)malloc(g->E * sizeof(struct Edge));\r\n	\r\n	g->edge[0].u = 0;\r\n	g->edge[0].v = 1;\r\n	g->edge[0].w = 2;\r\n\r\n	g->edge[1].u = 0;\r\n	g->edge[1].v = 2;\r\n	g->edge[1].w = 8;\r\n\r\n	g->edge[2].u = 1;\r\n	g->edge[2].v = 3;\r\n	g->edge[2].w = 5;\r\n\r\n	g->edge[3].u = 2;\r\n	g->edge[3].v = 1;\r\n	g->edge[3].w = -3;\r\n\r\n	g->edge[4].u = 3;\r\n	g->edge[4].v = 2;\r\n	g->edge[4].w = 5;	\r\n	bellmanford(g, 0);	\r\n	return 0;\r\n}\r\n}\r\n', 1000, '', '', '', '2020-05-25'),
(568, 15, 6701012018, 'import java.util.*;\r\npublic class Main\r\n{\r\n	public static int MatrixChainMultiplication(int[] dims, int i, int j)\r\n	{\r\n		if (j <= i + 1) {\r\n			return 0;\r\n		}\r\n		int min = Integer.MAX_VALUE;\r\n\r\n		for (int k = i + 1; k <= j - 1; k++)\r\n		{\r\n			int cost = MatrixChainMultiplication(dims, i, k);\r\n			cost += MatrixChainMultiplication(dims, k, j);\r\n			cost += dims[i] * dims[k] * dims[j];\r\n\r\n			if (cost < min) {\r\n				min = cost;\r\n			}\r\n		}\r\n		return min;\r\n	}\r\n	public static void main(String[] args)\r\n	{\r\n		Scanner sc = new Scanner(System.in);\r\n		int n = sc.nextInt();\r\n		int[] dims = new int[n];\r\n		for(int i=0;i<n;i++)\r\n		dims[i] = sc.nextInt();\r\n		System.out.print(\"Minimum cost is \" +\r\n				MatrixChainMultiplication(dims, 0, dims.length - 1));\r\n	}\r\n}', 1000, '', '', '', '2020-05-25'),
(569, 4, 6701012018, 'import java.util.*\r\npublic class Main{ \r\nstatic int max1,min1;\r\nstatic void MinMax(int arr[],int i,int j,int max,int min)\r\n{\r\n	if(i==j)\r\n	{\r\n		max = min = arr[i];\r\n	}\r\n	else if(i = j - 1)\r\n	{\r\n		if(arr[i]<arr[j])\r\n		{\r\n		    max = arr[j];\r\n		    min = arr[i];\r\n		}\r\n		else\r\n		{\r\n		    max = arr[i];\r\n		    min = arr[j];\r\n		}\r\n	} \r\n	else{\r\n		int mid = floor((i+j)/2);\r\n		MinMax(arr,i,mid,max,min);\r\n		MinMax(arr,mid+1,j,max1,min1);\r\n		if(max<max1)\r\n		    max = max1;\r\n		if(min>min1)\r\n		    min = min1;\r\n	}	\r\n}\r\n\r\npublic static void main(String args[]){\r\n	Scanner sc = new Scanner(System.in);\r\n		int n = sc.nextInt();\r\n		int arr[] = new int[n];\r\n		for(int i=0;i<n;i++)\r\n		{\r\n			arr[i] = sc.nextInt();\r\n		}\r\n		MinMax(arr,0,arr.length-1,Integer.MAX_VALUE,Integer.MIN_VALUE);\r\n		System.out.print(max1+ \" \"+min1);\r\n	\r\n	}\r\n}', 0, '6 1000 11 445 1 330 3000', '', '', '2020-05-25');
INSERT INTO `qtos_map` (`ID`, `Q_ID`, `ROLL`, `SUBMISSION`, `SCORE`, `INPUT`, `OP`, `ALGO`, `DATE`) VALUES
(570, 8, 6701012018, '#include < iostream>\r\n#include < vector>\r\n#include < cmath>\r\n#include < algorithm>\r\nusing namespace std;\r\n\r\nint nextpowerof2(int k)\r\n{\r\n    return pow(2, int(ceil(log2(k))));\r\n}\r\nvoid display(vector< vector<int>> &matrix, int m, int n)\r\n{\r\n    for (int i = 0; i < m; i++)\r\n    {\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            if (j != 0)\r\n            {\r\n                cout << \"	\";\r\n            }\r\n            cout << matrix[i][j];\r\n        }\r\n        cout << endl;\r\n    }\r\n}\r\n\r\nvoid add(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\r\n{\r\n    int i, j;\r\n\r\n    for (i = 0; i < size; i++)\r\n    {\r\n        for (j = 0; j < size; j++)\r\n        {\r\n            C[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid sub(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\r\n{\r\n    int i, j;\r\n\r\n    for (i = 0; i < size; i++)\r\n    {\r\n        for (j = 0; j < size; j++)\r\n        {\r\n            C[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid STRASSEN_algorithmA(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\r\n{\r\n    if (size == 1)\r\n    {\r\n        C[0][0] = A[0][0] * B[0][0];\r\n        return;\r\n    }\r\n    else\r\n    {\r\n        int new_size = size / 2;\r\n        vector<int> z(new_size);\r\n        vector<vector<int>>\r\n            a11(new_size, z), a12(new_size, z), a21(new_size, z), a22(new_size, z),\r\n            b11(new_size, z), b12(new_size, z), b21(new_size, z), b22(new_size, z),\r\n            c11(new_size, z), c12(new_size, z), c21(new_size, z), c22(new_size, z),\r\n            p1(new_size, z), p2(new_size, z), p3(new_size, z), p4(new_size, z),\r\n            p5(new_size, z), p6(new_size, z), p7(new_size, z),\r\n            aResult(new_size, z), bResult(new_size, z);\r\n\r\nint i, j;\r\nfor (i = 0; i < new_size; i++)\r\n        {\r\n            for (j = 0; j < new_size; j++)\r\n            {\r\n                a11[i][j] = A[i][j];\r\n                a12[i][j] = A[i][j + new_size];\r\n                a21[i][j] = A[i + new_size][j];\r\n                a22[i][j] = A[i + new_size][j + new_size];\r\n\r\n                b11[i][j] = B[i][j];\r\n                b12[i][j] = B[i][j + new_size];\r\n                b21[i][j] = B[i + new_size][j];\r\n                b22[i][j] = B[i + new_size][j + new_size];\r\n            }\r\n}\r\n        add(a11, a22, aResult, new_size);   \r\n        add(b11, b22, bResult, new_size);    \r\n        STRASSEN_algorithmA(aResult, bResult, p1, new_size); \r\n        \r\n        add(a21, a22, aResult, new_size);\r\n        STRASSEN_algorithmA(aResult, b11, p2, new_size);\r\n\r\n        sub(b12, b22, bResult, new_size);      \r\n        STRASSEN_algorithmA(a11, bResult, p3, new_size);\r\n\r\n        sub(b21, b11, bResult, new_size);       \r\n        STRASSEN_algorithmA(a22, bResult, p4, new_size); \r\n\r\n        add(a11, a12, aResult, new_size);      \r\n        STRASSEN_algorithmA(aResult, b22, p5, new_size);\r\n  \r\n        sub(a21, a11, aResult, new_size);    \r\n        add(b11, b12, bResult, new_size);               \r\n      \r\n        STRASSEN_algorithmA(aResult, bResult, p6, new_size);\r\n        sub(a12, a22, aResult, new_size);   \r\n        add(b21, b22, bResult, new_size);                \r\n        STRASSEN_algorithmA(aResult, bResult, p7, new_size);\r\n        add(p3, p5, c12, new_size); \r\n        add(p2, p4, c21, new_size); \r\n        add(p1, p4, aResult, new_size);       \r\n        add(aResult, p7, bResult, new_size); \r\n        sub(bResult, p5, c11, new_size); \r\n\r\n        add(p1, p3, aResult, new_size);      \r\n        add(aResult, p6, bResult, new_size); \r\n        sub(bResult, p2, c22, new_size); \r\n        for (i = 0; i < new_size; i++)\r\n        {\r\n            for (j = 0; j < new_size; j++)\r\n            {\r\n                C[i][j] = c11[i][j];\r\n                C[i][j + new_size] = c12[i][j];\r\n                C[i + new_size][j] = c21[i][j];\r\n                C[i + new_size][j + new_size] = c22[i][j];\r\n            }\r\n        }\r\n    }\r\n}\r\nvoid STRASSEN_algorithm(vector<vector<int>> &A, vector<vector<int>> &B, int m, int n, int a, int b)\r\n{  \r\n    int k =n;\r\n\r\n    int s = nextpowerof2(k);\r\n\r\n    vector<int> z(s);\r\n    vector<vector<int>> Aa(s, z), Bb(s, z), Cc(s, z);\r\n\r\n    for (unsigned int i = 0; i < n; i++)\r\n    {\r\n        for (unsigned int j = 0; j < n; j++)\r\n        {\r\n            Aa[i][j] = A[i][j];\r\n        }\r\n    }\r\n    for (unsigned int i = 0; i < n; i++)\r\n    {\r\n        for (unsigned int j = 0; j < n; j++)\r\n        {\r\n            Bb[i][j] = B[i][j];\r\n        }\r\n    }\r\n    STRASSEN_algorithmA(Aa, Bb, Cc, s);\r\n    vector<int> temp1(b);\r\n    vector<vector<int>> C(m, temp1);\r\n    for (unsigned int i = 0; i < n; i++)\r\n    {\r\n        for (unsigned int j = 0; j < n; j++)\r\n        {\r\n            C[i][j] = Cc[i][j];\r\n        }\r\n    }\r\n    display(C, n, n);\r\n}\r\n\r\nint main()\r\n{\r\n    int n;\r\n    cin >> n;\r\n    vector<vector<int>> A;\r\n   \r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        vector<int> temp;\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            int i;\r\n            cin >> i;\r\n            temp.push_back(i);\r\n        }\r\n        A.push_back(temp);\r\n    }\r\n    vector<vector<int>> B;\r\n    \r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        vector<int> temp;\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            int i;\r\n            cin >> i;\r\n            temp.push_back(i);\r\n        }\r\n        B.push_back(temp);\r\n    }\r\n        STRASSEN_algorithm(A, B, n, n, n, n);\r\n\r\n    return 0;\r\n}', 0, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '', '', '2020-05-25'),
(571, 5, 6701012018, '#include <stdio.h>\r\nint main()\r\n{\r\n	int a[2][2],b[2][2],c[2][2],i,j;\r\n	int m1,m2,m3,m4,m5,m6,m7;\r\n\r\n	printf(\"Enter the 4 elements of first matrix: \");\r\n	for(i=0;i<2;i++)\r\n		for(j=0;j<2;j++)\r\n			scanf(\"%d\",&a[i][j]);\r\n\r\n	printf(\"Enter the 4 elements of second matrix: \");\r\n	for(i=0;i<2;i++)\r\n		for(j=0;j<2;j++)\r\n			scanf(\"%d\",&b[i][j]);\r\n\r\n	printf(\"\nThe first matrix is\n\");\r\n	for(i=0;i<2;i++)\r\n	{\r\n		printf(\"\n\");\r\n		for(j=0;j<2;j++)\r\n			printf(\"%d	\",a[i][j]);\r\n	}\r\n\r\n	printf(\"\nThe second matrix is\n\");\r\n	for(i=0;i<2;i++)\r\n	{\r\n		printf(\"\n\");\r\n		for(j=0;j<2;j++)\r\n			printf(\"%d	\",b[i][j]);\r\n	}\r\n\r\n	m1= (a[0][0] + a[1][1])*(b[0][0]+b[1][1]);\r\n	m2= (a[1][0]+a[1][1])*b[0][0];\r\n	m3= a[0][0]*(b[0][1]-b[1][1]);\r\n	m4= a[1][1]*(b[1][0]-b[0][0]);\r\n	m5= (a[0][0]+a[0][1])*b[1][1];\r\n	m6= (a[1][0]-a[0][0])*(b[0][0]+b[0][1]);\r\n	m7= (a[0][1]-a[1][1])*(b[1][0]+b[1][1]);\r\n\r\n	c[0][0]=m1+m4-m5+m7;\r\n	c[0][1]=m3+m5;\r\n	c[1][0]=m2+m4;\r\n	c[1][1]=m1-m2+m3+m6;\r\n\r\n	printf(\"\nAfter multiplication using \n\");\r\n	for(i=0;i<2;i++)\r\n	{\r\n		printf(\"\n\");\r\n		for(j=0;j<2;j++)\r\n			printf(\"%d	\",c[i][j]);\r\n	}\r\n\r\n	return 0;\r\n}\r\n', 1000, '', '', '', '2020-05-25'),
(572, 16, 6701012018, '#include<iostream>\r\n#define MAXCHAR 256\r\nusing namespace std;\r\n\r\nvoid rabinKarpSearch(string mainString, string pattern, int prime, int array[], int *index) {\r\n   int patLen = pattern.size();\r\n   int strLen = mainString.size();\r\n   int charIndex, pattHash = 0, strHash = 0, h = 1;\r\n\r\n   for(int i = 0; i<patLen-1; i++) {\r\n      h = (h*MAXCHAR) % prime;   \r\n   }\r\n   \r\n   for(int i = 0; i<patLen; i++) {\r\n      pattHash = (MAXCHAR*pattHash + pattern[i]) % prime;    \r\n      strHash = (MAXCHAR*strHash + mainString[i]) % prime;  \r\n  }\r\n   \r\n   for(int i = 0; i<=(strLen-patLen); i++) {\r\n      if(pattHash == strHash) {      \r\n         for(charIndex = 0; charIndex < patLen; charIndex++) {\r\n            if(mainString[i+charIndex] != pattern[charIndex])\r\n               break;\r\n         }\r\n\r\n         if(charIndex == patLen) {    \r\n            (*index)++;\r\n            array[(*index)] = i;\r\n         }\r\n      }\r\n\r\n      if(i < (strLen-patLen)) {   \r\n         strHash = (MAXCHAR*(strHash - mainString[i]*h) + mainString[i+patLen])%prime;\r\n         if(strHash < 0) {\r\n            strHash += prime;    \r\n         }\r\n      }\r\n   }\r\n}\r\n\r\nint main() {\r\n   string mainString ;\r\n   string pattern;\r\n   cin>>mainString;\r\n   cin>>pattern;\r\n   int locArray[mainString.size()];\r\n   int prime = 101;\r\n   int index = -1;\r\n   rabinKarpSearch(mainString, pattern, prime, locArray, &index);\r\n\r\n   for(int i = 0; i <= index; i++) {\r\n      cout << \"Pattern found at index: \" << locArray[i]<<endl;\r\n   }\r\n}', 1000, '', '', '', '2020-05-25'),
(573, 12, 6801012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n  \r\nclass Edge  \r\n{  \r\n    public: \r\n    int src, dest, weight;  \r\n};  \r\nclass Graph  \r\n{  \r\n    public: \r\n    int V, E;  \r\n    Edge* edge;  \r\n};  \r\nGraph* createGraph(int V, int E)  \r\n{  \r\n    Graph* graph = new Graph;  \r\n    graph->V = V;  \r\n    graph->E = E;  \r\n  \r\n    graph->edge = new Edge[E];  \r\n  \r\n    return graph;  \r\n}   \r\nclass subset  \r\n{  \r\n    public: \r\n    int parent;  \r\n    int rank;  \r\n};  \r\nint find(subset subsets[], int i)  \r\n{  \r\n    if (subsets[i].parent != i)  \r\n        subsets[i].parent = find(subsets, subsets[i].parent);  \r\n  \r\n    return subsets[i].parent;  \r\n}    \r\nvoid Union(subset subsets[], int x, int y)  \r\n{  \r\n    int xroot = find(subsets, x);  \r\n    int yroot = find(subsets, y);    \r\n    if (subsets[xroot].rank < subsets[yroot].rank)  \r\n        subsets[xroot].parent = yroot;  \r\n    else if (subsets[xroot].rank > subsets[yroot].rank)  \r\n        subsets[yroot].parent = xroot;  \r\n    else\r\n    {  \r\n        subsets[yroot].parent = xroot;  \r\n        subsets[xroot].rank++;  \r\n    }  \r\n}   \r\nint myComp(const void* a, const void* b)  \r\n{  \r\n    Edge* a1 = (Edge*)a;  \r\n    Edge* b1 = (Edge*)b;  \r\n    return a1->weight > b1->weight;  \r\n}  \r\nvoid KruskalMST(Graph* graph)  \r\n{  \r\n    int V = graph->V;  \r\n    Edge result[V];  \r\n    int e = 0; \r\n    int i = 0;  \r\n \r\n    qsort(graph->edge, graph->E, sizeof(graph->edge[0]), myComp);  \r\n    subset *subsets = new subset[( V * sizeof(subset) )];    \r\n    for (int v = 0; v < V; ++v)  \r\n    {  \r\n        subsets[v].parent = v;  \r\n        subsets[v].rank = 0;  \r\n    }  \r\n\r\n    while (e < V - 1 && i < graph->E)  \r\n    {  \r\n        Edge next_edge = graph->edge[i++];  \r\n  \r\n        int x = find(subsets, next_edge.src);  \r\n        int y = find(subsets, next_edge.dest);  \r\n  \r\n        if (x != y)  \r\n        {  \r\n            result[e++] = next_edge;  \r\n            Union(subsets, x, y);  \r\n        }  \r\n   \r\n    }   \r\n    cout<<\"Following are the edges in the constructed MST\n\";  \r\n    for (i = 0; i < e; ++i)  \r\n        cout<<result[i].src<<\" -- \"<<result[i].dest<<\" == \"<<result[i].weight<<endl;  \r\n    return;  \r\n}  \r\n  \r\nint main()  \r\n{  \r\nint V=4;\r\nint E=5;\r\n\r\n    Graph* graph = createGraph(V, E);   \r\n    graph->edge[0].src = 0;  \r\n    graph->edge[0].dest = 1;  \r\n    graph->edge[0].weight = 10;   \r\n    graph->edge[1].src = 0;  \r\n    graph->edge[1].dest = 2;  \r\n    graph->edge[1].weight = 6;  \r\n\r\n    graph->edge[2].src = 0;  \r\n    graph->edge[2].dest = 3;  \r\n    graph->edge[2].weight = 5;   \r\n    graph->edge[3].src = 1;  \r\n    graph->edge[3].dest = 3;  \r\n    graph->edge[3].weight = 15;  \r\n  \r\n    graph->edge[4].src = 2;  \r\n    graph->edge[4].dest = 3;  \r\n    graph->edge[4].weight = 4;  \r\n  \r\n    KruskalMST(graph);  \r\n    return 0;  \r\n}  ', 1000, '', '', 'Approach: A simple solution is to consider all subsets of items and calculate the total weight and value of all subsets. Consider the only subsets whose total weight is smaller than W. From all such subsets, pick the maximum value subset.\r\nOptimal Sub-structure: To consider all subsets of items, there can be two cases for every item.\r\n\r\nCase 1: The item is included in the optimal subset.\r\nCase 2: The item is not included in the optimal set.\r\nTherefore, the maximum value that can be obtained from ‘n’ items is the max of the following two values.\r\n\r\n1.Maximum value obtained by n-1 items and W weight (excluding nth item).\r\n2.Value of nth item plus maximum value obtained by n-1 items and W minus the weight of the nth item (including nth item).\r\nIf the weight of ‘nth’ item is greater than ‘W’, then the nth item cannot be included and Case 1 is the only possibility.', '2020-05-25'),
(574, 13, 6801012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n  \r\n#define V 5  \r\n  \r\nint minKey(int key[], bool mstSet[])  \r\n{  \r\n    int min = INT_MAX, min_index;  \r\n  \r\n    for (int v = 0; v < V; v++)  \r\n        if (mstSet[v] == false && key[v] < min)  \r\n            min = key[v], min_index = v;  \r\n  \r\n    return min_index;  \r\n}  \r\n   \r\nvoid printMST(int parent[], int graph[V][V])  \r\n{  \r\n    cout<<\"Edge 	Weight\n\";  \r\n    for (int i = 1; i < V; i++)  \r\n        cout<<parent[i]<<\" - \"<<i<<\" 	\"<<graph[i][parent[i]]<<\" \n\";  \r\n}  \r\nvoid primMST(int graph[V][V])  \r\n{  \r\n    int parent[V];  \r\n    \r\n    int key[V];  \r\n    bool mstSet[V];  \r\n    for (int i = 0; i < V; i++)  \r\n        key[i] = INT_MAX, mstSet[i] = false;  \r\n   \r\n    key[0] = 0;  \r\n    parent[0] = -1; \r\n  \r\n    for (int count = 0; count < V - 1; count++) \r\n    {   \r\n        int u = minKey(key, mstSet); \r\n        mstSet[u] = true;  \r\n        for (int v = 0; v < V; v++)   \r\n            if (graph[u][v] && mstSet[v] == false && graph[u][v] < key[v])  \r\n                parent[v] = u, key[v] = graph[u][v];  \r\n    }   \r\n    printMST(parent, graph);  \r\n}  \r\nint main()  \r\n{  \r\n    int graph[V][V] = { { 0, 2, 0, 6, 0 },  \r\n                        { 2, 0, 3, 8, 5 },  \r\n                        { 0, 3, 0, 0, 7 },  \r\n                        { 6, 8, 0, 0, 9 },  \r\n                        { 0, 5, 7, 9, 0 } };  \r\n \r\n    primMST(graph);  \r\n  \r\n    return 0;  \r\n}  ', 1000, '', '', 'Algorithm\r\n1) Create a set mstSet that keeps track of vertices already included in MST.\r\n2) Assign a key value to all vertices in the input graph. Initialize all key values as INFINITE. Assign key value as 0 for the first vertex so that it is picked first.\r\n3) While mstSet doesn’t include all vertices\r\n….a) Pick a vertex u which is not there in mstSet and has minimum key value.\r\n….b) Include u to mstSet.\r\n….c) Update key value of all adjacent vertices of u. To update the key values, iterate through all adjacent vertices. For every adjacent vertex v, if weight of edge u-v is less than the previous key value of v, update the key value as weight of u-v\r\n', '2020-05-25'),
(575, 4, 6801012018, '#include<stdio.h> \nstruct pair  \n{ \n  int min; \n  int max; \n};   \n  \nstruct pair getMinMax(int arr[], int n) \n{ \n  struct pair minmax;      \n  int i; \n    \n  /*If there is only one element then return it as min and max both*/\n  if (n == 1) \n  { \n     minmax.max = arr[0]; \n     minmax.min = arr[0];      \n     return minmax; \n  }     \n  \n  /* If there are more than one elements, then initialize min  \n      and max*/\n  if (arr[0] > arr[1])   \n  { \n      minmax.max = arr[0]; \n      minmax.min = arr[1]; \n  }   \n  else\n  { \n      minmax.max = arr[1]; \n      minmax.min = arr[0]; \n  }     \n  \n  for (i = 2; i<n; i++) \n  { \n    if (arr[i] >  minmax.max)       \n      minmax.max = arr[i]; \n    \n    else if (arr[i] <  minmax.min)       \n      minmax.min = arr[i]; \n  } \n    \n  return minmax; \n} \n  \n/* Driver program to test above function */\nint main() \n{ \n  int arr[] = {1000, 11, 445, 1, 330, 3000}; \n  int arr_size = 6; \n  struct pair minmax = getMinMax (arr, arr_size); \n  printf(\"nMinimum element is %d\", minmax.min); \n  printf(\"nMaximum element is %d\", minmax.max); \n  getchar(); \n} \n', 0, '6 1000 11 445 1 330 3000', 'nMinimum element is 1nMaximum element is 3000', '#include<stdio.h> \nstruct pair  \n{ \n  int min; \n  int max; \n};   \n  \nstruct pair getMinMax(int arr[], int n) \n{ \n  struct pair minmax;      \n  int i; \n    \n  /*If there is only one element then return it as min and max both*/\n  if (n == 1) \n  { \n     minmax.max = arr[0]; \n     minmax.min = arr[0];      \n     return minmax; \n  }     \n  \n  /* If there are more than one elements, then initialize min  \n      and max*/\n  if (arr[0] > arr[1])   \n  { \n      minmax.max = arr[0]; \n      minmax.min = arr[1]; \n  }   \n  else\n  { \n      minmax.max = arr[1]; \n      minmax.min = arr[0]; \n  }     \n  \n  for (i = 2; i<n; i++) \n  { \n    if (arr[i] >  minmax.max)       \n      minmax.max = arr[i]; \n    \n    else if (arr[i] <  minmax.min)       \n      minmax.min = arr[i]; \n  } \n    \n  return minmax; \n} \n  \n/* Driver program to test above function */\nint main() \n{ \n  int arr[] = {1000, 11, 445, 1, 330, 3000}; \n  int arr_size = 6; \n  struct pair minmax = getMinMax (arr, arr_size); \n  printf(\"nMinimum element is %d\", minmax.min); \n  printf(\"nMaximum element is %d\", minmax.max); \n  getchar(); \n} \n', '2020-05-25'),
(576, 5, 6801012018, '// CPP program to implement Strassen’s Matrix  \r\n// Multiplication Algorithm  \r\n#include<iostream>\r\n#include<conio.h>\r\n#include<stdio.h>\r\nusing namespace std; \r\ntypedef long long lld; \r\ninline lld** MatrixMultiply(lld** a, lld** b, int n, \r\n                                      int l, int m) \r\n{ \r\n    lld** c = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        c[i] = new lld[m]; \r\n  \r\n    for (int i = 0; i < n; i++) { \r\n        for (int j = 0; j < m; j++) { \r\n            c[i][j] = 0; \r\n            for (int k = 0; k < l; k++) { \r\n                c[i][j] += a[i][k] * b[k][j]; \r\n            } \r\n        } \r\n    } \r\n    return c; \r\n} \r\n  \r\ninline lld** Strassen(lld** a, lld** b, int n,  \r\n                                int l, int m) \r\n{ \r\n    if (n == 1 || l == 1 || m == 1)  \r\n        return MatrixMultiply(a, b, n, l, m); \r\n  \r\n    lld** c = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        c[i] = new lld[m]; \r\n  \r\n    int adjN = (n >> 1) + (n & 1); \r\n    int adjL = (l >> 1) + (l & 1); \r\n    int adjM = (m >> 1) + (m & 1); \r\n  \r\n    lld**** As = new lld***[2]; \r\n    for (int x = 0; x < 2; x++) { \r\n        As[x] = new lld**[2]; \r\n        for (int y = 0; y < 2; y++) { \r\n            As[x][y] = new lld*[adjN]; \r\n            for (int i = 0; i < adjN; i++) { \r\n                As[x][y][i] = new lld[adjL]; \r\n                for (int j = 0; j < adjL; j++) { \r\n                    int I = i + (x & 1) * adjN; \r\n                    int J = j + (y & 1) * adjL; \r\n                    As[x][y][i][j] = (I < n && J < l) ? a[I][J] : 0; \r\n                } \r\n            } \r\n        } \r\n    } \r\n  \r\n    lld**** Bs = new lld***[2]; \r\n    for (int x = 0; x < 2; x++) { \r\n        Bs[x] = new lld**[2]; \r\n        for (int y = 0; y < 2; y++) { \r\n            Bs[x][y] = new lld*[adjN]; \r\n            for (int i = 0; i < adjL; i++) { \r\n                Bs[x][y][i] = new lld[adjM]; \r\n                for (int j = 0; j < adjM; j++) { \r\n                    int I = i + (x & 1) * adjL; \r\n                    int J = j + (y & 1) * adjM; \r\n                    Bs[x][y][i][j] = (I < l && J < m) ? b[I][J] : 0; \r\n                } \r\n            } \r\n        } \r\n    } \r\n  \r\n    lld*** s = new lld**[10]; \r\n    for (int i = 0; i < 10; i++) { \r\n        switch (i) { \r\n        case 0: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][1][j][k] - Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 1: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] + As[0][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 2: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[1][0][j][k] + As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 3: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[1][0][j][k] - Bs[0][0][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 4: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] + As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 5: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 6: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][1][j][k] - As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 7: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[1][0][j][k] + Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 8: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] - As[1][0][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 9: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[0][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        } \r\n    } \r\n  \r\n    lld*** p = new lld**[7]; \r\n    p[0] = Strassen(As[0][0], s[0], adjN, adjL, adjM); \r\n    p[1] = Strassen(s[1], Bs[1][1], adjN, adjL, adjM); \r\n    p[2] = Strassen(s[2], Bs[0][0], adjN, adjL, adjM); \r\n    p[3] = Strassen(As[1][1], s[3], adjN, adjL, adjM); \r\n    p[4] = Strassen(s[4], s[5], adjN, adjL, adjM); \r\n    p[5] = Strassen(s[6], s[7], adjN, adjL, adjM); \r\n    p[6] = Strassen(s[8], s[9], adjN, adjL, adjM); \r\n  \r\n    for (int i = 0; i < adjN; i++) { \r\n        for (int j = 0; j < adjM; j++) { \r\n            c[i][j] = p[4][i][j] + p[3][i][j] - p[1][i][j] + p[5][i][j]; \r\n            if (j + adjM < m) \r\n                c[i][j + adjM] = p[0][i][j] + p[1][i][j]; \r\n            if (i + adjN < n) \r\n                c[i + adjN][j] = p[2][i][j] + p[3][i][j]; \r\n            if (i + adjN < n && j + adjM < m) \r\n                c[i + adjN][j + adjM] = p[4][i][j] + p[0][i][j] - p[2][i][j] - p[6][i][j]; \r\n        } \r\n    } \r\n  \r\n    for (int x = 0; x < 2; x++) { \r\n        for (int y = 0; y < 2; y++) { \r\n            for (int i = 0; i < adjN; i++) { \r\n                delete[] As[x][y][i]; \r\n            } \r\n            delete[] As[x][y]; \r\n        } \r\n        delete[] As[x]; \r\n    } \r\n    delete[] As; \r\n  \r\n    for (int x = 0; x < 2; x++) { \r\n        for (int y = 0; y < 2; y++) { \r\n            for (int i = 0; i < adjL; i++) { \r\n                delete[] Bs[x][y][i]; \r\n            } \r\n            delete[] Bs[x][y]; \r\n        } \r\n        delete[] Bs[x]; \r\n    } \r\n    delete[] Bs; \r\n  \r\n    for (int i = 0; i < 10; i++) { \r\n        switch (i) { \r\n        case 0: \r\n        case 3: \r\n        case 5: \r\n        case 7: \r\n        case 9: \r\n            for (int j = 0; j < adjL; j++) { \r\n                delete[] s[i][j]; \r\n            } \r\n            break; \r\n        case 1: \r\n        case 2: \r\n        case 4: \r\n        case 6: \r\n        case 8: \r\n            for (int j = 0; j < adjN; j++) { \r\n                delete[] s[i][j]; \r\n            } \r\n            break; \r\n        } \r\n        delete[] s[i]; \r\n    } \r\n    delete[] s; \r\n  \r\n    for (int i = 0; i < 7; i++) { \r\n        for (int j = 0; j < (n >> 1); j++) { \r\n            delete[] p[i][j]; \r\n        } \r\n        delete[] p[i]; \r\n    } \r\n    delete[] p; \r\n  \r\n    return c; \r\n} \r\n  \r\nint main() \r\n{ \r\n    lld** matA; \r\n    matA = new lld*[2]; \r\n    for (int i = 0; i < 2; i++) \r\n        matA[i] = new lld[3]; \r\n    matA[0][0] = 1; \r\n    matA[0][1] = 2; \r\n    matA[0][2] = 3; \r\n    matA[1][0] = 4; \r\n    matA[1][1] = 5; \r\n    matA[1][2] = 6; \r\n  \r\n    lld** matB; \r\n    matB = new lld*[3]; \r\n    for (int i = 0; i < 3; i++) \r\n        matB[i] = new lld[2]; \r\n    matB[0][0] = 7; \r\n    matB[0][1] = 8; \r\n    matB[1][0] = 9; \r\n    matB[1][1] = 10; \r\n    matB[2][0] = 11; \r\n    matB[2][1] = 12; \r\n  \r\n    lld** matC = Strassen(matA, matB, 2, 3, 2); \r\n    for (int i = 0; i < 2; i++) { \r\n        for (int j = 0; j < 2; j++) { \r\n            printf(\"%lld \", matC[i][j]); \r\n        } \r\n        printf(\"\n\"); \r\n    } \r\n  \r\n    return 0; \r\n} ', 1000, '', '', 'void multiply(int A[][N], int B[][N], int C[][N]) \r\n{ \r\n    for (int i = 0; i < N; i++) \r\n    { \r\n        for (int j = 0; j < N; j++) \r\n        { \r\n            C[i][j] = 0; \r\n            for (int k = 0; k < N; k++) \r\n            { \r\n                C[i][j] += A[i][k]*B[k][j]; \r\n            } \r\n        } \r\n    } \r\n} ', '2020-05-25'),
(577, 16, 6801012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n#define d 256  \r\n  \r\n/* pat -> pattern  \r\n    txt -> text  \r\n    q -> A prime number  \r\n*/\r\nvoid search(char pat[], char txt[],int n,int m, int q)  \r\n{  \r\n    int M = n;  \r\n    int N = m;  \r\n    int i, j;  \r\n    int p = 0; // hash value for pattern  \r\n    int t = 0; // hash value for txt  \r\n    int h = 1;  \r\n  \r\n    for (i = 0; i < M - 1; i++)  \r\n        h = (h * d) % q;  \r\n  \r\n    for (i = 0; i < M; i++)  \r\n    {  \r\n        p = (d * p + pat[i]) % q;  \r\n        t = (d * t + txt[i]) % q;  \r\n    }  \r\n  \r\n    for (i = 0; i <= N - M; i++)  \r\n    {  \r\n   \r\n        if ( p == t )  \r\n        {  \r\n            /* Check for characters one by one */\r\n            for (j = 0; j < M; j++)  \r\n            {  \r\n                if (txt[i+j] != pat[j])  \r\n                    break;  \r\n            }  \r\n  \r\n            // if p == t and pat[0...M-1] = txt[i, i+1, ...i+M-1]  \r\n            if (j == M)  \r\n                cout<<\"Pattern found at index \"<< i<<endl;  \r\n        }  \r\n    \r\n        if ( i < N-M )  \r\n        {  \r\n            t = (d*(t - txt[i]*h) + txt[i+M])%q;  \r\n  \r\n              \r\n            if (t < 0)  \r\n            t = (t + q);  \r\n        }  \r\n    }  \r\n}  \r\n\r\nint main()  \r\n{  \r\n    int t;\r\ncin>>t;\r\nwhile(t!=0){\r\nint n;\r\ncin>>n;\r\nchar a[n];\r\nfor(int i=0;i<n;i++){\r\ncin>>a[i];\r\n}\r\nint m;\r\ncin>>m;\r\nchar b[m];\r\nfor(int i=0;i<m;i++){\r\ncin>>b[i];\r\n}\r\n    int q = 101; // A prime number  \r\n    search(a,b,n,m, q); \r\n\r\ncout<<endl;\r\nt--;\r\n} \r\n    return 0;  \r\n}  ', 1000, '', '', 'Rabin-Karp is another pattern searching algorithm to find the pattern in a more efficient way. It also checks the pattern by moving window one by one, but without checking all characters for all cases, it finds the hash value. When the hash value is matched, then only it tries to check each character. This procedure makes the algorithm more efficient.\r\nThe time complexity is O(m+n), but for the worst case, it is O(mn).\r\n\r\nInput and Output\r\nInput:\r\nMain String: “ABAAABCDBBABCDDEBCABC”, Pattern “ABC”\r\nOutput:\r\nPattern found at position: 4\r\nPattern found at position: 10\r\nPattern found at position: 18\r\n\r\nAlgorithm\r\nrabinKarpSearch(text, pattern, prime) ', '2020-05-25'),
(578, 9, 6901012018, '#include <iostream> \r\nusing namespace std; \r\nclass DisjSet { \r\n	int *rank, *parent, n; \r\n\r\npublic: \r\n	DisjSet(int n) \r\n	{ \r\n		rank = new int[n]; \r\n		parent = new int[n]; \r\n		this->n = n; \r\n		makeSet(); \r\n	} \r\n\r\n	void makeSet() \r\n	{ \r\n		for (int i = 0; i < n; i++) { \r\n			parent[i] = i; \r\n		} \r\n	} \r\n\r\n	int find(int x) \r\n	{ \r\n		if (parent[x] != x) { \r\n			parent[x] = find(parent[x]); \r\n		} \r\n\r\n		return parent[x]; \r\n	} \r\n\r\n\r\n	void Union(int x, int y) \r\n	{ \r\n		int xset = find(x); \r\n		int yset = find(y); \r\n\r\n		if (xset == yset) \r\n			return; \r\n\r\n		if (rank[xset] < rank[yset]) { \r\n			parent[xset] = yset; \r\n		} \r\n		else if (rank[xset] > rank[yset]) { \r\n			parent[yset] = xset; \r\n		} \r\n\r\n		else { \r\n			parent[yset] = xset; \r\n			rank[xset] = rank[xset] + 1; \r\n		} \r\n	} \r\n}; \r\n\r\nint main() \r\n{ \r\n    \r\n	DisjSet obj(6);\r\n	\r\n	obj.Union(4,5);\r\n	obj.Union(0, 2); \r\n	obj.Union(5, 3); \r\n	obj.Union(3, 1); \r\n	if (obj.find(4) == obj.find(5)) \r\n		cout << \"Yes\n\"; \r\n	else\r\n		cout << \"No\n\"; \r\n	if (obj.find(1) == obj.find(3)) \r\n		cout << \"Yes\n\"; \r\n	else\r\n		cout << \"No\n\"; \r\n\r\n	return 0; \r\n} \r\n\r\n', 1000, '', '', 'A disjoint-set data structure is a data structure that keeps track of a set of elements partitioned into a number of disjoint (non-overlapping) subsets. A union-find algorithm is an algorithm that performs two useful operations on such a data structure:\r\n\r\nFind: Determine which subset a particular element is in. This can be used for determining if two elements are in the same subset.\r\n\r\nUnion: Join two subsets into a single subset.', '2020-05-25'),
(579, 12, 6901012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n  \r\nclass Edge  \r\n{  \r\n    public: \r\n    int src, dest, weight;  \r\n};  \r\nclass Graph  \r\n{  \r\n    public: \r\n    int V, E;  \r\n    Edge* edge;  \r\n};  \r\nGraph* createGraph(int V, int E)  \r\n{  \r\n    Graph* graph = new Graph;  \r\n    graph->V = V;  \r\n    graph->E = E;  \r\n  \r\n    graph->edge = new Edge[E];  \r\n  \r\n    return graph;  \r\n}   \r\nclass subset  \r\n{  \r\n    public: \r\n    int parent;  \r\n    int rank;  \r\n};  \r\nint find(subset subsets[], int i)  \r\n{  \r\n    if (subsets[i].parent != i)  \r\n        subsets[i].parent = find(subsets, subsets[i].parent);  \r\n  \r\n    return subsets[i].parent;  \r\n}    \r\nvoid Union(subset subsets[], int x, int y)  \r\n{  \r\n    int xroot = find(subsets, x);  \r\n    int yroot = find(subsets, y);    \r\n    if (subsets[xroot].rank < subsets[yroot].rank)  \r\n        subsets[xroot].parent = yroot;  \r\n    else if (subsets[xroot].rank > subsets[yroot].rank)  \r\n        subsets[yroot].parent = xroot;  \r\n    else\r\n    {  \r\n        subsets[yroot].parent = xroot;  \r\n        subsets[xroot].rank++;  \r\n    }  \r\n}   \r\nint myComp(const void* a, const void* b)  \r\n{  \r\n    Edge* a1 = (Edge*)a;  \r\n    Edge* b1 = (Edge*)b;  \r\n    return a1->weight > b1->weight;  \r\n}  \r\nvoid KruskalMST(Graph* graph)  \r\n{  \r\n    int V = graph->V;  \r\n    Edge result[V];  \r\n    int e = 0; \r\n    int i = 0;  \r\n \r\n    qsort(graph->edge, graph->E, sizeof(graph->edge[0]), myComp);  \r\n    subset *subsets = new subset[( V * sizeof(subset) )];    \r\n    for (int v = 0; v < V; ++v)  \r\n    {  \r\n        subsets[v].parent = v;  \r\n        subsets[v].rank = 0;  \r\n    }  \r\n\r\n    while (e < V - 1 && i < graph->E)  \r\n    {  \r\n        Edge next_edge = graph->edge[i++];  \r\n  \r\n        int x = find(subsets, next_edge.src);  \r\n        int y = find(subsets, next_edge.dest);  \r\n  \r\n        if (x != y)  \r\n        {  \r\n            result[e++] = next_edge;  \r\n            Union(subsets, x, y);  \r\n        }  \r\n   \r\n    }   \r\n    cout<<\"Following are the edges in the constructed MST\n\";  \r\n    for (i = 0; i < e; ++i)  \r\n        cout<<result[i].src<<\" -- \"<<result[i].dest<<\" == \"<<result[i].weight<<endl;  \r\n    return;  \r\n}  \r\n  \r\nint main()  \r\n{  \r\nint V=4;\r\nint E=5;\r\n\r\n    Graph* graph = createGraph(V, E);   \r\n    graph->edge[0].src = 0;  \r\n    graph->edge[0].dest = 1;  \r\n    graph->edge[0].weight = 10;   \r\n    graph->edge[1].src = 0;  \r\n    graph->edge[1].dest = 2;  \r\n    graph->edge[1].weight = 6;  \r\n\r\n    graph->edge[2].src = 0;  \r\n    graph->edge[2].dest = 3;  \r\n    graph->edge[2].weight = 5;   \r\n    graph->edge[3].src = 1;  \r\n    graph->edge[3].dest = 3;  \r\n    graph->edge[3].weight = 15;  \r\n  \r\n    graph->edge[4].src = 2;  \r\n    graph->edge[4].dest = 3;  \r\n    graph->edge[4].weight = 4;  \r\n  \r\n    KruskalMST(graph);  \r\n    return 0;  \r\n}  ', 1000, '', '', '1. Sort all the edges in non-decreasing order of their weight.\r\n2. Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If cycle is not formed, include this edge. Else, discard it.\r\n3. Repeat step#2 until there are (V-1) edges in the spanning tree.\r\n\r\n', '2020-05-25'),
(580, 13, 6901012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n  \r\n#define V 5  \r\n  \r\nint minKey(int key[], bool mstSet[])  \r\n{  \r\n    int min = INT_MAX, min_index;  \r\n  \r\n    for (int v = 0; v < V; v++)  \r\n        if (mstSet[v] == false && key[v] < min)  \r\n            min = key[v], min_index = v;  \r\n  \r\n    return min_index;  \r\n}  \r\n   \r\nvoid printMST(int parent[], int graph[V][V])  \r\n{  \r\n    cout<<\"Edge 	Weight\n\";  \r\n    for (int i = 1; i < V; i++)  \r\n        cout<<parent[i]<<\" - \"<<i<<\" 	\"<<graph[i][parent[i]]<<\" \n\";  \r\n}  \r\nvoid primMST(int graph[V][V])  \r\n{  \r\n    int parent[V];  \r\n    \r\n    int key[V];  \r\n    bool mstSet[V];  \r\n    for (int i = 0; i < V; i++)  \r\n        key[i] = INT_MAX, mstSet[i] = false;  \r\n   \r\n    key[0] = 0;  \r\n    parent[0] = -1; \r\n  \r\n    for (int count = 0; count < V - 1; count++) \r\n    {   \r\n        int u = minKey(key, mstSet); \r\n        mstSet[u] = true;  \r\n        for (int v = 0; v < V; v++)   \r\n            if (graph[u][v] && mstSet[v] == false && graph[u][v] < key[v])  \r\n                parent[v] = u, key[v] = graph[u][v];  \r\n    }   \r\n    printMST(parent, graph);  \r\n}  \r\nint main()  \r\n{  \r\n    int graph[V][V] = { { 0, 2, 0, 6, 0 },  \r\n                        { 2, 0, 3, 8, 5 },  \r\n                        { 0, 3, 0, 0, 7 },  \r\n                        { 6, 8, 0, 0, 9 },  \r\n                        { 0, 5, 7, 9, 0 } };  \r\n \r\n    primMST(graph);  \r\n  \r\n    return 0;  \r\n}  ', 1000, '', '', 'Algorithm\r\n1) Create a set mstSet that keeps track of vertices already included in MST.\r\n2) Assign a key value to all vertices in the input graph. Initialize all key values as INFINITE. Assign key value as 0 for the first vertex so that it is picked first.\r\n3) While mstSet doesn’t include all vertices\r\n….a) Pick a vertex u which is not there in mstSet and has minimum key value.\r\n….b) Include u to mstSet.\r\n….c) Update key value of all adjacent vertices of u. To update the key values, iterate through all adjacent vertices. For every adjacent vertex v, if weight of edge u-v is less than the previous key value of v, update the key value as weight of u-v\r\n', '2020-05-25'),
(581, 15, 6901012018, '#include<bits/stdc++.h> \r\nusing namespace std; \r\n  \r\n// Matrix Ai has dimension p[i-1] x p[i]  \r\n// for i = 1..n \r\nint MatrixChainOrder(int p[], int i, int j) \r\n{ \r\n    if(i == j) \r\n        return 0; \r\n    int k; \r\n    int min = INT_MAX; \r\n    int count; \r\n  \r\n    // place parenthesis at different places  \r\n    // between first and last matrix, recursively  \r\n    // calculate count of multiplications for  \r\n    // each parenthesis placement and return the  \r\n    // minimum count \r\n    for (k = i; k < j; k++) \r\n    { \r\n        count = MatrixChainOrder(p, i, k) + \r\n                MatrixChainOrder(p, k + 1, j) + \r\n                p[i - 1] * p[k] * p[j]; \r\n  \r\n        if (count < min) \r\n            min = count; \r\n    } \r\n  \r\n    // Return minimum count \r\n    return min; \r\n} \r\n  \r\n// Driver Code \r\nint main() \r\n{ \r\n    int arr[] = {1, 2, 3, 4, 3}; \r\n    int n = sizeof(arr)/sizeof(arr[0]); \r\n  \r\n    cout << \"Minimum number of multiplications is \"\r\n         << MatrixChainOrder(arr, 1, n - 1); \r\n} ', 1000, '', '', 'MATRIX-CHAIN-ORDER (p)\r\n\r\n\r\n 1. n   length[p]-1\r\n 2. for i ← 1 to n\r\n 3. do m [i, i] ← 0\r\n 4. for l ← 2 to n    // l is the chain length\r\n 5. do for i ← 1 to n-l + 1\r\n 6. do j ← i+ l -1\r\n 7. m[i,j] ←  ∞\r\n 8. for k  ← i to j-1\r\n 9. do q  ← m [i, k] + m [k + 1, j] + pi-1 pk pj	\r\n 10. If q < m [i,j]\r\n 11. then m [i,j] ← q\r\n 12. s [i,j] ← k\r\n 13. return m and s.   ', '2020-05-25'),
(582, 4, 6901012018, '#include<stdio.h> \r\nstruct pair  \r\n{ \r\n  int min; \r\n  int max; \r\n};   \r\n  \r\nstruct pair getMinMax(int arr[], int n) \r\n{ \r\n  struct pair minmax;      \r\n  int i; \r\n    \r\n  /*If there is only one element then return it as min and max both*/\r\n  if (n == 1) \r\n  { \r\n     minmax.max = arr[0]; \r\n     minmax.min = arr[0];      \r\n     return minmax; \r\n  }     \r\n  \r\n  /* If there are more than one elements, then initialize min  \r\n      and max*/\r\n  if (arr[0] > arr[1])   \r\n  { \r\n      minmax.max = arr[0]; \r\n      minmax.min = arr[1]; \r\n  }   \r\n  else\r\n  { \r\n      minmax.max = arr[1]; \r\n      minmax.min = arr[0]; \r\n  }     \r\n \r\n  for (i = 2; i<n; i++) \r\n  { \r\n    if (arr[i] >  minmax.max)       \r\n      minmax.max = arr[i]; \r\n    \r\n    else if (arr[i] <  minmax.min)       \r\n      minmax.min = arr[i]; \r\n  } \r\n    \r\n  return minmax; \r\n} \r\n  \r\n/* Driver program to test above function */\r\nint main() \r\n{ \r\n  int arr[] = {1000, 11, 445, 1, 330, 3000}; \r\n  int arr_size = 6; \r\n  struct pair minmax = getMinMax (arr, arr_size); \r\n  printf(\"nMinimum element is %d\", minmax.min); \r\n  printf(\"nMaximum element is %d\", minmax.max); \r\n  getchar(); \r\n}   ', 0, '6 1000 11 445 1 330 3000', 'nMinimum element is 1nMaximum element is 3000', 'Pair MaxMin(array, array_size)\r\n   if array_size = 1\r\n      return element as both max and min\r\n   else if arry_size = 2\r\n      one comparison to determine max and min\r\n      return that pair\r\n   else    /* array_size  > 2 */\r\n      recur for max and min of left half\r\n      recur for max and min of right half\r\n      one comparison determines true max of the two candidates\r\n      one comparison determines true min of the two candidates\r\n      return the pair of max and min', '2020-05-25'),
(583, 16, 6901012018, '#include<stdio.h> \r\n#include<string.h> \r\n  \r\n// d is the number of characters in the input alphabet \r\n#define d 256 \r\n  \r\n/* pat -> pattern \r\n    txt -> text \r\n    q -> A prime number \r\n*/\r\nvoid search(char pat[], char txt[], int q) \r\n{ \r\n    int M = strlen(pat); \r\n    int N = strlen(txt); \r\n    int i, j; \r\n    int p = 0; // hash value for pattern \r\n    int t = 0; // hash value for txt \r\n    int h = 1; \r\n  \r\n    // The value of h would be \"pow(d, M-1)%q\" \r\n    for (i = 0; i < M-1; i++) \r\n        h = (h*d)%q; \r\n  \r\n    // Calculate the hash value of pattern and first \r\n    // window of text \r\n    for (i = 0; i < M; i++) \r\n    { \r\n        p = (d*p + pat[i])%q; \r\n        t = (d*t + txt[i])%q; \r\n    } \r\n  \r\n    // Slide the pattern over text one by one \r\n    for (i = 0; i <= N - M; i++) \r\n    { \r\n  \r\n        // Check the hash values of current window of text \r\n        // and pattern. If the hash values match then only \r\n        // check for characters on by one \r\n        if ( p == t ) \r\n        { \r\n            /* Check for characters one by one */\r\n            for (j = 0; j < M; j++) \r\n            { \r\n                if (txt[i+j] != pat[j]) \r\n                    break; \r\n            } \r\n  \r\n            // if p == t and pat[0...M-1] = txt[i, i+1, ...i+M-1] \r\n            if (j == M) \r\n                printf(\"Pattern found at index %d \n\", i); \r\n        } \r\n  \r\n        // Calculate hash value for next window of text: Remove \r\n        // leading digit, add trailing digit \r\n        if ( i < N-M ) \r\n        { \r\n            t = (d*(t - txt[i]*h) + txt[i+M])%q; \r\n  \r\n            // We might get negative value of t, converting it \r\n            // to positive \r\n            if (t < 0) \r\n            t = (t + q); \r\n        } \r\n    } \r\n} \r\n  \r\n/* Driver program to test above function */\r\nint main() \r\n{ \r\n    char txt[] = \"water is water\"; \r\n    char pat[] = \"water\"; \r\n    int q = 101; // A prime number \r\n    search(pat, txt, q); \r\n    return 0; \r\n} ', 1000, '', '', 'Rabin-Karp is another pattern searching algorithm to find the pattern in a more efficient way. It also checks the pattern by moving window one by one, but without checking all characters for all cases, it finds the hash value. When the hash value is matched, then only it tries to check each character. This procedure makes the algorithm more efficient.\r\nThe time complexity is O(m+n), but for the worst case, it is O(mn).\r\n\r\nInput and Output\r\nInput:\r\nMain String: “ABAAABCDBBABCDDEBCABC”, Pattern “ABC”\r\nOutput:\r\nPattern found at position: 4\r\nPattern found at position: 10\r\nPattern found at position: 18\r\n\r\nAlgorithm\r\nrabinKarpSearch(text, pattern, prime) ', '2020-05-25'),
(584, 2, 7001012018, '#include<stdlib.h> \r\n#include<stdio.h> \r\nvoid merge(int arr[], int l, int m, int r) \r\n{ \r\n	int i, j, k; \r\n	int n1 = m - l + 1; \r\n	int n2 = r - m; \r\n	int L[n1], R[n2]; \r\n\r\n	for (i = 0; i < n1; i++) \r\n		L[i] = arr[l + i]; \r\n	for (j = 0; j < n2; j++) \r\n		R[j] = arr[m + 1+ j]; \r\n\r\n	i = 0; \r\n	j = 0; \r\n	k = l; \r\n	while (i < n1 && j < n2) \r\n	{ \r\n		if (L[i] <= R[j]) \r\n		{ \r\n			arr[k] = L[i]; \r\n			i++; \r\n		} \r\n		else\r\n		{ \r\n			arr[k] = R[j]; \r\n			j++; \r\n		} \r\n		k++; \r\n	} \r\n\r\n	while (i < n1) \r\n	{ \r\n		arr[k] = L[i]; \r\n		i++; \r\n		k++; \r\n	} \r\n\r\n	while (j < n2) \r\n	{ \r\n		arr[k] = R[j]; \r\n		j++; \r\n		k++; \r\n	} \r\n} \r\n\r\nvoid mergeSort(int arr[], int l, int r) \r\n{ \r\n	if (l < r) \r\n	{ \r\n		int m = l+(r-l)/2; \r\n\r\n		mergeSort(arr, l, m); \r\n		mergeSort(arr, m+1, r); \r\n\r\n		merge(arr, l, m, r); \r\n	} \r\n} \r\nvoid printArray(int A[], int size) \r\n{ \r\n	int i; \r\n	for (i=0; i < size; i++) \r\n		printf(\"%d \", A[i]); \r\n	printf(\"\n\"); \r\n} \r\nint main() \r\n{ \r\n	int n;\r\n	scanf(\"%d\",&n);\r\n	int arr[n];\r\n	for(int i=0;i<n;i++){\r\n		scanf(\"%d\",&arr[i]);\r\n	}\r\n	mergeSort(arr, 0, n-1); \r\n	printArray(arr, n); \r\n	return 0; \r\n} \r\n', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 \n', 'void merge(int arr[], int l, int m, int r) \r\n{ \r\n	int i, j, k; \r\n	int n1 = m - l + 1; \r\n	int n2 = r - m; \r\n	int L[n1], R[n2]; \r\n\r\n	for (i = 0; i < n1; i++) \r\n		L[i] = arr[l + i]; \r\n	for (j = 0; j < n2; j++) \r\n		R[j] = arr[m + 1+ j]; \r\n\r\n	i = 0; \r\n	j = 0; \r\n	k = l; \r\n	while (i < n1 && j < n2) \r\n	{ \r\n		if (L[i] <= R[j]) \r\n		{ \r\n			arr[k] = L[i]; \r\n			i++; \r\n		} \r\n		else\r\n		{ \r\n			arr[k] = R[j]; \r\n			j++; \r\n		} \r\n		k++; \r\n	} \r\n\r\n	while (i < n1) \r\n	{ \r\n		arr[k] = L[i]; \r\n		i++; \r\n		k++; \r\n	} \r\n\r\n	while (j < n2) \r\n	{ \r\n		arr[k] = R[j]; \r\n		j++; \r\n		k++; \r\n	} \r\n} \r\n\r\nvoid mergeSort(int arr[], int l, int r) \r\n{ \r\n	if (l < r) \r\n	{ \r\n		int m = l+(r-l)/2; \r\n\r\n		mergeSort(arr, l, m); \r\n		mergeSort(arr, m+1, r); \r\n\r\n		merge(arr, l, m, r); \r\n	} \r\n} ', '2020-05-25');
INSERT INTO `qtos_map` (`ID`, `Q_ID`, `ROLL`, `SUBMISSION`, `SCORE`, `INPUT`, `OP`, `ALGO`, `DATE`) VALUES
(585, 3, 7001012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\nvoid swap(int* a, int* b) \r\n{ \r\n	int t = *a; \r\n	*a = *b; \r\n	*b = t; \r\n} \r\n\r\nint partition (int arr[], int low, int high) \r\n{ \r\n	int pivot = arr[high];  \r\n	int i = (low - 1); \r\n\r\n	for (int j = low; j <= high - 1; j++) \r\n	{ \r\n		if (arr[j] < pivot) \r\n		{ \r\n			i++; \r\n			swap(&arr[i], &arr[j]); \r\n		} \r\n	} \r\n	swap(&arr[i + 1], &arr[high]); \r\n	return (i + 1); \r\n} \r\n\r\nvoid quickSort(int arr[], int low, int high) \r\n{ \r\n	if (low < high) \r\n	{ \r\n		int pi = partition(arr, low, high); \r\n\r\n		quickSort(arr, low, pi - 1); \r\n		quickSort(arr, pi + 1, high); \r\n	} \r\n} \r\nvoid printArray(int arr[], int size) \r\n{ \r\n	int i; \r\n	for (i=0; i<size; i++) \r\n		cout << arr[i] << \" \"; \r\n	cout << endl; \r\n} \r\nint main() \r\n{ \r\n	int t;\r\n	scanf(\"%d\",&t);\r\n	int n;\r\n	scanf(\"%d\",&n);\r\n	int arr[n];\r\n	for(int i=0; i<n; i++){\r\n		scanf(\"%d\",&arr[i]);\r\n	}\r\n	quickSort(arr, 0, n-1); \r\n	\r\n	printArray(arr, n); \r\n	return 0; \r\n} \r\n\r\n', 0, '1 2000', '-2147483648 -1819111024 -1685415528 -1618043508 -1612784164 -1549622880 -1482250844 -1414878808 -1347506772 -1280134736 -1258291019 -1212762700 -1145390664 -1131412253 -1131412253 -1131411073 -1131410985 -1131410581 -1131397709 -1131397633 -1078018628 -1073741807 -1010646592 -1010646592 -943274556 -943274556 -919471757 -896487233 -877486153 -876857905 -876810249 -875902520 -875902520 -808530484 -808530484 -741158448 -741158448 -673786412 -606414376 -606414376 -539042340 -404298268 -336926232 -285211923 -285211923 -201325834 -201325834 -201325834 -136915500 -100662789 -100662789 -2 -2 -2 -2 -2 -2 -2 -2 -2 -2 -2 -2 -2 -2 -2 -1 -1 -1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 2 2 2 3 3 4 5 5 5 5 5 5 5 5 5 5 6 6 6 8 8 8 8 10 14 16 16 16 16 16 17 24 24 28 28 28 28 28 32 32 36 36 40 40 44 49 63 64 100 111 115 116 116 127 127 127 127 127 127 128 191 244 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 257 257 292 292 292 292 292 319 348 350 372 502 502 512 512 512 512 512 512 532 744 744 1024 1024 1252 1252 1528 1703 2000 2000 2047 2048 2048 2048 2056 4096 4096 4096 4096 4096 5852 5852 5852 5852 8016 12600 15352 52428 52428 65568 65568 131097 196610 196610 327684 327684 458758 458758 491520 589832 589832 720906 720906 851980 851980 983054 983054 983054 983054 1114128 1114128 1245202 1245202 1376276 1376276 1507350 1507350 1638424 1638424 1769498 1769498 1900572 1900572 2031646 2031646 2162720 2162720 2293794 2293794 2424868 2424868 2555942 2555942 2681284 2681316 2681324 2681364 2681364 2682024 2682076 2682100 2682308 2682308 2682340 2682388 2682412 2682420 2682420 2682464 2682464 2682488 2682544 2682588 2682604 2682636 2682692 2682728 2682768 2682776 2682776 2682776 2682776 2682776 2682776 2683040 2683052 2683052 2683072 2683072 2683080 2683104 2683164 2683164 2683288 2683304 2683304 2683304 2683784 2683816 2683892 2683892 2683936 2684540 2684540 2684540 2684540 2684673 2684676 2684692 2684696 2684796 2684856 2684908 2685052 2685052 2685116 2685116 2685244 2685296 2685312 2685348 2685352 2685416 2685428 2685492 2685508 2685532 2685556 2685556 2685668 2685716 2685792 2685804 2685808 2685832 2685892 2685920 2685984 2685984 2685984 2685996 2686012 2686028 2686060 2686076 2686232 2686568 2686580 2686588 2686592 2686604 2686604 2686612 2686640 2686640 2686656 2686664 2686688 2686688 2686692 2686696 2686716 2686916 2687016 2687016 2818090 2818090 2949164 2949164 3080238 3080238 3145774 3145776 3145776 3145777 3145782 3211312 3211312 3211312 3211312 3342386 3342386 3473460 3473460 3531379 3531379 3531379 3538992 3604534 3604534 3735608 3735608 3866682 3866682 3932218 3997756 3997756 4128830 4128830 4228341 4232732 4259904 4259904 4259936 4293252 4390978 4390978 4390978 4391004 4391004 4409264 4420362 4420362 4420362 4522052 4522052 4522052 4653126 4653126 4653126 4784200 4784200 4784200 4915274 4915274 4915274 4952102 4952104 4976516 4976516 4978420 4978420 4978420 4978420 4984480 5009096 5009096 5009096 5011380 5011380 5046348 5046348 5046348 5111900 5177422 5177422 5177422 5232688 5232696 5232696 5232696 5238760 5308496 5308496 5308496 5374044 5439570 5439570 5439570 5439580 5439596 5570644 5570644 5570644 5636188 5701718 5701718 5701718 5832792 5832792 5832792 5963866 5963866 6029413 6029433 6094940 6094940 6226014 6226014 6357069 6357088 6488162 6619236 6619250 6750309 6750310 6750318 6815843 6881384 6881395 6881396 7012458 7077999 7143525 7143532 7209065 7209071 7209071 7274563 7274606 7274610 7405680 7471205 7471215 7471220 7471220 7471221 7536745 7536748 7536754 7602277 7602286 7602286 7602291 7667828 7798902 7864320 7864320 7864320 7864320 7864320 7864320 7864320 7864320 7864320 7864320 7864320 7864320 7864320 7864320 7864320 7864320 7864320 7864320 7864320 7864320 7864320 7864516 7864516 7864516 7864516 7864516 7864516 7864516 7864576 7864656 7864656 7864656 7864656 7864656 7864656 7864656 7864656 7864656 7864692 7864748 7864748 7864748 7876392 7876392 7876392 7876576 7876576 7876584 7876616 7876616 7876616 7876618 7876619 7876624 7876624 7876624 7878776 7878776 7878776 7878778 7878779 7878784 7878784 7878784 7880672 7880672 7880680 7880680 7880680 7881064 7881816 7881816 7881816 7881880 7884768 7929939 7929976 8018600 8024032 8024040 8028784 8029248 8029248 8029256 8032224 8032224 8032232 8032232 8032232 8061018 8061050 8192124 8192124 8323198 8323198 8462508 8462508 9240914 9240914 9372029 9372029 9437326 9510605 10289490 10289491 10551456 10551456 10682530 10682530 10813440 10813440 10813440 10813440 10813440 10813440 10813440 10813440 10813440 10813440 10813440 10813440 10813604 10813604 10813752 10813776 10813776 10813776 10813776 10813776 10813776 10813776 10813776 10813776 10815440 10815440 10815984 10815996 10817144 10817144 10817432 10817432 10817432 10817432 10817432 10817664 10817664 10817664 10817664 10817664 10817664 10817716 10817716 10817716 10818432 10818448 10818592 10818592 10818620 10820728 10820728 10820728 10820728 10820744 10820856 10825696 10825704 10825704 10825704 10841872 10841872 10841928 10841932 10859560 10859560 10859568 10859568 10859568 10859784 10859784 10859787 10859792 10859792 10859792 10860016 10862560 10944678 10944678 11075752 11075752 11206826 11206826 11337900 11337900 11468974 11468974 11600048 11600048 11731122 11731122 11862196 11862196 11993270 11993270 12124344 12124344 12255418 12255418 12386492 12386492 12517566 12517566 12648640 12648640 12648640 12779714 12779714 12779714 12910788 12910788 12910788 13041862 13041862 13041862 13172936 13172936 13172936 13304010 13304010 13304010 13435084 13435084 13435084 13566158 13566158 13566158 13697232 13697232 13697232 13828306 13828306 13828306 13959380 13959380 13959380 14090454 14090454 14221528 14221528 14221528 14352602 14352602 14352602 14483676 14483676 14483676 14614750 14614750 14745824 14876898 15007972 15139046 15270120 15401194 15532268 15663342 15794416 15925490 16056564 16187606 16187638 16318712 16449786 16580860 16711934 16777218 16777240 16782849 16842496 24641758 24641917 24641918 26288154 26353690 27594360 33554944 34603520 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603536 34603552 34603592 34603592 34603777 34603777 34603777 34603778 34603778 34603778 34603794 34603794 34865680 34865684 35652096 35652112 35652128 35652128 35652128 35652128 35652128 35652128 35652128 35652128 35652128 35652128 35652128 35652128 35652168 35652353 35652353 35652354 36176424 36176424 36700688 40370720 42205828 42205828 42205828 42205828 42205828 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397953 50397954 50398081 50463008 50463008 50463248 50463489 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463490 50463618 51511824 58786320 58786689 58786689 58851856 58852226 58852226 117835012 185207048 252579084 268435456 319951120 335544340 335544340 335544340 387323156 454695192 486604828 522067228 538189843 538189843 538443920 538443920 538714137 538714137 539041824 539041824 539107357 539107357 539369502 539369502 540017350 540017350 540606816 540606816 540672352 540672353 555877084 555877084 589439264 656811300 724183336 791555372 858927408 926299444 993671480 1040187711 1040187711 1061043516 1128415552 1195787588 1263159624 1330531660 1397903696 1465275732 1971928871 1971928876 1971928876 1971938759 1972584718 1972584718 1972764928 1972764960 1972764960 1972764960 1982162552 1982189765 1982189765 1982189847 1982189847 1982190659 1982323158 1982331814 1982344999 1982345122 1982352408 1982353328 1982353351 1982353775 1982353775 1982353775 1982353775 1982355716 1982355716 1982357216 1996727362 1996747260 1996747305 1996747904 1996747913 1996756642 1996756704 1996757057 1996757148 1996757199 1996757210 1996757210 1996758339 1996758387 1996800726 1996800726 1996800947 1996801034 1996801138 1996810641 1996811370 1996811563 1996852437 1996852437 1996852437 1997170816 1997170816 1997170838 1997170905 1997341784 1997341952 1997341952 1997341952 1997341952 1997350624 1997351168 1997351168 1997351168 1997351168 1997351168 1997351168 1997351888 1997355784 1997357184 1997357184 1997357184 1997357184 2005532672 2005614976 2005661941 2005661941 2005662250 2005662378 2005662378 2005662426 2005676794 2005740647 2005740647 2005743738 2005743774 2005744682 2005744756 2005744756 2005744756 2005744756 2005744803 2005744803 2005744803 2005744803 2005744803 2005744803 2005744803 2005744803 2005744846 2005744846 2005744846 2005744846 2005775221 2005775221 2005775221 2005775346 2005775346 2005775346 2005798882 2005938246 2005938281 2005999309 2005999309 2005999309 2005999309 2006042583 2006042615 2006044775 2006044935 2006045055 2006045359 2006045415 2130379298 2147483626 2147483647 \n', '\r\nint partition (int arr[], int low, int high) \r\n{ \r\n	int pivot = arr[high];  \r\n	int i = (low - 1); \r\n\r\n	for (int j = low; j <= high - 1; j++) \r\n	{ \r\n		if (arr[j] < pivot) \r\n		{ \r\n			i++; \r\n			swap(&arr[i], &arr[j]); \r\n		} \r\n	} \r\n	swap(&arr[i + 1], &arr[high]); \r\n	return (i + 1); \r\n} \r\n\r\nvoid quickSort(int arr[], int low, int high) \r\n{ \r\n	if (low < high) \r\n	{ \r\n		int pi = partition(arr, low, high); \r\n\r\n		quickSort(arr, low, pi - 1); \r\n		quickSort(arr, pi + 1, high); \r\n	} \r\n} ', '2020-05-25'),
(586, 7, 7001012018, '\r\n#include <cstdlib> \r\n#include <iostream> \r\nusing namespace std; \r\nint partition(int arr[], int low, int high) \r\n{ \r\n	int pivot = arr[high];  \r\n	int i = (low - 1);  \r\n	for (int j = low; j <= high - 1; j++) {  \r\n		if (arr[j] <= pivot) { \r\n			i++; \r\n			swap(arr[i], arr[j]); \r\n		} \r\n	} \r\n	swap(arr[i + 1], arr[high]); \r\n	return (i + 1); \r\n}  \r\nint partition_r(int arr[], int low, int high) \r\n{ \r\n	int random = low + rand() % (high - low); \r\n	swap(arr[random], arr[high]); \r\n	return partition(arr, low, high); \r\n} \r\nvoid RqSort(int arr[], int low, int high) \r\n{ \r\n	if (low < high) { \r\n		int pi = partition_r(arr, low, high); \r\n		RqSort(arr, low, pi - 1); \r\n		RqSort(arr, pi + 1, high); \r\n	} \r\n} \r\nvoid printArray(int arr[], int size) \r\n{ \r\n	int i; \r\n	for (i = 0; i < size; i++) \r\n		printf(\"%d \", arr[i]); \r\n	printf(\"\n\"); \r\n} \r\nint main() \r\n{ \r\n	int n;\r\n	cin>>n;\r\n	int arr[n];\r\n	for(int i=0;i<n;i++){\r\n		cin>>arr[i];\r\n	}\r\n	RqSort(arr, 0, n - 1); \r\n	printArray(arr, n); \r\n	return 0; \r\n} \r\n', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '', 'int partition(int arr[], int low, int high) \r\n{ \r\n	int pivot = arr[high];  \r\n	int i = (low - 1);  \r\n	for (int j = low; j <= high - 1; j++) {  \r\n		if (arr[j] <= pivot) { \r\n			i++; \r\n			swap(arr[i], arr[j]); \r\n		} \r\n	} \r\n	swap(arr[i + 1], arr[high]); \r\n	return (i + 1); \r\n}  \r\nint partition_r(int arr[], int low, int high) \r\n{ \r\n	int random = low + rand() % (high - low); \r\n	swap(arr[random], arr[high]); \r\n	return partition(arr, low, high); \r\n} \r\nvoid RqSort(int arr[], int low, int high) \r\n{ \r\n	if (low < high) { \r\n		int pi = partition_r(arr, low, high); \r\n		RqSort(arr, low, pi - 1); \r\n		RqSort(arr, pi + 1, high); \r\n	} \r\n} ', '2020-05-25'),
(587, 9, 7001012018, '#include <iostream> \r\nusing namespace std; \r\nclass DisjSet { \r\n	int *r,*p, n; \r\npublic: \r\n	DisjSet(int n) \r\n	{ \r\n		r = new int[n]; \r\n		p= new int[n]; \r\n		this->n = n; \r\n		createSet(); \r\n	} \r\n	void createSet() \r\n	{ \r\n		for (int i = 0; i < n; i++) { \r\n			p[i] = i; \r\n		} \r\n	}\r\n	int findSet(int x) \r\n	{  \r\n		if (p[x] != x) { \r\n			p[x] = findSet(p[x]); \r\n		} \r\n		return p[x]; \r\n	}  \r\n	void mergeSet(int x, int y) \r\n	{ \r\n		int xset = findSet(x); \r\n		int yset = findSet(y); \r\n		if (xset == yset) \r\n			return; \r\n		if (r[xset] < r[yset]) { \r\n			p[xset] = yset; \r\n		} \r\n		else if (r[xset] > r[yset]) { \r\n			p[yset] = xset; \r\n		} \r\n		else { \r\n			p[yset] = xset; \r\n			r[xset] = r[xset] + 1; \r\n		} \r\n	} \r\n}; \r\n\r\nint main() \r\n{ \r\n	DisjSet obj(5); \r\n	obj.mergeSet(0, 2); \r\n	obj.mergeSet(2, 4);\r\n	obj.mergeSet(1, 3); \r\n	if (obj.findSet(2) == obj.findSet(0)) \r\n		cout << \"Yes\n\"; \r\n	else\r\n		cout << \"No\n\"; \r\n	if (obj.findSet(4) == obj.findSet(0)) \r\n		cout << \"Yes\n\"; \r\n	else\r\n		cout << \"No\n\"; \r\n\r\n	return 0; \r\n} \r\n', 1000, '', '', 'void createSet() \r\n	{ \r\n		for (int i = 0; i < n; i++) { \r\n			p[i] = i; \r\n		} \r\n	}\r\n	int findSet(int x) \r\n	{  \r\n		if (p[x] != x) { \r\n			p[x] = findSet(p[x]); \r\n		} \r\n		return p[x]; \r\n	}  \r\n	void mergeSet(int x, int y) \r\n	{ \r\n		int xset = findSet(x); \r\n		int yset = findSet(y); \r\n		if (xset == yset) \r\n			return; \r\n		if (r[xset] < r[yset]) { \r\n			p[xset] = yset; \r\n		} \r\n		else if (r[xset] > r[yset]) { \r\n			p[yset] = xset; \r\n		} \r\n		else { \r\n			p[yset] = xset; \r\n			r[xset] = r[xset] + 1; \r\n		} \r\n	} ', '2020-05-25'),
(588, 10, 7001012018, '\r\n#include <bits/stdc++.h> \r\nusing namespace std;\r\nint max(int a, int b) {\r\n	 return (a > b)? a : b; \r\n} \r\n\r\nint knapSack(int W, int wt[], int val[], int n) \r\n{ \r\n	if (n == 0||W == 0) \r\n		return 0; \r\n\r\n	if (wt[n-1] > W) \r\n		return knapSack(W, wt, val, n-1); \r\n\r\n	else \r\n		return max( val[n-1] + knapSack(W-wt[n-1], wt, val, n-1), knapSack(W, wt, val, n-1) ); \r\n} \r\n\r\nint main() \r\n{ \r\n	int n,W;\r\n	cin>>n>>W; \r\n    int val[n];  \r\n    int wt[n]; \r\n      for(int i=0;i<n;i++)\r\n      	cin>>val[i];\r\n      	for(int i=0;i<n;i++)\r\n      	cin>>wt[i];\r\n     \r\n    cout<<knapSack(W, wt, val, n);  \r\n    \r\n	return 0; \r\n} \r\n', 10, '5 15 4 2 1 2 10 12 2 1 1 4', '15', 'int knapSack(int W, int wt[], int val[], int n) \r\n{ \r\n	if (n == 0||W == 0) \r\n		return 0; \r\n\r\n	if (wt[n-1] > W) \r\n		return knapSack(W, wt, val, n-1); \r\n\r\n	else \r\n		return max( val[n-1] + knapSack(W-wt[n-1], wt, val, n-1), knapSack(W, wt, val, n-1) ); \r\n} ', '2020-05-25'),
(589, 12, 7001012018, '\r\n#include <bits/stdc++.h> \r\nusing namespace std; \r\nclass Edge \r\n{ \r\n	public: \r\n	int src,dest,w; \r\n}; \r\nclass Graph \r\n{ \r\n	public: \r\n	int V, E; \r\n	Edge* e; \r\n}; \r\nGraph* createGraph(int V, int E) \r\n{ \r\n	Graph* g = new Graph; \r\n	g->V = V; \r\n	g->E = E; \r\n	g->e = new Edge[E]; \r\n\r\n	return g; \r\n} \r\nclass subset \r\n{ \r\n	public: \r\n	int parent; \r\n	int rank; \r\n};  \r\nint find(subset s[], int i) \r\n{  \r\n	if (s[i].parent != i) \r\n		s[i].parent = find(s, s[i].parent); \r\n\r\n	return s[i].parent; \r\n} \r\nvoid Union(subset s[], int x, int y) \r\n{ \r\n	int xroot = find(s, x); \r\n	int yroot = find(s, y); \r\n	if (s[xroot].rank <s[yroot].rank) \r\n		s[xroot].parent = yroot; \r\n	else if (s[xroot].rank >s[yroot].rank) \r\n		s[yroot].parent = xroot;\r\n	else\r\n	{ \r\n		s[yroot].parent = xroot; \r\n		s[xroot].rank++; \r\n	} \r\n} \r\nint myComp(const void* a, const void* b) \r\n{ \r\n	Edge* a1 = (Edge*)a; \r\n	Edge* b1 = (Edge*)b; \r\n	return a1->w > b1->w; \r\n} \r\nvoid KruskalMST(Graph* g) \r\n{ \r\n	int V = g->V; \r\n	Edge result[V]; \r\n	int e = 0; \r\n	int i = 0; \r\n\r\n	qsort(g->e, g->E, sizeof(g->e[0]), myComp); \r\n	subset *s = new subset[( V * sizeof(subset) )];  \r\n	for (int v = 0; v < V; ++v) \r\n	{ \r\n		s[v].parent = v; \r\n		s[v].rank = 0; \r\n	} \r\n	while (e < V - 1 && i < g->E) \r\n	{ \r\n		Edge next = g->e[i++]; \r\n\r\n		int x = find(s, next.src); \r\n		int y = find(s, next.dest); \r\n\r\n		if (x != y) \r\n		{ \r\n			result[e++] = next; \r\n			Union(s, x, y); \r\n		} \r\n	\r\n	} \r\n	for (i = 0; i < e; ++i) \r\n		cout<<result[i].src<<\" -- \"<<result[i].dest<<\" ==> \"<<result[i].w<<endl; \r\n	return; \r\n} \r\nint main() \r\n{ \r\n	int V = 4; \r\n	int E = 5;\r\n	Graph* graph = createGraph(V, E); \r\n\r\n	graph->e[0].src = 0; \r\n	graph->e[0].dest = 1; \r\n	graph->e[0].w = 8; \r\n\r\n	graph->e[1].src = 0; \r\n	graph->e[1].dest = 2; \r\n	graph->e[1].w = 7; \r\n\r\n	graph->e[2].src = 0; \r\n	graph->e[2].dest = 3; \r\n	graph->e[2].w = 8; \r\n\r\n	graph->e[3].src = 1; \r\n	graph->e[3].dest = 3; \r\n	graph->e[3].w = 35; \r\n\r\n	graph->e[4].src = 3; \r\n	graph->e[4].dest = 1; \r\n	graph->e[4].w = 4; \r\n\r\n	KruskalMST(graph); \r\n\r\n	return 0; \r\n} \r\n', 1000, '', '', 'void KruskalMST(Graph* g) \r\n{ \r\n	int V = g->V; \r\n	Edge result[V]; \r\n	int e = 0; \r\n	int i = 0; \r\n\r\n	qsort(g->e, g->E, sizeof(g->e[0]), myComp); \r\n	subset *s = new subset[( V * sizeof(subset) )];  \r\n	for (int v = 0; v < V; ++v) \r\n	{ \r\n		s[v].parent = v; \r\n		s[v].rank = 0; \r\n	} \r\n	while (e < V - 1 && i < g->E) \r\n	{ \r\n		Edge next = g->e[i++]; \r\n\r\n		int x = find(s, next.src); \r\n		int y = find(s, next.dest); \r\n\r\n		if (x != y) \r\n		{ \r\n			result[e++] = next; \r\n			Union(s, x, y); \r\n		} \r\n	\r\n	} \r\n	for (i = 0; i < e; ++i) \r\n		cout<<result[i].src<<\" -- \"<<result[i].dest<<\" ==> \"<<result[i].w<<endl; \r\n	return; \r\n} ', '2020-05-25'),
(590, 13, 7001012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n#define V 5 \r\nint minKey(int key[], bool mstSet[]) \r\n{ \r\n	int min = INT_MAX, min_index; \r\n	for (int v = 0; v < V; v++) \r\n		if (mstSet[v] == false && key[v] < min) \r\n			min = key[v], min_index = v; \r\n\r\n	return min_index; \r\n} \r\nvoid print(int parent[], int graph[V][V]) \r\n{ \r\n	cout<<\"Edge 	Weight\n\"; \r\n	for (int i = 1; i < V; i++) \r\n		cout<<parent[i]<<\" - \"<<i<<\" 	\"<<graph[i][parent[i]]<<\" \n\"; \r\n} \r\nvoid Prims(int graph[V][V]) \r\n{ \r\n	int parent[V]; \r\n	int key[V]; \r\n	bool mstSet[V];\r\n	for (int i = 0; i < V; i++) \r\n		key[i] = INT_MAX, mstSet[i] = false; \r\n	key[0] = 0; \r\n	parent[0] = -1; \r\n	for (int count = 0; count < V - 1; count++) \r\n	{  \r\n		int u = minKey(key, mstSet); \r\n		mstSet[u] = true; \r\n		for (int v = 0; v < V; v++) \r\n			if (graph[u][v] && mstSet[v] == false && graph[u][v] < key[v]) \r\n				parent[v] = u, key[v] = graph[u][v]; \r\n	} 	\r\n	print(parent, graph); \r\n} \r\nint main() \r\n{ \r\n	int graph[V][V] = { 	{ 0, 1, 1, 3, 0 }, \r\n			{ 3, 0, 3, 6, 4 }, \r\n			{ 1, 2, 0, 0, 7 }, \r\n			{ 6, 8, 0, 0, 9 }, \r\n			{ 0, 5, 7, 9, 0 } }; \r\n\r\n	Prims(graph); \r\n	return 0; \r\n} \r\n', 1000, '', '', '\r\nint minKey(int key[], bool mstSet[]) \r\n{ \r\n	int min = INT_MAX, min_index; \r\n	for (int v = 0; v < V; v++) \r\n		if (mstSet[v] == false && key[v] < min) \r\n			min = key[v], min_index = v; \r\n\r\n	return min_index; \r\n} \r\nvoid print(int parent[], int graph[V][V]) \r\n{ \r\n	cout<<\"Edge 	Weight\n\"; \r\n	for (int i = 1; i < V; i++) \r\n		cout<<parent[i]<<\" - \"<<i<<\" 	\"<<graph[i][parent[i]]<<\" \n\"; \r\n} \r\nvoid Prims(int graph[V][V]) \r\n{ \r\n	int parent[V]; \r\n	int key[V]; \r\n	bool mstSet[V];\r\n	for (int i = 0; i < V; i++) \r\n		key[i] = INT_MAX, mstSet[i] = false; \r\n	key[0] = 0; \r\n	parent[0] = -1; \r\n	for (int count = 0; count < V - 1; count++) \r\n	{  \r\n		int u = minKey(key, mstSet); \r\n		mstSet[u] = true; \r\n		for (int v = 0; v < V; v++) \r\n			if (graph[u][v] && mstSet[v] == false && graph[u][v] < key[v]) \r\n				parent[v] = u, key[v] = graph[u][v]; \r\n	} 	\r\n	print(parent, graph); \r\n} \r\n\r\n', '2020-05-25'),
(591, 14, 7001012018, '#include <bits/stdc++.h> \r\nstruct Edge { \r\n	int src, dest, weight; \r\n}; \r\nstruct Graph { \r\n	int V, E; \r\n	struct Edge* edge; \r\n};  \r\nstruct Graph* createGraph(int V, int E) \r\n{ \r\n	struct Graph* graph = new Graph; \r\n	graph->V = V; \r\n	graph->E = E; \r\n	graph->edge = new Edge[E]; \r\n	return graph; \r\n} \r\nvoid printArr(int dist[], int n) \r\n{ \r\n	printf(\"Vertex Distance from Source\n\"); \r\n	for (int i = 0; i < n; ++i) \r\n		printf(\"%d     %d\n\", i, dist[i]); \r\n} \r\nvoid BellmanFord(struct Graph* graph, int src) \r\n{ \r\n	int V = graph->V; \r\n	int E = graph->E; \r\n	int dist[V]; \r\n	for (int i = 0; i < V; i++) \r\n		dist[i] = INT_MAX; \r\n	dist[src] = 0; \r\n	for (int i = 1; i <= V - 1; i++) { \r\n		for (int j = 0; j < E; j++) { \r\n			int u = graph->edge[j].src; \r\n			int v = graph->edge[j].dest; \r\n			int weight = graph->edge[j].weight; \r\n			if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) \r\n				dist[v] = dist[u] + weight; \r\n		} \r\n	}  \r\n	for (int i = 0; i < E; i++) { \r\n		int u = graph->edge[i].src; \r\n		int v = graph->edge[i].dest; \r\n		int weight = graph->edge[i].weight; \r\n		if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) { \r\n			printf(\"Graph contains negative weight cycle\"); \r\n			return; \r\n		} \r\n	} \r\n\r\n	printArr(dist, V); \r\n	return; \r\n} \r\nint main() \r\n{ \r\n	int V = 5; \r\n	int E = 8; \r\n	struct Graph* graph = createGraph(V, E); \r\n\r\n	graph->edge[0].src = 0; \r\n	graph->edge[0].dest = 1; \r\n	graph->edge[0].weight = -1; \r\n\r\n	graph->edge[1].src = 0; \r\n	graph->edge[1].dest = 2; \r\n	graph->edge[1].weight = 9; \r\n\r\n	graph->edge[2].src = 1; \r\n	graph->edge[2].dest = 2; \r\n	graph->edge[2].weight = -7; \r\n\r\n	graph->edge[3].src = 1; \r\n	graph->edge[3].dest = 3; \r\n	graph->edge[3].weight = 2; \r\n\r\n	graph->edge[4].src = 1; \r\n	graph->edge[4].dest = 4; \r\n	graph->edge[4].weight = 2; \r\n\r\n	graph->edge[5].src = 3; \r\n	graph->edge[5].dest = 2; \r\n	graph->edge[5].weight = 5; \r\n	\r\n	graph->edge[6].src = 3; \r\n	graph->edge[6].dest = 1; \r\n	graph->edge[6].weight = 1; \r\n	\r\n	graph->edge[7].src = 4; \r\n	graph->edge[7].dest = 3; \r\n	graph->edge[7].weight = -3; \r\n\r\n	BellmanFord(graph, 0); \r\n\r\n	return 0; \r\n} \r\n', 1000, '', '', 'void BellmanFord(struct Graph* graph, int src) \r\n{ \r\n	int V = graph->V; \r\n	int E = graph->E; \r\n	int dist[V]; \r\n	for (int i = 0; i < V; i++) \r\n		dist[i] = INT_MAX; \r\n	dist[src] = 0; \r\n	for (int i = 1; i <= V - 1; i++) { \r\n		for (int j = 0; j < E; j++) { \r\n			int u = graph->edge[j].src; \r\n			int v = graph->edge[j].dest; \r\n			int weight = graph->edge[j].weight; \r\n			if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) \r\n				dist[v] = dist[u] + weight; \r\n		} \r\n	}  \r\n	for (int i = 0; i < E; i++) { \r\n		int u = graph->edge[i].src; \r\n		int v = graph->edge[i].dest; \r\n		int weight = graph->edge[i].weight; \r\n		if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) { \r\n			printf(\"Graph contains negative weight cycle\"); \r\n			return; \r\n		} \r\n	} ', '2020-05-25'),
(592, 15, 7001012018, '\r\n#include<bits/stdc++.h> \r\nusing namespace std; \r\nint MatrixChainOrder(int p[], int i, int j) \r\n{ \r\n	if(i == j) \r\n		return 0; \r\n	int k; \r\n	int min = INT_MAX; \r\n	int count; \r\n \r\n	for (k = i; k < j; k++) \r\n	{ \r\n		count = MatrixChainOrder(p, i, k) + \r\n				MatrixChainOrder(p, k + 1, j) + \r\n				p[i - 1] * p[k] * p[j]; \r\n\r\n		if (count < min) \r\n			min = count; \r\n	}  \r\n	return min; \r\n} \r\nint main() \r\n{ \r\n    int n;\r\n    cin>>n;\r\n	int arr[n]; \r\n	for(int i=0; i<n ;i++)\r\n		cin>>arr[i];\r\n\r\n	cout<< MatrixChainOrder(arr, 1, n - 1); \r\n} ', 1000, '', '', 'int MatrixChainOrder(int p[], int i, int j) \r\n{ \r\n	if(i == j) \r\n		return 0; \r\n	int k; \r\n	int min = INT_MAX; \r\n	int count; \r\n \r\n	for (k = i; k < j; k++) \r\n	{ \r\n		count = MatrixChainOrder(p, i, k) + \r\n				MatrixChainOrder(p, k + 1, j) + \r\n				p[i - 1] * p[k] * p[j]; \r\n\r\n		if (count < min) \r\n			min = count; \r\n	}  \r\n	return min; \r\n} ', '2020-05-25'),
(593, 4, 7001012018, '\r\n#include<stdio.h> \r\nstruct pair \r\n{ \r\nint min; \r\nint max; \r\n}; \r\n\r\nstruct pair getMinMax(int arr[], int low, int high) \r\n{ \r\nstruct pair minmax, mml, mmr;	 \r\nint mid; \r\nif (low == high) \r\n{ \r\n	minmax.max = arr[low]; \r\n	minmax.min = arr[low];	 \r\n	return minmax; \r\n}	 \r\nif (high == low + 1) \r\n{ \r\n	if (arr[low] > arr[high]) \r\n	{ \r\n		minmax.max = arr[low]; \r\n		minmax.min = arr[high]; \r\n	} \r\n	else\r\n	{ \r\n		minmax.max = arr[high]; \r\n		minmax.min = arr[low]; \r\n	} \r\n	return minmax; \r\n} \r\nmid = (low + high)/2; \r\nmml = getMinMax(arr, low, mid); \r\nmmr = getMinMax(arr, mid+1, high); \r\nif (mml.min < mmr.min) \r\n	minmax.min = mml.min; \r\nelse\r\n	minmax.min = mmr.min;	 \r\nif (mml.max > mmr.max) \r\n	minmax.max = mml.max; \r\nelse\r\n	minmax.max = mmr.max;	 \r\n\r\nreturn minmax; \r\n} \r\nint main() \r\n{ \r\nint arr[] = {22,13,-5,-8,15,60,17,31,47}; \r\nint arr_size = 10; \r\nstruct pair minmax = getMinMax(arr, 0, arr_size-1); \r\nprintf(\"Minimum element is %d  \", minmax.min); \r\nprintf(\"Maximum element is %d  \", minmax.max); \r\ngetchar(); \r\n} \r\n', 0, '6 1000 11 445 1 330 3000', 'Minimum element is -8  Maximum element is 60  ', 'if (low == high) \r\n{ \r\n	minmax.max = arr[low]; \r\n	minmax.min = arr[low];	 \r\n	return minmax; \r\n}	 \r\nif (high == low + 1) \r\n{ \r\n	if (arr[low] > arr[high]) \r\n	{ \r\n		minmax.max = arr[low]; \r\n		minmax.min = arr[high]; \r\n	} \r\n	else\r\n	{ \r\n		minmax.max = arr[high]; \r\n		minmax.min = arr[low]; \r\n	} \r\n	return minmax; \r\n} \r\nmid = (low + high)/2; \r\nmml = getMinMax(arr, low, mid); \r\nmmr = getMinMax(arr, mid+1, high); \r\nif (mml.min < mmr.min) \r\n	minmax.min = mml.min; \r\nelse\r\n	minmax.min = mmr.min;	 \r\nif (mml.max > mmr.max) \r\n	minmax.max = mml.max; \r\nelse\r\n	minmax.max = mmr.max;	 \r\n\r\nreturn minmax; \r\n} ', '2020-05-25'),
(594, 8, 7001012018, '#include < iostream>\r\n#include < vector>\r\n#include < cmath>\r\n#include < algorithm>\r\nusing namespace std;\r\n\r\nint nextpowerof2(int k)\r\n{\r\n    return pow(2, int(ceil(log2(k))));\r\n}\r\nvoid display(vector< vector<int>> &matrix, int m, int n)\r\n{\r\n    for (int i = 0; i < m; i++)\r\n    {\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            if (j != 0)\r\n            {\r\n                cout << \"	\";\r\n            }\r\n            cout << matrix[i][j];\r\n        }\r\n        cout << endl;\r\n    }\r\n}\r\n\r\nvoid add(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\r\n{\r\n    int i, j;\r\n\r\n    for (i = 0; i < size; i++)\r\n    {\r\n        for (j = 0; j < size; j++)\r\n        {\r\n            C[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid sub(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\r\n{\r\n    int i, j;\r\n\r\n    for (i = 0; i < size; i++)\r\n    {\r\n        for (j = 0; j < size; j++)\r\n        {\r\n            C[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid STRASSEN_algorithmA(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\r\n{\r\n    if (size == 1)\r\n    {\r\n        C[0][0] = A[0][0] * B[0][0];\r\n        return;\r\n    }\r\n    else\r\n    {\r\n        int new_size = size / 2;\r\n        vector<int> z(new_size);\r\n        vector<vector<int>>\r\n            a11(new_size, z), a12(new_size, z), a21(new_size, z), a22(new_size, z),\r\n            b11(new_size, z), b12(new_size, z), b21(new_size, z), b22(new_size, z),\r\n            c11(new_size, z), c12(new_size, z), c21(new_size, z), c22(new_size, z),\r\n            p1(new_size, z), p2(new_size, z), p3(new_size, z), p4(new_size, z),\r\n            p5(new_size, z), p6(new_size, z), p7(new_size, z),\r\n            aResult(new_size, z), bResult(new_size, z);\r\n\r\nint i, j;\r\nfor (i = 0; i < new_size; i++)\r\n        {\r\n            for (j = 0; j < new_size; j++)\r\n            {\r\n                a11[i][j] = A[i][j];\r\n                a12[i][j] = A[i][j + new_size];\r\n                a21[i][j] = A[i + new_size][j];\r\n                a22[i][j] = A[i + new_size][j + new_size];\r\n\r\n                b11[i][j] = B[i][j];\r\n                b12[i][j] = B[i][j + new_size];\r\n                b21[i][j] = B[i + new_size][j];\r\n                b22[i][j] = B[i + new_size][j + new_size];\r\n            }\r\n}\r\n        add(a11, a22, aResult, new_size);   \r\n        add(b11, b22, bResult, new_size);    \r\n        STRASSEN_algorithmA(aResult, bResult, p1, new_size); \r\n        \r\n        add(a21, a22, aResult, new_size);\r\n        STRASSEN_algorithmA(aResult, b11, p2, new_size);\r\n\r\n        sub(b12, b22, bResult, new_size);      \r\n        STRASSEN_algorithmA(a11, bResult, p3, new_size);\r\n\r\n        sub(b21, b11, bResult, new_size);       \r\n        STRASSEN_algorithmA(a22, bResult, p4, new_size); \r\n\r\n        add(a11, a12, aResult, new_size);      \r\n        STRASSEN_algorithmA(aResult, b22, p5, new_size);\r\n  \r\n        sub(a21, a11, aResult, new_size);    \r\n        add(b11, b12, bResult, new_size);               \r\n      \r\n        STRASSEN_algorithmA(aResult, bResult, p6, new_size);\r\n        sub(a12, a22, aResult, new_size);   \r\n        add(b21, b22, bResult, new_size);                \r\n        STRASSEN_algorithmA(aResult, bResult, p7, new_size);\r\n        add(p3, p5, c12, new_size); \r\n        add(p2, p4, c21, new_size); \r\n        add(p1, p4, aResult, new_size);       \r\n        add(aResult, p7, bResult, new_size); \r\n        sub(bResult, p5, c11, new_size); \r\n\r\n        add(p1, p3, aResult, new_size);      \r\n        add(aResult, p6, bResult, new_size); \r\n        sub(bResult, p2, c22, new_size); \r\n        for (i = 0; i < new_size; i++)\r\n        {\r\n            for (j = 0; j < new_size; j++)\r\n            {\r\n                C[i][j] = c11[i][j];\r\n                C[i][j + new_size] = c12[i][j];\r\n                C[i + new_size][j] = c21[i][j];\r\n                C[i + new_size][j + new_size] = c22[i][j];\r\n            }\r\n        }\r\n    }\r\n}\r\nvoid STRASSEN_algorithm(vector<vector<int>> &A, vector<vector<int>> &B, int m, int n, int a, int b)\r\n{  \r\n    int k =n;\r\n\r\n    int s = nextpowerof2(k);\r\n\r\n    vector<int> z(s);\r\n    vector<vector<int>> Aa(s, z), Bb(s, z), Cc(s, z);\r\n\r\n    for (unsigned int i = 0; i < n; i++)\r\n    {\r\n        for (unsigned int j = 0; j < n; j++)\r\n        {\r\n            Aa[i][j] = A[i][j];\r\n        }\r\n    }\r\n    for (unsigned int i = 0; i < n; i++)\r\n    {\r\n        for (unsigned int j = 0; j < n; j++)\r\n        {\r\n            Bb[i][j] = B[i][j];\r\n        }\r\n    }\r\n    STRASSEN_algorithmA(Aa, Bb, Cc, s);\r\n    vector<int> temp1(b);\r\n    vector<vector<int>> C(m, temp1);\r\n    for (unsigned int i = 0; i < n; i++)\r\n    {\r\n        for (unsigned int j = 0; j < n; j++)\r\n        {\r\n            C[i][j] = Cc[i][j];\r\n        }\r\n    }\r\n    display(C, n, n);\r\n}\r\n\r\nint main()\r\n{\r\n    int n;\r\n    cin >> n;\r\n    vector<vector<int>> A;\r\n   \r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        vector<int> temp;\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            int i;\r\n            cin >> i;\r\n            temp.push_back(i);\r\n        }\r\n        A.push_back(temp);\r\n    }\r\n    vector<vector<int>> B;\r\n    \r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        vector<int> temp;\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            int i;\r\n            cin >> i;\r\n            temp.push_back(i);\r\n        }\r\n        B.push_back(temp);\r\n    }\r\n        STRASSEN_algorithm(A, B, n, n, n, n);\r\n\r\n    return 0;\r\n}', 0, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '', '\r\nvoid add(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\r\n{\r\n    int i, j;\r\n\r\n    for (i = 0; i < size; i++)\r\n    {\r\n        for (j = 0; j < size; j++)\r\n        {\r\n            C[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid sub(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\r\n{\r\n    int i, j;\r\n\r\n    for (i = 0; i < size; i++)\r\n    {\r\n        for (j = 0; j < size; j++)\r\n        {\r\n            C[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid STRASSEN_algorithmA(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\r\n{\r\n    if (size == 1)\r\n    {\r\n        C[0][0] = A[0][0] * B[0][0];\r\n        return;\r\n    }\r\n    else\r\n    {\r\n        int new_size = size / 2;\r\n        vector<int> z(new_size);\r\n        vector<vector<int>>\r\n            a11(new_size, z), a12(new_size, z), a21(new_size, z), a22(new_size, z),\r\n            b11(new_size, z), b12(new_size, z), b21(new_size, z), b22(new_size, z),\r\n            c11(new_size, z), c12(new_size, z), c21(new_size, z), c22(new_size, z),\r\n            p1(new_size, z), p2(new_size, z), p3(new_size, z), p4(new_size, z),\r\n            p5(new_size, z), p6(new_size, z), p7(new_size, z),\r\n            aResult(new_size, z), bResult(new_size, z);\r\n\r\nint i, j;\r\nfor (i = 0; i < new_size; i++)\r\n        {\r\n            for (j = 0; j < new_size; j++)\r\n            {\r\n                a11[i][j] = A[i][j];\r\n                a12[i][j] = A[i][j + new_size];\r\n                a21[i][j] = A[i + new_size][j];\r\n                a22[i][j] = A[i + new_size][j + new_size];\r\n\r\n                b11[i][j] = B[i][j];\r\n                b12[i][j] = B[i][j + new_size];\r\n                b21[i][j] = B[i + new_size][j];\r\n                b22[i][j] = B[i + new_size][j + new_size];\r\n            }\r\n}\r\n        add(a11, a22, aResult, new_size);   \r\n        add(b11, b22, bResult, new_size);    \r\n        STRASSEN_algorithmA(aResult, bResult, p1, new_size); \r\n        \r\n        add(a21, a22, aResult, new_size);\r\n        STRASSEN_algorithmA(aResult, b11, p2, new_size);\r\n\r\n        sub(b12, b22, bResult, new_size);      \r\n        STRASSEN_algorithmA(a11, bResult, p3, new_size);\r\n\r\n        sub(b21, b11, bResult, new_size);       \r\n        STRASSEN_algorithmA(a22, bResult, p4, new_size); \r\n\r\n        add(a11, a12, aResult, new_size);      \r\n        STRASSEN_algorithmA(aResult, b22, p5, new_size);\r\n  \r\n        sub(a21, a11, aResult, new_size);    \r\n        add(b11, b12, bResult, new_size);               \r\n      \r\n        STRASSEN_algorithmA(aResult, bResult, p6, new_size);\r\n        sub(a12, a22, aResult, new_size);   \r\n        add(b21, b22, bResult, new_size);                \r\n        STRASSEN_algorithmA(aResult, bResult, p7, new_size);\r\n        add(p3, p5, c12, new_size); \r\n        add(p2, p4, c21, new_size); \r\n        add(p1, p4, aResult, new_size);       \r\n        add(aResult, p7, bResult, new_size); \r\n        sub(bResult, p5, c11, new_size); \r\n\r\n        add(p1, p3, aResult, new_size);      \r\n        add(aResult, p6, bResult, new_size); \r\n        sub(bResult, p2, c22, new_size); \r\n        for (i = 0; i < new_size; i++)\r\n        {\r\n            for (j = 0; j < new_size; j++)\r\n            {\r\n                C[i][j] = c11[i][j];\r\n                C[i][j + new_size] = c12[i][j];\r\n                C[i + new_size][j] = c21[i][j];\r\n                C[i + new_size][j + new_size] = c22[i][j];\r\n            }\r\n        }\r\n    }\r\n}\r\nvoid STRASSEN_algorithm(vector<vector<int>> &A, vector<vector<int>> &B, int m, int n, int a, int b)\r\n{  \r\n    int k =n;\r\n\r\n    int s = nextpowerof2(k);\r\n\r\n    vector<int> z(s);\r\n    vector<vector<int>> Aa(s, z), Bb(s, z), Cc(s, z);\r\n\r\n    for (unsigned int i = 0; i < n; i++)\r\n    {\r\n        for (unsigned int j = 0; j < n; j++)\r\n        {\r\n            Aa[i][j] = A[i][j];\r\n        }\r\n    }\r\n    for (unsigned int i = 0; i < n; i++)\r\n    {\r\n        for (unsigned int j = 0; j < n; j++)\r\n        {\r\n            Bb[i][j] = B[i][j];\r\n        }\r\n    }\r\n    STRASSEN_algorithmA(Aa, Bb, Cc, s);\r\n    vector<int> temp1(b);\r\n    vector<vector<int>> C(m, temp1);\r\n    for (unsigned int i = 0; i < n; i++)\r\n    {\r\n        for (unsigned int j = 0; j < n; j++)\r\n        {\r\n            C[i][j] = Cc[i][j];\r\n        }\r\n    }\r\n    display(C, n, n);\r\n}\r\n\r\nint main()\r\n{\r\n    int n;\r\n    cin >> n;\r\n    vector<vector<int>> A;\r\n   \r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        vector<int> temp;\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            int i;\r\n            cin >> i;\r\n            temp.push_back(i);\r\n        }\r\n        A.push_back(temp);\r\n    }\r\n    vector<vector<int>> B;\r\n    \r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        vector<int> temp;\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            int i;\r\n            cin >> i;\r\n            temp.push_back(i);\r\n        }\r\n        B.push_back(temp);\r\n    }\r\n        STRASSEN_algorithm(A, B, n, n, n, n);\r\n\r\n    return 0;\r\n}', '2020-05-25');
INSERT INTO `qtos_map` (`ID`, `Q_ID`, `ROLL`, `SUBMISSION`, `SCORE`, `INPUT`, `OP`, `ALGO`, `DATE`) VALUES
(595, 5, 7001012018, '#include < iostream>\r\n#include < vector>\r\n#include < cmath>\r\n#include < algorithm>\r\nusing namespace std;\r\n\r\nint nextpowerof2(int k)\r\n{\r\n    return pow(2, int(ceil(log2(k))));\r\n}\r\nvoid display(vector< vector<int>> &matrix, int m, int n)\r\n{\r\n    for (int i = 0; i < m; i++)\r\n    {\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            if (j != 0)\r\n            {\r\n                cout << \"	\";\r\n            }\r\n            cout << matrix[i][j];\r\n        }\r\n        cout << endl;\r\n    }\r\n}\r\n\r\nvoid add(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\r\n{\r\n    int i, j;\r\n\r\n    for (i = 0; i < size; i++)\r\n    {\r\n        for (j = 0; j < size; j++)\r\n        {\r\n            C[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid sub(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\r\n{\r\n    int i, j;\r\n\r\n    for (i = 0; i < size; i++)\r\n    {\r\n        for (j = 0; j < size; j++)\r\n        {\r\n            C[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid STRASSEN_algorithmA(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\r\n{\r\n    if (size == 1)\r\n    {\r\n        C[0][0] = A[0][0] * B[0][0];\r\n        return;\r\n    }\r\n    else\r\n    {\r\n        int new_size = size / 2;\r\n        vector<int> z(new_size);\r\n        vector<vector<int>>\r\n            a11(new_size, z), a12(new_size, z), a21(new_size, z), a22(new_size, z),\r\n            b11(new_size, z), b12(new_size, z), b21(new_size, z), b22(new_size, z),\r\n            c11(new_size, z), c12(new_size, z), c21(new_size, z), c22(new_size, z),\r\n            p1(new_size, z), p2(new_size, z), p3(new_size, z), p4(new_size, z),\r\n            p5(new_size, z), p6(new_size, z), p7(new_size, z),\r\n            aResult(new_size, z), bResult(new_size, z);\r\n\r\nint i, j;\r\nfor (i = 0; i < new_size; i++)\r\n        {\r\n            for (j = 0; j < new_size; j++)\r\n            {\r\n                a11[i][j] = A[i][j];\r\n                a12[i][j] = A[i][j + new_size];\r\n                a21[i][j] = A[i + new_size][j];\r\n                a22[i][j] = A[i + new_size][j + new_size];\r\n\r\n                b11[i][j] = B[i][j];\r\n                b12[i][j] = B[i][j + new_size];\r\n                b21[i][j] = B[i + new_size][j];\r\n                b22[i][j] = B[i + new_size][j + new_size];\r\n            }\r\n}\r\n        add(a11, a22, aResult, new_size);   \r\n        add(b11, b22, bResult, new_size);    \r\n        STRASSEN_algorithmA(aResult, bResult, p1, new_size); \r\n        \r\n        add(a21, a22, aResult, new_size);\r\n        STRASSEN_algorithmA(aResult, b11, p2, new_size);\r\n\r\n        sub(b12, b22, bResult, new_size);      \r\n        STRASSEN_algorithmA(a11, bResult, p3, new_size);\r\n\r\n        sub(b21, b11, bResult, new_size);       \r\n        STRASSEN_algorithmA(a22, bResult, p4, new_size); \r\n\r\n        add(a11, a12, aResult, new_size);      \r\n        STRASSEN_algorithmA(aResult, b22, p5, new_size);\r\n  \r\n        sub(a21, a11, aResult, new_size);    \r\n        add(b11, b12, bResult, new_size);               \r\n      \r\n        STRASSEN_algorithmA(aResult, bResult, p6, new_size);\r\n        sub(a12, a22, aResult, new_size);   \r\n        add(b21, b22, bResult, new_size);                \r\n        STRASSEN_algorithmA(aResult, bResult, p7, new_size);\r\n        add(p3, p5, c12, new_size); \r\n        add(p2, p4, c21, new_size); \r\n        add(p1, p4, aResult, new_size);       \r\n        add(aResult, p7, bResult, new_size); \r\n        sub(bResult, p5, c11, new_size); \r\n\r\n        add(p1, p3, aResult, new_size);      \r\n        add(aResult, p6, bResult, new_size); \r\n        sub(bResult, p2, c22, new_size); \r\n        for (i = 0; i < new_size; i++)\r\n        {\r\n            for (j = 0; j < new_size; j++)\r\n            {\r\n                C[i][j] = c11[i][j];\r\n                C[i][j + new_size] = c12[i][j];\r\n                C[i + new_size][j] = c21[i][j];\r\n                C[i + new_size][j + new_size] = c22[i][j];\r\n            }\r\n        }\r\n    }\r\n}\r\nvoid STRASSEN_algorithm(vector<vector<int>> &A, vector<vector<int>> &B, int m, int n, int a, int b)\r\n{  \r\n    int k =n;\r\n\r\n    int s = nextpowerof2(k);\r\n\r\n    vector<int> z(s);\r\n    vector<vector<int>> Aa(s, z), Bb(s, z), Cc(s, z);\r\n\r\n    for (unsigned int i = 0; i < n; i++)\r\n    {\r\n        for (unsigned int j = 0; j < n; j++)\r\n        {\r\n            Aa[i][j] = A[i][j];\r\n        }\r\n    }\r\n    for (unsigned int i = 0; i < n; i++)\r\n    {\r\n        for (unsigned int j = 0; j < n; j++)\r\n        {\r\n            Bb[i][j] = B[i][j];\r\n        }\r\n    }\r\n    STRASSEN_algorithmA(Aa, Bb, Cc, s);\r\n    vector<int> temp1(b);\r\n    vector<vector<int>> C(m, temp1);\r\n    for (unsigned int i = 0; i < n; i++)\r\n    {\r\n        for (unsigned int j = 0; j < n; j++)\r\n        {\r\n            C[i][j] = Cc[i][j];\r\n        }\r\n    }\r\n    display(C, n, n);\r\n}\r\n\r\nint main()\r\n{\r\n    int n;\r\n    cin >> n;\r\n    vector<vector<int>> A;\r\n   \r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        vector<int> temp;\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            int i;\r\n            cin >> i;\r\n            temp.push_back(i);\r\n        }\r\n        A.push_back(temp);\r\n    }\r\n    vector<vector<int>> B;\r\n    \r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        vector<int> temp;\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            int i;\r\n            cin >> i;\r\n            temp.push_back(i);\r\n        }\r\n        B.push_back(temp);\r\n    }\r\n        STRASSEN_algorithm(A, B, n, n, n, n);\r\n\r\n    return 0;\r\n}', 1000, '', '', '\r\nvoid add(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\r\n{\r\n    int i, j;\r\n\r\n    for (i = 0; i < size; i++)\r\n    {\r\n        for (j = 0; j < size; j++)\r\n        {\r\n            C[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid sub(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\r\n{\r\n    int i, j;\r\n\r\n    for (i = 0; i < size; i++)\r\n    {\r\n        for (j = 0; j < size; j++)\r\n        {\r\n            C[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid STRASSEN_algorithmA(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\r\n{\r\n    if (size == 1)\r\n    {\r\n        C[0][0] = A[0][0] * B[0][0];\r\n        return;\r\n    }\r\n    else\r\n    {\r\n        int new_size = size / 2;\r\n        vector<int> z(new_size);\r\n        vector<vector<int>>\r\n            a11(new_size, z), a12(new_size, z), a21(new_size, z), a22(new_size, z),\r\n            b11(new_size, z), b12(new_size, z), b21(new_size, z), b22(new_size, z),\r\n            c11(new_size, z), c12(new_size, z), c21(new_size, z), c22(new_size, z),\r\n            p1(new_size, z), p2(new_size, z), p3(new_size, z), p4(new_size, z),\r\n            p5(new_size, z), p6(new_size, z), p7(new_size, z),\r\n            aResult(new_size, z), bResult(new_size, z);\r\n\r\nint i, j;\r\nfor (i = 0; i < new_size; i++)\r\n        {\r\n            for (j = 0; j < new_size; j++)\r\n            {\r\n                a11[i][j] = A[i][j];\r\n                a12[i][j] = A[i][j + new_size];\r\n                a21[i][j] = A[i + new_size][j];\r\n                a22[i][j] = A[i + new_size][j + new_size];\r\n\r\n                b11[i][j] = B[i][j];\r\n                b12[i][j] = B[i][j + new_size];\r\n                b21[i][j] = B[i + new_size][j];\r\n                b22[i][j] = B[i + new_size][j + new_size];\r\n            }\r\n}\r\n        add(a11, a22, aResult, new_size);   \r\n        add(b11, b22, bResult, new_size);    \r\n        STRASSEN_algorithmA(aResult, bResult, p1, new_size); \r\n        \r\n        add(a21, a22, aResult, new_size);\r\n        STRASSEN_algorithmA(aResult, b11, p2, new_size);\r\n\r\n        sub(b12, b22, bResult, new_size);      \r\n        STRASSEN_algorithmA(a11, bResult, p3, new_size);\r\n\r\n        sub(b21, b11, bResult, new_size);       \r\n        STRASSEN_algorithmA(a22, bResult, p4, new_size); \r\n\r\n        add(a11, a12, aResult, new_size);      \r\n        STRASSEN_algorithmA(aResult, b22, p5, new_size);\r\n  \r\n        sub(a21, a11, aResult, new_size);    \r\n        add(b11, b12, bResult, new_size);               \r\n      \r\n        STRASSEN_algorithmA(aResult, bResult, p6, new_size);\r\n        sub(a12, a22, aResult, new_size);   \r\n        add(b21, b22, bResult, new_size);                \r\n        STRASSEN_algorithmA(aResult, bResult, p7, new_size);\r\n        add(p3, p5, c12, new_size); \r\n        add(p2, p4, c21, new_size); \r\n        add(p1, p4, aResult, new_size);       \r\n        add(aResult, p7, bResult, new_size); \r\n        sub(bResult, p5, c11, new_size); \r\n\r\n        add(p1, p3, aResult, new_size);      \r\n        add(aResult, p6, bResult, new_size); \r\n        sub(bResult, p2, c22, new_size); \r\n        for (i = 0; i < new_size; i++)\r\n        {\r\n            for (j = 0; j < new_size; j++)\r\n            {\r\n                C[i][j] = c11[i][j];\r\n                C[i][j + new_size] = c12[i][j];\r\n                C[i + new_size][j] = c21[i][j];\r\n                C[i + new_size][j + new_size] = c22[i][j];\r\n            }\r\n        }\r\n    }\r\n}\r\nvoid STRASSEN_algorithm(vector<vector<int>> &A, vector<vector<int>> &B, int m, int n, int a, int b)\r\n{  \r\n    int k =n;\r\n\r\n    int s = nextpowerof2(k);\r\n\r\n    vector<int> z(s);\r\n    vector<vector<int>> Aa(s, z), Bb(s, z), Cc(s, z);\r\n\r\n    for (unsigned int i = 0; i < n; i++)\r\n    {\r\n        for (unsigned int j = 0; j < n; j++)\r\n        {\r\n            Aa[i][j] = A[i][j];\r\n        }\r\n    }\r\n    for (unsigned int i = 0; i < n; i++)\r\n    {\r\n        for (unsigned int j = 0; j < n; j++)\r\n        {\r\n            Bb[i][j] = B[i][j];\r\n        }\r\n    }\r\n    STRASSEN_algorithmA(Aa, Bb, Cc, s);\r\n    vector<int> temp1(b);\r\n    vector<vector<int>> C(m, temp1);\r\n    for (unsigned int i = 0; i < n; i++)\r\n    {\r\n        for (unsigned int j = 0; j < n; j++)\r\n        {\r\n            C[i][j] = Cc[i][j];\r\n        }\r\n    }\r\n    display(C, n, n);\r\n}\r\n\r\nint main()\r\n{\r\n    int n;\r\n    cin >> n;\r\n    vector<vector<int>> A;\r\n   \r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        vector<int> temp;\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            int i;\r\n            cin >> i;\r\n            temp.push_back(i);\r\n        }\r\n        A.push_back(temp);\r\n    }\r\n    vector<vector<int>> B;\r\n    \r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        vector<int> temp;\r\n        for (int j = 0; j < n; j++)\r\n        {\r\n            int i;\r\n            cin >> i;\r\n            temp.push_back(i);\r\n        }\r\n        B.push_back(temp);\r\n    }\r\n        STRASSEN_algorithm(A, B, n, n, n, n);\r\n\r\n    return 0;\r\n}', '2020-05-25'),
(596, 16, 7001012018, '\r\n#include <bits/stdc++.h> \r\nusing namespace std; \r\n#define d 256\r\nvoid search(char pat[], char txt[], int q) \r\n{ \r\n	int M = strlen(pat); \r\n	int N = strlen(txt); \r\n	int i, j; \r\n	int p = 0;\r\n	int t = 0;\r\n	int h = 1; \r\n	for (i = 0; i < M - 1; i++) \r\n		h = (h * d) % q;  \r\n	for (i = 0; i < M; i++) \r\n	{ \r\n		p = (d * p + pat[i]) % q; \r\n		t = (d * t + txt[i]) % q; \r\n	} \r\n	for (i = 0; i <= N - M; i++) \r\n	{ \r\n		if ( p == t ) \r\n		{ \r\n			for (j = 0; j < M; j++) \r\n			{ \r\n				if (txt[i+j] != pat[j]) \r\n					break; \r\n			} \r\n			if (j == M) \r\n				cout<<\"Pattern found at index \"<< i<<\" \"; \r\n		}  \r\n		if ( i < N-M ) \r\n		{ \r\n			t = (d*(t - txt[i]*h) + txt[i+M])%q; \r\n			if (t < 0) \r\n			t = (t + q); \r\n		} \r\n	} \r\n} \r\nint main() \r\n{ \r\n	char txt[] = \"GEEKS FOR GEEKS\"; \r\n	char pat[] = \"GEEK\"; \r\n	int q = 101; \r\n	search(pat, txt, q); \r\n	return 0; \r\n} ', 1000, '', '', 'void search(char pat[], char txt[], int q) \r\n{ \r\n	int M = strlen(pat); \r\n	int N = strlen(txt); \r\n	int i, j; \r\n	int p = 0;\r\n	int t = 0;\r\n	int h = 1; \r\n	for (i = 0; i < M - 1; i++) \r\n		h = (h * d) % q;  \r\n	for (i = 0; i < M; i++) \r\n	{ \r\n		p = (d * p + pat[i]) % q; \r\n		t = (d * t + txt[i]) % q; \r\n	} \r\n	for (i = 0; i <= N - M; i++) \r\n	{ \r\n		if ( p == t ) \r\n		{ \r\n			for (j = 0; j < M; j++) \r\n			{ \r\n				if (txt[i+j] != pat[j]) \r\n					break; \r\n			} \r\n			if (j == M) \r\n				cout<<\"Pattern found at index \"<< i<<\" \"; \r\n		}  \r\n		if ( i < N-M ) \r\n		{ \r\n			t = (d*(t - txt[i]*h) + txt[i+M])%q; \r\n			if (t < 0) \r\n			t = (t + q); \r\n		} \r\n	} \r\n} ', '2020-05-25'),
(597, 7, 7101012018, '#include <cstdlib>\r\n#include <iostream>\r\nusing namespace std;\r\n\r\nint partition(int arr[], int low, int high)\r\n{\r\n int pivot = arr[low];\r\n int i = low - 1, j = high + 1;\r\n\r\n while (true) {\r\n\r\n\r\n do {\r\n i++;\r\n } while (arr[i] < pivot);\r\n do {\r\n j--;\r\n } while (arr[j] > pivot);\r\n\r\n if (i >= j)\r\n return j;\r\n\r\n swap(arr[i], arr[j]);\r\n }\r\n}\r\n\r\nint partition_r(int arr[], int low, int high)\r\n{\r\n //srand(time(NULL));\r\n int random = low + rand() % (high - low);\r\n\r\n swap(arr[random], arr[low]);\r\n\r\n return partition(arr, low, high);\r\n}\r\n\r\nvoid quickSort(int arr[], int low, int high)\r\n{\r\n if (low < high) {\r\n\r\n int pi = partition_r(arr, low, high);\r\n\r\n quickSort(arr, low, pi);\r\n quickSort(arr, pi + 1, high);\r\n }\r\n}\r\n\r\nvoid printArray(int arr[], int n)\r\n{\r\n for (int i = 0; i < n; i++)\r\n printf(\"%d \", arr[i]);\r\n printf(\" \");\r\n}\r\n\r\nint main()\r\n{\r\n int no;\r\n cin >> no;\r\n int arr[no];\r\n for(int i =0; i< no; i++){\r\n int elem;\r\n cin>> elem;\r\n arr[i] = elem;\r\n }\r\n int n = sizeof(arr) / sizeof(arr[0]);\r\n quickSort(arr, 0, n - 1);\r\n //printf(\"Sorted array:\");\r\n printArray(arr, n);\r\n return 0;\r\n} ', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '', 'QuickSort is a Divide and Conquer algorithm. It picks an element as pivot and partitions the given array around the picked pivot.\r\nThe key process in quickSort is partition(). Target of partitions is, given an array and an element x of array as pivot, put x at its correct position in sorted array and put all smaller elements (smaller than x) before x, and put all greater elements (greater than x) after x. \r\n/* low  --> Starting index,  high  --> Ending index */\r\n\r\nquickSort(arr[], low, high)\r\n{\r\n    if (low < high)\r\n    {\r\n        /* pi is partitioning index, arr[pi] is now\r\n           at right place */\r\n        pi = partition(arr, low, high);\r\n\r\n        quickSort(arr, low, pi - 1);  // Before pi\r\n        quickSort(arr, pi + 1, high); // After pi\r\n    }\r\n}', '2020-05-25'),
(598, 10, 7101012018, '#include<stdio.h>\r\n#include<limits.h>\r\nint max(int a, int b) { return (a > b)? a : b; }\r\nint knapSack(int W, int wt[], int val[], int n)\r\n{\r\n if (n == 0 || W == 0)\r\n return 0;\r\n if (wt[n-1] > W)\r\n return knapSack(W, wt, val, n-1);\r\n\r\n else return max( val[n-1] + knapSack(W-wt[n-1], wt, val, n-1),\r\n knapSack(W, wt, val, n-1) );\r\n}\r\n\r\nint main()\r\n{\r\n int n;\r\n int W ,i;\r\n scanf(\"%d\",&n);\r\n scanf(\"%d\",&W);\r\n int wt[n],val[n];\r\n for(i=0;i<n;i++)\r\n scanf(\"%d\",&val[i]);\r\n for(i=0;i<n;i++)\r\n scanf(\"%d\",&wt[i]);\r\n printf(\"%d\", knapSack(W, wt, val, n));\r\n return 0;\r\n}\r\n', 10, '5 15 4 2 1 2 10 12 2 1 1 4', '15', 'Partitioning the individuals into different sets according to the groups in which they fall. This method is known as disjoint set data structure which maintains collection of disjoint sets and each set is represented by its representative which is one of its members.\r\n\r\nApproach:\r\n\r\n    How to Resolve sets ? Initially all elements belong to different sets. After working on the given relations, we select a member as representative. There can by many ways to select a representative, a simple one is to select with the biggest index.\r\n    Check if 2 persons are in the same group ? If representatives of two individuals are same, then they?ll become friends.\r\n\r\n \r\nData Structures used:\r\nArray : An array of integers, called parent[]. If we are dealing with n items, i?th element of the array represents the i?th item. More precisely, the i?th element of the array is the parent of the i?th item. These relationships create one, or more, virtual trees.\r\n\r\nTree : It is a disjoint set. If two elements are in the same tree, then they are in the same disjoint set. The root node (or the topmost node) of each tree is called the representative of the set. There is always a single unique representative of each set. A simple rule to identify representative is, if i is the representative of a set, then parent[i] = i. If i is not the representative of his set, then it can be found by traveling up the tree until we find the representative.\r\n\r\n \r\nOperations :\r\n\r\nFind : Can be implemented by recursively traversing the parent array until we hit a node who is parent of itself.\r\n\r\n// Finds the representative of the set  \r\n// that i is an element of\r\nint find(int i) \r\n{\r\n    // If i is the parent of itself\r\n    if (parent[i] == i) \r\n    {\r\n        // Then i is the representative of \r\n        // this set\r\n        return i;\r\n    }\r\n    else \r\n    {\r\n        // Else if i is not the parent of \r\n        // itself, then i is not the \r\n        // representative of his set. So we \r\n        // recursively call Find on its parent\r\n        return find(parent[i]);\r\n    }\r\n}\r\n\r\nUnion: It takes, as input, two elements. And finds the representatives of their sets using the find operation, and finally puts either one of the trees (representing the set) under the root node of the other tree, effectively merging the trees and the sets.\r\n\r\n// Unites the set that includes i \r\n// and the set that includes j\r\nvoid union(int i, int j) \r\n{\r\n    // Find the representatives\r\n    // (or the root nodes) for the set\r\n    // that includes i\r\n    \r\n    int irep = this.Find(i),\r\n\r\n    // And do the same for the set \r\n    // that includes j    \r\n    int jrep = this.Find(j);\r\n\r\n    // Make the parent of i?s representative\r\n    // be j?s  representative effectively \r\n    // moving all of i?s set into j?s set)\r\n    this.Parent[irep] = jrep;\r\n}\r\n\r\nImprovements (Union by Rank and Path Compression)\r\nThe efficiency depends heavily on the height of the tree. We need to minimize the height of tree in order improve the efficiency. We can use Path Compression and Union by rank methods to do so.\r\n\r\nPath Compression (Modifications to find()) : It speeds up the data structure by compressing the height of the trees. It can be achieved by inserting a small caching mechanism into the Find operation. Take a look at the code for more details:\r\n\r\n// Finds the representative of the set that i\r\n// is an element of.\r\nint find(int i) \r\n{\r\n    // If i is the parent of itself\r\n    if (Parent[i] == i) \r\n    {\r\n        // Then i is the representative \r\n        return i;\r\n    }\r\n    else\r\n    { \r\n        // Recursively find the representative.\r\n        int result = find(Parent[i]);\r\n\r\n        // We cache the result by moving i?s node \r\n        // directly under the representative of this\r\n        // set\r\n        Parent[i] = result;\r\n       \r\n        // And then we return the result\r\n        return result;\r\n     }\r\n}\r\n\r\nUnion by Rank: First of all, we need a new array of integers called rank[]. Size of this array is same as the parent array. If i is a representative of a set, rank[i] is the height of the tree representing the set.\r\nNow recall that, in the Union operation, it doesn?t matter which of the two trees is moved under the other (see last two image examples above). Now what we want to do is minimize the height of the resulting tree. If we are uniting two trees (or sets), let?s call them left and right, then it all depends on the rank of left and the rank of right.\r\n\r\n\r\n    If the rank of left is less than the rank of right, then it?s best to move left under right, because that won?t change the rank of right (while moving right under left would increase the height). In the same way, if the rank of right is less than the rank of left, then we should move right under left.\r\n    If the ranks are equal, it doesn?t matter which tree goes under the other, but the rank of the result will always be one greater than the rank of the trees.\r\n\r\n// Unites the set that includes i and the set \r\n// that includes j\r\nvoid union(int i, int j) \r\n{\r\n    // Find the representatives (or the root nodes) \r\n    // for the set that includes i\r\n    int irep = this.find(i);\r\n\r\n    // And do the same for the set that includes j\r\n    int jrep = this.Find(j);\r\n\r\n    // Elements are in same set, no need to \r\n    // unite anything.    \r\n    if (irep == jrep)\r\n        return;\r\n\r\n    // Get the rank of i?s tree\r\n    irank = Rank[irep],\r\n\r\n    // Get the rank of j?s tree\r\n    jrank = Rank[jrep];\r\n\r\n    // If i?s rank is less than j?s rank\r\n    if (irank < jrank) \r\n    {\r\n        // Then move i under j\r\n        this.parent[irep] = jrep;\r\n    } \r\n\r\n    // Else if j?s rank is less than i?s rank\r\n    else if (jrank < irank) \r\n    {\r\n        // Then move j under i\r\n        this.Parent[jrep] = irep;\r\n    } \r\n\r\n    // Else if their ranks are the same\r\n    else\r\n    {\r\n\r\n        // Then move i under j (doesn?t matter\r\n        // which one goes where)\r\n        this.Parent[irep] = jrep;\r\n\r\n        // And increment the result tree?s \r\n        // rank by 1\r\n        Rank[jrep]++;\r\n    }\r\n}\r\nPartitioning the individuals into different sets according to the groups in which they fall. This method is known as disjoint set data structure which maintains collection of disjoint sets and each set is represented by its representative which is one of its members.\r\n\r\nApproach:\r\n\r\n    How to Resolve sets ? Initially all elements belong to different sets. After working on the given relations, we select a member as representative. There can by many ways to select a representative, a simple one is to select with the biggest index.\r\n    Check if 2 persons are in the same group ? If representatives of two individuals are same, then they?ll become friends.\r\n\r\n \r\nData Structures used:\r\nArray : An array of integers, called parent[]. If we are dealing with n items, i?th element of the array represents the i?th item. More precisely, the i?th element of the array is the parent of the i?th item. These relationships create one, or more, virtual trees.\r\n\r\nTree : It is a disjoint set. If two elements are in the same tree, then they are in the same disjoint set. The root node (or the topmost node) of each tree is called the representative of the set. There is always a single unique representative of each set. A simple rule to identify representative is, if i is the representative of a set, then parent[i] = i. If i is not the representative of his set, then it can be found by traveling up the tree until we find the representative.\r\n\r\n \r\nOperations :\r\n\r\nFind : Can be implemented by recursively traversing the parent array until we hit a node who is parent of itself.\r\n\r\n// Finds the representative of the set  \r\n// that i is an element of\r\nint find(int i) \r\n{\r\n    // If i is the parent of itself\r\n    if (parent[i] == i) \r\n    {\r\n        // Then i is the representative of \r\n        // this set\r\n        return i;\r\n    }\r\n    else \r\n    {\r\n        // Else if i is not the parent of \r\n        // itself, then i is not the \r\n        // representative of his set. So we \r\n        // recursively call Find on its parent\r\n        return find(parent[i]);\r\n    }\r\n}\r\n\r\nUnion: It takes, as input, two elements. And finds the representatives of their sets using the find operation, and finally puts either one of the trees (representing the set) under the root node of the other tree, effectively merging the trees and the sets.\r\n\r\n// Unites the set that includes i \r\n// and the set that includes j\r\nvoid union(int i, int j) \r\n{\r\n    // Find the representatives\r\n    // (or the root nodes) for the set\r\n    // that includes i\r\n    \r\n    int irep = this.Find(i),\r\n\r\n    // And do the same for the set \r\n    // that includes j    \r\n    int jrep = this.Find(j);\r\n\r\n    // Make the parent of i?s representative\r\n    // be j?s  representative effectively \r\n    // moving all of i?s set into j?s set)\r\n    this.Parent[irep] = jrep;\r\n}\r\n\r\nImprovements (Union by Rank and Path Compression)\r\nThe efficiency depends heavily on the height of the tree. We need to minimize the height of tree in order improve the efficiency. We can use Path Compression and Union by rank methods to do so.\r\n\r\nPath Compression (Modifications to find()) : It speeds up the data structure by compressing the height of the trees. It can be achieved by inserting a small caching mechanism into the Find operation. Take a look at the code for more details:\r\n\r\n// Finds the representative of the set that i\r\n// is an element of.\r\nint find(int i) \r\n{\r\n    // If i is the parent of itself\r\n    if (Parent[i] == i) \r\n    {\r\n        // Then i is the representative \r\n        return i;\r\n    }\r\n    else\r\n    { \r\n        // Recursively find the representative.\r\n        int result = find(Parent[i]);\r\n\r\n        // We cache the result by moving i?s node \r\n        // directly under the representative of this\r\n        // set\r\n        Parent[i] = result;\r\n       \r\n        // And then we return the result\r\n        return result;\r\n     }\r\n}\r\n\r\nUnion by Rank: First of all, we need a new array of integers called rank[]. Size of this array is same as the parent array. If i is a representative of a set, rank[i] is the height of the tree representing the set.\r\nNow recall that, in the Union operation, it doesn?t matter which of the two trees is moved under the other (see last two image examples above). Now what we want to do is minimize the height of the resulting tree. If we are uniting two trees (or sets), let?s call them left and right, then it all depends on the rank of left and the rank of right.\r\n\r\n\r\n    If the rank of left is less than the rank of right, then it?s best to move left under right, because that won?t change the rank of right (while moving right under left would increase the height). In the same way, if the rank of right is less than the rank of left, then we should move right under left.\r\n    If the ranks are equal, it doesn?t matter which tree goes under the other, but the rank of the result will always be one greater than the rank of the trees.\r\n\r\n// Unites the set that includes i and the set \r\n// that includes j\r\nvoid union(int i, int j) \r\n{\r\n    // Find the representatives (or the root nodes) \r\n    // for the set that includes i\r\n    int irep = this.find(i);\r\n\r\n    // And do the same for the set that includes j\r\n    int jrep = this.Find(j);\r\n\r\n    // Elements are in same set, no need to \r\n    // unite anything.    \r\n    if (irep == jrep)\r\n        return;\r\n\r\n    // Get the rank of i?s tree\r\n    irank = Rank[irep],\r\n\r\n    // Get the rank of j?s tree\r\n    jrank = Rank[jrep];\r\n\r\n    // If i?s rank is less than j?s rank\r\n    if (irank < jrank) \r\n    {\r\n        // Then move i under j\r\n        this.parent[irep] = jrep;\r\n    } \r\n\r\n    // Else if j?s rank is less than i?s rank\r\n    else if (jrank < irank) \r\n    {\r\n        // Then move j under i\r\n        this.Parent[jrep] = irep;\r\n    } \r\n\r\n    // Else if their ranks are the same\r\n    else\r\n    {\r\n\r\n        // Then move i under j (doesn?t matter\r\n        // which one goes where)\r\n        this.Parent[irep] = jrep;\r\n\r\n        // And increment the result tree?s \r\n        // rank by 1\r\n        Rank[jrep]++;\r\n    }\r\n}\r\n', '2020-05-25'),
(599, 13, 7101012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n\r\n \r\nint minKey(int V,int key[], bool mstSet[]) \r\n{ \r\n	int min = INT_MAX, min_index; \r\n	for (int v = 0; v < V; v++) \r\n		if (mstSet[v] == false && key[v] < min) \r\n			min = key[v], min_index = v; \r\n\r\n	return min_index; \r\n} \r\n\r\n\r\nvoid printMST(int V,int parent[], int graph[100][100]) \r\n{ \r\n	 \r\n	int sum=0;\r\n	for (int i = 1; i < V; i++) \r\n	{sum+=graph[i][parent[i]];\r\n		 }\r\n		cout<<\"\n\"<<sum;\r\n} \r\n\r\n\r\nvoid primMST(int V,int graph[100][100]) \r\n{ \r\n	 \r\n	int parent[V]; \r\n	int key[V]; \r\n	bool mstSet[V]; \r\n\r\n	for (int i = 0; i < V; i++) \r\n		key[i] = INT_MAX, mstSet[i] = false; \r\n\r\n	key[0] = 0; \r\n	parent[0] = -1;  \r\n	for (int count = 0; count < V - 1; count++) \r\n	{ \r\n		int u = minKey(V,key, mstSet);\r\n		mstSet[u] = true; \r\n		for (int v = 0; v < V; v++) \r\n			if (graph[u][v] && mstSet[v] == false && graph[u][v] < key[v]) \r\n				parent[v] = u, key[v] = graph[u][v]; \r\n	} \r\n	printMST( V,parent, graph); \r\n} \r\n\r\n\r\nint main() \r\n{ \r\n	\r\nint V,E;\r\ncin>>V;\r\ncin>>E;\r\n\r\nint graph[100][100];\r\n	\r\n      for(int i=0;i<V;i++)\r\n       for(int j=0;j<V;j++)\r\n        {\r\n        graph[i][j]=0;\r\n       }\r\n     int a,b,w;\r\n      for(int i=0;i<E;i++)\r\n       {\r\n       cin>>a>>b>>w;\r\n       graph[a][b]=w;\r\n       graph[b][a]=w;\r\n       }\r\n	primMST(V,graph); \r\n\r\n	return 0; \r\n} ', 1000, '', '', 'Algorithm: \r\n1. Sort all the edges from low weight to high \r\n2. Take the edge with the lowest weight and add it to the spanning tree. \r\n   If adding the edge created a cycle, then reject this edge. \r\n3. Keep adding edges until we reach all vertices.\r\n', '2020-05-25'),
(600, 14, 7101012018, '#include <bits/stdc++.h> \r\n\r\nstruct Edge { \r\n    int src, dest, weight; \r\n}; \r\n \r\nstruct Graph { \r\n    int V, E;  \r\n    struct Edge* edge; \r\n};  \r\nstruct Graph* createGraph(int V, int E) \r\n{ \r\n    struct Graph* graph = new Graph; \r\n    graph->V = V; \r\n    graph->E = E; \r\n    graph->edge = new Edge[E]; \r\n    return graph; \r\n} \r\n  \r\n\r\nvoid printArr(int dist[], int n) \r\n{ \r\n    printf(\"Vertex   Distance from Source\n\"); \r\n    for (int i = 0; i < n; ++i) \r\n        printf(\"%d 		 %d\n\", i, dist[i]); \r\n} \r\n  \r\n\r\nvoid BellmanFord(struct Graph* graph, int src) \r\n{ \r\n    int V = graph->V; \r\n    int E = graph->E; \r\n    int dist[V]; \r\n\r\n    for (int i = 0; i < V; i++) \r\n        dist[i] = INT_MAX; \r\n    dist[src] = 0; \r\n    for (int i = 1; i <= V - 1; i++) { \r\n        for (int j = 0; j < E; j++) { \r\n            int u = graph->edge[j].src; \r\n            int v = graph->edge[j].dest; \r\n            int weight = graph->edge[j].weight; \r\n            if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) \r\n                dist[v] = dist[u] + weight; \r\n        } \r\n    } \r\n  \r\n    for (int i = 0; i < E; i++) { \r\n        int u = graph->edge[i].src; \r\n        int v = graph->edge[i].dest; \r\n        int weight = graph->edge[i].weight; \r\n        if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) { \r\n            printf(\"Graph contains negative weight cycle\"); \r\n            return; // If negative cycle is detected, simply return \r\n        } \r\n    } \r\n  \r\n    printArr(dist, V); \r\n  \r\n    return; \r\n} \r\n \r\nint main() \r\n{ \r\n    int V = 5; // Number of vertices in graph \r\n    int E = 8; // Number of edges in graph \r\n    struct Graph* graph = createGraph(V, E); \r\n \r\n    graph->edge[0].src = 0; \r\n    graph->edge[0].dest = 1; \r\n    graph->edge[0].weight = -1; \r\n\r\n    graph->edge[1].src = 0; \r\n    graph->edge[1].dest = 2; \r\n    graph->edge[1].weight = 4; \r\n  \r\n    graph->edge[2].src = 1; \r\n    graph->edge[2].dest = 2; \r\n    graph->edge[2].weight = 3; \r\n  \r\n    graph->edge[3].src = 1; \r\n    graph->edge[3].dest = 3; \r\n    graph->edge[3].weight = 2; \r\n  \r\n    graph->edge[4].src = 1; \r\n    graph->edge[4].dest = 4; \r\n    graph->edge[4].weight = 2; \r\n   \r\n    graph->edge[5].src = 3; \r\n    graph->edge[5].dest = 2; \r\n    graph->edge[5].weight = 5; \r\n   \r\n    graph->edge[6].src = 3; \r\n    graph->edge[6].dest = 1; \r\n    graph->edge[6].weight = 1; \r\n   \r\n    graph->edge[7].src = 4; \r\n    graph->edge[7].dest = 3; \r\n    graph->edge[7].weight = -3; \r\n  \r\n    BellmanFord(graph, 0); \r\n  \r\n    return 0; \r\n} ', 1000, '', '', '1. Create a set mstSet that keeps track of vertices already included in MST.\r\n2. Assign a key value to all vertices in the input graph. Initialize all key values as INFINITE. Assign key value as\r\n0 for the first vertex so that it is picked first.\r\n3. While mst Set doesnâ€™t include all vertices\r\n	a) Pick a vertex u which is not there in mstSet and has minimum key value.\r\n	b) Include u to mstSet.\r\n	c) Update key value of all adjacent vertices of u. To update the key values, iterate through all adjacent vertices.\r\nFor every adjacent vertex v, if weight of edge u-v is less than the previous key value of v, update the key value\r\nas weight of u-v', '2020-05-25'),
(601, 15, 7101012018, '#include<bits/stdc++.h> \r\nusing namespace std; \r\n\r\nint MatrixChainOrder(int p[], int i, int j) \r\n{ \r\n    if(i == j) \r\n        return 0; \r\n    int k; \r\n    int min = INT_MAX; \r\n    int count; \r\n   \r\n    for (k = i; k < j; k++) \r\n    { \r\n        count = MatrixChainOrder(p, i, k) + \r\n                MatrixChainOrder(p, k + 1, j) + \r\n                p[i - 1] * p[k] * p[j]; \r\n  \r\n        if (count < min) \r\n            min = count; \r\n    } \r\n  \r\n    return min; \r\n} \r\n  \r\n// Driver Code \r\nint main() \r\n{ int n; \r\n    cin >> n;\r\n    int arr[n]; //= {1, 2, 3, 4, 3}; \r\n    \r\n    for(int i = 0; i < n; i++)\r\n	cin>>arr[i];\r\n    //int n = sizeof(arr)/sizeof(arr[0]); \r\n    cout << MatrixChainOrder(arr, 1, n - 1); \r\n} ', 1000, '', '', '1. Initialize distances from source to all vertices as infinite and distance to source itself as 0. \r\n   Create an array dist[] of size |V| with all values as infinite except dist[src] where src is source vertex. \r\n2. calculate shortest distances. Do following |V|-1 times where |V| is the number of vertices.\r\n   If dist[v] > dist[u] + weight of edge uv, then update dist[v]	\r\n       dist[v] = dist[u] + weight of edge uv \r\n3. report if there is a negative weight cycle in graph	\r\n   If dist[v] > dist[u] + weight of edge uv, then Graph contains negative weight cycle.	\r\nreturn\r\n', '2020-05-25'),
(602, 8, 7101012018, '#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\n\r\ninline ll** MatrixMultiply(ll** a, ll** b, int n, int l, int m)\r\n{\r\n    ll** c = new ll*[n];\r\n    for (int i = 0; i < n; i++)\r\n        c[i] = new ll[m];\r\n\r\n    for (int i = 0; i < n; i++) {\r\n        for (int j = 0; j < m; j++) {\r\n            c[i][j] = 0;\r\n            for (int k = 0; k < l; k++) {\r\n                c[i][j] += a[i][k] * b[k][j];\r\n            }\r\n        }\r\n    }\r\n    return c;\r\n}\r\n\r\ninline ll** Strassen(ll** a, ll** b, int n, int l, int m)\r\n{\r\n    if (n == 1 || l == 1 || m == 1)\r\n        return MatrixMultiply(a, b, n, l, m);\r\n\r\n    ll** c = new ll*[n];\r\n    for (int i = 0; i < n; i++)\r\n        c[i] = new ll[m];\r\n\r\n    int adjN = (n >> 1) + (n & 1);\r\n    int adjL = (l >> 1) + (l & 1);\r\n    int adjM = (m >> 1) + (m & 1);\r\n\r\n    ll**** As = new ll***[2];\r\n    for (int x = 0; x < 2; x++) {\r\n        As[x] = new ll**[2];\r\n        for (int y = 0; y < 2; y++) {\r\n            As[x][y] = new ll*[adjN];\r\n            for (int i = 0; i < adjN; i++) {\r\n                As[x][y][i] = new ll[adjL];\r\n                for (int j = 0; j < adjL; j++) {\r\n                    int I = i + (x & 1) * adjN;\r\n                    int J = j + (y & 1) * adjL;\r\n                    As[x][y][i][j] = (I < n && J < l) ? a[I][J] : 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    ll**** Bs = new ll***[2];\r\n    for (int x = 0; x < 2; x++) {\r\n        Bs[x] = new ll**[2];\r\n        for (int y = 0; y < 2; y++) {\r\n            Bs[x][y] = new ll*[adjN];\r\n            for (int i = 0; i < adjL; i++) {\r\n                Bs[x][y][i] = new ll[adjM];\r\n                for (int j = 0; j < adjM; j++) {\r\n                    int I = i + (x & 1) * adjL;\r\n                    int J = j + (y & 1) * adjM;\r\n                    Bs[x][y][i][j] = (I < l && J < m) ? b[I][J] : 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    ll*** s = new ll**[10];\r\n    for (int i = 0; i < 10; i++) {\r\n        switch (i) {\r\n        case 0:\r\n            s[i] = new ll*[adjL];\r\n            for (int j = 0; j < adjL; j++) {\r\n                s[i][j] = new ll[adjM];\r\n                for (int k = 0; k < adjM; k++) {\r\n                    s[i][j][k] = Bs[0][1][j][k] - Bs[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 1:\r\n            s[i] = new ll*[adjN];\r\n            for (int j = 0; j < adjN; j++) {\r\n                s[i][j] = new ll[adjL];\r\n                for (int k = 0; k < adjL; k++) {\r\n                    s[i][j][k] = As[0][0][j][k] + As[0][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 2:\r\n            s[i] = new ll*[adjN];\r\n            for (int j = 0; j < adjN; j++) {\r\n                s[i][j] = new ll[adjL];\r\n                for (int k = 0; k < adjL; k++) {\r\n                    s[i][j][k] = As[1][0][j][k] + As[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 3:\r\n            s[i] = new ll*[adjL];\r\n            for (int j = 0; j < adjL; j++) {\r\n                s[i][j] = new ll[adjM];\r\n                for (int k = 0; k < adjM; k++) {\r\n                    s[i][j][k] = Bs[1][0][j][k] - Bs[0][0][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 4:\r\n            s[i] = new ll*[adjN];\r\n            for (int j = 0; j < adjN; j++) {\r\n                s[i][j] = new ll[adjL];\r\n                for (int k = 0; k < adjL; k++) {\r\n                    s[i][j][k] = As[0][0][j][k] + As[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 5:\r\n            s[i] = new ll*[adjL];\r\n            for (int j = 0; j < adjL; j++) {\r\n                s[i][j] = new ll[adjM];\r\n                for (int k = 0; k < adjM; k++) {\r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 6:\r\n            s[i] = new ll*[adjN];\r\n            for (int j = 0; j < adjN; j++) {\r\n                s[i][j] = new ll[adjL];\r\n                for (int k = 0; k < adjL; k++) {\r\n                    s[i][j][k] = As[0][1][j][k] - As[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 7:\r\n            s[i] = new ll*[adjL];\r\n            for (int j = 0; j < adjL; j++) {\r\n                s[i][j] = new ll[adjM];\r\n                for (int k = 0; k < adjM; k++) {\r\n                    s[i][j][k] = Bs[1][0][j][k] + Bs[1][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 8:\r\n            s[i] = new ll*[adjN];\r\n            for (int j = 0; j < adjN; j++) {\r\n                s[i][j] = new ll[adjL];\r\n                for (int k = 0; k < adjL; k++) {\r\n                    s[i][j][k] = As[0][0][j][k] - As[1][0][j][k];\r\n                }\r\n            }\r\n            break;\r\n        case 9:\r\n            s[i] = new ll*[adjL];\r\n            for (int j = 0; j < adjL; j++) {\r\n                s[i][j] = new ll[adjM];\r\n                for (int k = 0; k < adjM; k++) {\r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[0][1][j][k];\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    }\r\n\r\n    ll*** p = new ll**[7];\r\n    p[0] = Strassen(As[0][0], s[0], adjN, adjL, adjM);\r\n    p[1] = Strassen(s[1], Bs[1][1], adjN, adjL, adjM);\r\n    p[2] = Strassen(s[2], Bs[0][0], adjN, adjL, adjM);\r\n    p[3] = Strassen(As[1][1], s[3], adjN, adjL, adjM);\r\n    p[4] = Strassen(s[4], s[5], adjN, adjL, adjM);\r\n    p[5] = Strassen(s[6], s[7], adjN, adjL, adjM);\r\n    p[6] = Strassen(s[8], s[9], adjN, adjL, adjM);\r\n\r\n    for (int i = 0; i < adjN; i++) {\r\n        for (int j = 0; j < adjM; j++) {\r\n            c[i][j] = p[4][i][j] + p[3][i][j] - p[1][i][j] + p[5][i][j];\r\n            if (j + adjM < m)\r\n                c[i][j + adjM] = p[0][i][j] + p[1][i][j];\r\n            if (i + adjN < n)\r\n                c[i + adjN][j] = p[2][i][j] + p[3][i][j];\r\n            if (i + adjN < n && j + adjM < m)\r\n                c[i + adjN][j + adjM] = p[4][i][j] + p[0][i][j] - p[2][i][j] - p[6][i][j];\r\n        }\r\n    }\r\n\r\n    for (int x = 0; x < 2; x++) {\r\n        for (int y = 0; y < 2; y++) {\r\n            for (int i = 0; i < adjN; i++) {\r\n                delete[] As[x][y][i];\r\n            }\r\n            delete[] As[x][y];\r\n        }\r\n        delete[] As[x];\r\n    }\r\n    delete[] As;\r\n\r\n    for (int x = 0; x < 2; x++) {\r\n        for (int y = 0; y < 2; y++) {\r\n            for (int i = 0; i < adjL; i++) {\r\n                delete[] Bs[x][y][i];\r\n            }\r\n            delete[] Bs[x][y];\r\n        }\r\n        delete[] Bs[x];\r\n    }\r\n    delete[] Bs;\r\n\r\n    for (int i = 0; i < 10; i++) {\r\n        switch (i) {\r\n        case 0:\r\n        case 3:\r\n        case 5:\r\n        case 7:\r\n        case 9:\r\n            for (int j = 0; j < adjL; j++) {\r\n                delete[] s[i][j];\r\n            }\r\n            break;\r\n        case 1:\r\n        case 2:\r\n        case 4:\r\n        case 6:\r\n        case 8:\r\n            for (int j = 0; j < adjN; j++) {\r\n                delete[] s[i][j];\r\n            }\r\n            break;\r\n        }\r\n        delete[] s[i];\r\n    }\r\n    delete[] s;\r\n\r\n    for (int i = 0; i < 7; i++) {\r\n        for (int j = 0; j < (n >> 1); j++) {\r\n            delete[] p[i][j];\r\n        }\r\n        delete[] p[i];\r\n    }\r\n    delete[] p;\r\n\r\n    return c;\r\n}\r\n\r\nint main()\r\n{\r\n    int mat1_m,mat1_n,mat2_m,mat2_n;\r\n\r\n   cin>>mat1_m;\r\n\r\nmat1_n=mat1_m;\r\nmat2_m=mat1_m;\r\nmat2_n=mat1_m;\r\n    ll** mat1 =new ll*[mat1_m];\r\n\r\n    for(int i=0;i<mat1_m;i++)\r\n    {\r\n        mat1[i]=new ll[mat1_n];\r\n        for(int j=0;j<mat1_n;j++)\r\n        {\r\n            cin>>mat1[i][j];\r\n        }\r\n\r\n    }\r\n\r\n    ll**mat2 =new ll*[mat2_m];\r\n    for(int i=0;i<mat2_m;i++)\r\n    {\r\n        mat2[i]=new ll[mat2_n];\r\n        for(int j=0;j<mat2_n;j++)\r\n        {\r\n            cin>>mat2[i][j];\r\n        }\r\n\r\n    }\r\n\r\nif(mat1_n!=mat2_m)\r\n{\r\n    cout<<\"/////////Multipliaction not possible //////// \";\r\n    return 0;\r\n\r\n}\r\n\r\n\r\n    ll** mat3 = Strassen(mat1, mat2, mat1_m, mat1_n, mat2_n);\r\n    for (int i = 0; i < mat1_m; i++)\r\n    {\r\n        for (int j = 0; j < mat2_n; j++)\r\n        {\r\n            cout<<mat3[i][j]<<\" \";\r\n        }\r\n        cout<<endl;\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n', 0, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '-17 -4 -7 \n10 2 11 \n40 92 107 \n', 'Divide the array into two parts and compare the maximums and minimums of the two parts to get the maximum and the minimum of the whole array.\r\n\r\nPair MaxMin(array, array_size)\r\n   if array_size = 1\r\n      return element as both max and min\r\n   else if arry_size = 2\r\n      one comparison to determine max and min\r\n      return that pair\r\n   else if array_size  > 2 \r\n      recur for max and min of left half\r\n      recur for max and min of right half\r\n      one comparison determines true max of the two candidates\r\n      one comparison determines true min of the two candidates\r\n      return the pair of max and min', '2020-05-25');
INSERT INTO `qtos_map` (`ID`, `Q_ID`, `ROLL`, `SUBMISSION`, `SCORE`, `INPUT`, `OP`, `ALGO`, `DATE`) VALUES
(603, 5, 7101012018, '#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nint nextpowerof2(int k)\n{\n    return pow(2, int(ceil(log2(k))));\n}\nvoid display(vector< vector<int> > &matrix, int m, int n)\n{\n    for (int i = 0; i < m; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (j != 0)\n            {\n                cout << \"	\";\n            }\n            cout << matrix[i][j];\n        }\n        cout << endl;\n    }\n}\n\nvoid add(vector<vector<int> > &A, vector<vector<int> > &B, vector<vector<int> > &C, int size)\n{\n    int i, j;\n\n    for (i = 0; i < size; i++)\n    {\n        for (j = 0; j < size; j++)\n        {\n            C[i][j] = A[i][j] + B[i][j];\n        }\n    }\n}\n\nvoid sub(vector<vector<int> > &A, vector<vector<int> > &B, vector<vector<int> > &C, int size)\n{\n    int i, j;\n\n    for (i = 0; i < size; i++)\n    {\n        for (j = 0; j < size; j++)\n        {\n            C[i][j] = A[i][j] - B[i][j];\n        }\n    }\n}\n\nvoid STRASSEN_algorithmA(vector<vector<int> > &A, vector<vector<int> > &B, vector<vector<int> > &C, int size)\n{\n\n    if (size == 1)\n    {\n        C[0][0] = A[0][0] * B[0][0];\n        return;\n    }\n    else\n    {\n        int new_size = size / 2;\n        vector<int> z(new_size);\n        vector<vector<int> >\n            a11(new_size, z), a12(new_size, z), a21(new_size, z), a22(new_size, z),\n            b11(new_size, z), b12(new_size, z), b21(new_size, z), b22(new_size, z),\n            c11(new_size, z), c12(new_size, z), c21(new_size, z), c22(new_size, z),\n            p1(new_size, z), p2(new_size, z), p3(new_size, z), p4(new_size, z),\n            p5(new_size, z), p6(new_size, z), p7(new_size, z),\n            aResult(new_size, z), bResult(new_size, z);\n\nint i, j;\n\nfor (i = 0; i < new_size; i++)\n        {\n            for (j = 0; j < new_size; j++)\n            {\n                a11[i][j] = A[i][j];\n                a12[i][j] = A[i][j + new_size];\n                a21[i][j] = A[i + new_size][j];\n                a22[i][j] = A[i + new_size][j + new_size];\n\n                b11[i][j] = B[i][j];\n                b12[i][j] = B[i][j + new_size];\n                b21[i][j] = B[i + new_size][j];\n                b22[i][j] = B[i + new_size][j + new_size];\n            }\n}\n\n\n        add(a11, a22, aResult, new_size);\n        add(b11, b22, bResult, new_size);\n        STRASSEN_algorithmA(aResult, bResult, p1, new_size);\n\n        add(a21, a22, aResult, new_size);\n        STRASSEN_algorithmA(aResult, b11, p2, new_size);\n\n        sub(b12, b22, bResult, new_size);\n        STRASSEN_algorithmA(a11, bResult, p3, new_size);\n\n        sub(b21, b11, bResult, new_size);\n        STRASSEN_algorithmA(a22, bResult, p4, new_size);\n\n        add(a11, a12, aResult, new_size);\n        STRASSEN_algorithmA(aResult, b22, p5, new_size);\n\n        sub(a21, a11, aResult, new_size);\n        add(b11, b12, bResult, new_size);\n\n        STRASSEN_algorithmA(aResult, bResult, p6, new_size);\n\n        sub(a12, a22, aResult, new_size);\n        add(b21, b22, bResult, new_size);\n\n        STRASSEN_algorithmA(aResult, bResult, p7, new_size);\n\n\n        add(p3, p5, c12, new_size);\n        add(p2, p4, c21, new_size);\n\n        add(p1, p4, aResult, new_size);\n        add(aResult, p7, bResult, new_size);\n        sub(bResult, p5, c11, new_size);\n\n        add(p1, p3, aResult, new_size);\n        add(aResult, p6, bResult, new_size);\n        sub(bResult, p2, c22, new_size);\n\n        for (i = 0; i < new_size; i++)\n        {\n            for (j = 0; j < new_size; j++)\n            {\n                C[i][j] = c11[i][j];\n                C[i][j + new_size] = c12[i][j];\n                C[i + new_size][j] = c21[i][j];\n                C[i + new_size][j + new_size] = c22[i][j];\n            }\n        }\n    }\n}\nvoid STRASSEN_algorithm(vector<vector<int> > &A, vector<vector<int> > &B, int m, int n, int a, int b)\n{\n    int k = max(max(m, n),max(a, b));\n\n    int s = nextpowerof2(k);\n\n    vector<int> z(s);\n    vector<vector<int> > Aa(s, z), Bb(s, z), Cc(s, z);\n\n    for (unsigned int i = 0; i < m; i++)\n    {\n        for (unsigned int j = 0; j < n; j++)\n        {\n            Aa[i][j] = A[i][j];\n        }\n    }\n    for (unsigned int i = 0; i < a; i++)\n    {\n        for (unsigned int j = 0; j < b; j++)\n        {\n            Bb[i][j] = B[i][j];\n        }\n    }\n    STRASSEN_algorithmA(Aa, Bb, Cc, s);\n    vector<int> temp1(b);\n    vector<vector<int> > C(m, temp1);\n    for (unsigned int i = 0; i < m; i++)\n    {\n        for (unsigned int j = 0; j < b; j++)\n        {\n            C[i][j] = Cc[i][j];\n        }\n    }\n    display(C, m, b);\n}\n\nbool check(int n, int a)\n{\n    if (n == a)\n        return true;\n    else\n        return false;\n}\n\nint main()\n{\n    int m, n, a, b;\n    cin >> m >> n;\n    vector<vector<int> > A;\n\n    for (int i = 0; i < m; i++)\n    {\n        vector<int> temp;\n        for (int j = 0; j < n; j++)\n        {\n            int i;\n            cin >> i;\n            temp.push_back(i);\n        }\n        A.push_back(temp);\n    }\n\n    cin >> a >> b;\n\n    vector<vector<int> > B;\n    for (int i = 0; i < a; i++)\n    {\n        vector<int> temp;\n        for (int j = 0; j < b; j++)\n        {\n            int i;\n            cin >> i;\n            temp.push_back(i);\n        }\n        B.push_back(temp);\n    }\n\n    bool k = check(n, a);\n    if (k)\n    {\n        STRASSEN_algorithm(A, B, m, n, a, b);\n    }\n    else\n    {\n        cout << \"-1\";\n    }\n    return 0;\n}\n\n\n', 1000, '', '', '??D\0i\0v\0i\0d\0e\0 \0a\0n\0d\0 \0C\0o\0n\0q\0u\0e\0r\0 \0m\0e\0t\0h\0o\0d\0 \0t\0o\0 \0m\0u\0l\0t\0i\0p\0l\0y\0 \0t\0w\0o\0 \0s\0q\0u\0a\0r\0e\0 \0m\0a\0t\0r\0i\0c\0e\0s\0.\0\r\0\n\01\0)\0 \0D\0i\0v\0i\0d\0e\0 \0m\0a\0t\0r\0i\0c\0e\0s\0 \0A\0 \0a\0n\0d\0 \0B\0 \0i\0n\0 \04\0 \0s\0u\0b\0-\0m\0a\0t\0r\0i\0c\0e\0s\0 \0o\0f\0 \0s\0i\0z\0e\0 \0N\0/\02\0 \0x\0 \0N\0/\02\0 \0a\0s\0 \0s\0h\0o\0w\0n\0 \0i\0n\0 \0t\0h\0e\0 \0b\0e\0l\0o\0w\0 \0d\0i\0a\0g\0r\0a\0m\0.\0\r\0\n\02\0)\0 \0C\0a\0l\0c\0u\0l\0a\0t\0e\0 \0f\0o\0l\0l\0o\0w\0i\0n\0g\0 \0v\0a\0l\0u\0e\0s\0 \0r\0e\0c\0u\0r\0s\0i\0v\0e\0l\0y\0.\0 \0a\0e\0 \0+\0 \0b\0g\0,\0 \0a\0f\0 \0+\0 \0b\0h\0,\0 \0c\0e\0 \0+\0 \0d\0g\0 \0a\0n\0d\0 \0c\0f\0 \0+\0 \0d\0h\0.\0 \0\r\0\n\0\r\0\n\0 \0T\0h\0e\0 \0i\0d\0e\0a\0 \0o\0f\0 \0S\0t\0r\0a\0s\0s\0e\0n\0 s\0 \0m\0e\0t\0h\0o\0d\0 \0i\0s\0 \0t\0o\0 \0r\0e\0d\0u\0c\0e\0 \0t\0h\0e\0 \0n\0u\0m\0b\0e\0r\0 \0o\0f\0 \0r\0e\0c\0u\0r\0s\0i\0v\0e\0 \0c\0a\0l\0l\0s\0 \0t\0o\0 \07\0.\0 \0S\0t\0r\0a\0s\0s\0e\0n\0 s\0 \0m\0e\0t\0h\0o\0d\0 \0i\0s\0 \0s\0i\0m\0i\0l\0a\0r\0 \0t\0o\0 \0a\0b\0o\0v\0e\0 \0s\0i\0m\0p\0l\0e\0 \0d\0i\0v\0i\0d\0e\0 \0a\0n\0d\0 \0c\0o\0n\0q\0u\0e\0r\0 \0m\0e\0t\0h\0o\0d\0 \0i\0n\0 \0t\0h\0e\0 \0s\0e\0n\0s\0e\0 \0t\0h\0a\0t\0 \0t\0h\0i\0s\0 \0m\0e\0t\0h\0o\0d\0 \0a\0l\0s\0o\0 \0d\0i\0v\0i\0d\0e\0 \0m\0a\0t\0r\0i\0c\0e\0s\0 \0t\0o\0 \0s\0u\0b\0-\0m\0a\0t\0r\0i\0c\0e\0s\0 \0o\0f\0 \0s\0i\0z\0e\0 \0N\0/\02\0 \0x\0 \0N\0/\02\0 \0a\0s\0 \0s\0h\0o\0w\0n\0 \0i\0n\0 \0t\0h\0e\0 \0a\0b\0o\0v\0e\0 \0d\0i\0a\0g\0r\0a\0m\0,\0 \0b\0u\0t\0 \0i\0n\0 \0S\0t\0r\0a\0s\0s\0e\0n\0 s\0 \0m\0e\0t\0h\0o\0d\0,\0 \0t\0h\0e\0 \0f\0o\0u\0r\0 \0s\0u\0b\0-\0m\0a\0t\0r\0i\0c\0e\0s\0 \0o\0f\0 \0r\0e\0s\0u\0l\0t\0 \0a\0r\0e\0 \0c\0a\0l\0c\0u\0l\0a\0t\0e\0d\0 \0u\0s\0i\0n\0g\0 \0f\0o\0l\0l\0o\0w\0i\0n\0g\0 \0f\0o\0r\0m\0u\0l\0a\0e\0.\0\r\0\n\0\r\0\n\0S\0t\0r\0a\0s\0s\0e\0n\0 s\0 \0M\0a\0t\0r\0i\0x\0 \0m\0u\0l\0t\0i\0p\0l\0i\0c\0a\0t\0i\0o\0n\0 \0c\0a\0n\0 \0b\0e\0 \0p\0e\0r\0f\0o\0r\0m\0e\0d\0 \0o\0n\0l\0y\0 \0o\0n\0 \0s\0q\0u\0a\0r\0e\0 \0m\0a\0t\0r\0i\0c\0e\0s\0 \0w\0h\0e\0r\0e\0 \0n\0 \0i\0s\0 \0a\0 \0p\0o\0w\0e\0r\0 \0o\0f\0 \02\0.\0 \0O\0r\0d\0e\0r\0 \0o\0f\0 \0b\0o\0t\0h\0 \0o\0f\0 \0t\0h\0e\0 \0m\0a\0t\0r\0i\0c\0e\0s\0 \0a\0r\0e\0 \0n\0 \0?\0 \0n\0.\0\r\0\n\0\r\0\n\0D\0i\0v\0i\0d\0e\0 \0X\0,\0 \0Y\0 \0a\0n\0d\0 \0Z\0 \0i\0n\0t\0o\0 \0f\0o\0u\0r\0 \0(\0n\0/\02\0)\0?\0(\0n\0/\02\0)\0 \0m\0a\0t\0r\0i\0c\0e\0s\0 \0a\0s\0 \0r\0e\0p\0r\0e\0s\0e\0n\0t\0e\0d\0 \0b\0e\0l\0o\0w\0 \0\"\r\0\n\0\r\0\n\0Z\0=\0[\0I\0K\0J\0L\0]\0\r\0\n\0X\0=\0[\0A\0C\0B\0D\0]\0 \0a\0n\0d\0 \0Y\0=\0[\0E\0G\0F\0H\0]\0\r\0\n\0\r\0\n\0U\0s\0i\0n\0g\0 \0S\0t\0r\0a\0s\0s\0e\0n\0 s\0 \0A\0l\0g\0o\0r\0i\0t\0h\0m\0 \0c\0o\0m\0p\0u\0t\0e\0 \0t\0h\0e\0 \0f\0o\0l\0l\0o\0w\0i\0n\0g\0 \0\"\r\0\n\0\r\0\n\0M\01\0:\0=\0(\0A\0+\0C\0)\0?\0(\0E\0+\0F\0)\0\r\0\n\0\r\0\n\0M\02\0:\0=\0(\0B\0+\0D\0)\0?\0(\0G\0+\0H\0)\0\r\0\n\0\r\0\n\0M\03\0:\0=\0(\0A\0\"D\0)\0?\0(\0E\0+\0H\0)\0\r\0\n\0\r\0\n\0M\04\0:\0=\0A\0?\0(\0F\0\"H\0)\0\r\0\n\0\r\0\n\0M\05\0:\0=\0(\0C\0+\0D\0)\0?\0(\0E\0)\0\r\0\n\0\r\0\n\0M\06\0:\0=\0(\0A\0+\0B\0)\0?\0(\0H\0)\0\r\0\n\0\r\0\n\0M\07\0:\0=\0D\0?\0(\0G\0\"E\0)\0\r\0\n\0\r\0\n\0T\0h\0e\0n\0,\0\r\0\n\0\r\0\n\0I\0:\0=\0M\02\0+\0M\03\0\"M\06\0\"M\07\0\r\0\n\0\r\0\n\0J\0:\0=\0M\04\0+\0M\06\0\r\0\n\0\r\0\n\0K\0:\0=\0M\05\0+\0M\07\0\r\0\n\0\r\0\n\0L\0:\0=\0M\01\0\"M\03\0\"M\04\0\"M\05\0\r\0\n\0\r\0\n\0A\0n\0a\0l\0y\0s\0i\0s\0\r\0\n\0\r\0\n\0T\0(\0n\0)\0=\0{\0c\07\0x\0T\0(\0n\02\0)\0+\0d\0x\0n\02\0 \0i\0f\0 \0n\0=\01\0 \0o\0t\0h\0e\0r\0w\0i\0s\0e\0\r\0\n\0\r\0\n\0w\0h\0e\0r\0e\0 \0c\0 \0a\0n\0d\0 \0d\0 \0a\0r\0e\0 \0c\0o\0n\0s\0t\0a\0n\0t\0s\0\r\0\n\0\r\0\n\0U\0s\0i\0n\0g\0 \0t\0h\0i\0s\0 \0r\0e\0c\0u\0r\0r\0e\0n\0c\0e\0 \0r\0e\0l\0a\0t\0i\0o\0n\0,\0 \0w\0e\0 \0g\0e\0t\0 \0T\0(\0n\0)\0=\0O\0(\0n\0l\0o\0g\07\0)\0\r\0\n\0\r\0\n\0H\0e\0n\0c\0e\0,\0 \0t\0h\0e\0 \0c\0o\0m\0p\0l\0e\0x\0i\0t\0y\0 \0o\0f\0 \0S\0t\0r\0a\0s\0s\0e\0n\0 s\0 \0m\0a\0t\0r\0i\0x\0 \0m\0u\0l\0t\0i\0p\0l\0i\0c\0a\0t\0i\0o\0n\0 \0a\0l\0g\0o\0r\0i\0t\0h\0m\0 \0i\0s\0 \0O\0(\0n\0l\0o\0g\07\0)\0\r\0\n\0', '2020-05-25'),
(604, 16, 7101012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n#define d 256  \r\n\r\nvoid search(char pat[], char txt[], int q)  \r\n{  \r\n    int M = strlen(pat);  \r\n    int N = strlen(txt);  \r\n    int i, j;  \r\n    int p = 0; // hash value for pattern  \r\n    int t = 0; // hash value for txt  \r\n    int h = 1;  \r\n\r\n    for (i = 0; i < M - 1; i++)  \r\n        h = (h * d) % q;  \r\n  \r\n    for (i = 0; i < M; i++)  \r\n    {  \r\n        p = (d * p + pat[i]) % q;  \r\n        t = (d * t + txt[i]) % q;  \r\n    }  \r\n    \r\n    for (i = 0; i <= N - M; i++)  \r\n    {  \r\n        if ( p == t )  \r\n        {  \r\n            for (j = 0; j < M; j++)  \r\n            {  \r\n                if (txt[i+j] != pat[j])  \r\n                    break;  \r\n            }  \r\n  \r\n            if (j == M)  \r\n                cout<<\"Pattern found at index \"<< i<<endl;  \r\n        }   \r\n        if ( i < N-M )  \r\n        {  \r\n            t = (d*(t - txt[i]*h) + txt[i+M])%q;  \r\n  \r\n            // We might get negative value of t, converting it  \r\n            // to positive  \r\n            if (t < 0)  \r\n            t = (t + q);  \r\n        }  \r\n    }  \r\n}  \r\nint main()  \r\n{  \r\n    char txt[100];  \r\n    char pat[100]; \r\n    gets(txt);\r\n    gets(pat); \r\n    int q = 101;  \r\n    search(pat, txt, q);  \r\n    return 0;  \r\n}  ', 1000, '', '', '﻿\n\nFormulas for Stassen’s matrix multiplication\nIn Strassen’s matrix multiplication there are seven multiplication and four addition, subtraction in total.\n\n    1.	D1 =  (a11 + a22) (b11 + b22)\n    2.	D2 =  (a21 + a22).b11\n    3.	D3 =  (b12 – b22).a11\n    4.	D4 =  (b21 – b11).a22\n    5.	D5 =  (a11 + a12).b22\n    6.	D6 =  (a21 – a11) . (b11 + b12)\n    7.	D7 =  (a12 – a22) . (b21 + b22)\n\n    C11 = d1 + d4 – d5 + d7\n    C12 = d3 + d5\n    C21 = d2 + d4\n    C22 = d1 + d3 – d2 – d6\nAlgorithm for Strassen’s matrix multiplication\nAlgorithm Strassen(n, a, b, d)\n\nbegin \n	If n = threshold then compute\n		C = a * b is a conventional matrix.\n	Else\n		Partition a into four sub matrices a11, a12, a21, a22.\n		Partition b into four sub matrices b11, b12, b21, b22.\n		Strassen ( n/2, a11 + a22, b11 + b22, d1)\n		Strassen ( n/2, a21 + a22, b11, d2)\n		Strassen ( n/2, a11, b12 – b22, d3)\n		Strassen ( n/2, a22, b21 – b11, d4)\n		Strassen ( n/2, a11 + a12, b22, d5)\n		Strassen (n/2, a21 – a11, b11 + b22, d6)\n		Strassen (n/2, a12 – a22, b21 + b22, d7)\n\n		C = d1+d4-d5+d7     d3+d5\n		    d2+d4           d1+d3-d2-d6  \n		\n	end if\n	\n	return (C)\nend.\n\n\n\n', '2020-05-25'),
(605, 7, 7201012018, '﻿#include<iostream>\r\n#include<cstdlib>\r\nusing namespace std;\r\n void swap(int *a, int *b)\r\n{\r\n        int temp; \r\n        temp = *a;\r\n        *a = *b;\r\n        *b = temp;\r\n}\r\nint Partition(int a[], int low, int high)\r\n{\r\n        int pivot, index, i;\r\n        index = low;\r\n        pivot = high;\r\n         for(i=low; i < high; i++)\r\n        {\r\n                if(a[i] < a[pivot])\r\n                {\r\n                        swap(&a[i], &a[index]);\r\n                        index++;\r\n                }\r\n        }\r\n                swap(&a[pivot], &a[index]);\r\n \r\n        return index;\r\n}\r\nint RandomPivotPartition(int a[], int low, int high)\r\n{\r\n        int pvt, n, temp;\r\n        n = rand();\r\n                pvt = low + n%(high-low+1);\r\n \r\n                swap(&a[high], &a[pvt]);\r\n \r\n        return Partition(a, low, high);\r\n}\r\nint QuickSort(int a[], int low, int high)\r\n{\r\n        int pindex;\r\n        if(low < high)\r\n        {\r\n                pindex = RandomPivotPartition(a, low, high);\r\n                QuickSort(a, low, pindex-1);\r\n                QuickSort(a, pindex+1, high);\r\n        }\r\n        return 0;\r\n}\r\n \r\nint main()\r\n{\r\n        int n, i;\r\n        cin>>n;\r\n \r\n        int arr[n];\r\n        for(i = 0; i < n; i++)\r\n        {\r\n                cin>>arr[i];\r\n        }\r\n \r\n        QuickSort(arr, 0, n-1);\r\n        for (i = 0; i < n; i++)\r\n                cout<<arr[i]<<\" \";\r\n \r\n        return 0;\r\n}', 10, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 ', 'MergeSort(arr[], l,  r)\r\nIf r > l\r\n     1. Find the middle point to divide the array into two halves:  \r\n             middle m = (l+r)/2\r\n     2. Call mergeSort for first half:   \r\n             Call mergeSort(arr, l, m)\r\n     3. Call mergeSort for second half:\r\n             Call mergeSort(arr, m+1, r)\r\n     4. Merge the two halves sorted in step 2 and 3:\r\n             Call merge(arr, l, m, r)', '2020-05-25'),
(606, 9, 7201012018, '#include <iostream> \nusing namespace std; \nclass DisjSet { \n	int *rank, *parent, n; \n\npublic: \n	DisjSet(int n) \n	{ \n		rank = new int[n]; \n		parent = new int[n]; \n		this->n = n; \n		makeSet(); \n	} \n\n	void makeSet() \n	{ \n		for (int i = 0; i < n; i++) { \n			parent[i] = i; \n		} \n	} \n\n	int find(int x) \n	{ \n		if (parent[x] != x) { \n			parent[x] = find(parent[x]); \n		} \n\n		return parent[x]; \n	} \n\n\n	void Union(int x, int y) \n	{ \n		int xset = find(x); \n		int yset = find(y); \n\n		if (xset == yset) \n			return; \n\n		if (rank[xset] < rank[yset]) { \n			parent[xset] = yset; \n		} \n		else if (rank[xset] > rank[yset]) { \n			parent[yset] = xset; \n		} \n\n		else { \n			parent[yset] = xset; \n			rank[xset] = rank[xset] + 1; \n		} \n	} \n}; \n\nint main() \n{ \n    \n	DisjSet obj(6);\n	\n	obj.Union(4,5);\n	obj.Union(0, 2); \n	obj.Union(5, 3); \n	obj.Union(3, 1); \n	if (obj.find(4) == obj.find(5)) \n		cout << \"Yes\n\"; \n	else\n		cout << \"No\n\"; \n	if (obj.find(1) == obj.find(3)) \n		cout << \"Yes\n\"; \n	else\n		cout << \"No\n\"; \n\n	return 0; \n} \n\n', 1000, '', '', '﻿\r\npartition (arr[], low, high)\r\n{\r\n    pivot = arr[high];  \r\n \r\n    i = (low - 1)  \r\n\r\n    for (j = low; j <= high- 1; j++)\r\n    {\r\n        if (arr[j] < pivot)\r\n        {\r\n            i++;    \r\n            swap arr[i] and arr[j]\r\n        }\r\n    }\r\n    swap arr[i + 1] and arr[high])\r\n    return (i + 1)\r\n}\r\n\r\nquickSort(arr[], low, high)\r\n{\r\n    if (low < high)\r\n    {\r\n        pi = partition(arr, low, high);\r\n\r\n        quickSort(arr, low, pi - 1);  // Before pi\r\n        quickSort(arr, pi + 1, high); // After pi\r\n    }\r\n}\r\n\r\n', '2020-05-25'),
(607, 12, 7201012018, '﻿#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nclass Edge\r\n{\r\n    public:\r\n    int src, dest, weight;\r\n};\r\n\r\n\r\nclass Graph\r\n{\r\n    public:\r\n    int V, E;\r\n    Edge* edge;\r\n};\r\n\r\nGraph* createGraph(int V, int E)\r\n{\r\n    Graph* graph = new Graph;\r\n    graph->V = V;\r\n    graph->E = E;\r\n    graph->edge = new Edge[E];\r\n    return graph;\r\n}\r\n\r\nclass subset\r\n{\r\n    public:\r\n    int parent;\r\n    int rank;\r\n};\r\n\r\nint find(subset subsets[], int i)\r\n{\r\n    if (subsets[i].parent != i)\r\n        subsets[i].parent = find(subsets, subsets[i].parent);\r\n    return subsets[i].parent;\r\n}\r\n\r\nvoid Union(subset subsets[], int x, int y)\r\n{\r\n    int xroot = find(subsets, x);\r\n    int yroot = find(subsets, y);\r\n    if (subsets[xroot].rank < subsets[yroot].rank)\r\n        subsets[xroot].parent = yroot;\r\n    else if (subsets[xroot].rank > subsets[yroot].rank)\r\n        subsets[yroot].parent = xroot;\r\n    else\r\n    {\r\n        subsets[yroot].parent = xroot;\r\n        subsets[xroot].rank++;\r\n    }\r\n}\r\n\r\nint myComp(const void* a, const void* b)\r\n{\r\n    Edge* a1 = (Edge*)a;\r\n    Edge* b1 = (Edge*)b;\r\n    return a1->weight > b1->weight;\r\n}\r\n\r\nvoid KruskalMST(Graph* graph)\r\n{\r\n    int V = graph->V;\r\n    Edge result[V];\r\n    int e = 0;\r\n    int i = 0;\r\n    qsort(graph->edge, graph->E, sizeof(graph->edge[0]), myComp);\r\n    subset *subsets = new subset[( V * sizeof(subset) )];\r\n\r\n    for (int v = 0; v < V; ++v)\r\n    {\r\n        subsets[v].parent = v;\r\n        subsets[v].rank = 0;\r\n    }\r\n    while (e < V - 1 && i < graph->E)\r\n    {\r\n        Edge next_edge = graph->edge[i++];\r\n        int x = find(subsets, next_edge.src);\r\n        int y = find(subsets, next_edge.dest);\r\n        if (x != y)\r\n        {\r\n            result[e++] = next_edge;\r\n            Union(subsets, x, y);\r\n        }\r\n    }\r\n\r\n    cout<<\"Following are the edges in the constructed MST\n\";\r\n    for (i = 0; i < e; ++i)\r\n        cout<<result[i].src<<\" -- \"<<result[i].dest<<\" == \"<<result[i].weight<<endl;\r\n    return;\r\n}\r\n\r\nint main()\r\n{\r\n    int V = 4;\r\n    int E = 5;\r\n    Graph* graph = createGraph(V, E);\r\n\r\n\r\n    graph->edge[0].src = 0;\r\n    graph->edge[0].dest = 1;\r\n    graph->edge[0].weight = 10;\r\n    graph->edge[1].src = 0;\r\n    graph->edge[1].dest = 2;\r\n    graph->edge[1].weight = 6;\r\n    graph->edge[2].src = 0;\r\n    graph->edge[2].dest = 3;\r\n    graph->edge[2].weight = 5;\r\n    graph->edge[3].src = 1;\r\n    graph->edge[3].dest = 3;\r\n    graph->edge[3].weight = 15;\r\n    graph->edge[4].src = 2;\r\n    graph->edge[4].dest = 3;\r\n    graph->edge[4].weight = 4;\r\n\r\n    KruskalMST(graph);\r\n\r\n\r\n    return 0;\r\n}', 1000, '', '', '﻿An efficient solution is to use the Greedy approach. The basic idea of the greedy approach is to calculate the ratio value/weight for each item and sort the item on the basis of this ratio. Then take the item with the highest ratio and add them until we can’t add the next item as a whole and at the end add the next item as much as we can. Which will always be the optimal solution to this problem.\r\n\r\n\r\nAlgorithm: Greedy-Fractional-Knapsack (w[1..n], p[1..n], W) \r\nfor i = 1 to n \r\n   do x[i] = 0 \r\nweight = 0 \r\nfor i = 1 to n \r\n   if weight + w[i] ≤ W then  \r\n      x[i] = 1 \r\n      weight = weight + w[i] \r\n   else \r\n      x[i] = (W - weight) / w[i] \r\n      weight = W \r\n      break \r\nreturn x', '2020-05-25'),
(608, 13, 7201012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n\r\nint minKey(int V,int key[], bool mstSet[]) \r\n{ \r\n	int min = INT_MAX, min_index; \r\n	for (int v = 1; v <= V; v++) \r\n		if (mstSet[v] == false && key[v] < min) \r\n			min = key[v], min_index = v; \r\n\r\n	return min_index; \r\n} \r\n\r\n\r\nvoid printMST(int V,int parent[], int graph[100][100]) \r\n{ \r\n	 \r\n	int sum=0;\r\n	for (int i = 1; i <= V; i++) \r\n	{sum+=graph[i][parent[i]];\r\n		 }\r\n		cout<<sum<<endl;\r\n} \r\n\r\n\r\nvoid primMST(int V,int graph[100][100]) \r\n{ \r\n	 \r\n	int parent[V+1]; \r\n	int key[V+1]; \r\n	bool mstSet[V+1]; \r\n\r\n	for (int i = 1; i <= V; i++) \r\n		key[i] = INT_MAX, mstSet[i] = false; \r\n\r\n	key[1] = 0; \r\n	parent[1] = -1;  \r\n	for (int count = 1; count < V; count++) \r\n	{ \r\n		int u = minKey(V,key, mstSet);\r\n		mstSet[u] = true; \r\n		for (int v = 1; v <= V; v++) \r\n			if (graph[u][v] && mstSet[v] == false && graph[u][v] < key[v]) \r\n				parent[v] = u, key[v] = graph[u][v]; \r\n	} \r\n	printMST( V,parent, graph); \r\n} \r\n\r\n\r\nint main() \r\n{ \r\n	\r\nint V,E;\r\ncin>>V;\r\ncin>>E;\r\n\r\nint graph[100][100];\r\n	\r\n      for(int i=0;i<=V;i++)\r\n       for(int j=0;j<=V;j++)\r\n        {\r\n        graph[i][j]=0;\r\n       }\r\n       int a,b,w;\r\n      for(int i=0;i<E;i++)\r\n       {\r\n       cin>>a>>b>>w;\r\n       graph[a][b]=w;\r\n       graph[b][a]=w;\r\n       }\r\n	primMST(V,graph); \r\n\r\n	return 0; \r\n} ', 1000, '', '', '﻿There are mainly two major parts in Huffman Coding\r\n1) Build a Huffman Tree from input characters.\r\n2) Traverse the Huffman Tree and assign codes to characters.\r\nInput is an array of unique characters along with their frequency of occurrences and output is Huffman Tree.\r\n1. Create a leaf node for each unique character and build a min heap of all leaf nodes (Min Heap is used as a priority queue. The value of the frequency field is used to compare two nodes in a min heap. Initially, the least frequent character is at root)\r\n2. Extract two nodes with the minimum frequency from the min heap.\r\n3. Create a new internal node with a frequency equal to the sum of the two nodes frequencies. Make the first extracted node as its left child and the other extracted node as its right child. Add this node to the min heap.\r\n4. Repeat steps#2 and #3 until the heap contains only one node. The remaining node is the root node and the tree is complete.', '2020-05-25'),
(609, 14, 7201012018, '﻿#include <bits/stdc++.h>\r\nstruct Edge {\r\n    int src, dest, weight;\r\n};\r\nstruct Graph {\r\n       int V, E;\r\n      struct Edge* edge;\r\n};\r\nstruct Graph* createGraph(int V, int E)\r\n{\r\n    struct Graph* graph = new Graph;\r\n    graph->V = V;\r\n    graph->E = E;\r\n    graph->edge = new Edge[E];\r\n    return graph;\r\n}\r\nvoid printArr(int dist[], int n)\r\n{\r\n    printf(\"Vertex   Distance from Source\n\");\r\n    for (int i = 0; i < n; ++i)\r\n        printf(\"%d 		 %d\n\", i, dist[i]);\r\n}\r\nvoid BellmanFord(struct Graph* graph, int src)\r\n{\r\n    int V = graph->V;\r\n    int E = graph->E;\r\n    int dist[V];\r\n      for (int i = 0; i < V; i++)\r\n        dist[i] = INT_MAX;\r\n    dist[src] = 0;\r\n      for (int i = 1; i <= V - 1; i++) {\r\n        for (int j = 0; j < E; j++) {\r\n            int u = graph->edge[j].src;\r\n            int v = graph->edge[j].dest;\r\n            int weight = graph->edge[j].weight;\r\n            if (dist[u] != INT_MAX && dist[u] + weight < dist[v])\r\n                dist[v] = dist[u] + weight;\r\n        }\r\n    }\r\n      for (int i = 0; i < E; i++) {\r\n        int u = graph->edge[i].src;\r\n        int v = graph->edge[i].dest;\r\n        int weight = graph->edge[i].weight;\r\n        if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {\r\n            printf(\"Graph contains negative weight cycle\");\r\n            return; // If negative cycle is detected, simply return\r\n        }\r\n    }\r\n    printArr(dist, V);\r\n    return;\r\n}\r\n  \r\nint main()\r\n{\r\n    int V = 5; \r\n    int E = 8; \r\n    struct Graph* graph = createGraph(V, E);\r\n \r\n    graph->edge[0].src = 0;\r\n    graph->edge[0].dest = 1;\r\n    graph->edge[0].weight = -1;\r\n    graph->edge[1].src = 0;\r\n    graph->edge[1].dest = 2;\r\n    graph->edge[1].weight = 4;\r\n    graph->edge[2].src = 1;\r\n    graph->edge[2].dest = 2;\r\n    graph->edge[2].weight = 3;\r\n    graph->edge[3].src = 1;\r\n    graph->edge[3].dest = 3;\r\n    graph->edge[3].weight = 2;\r\n    graph->edge[4].src = 1;\r\n    graph->edge[4].dest = 4;\r\n    graph->edge[4].weight = 2;\r\n    graph->edge[5].src = 3;\r\n    graph->edge[5].dest = 2;\r\n    graph->edge[5].weight = 5;\r\n    graph->edge[6].src = 3;\r\n    graph->edge[6].dest = 1;\r\n    graph->edge[6].weight = 1;\r\n    graph->edge[7].src = 4;\r\n    graph->edge[7].dest = 3;\r\n    graph->edge[7].weight = -3;\r\n  \r\n    BellmanFord(graph, 0);\r\n  \r\n    return 0;\r\n}', 1000, '', '', '﻿1. Sort all the edges in non-decreasing order of their weight.\r\n2. Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If a cycle is not formed, include this edge. Else, discard it.\r\n3. Repeat step#2 until there are (V-1) edges in the spanning tree.', '2020-05-25'),
(610, 15, 7201012018, '﻿#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\n\r\nint MatrixChainOrder(int p[], int n)\r\n{\r\n    int m[n][n];\r\n    int i, j, k, L, q;\r\n    for (i = 1; i < n; i++)\r\n        m[i][i] = 0;\r\n\r\n    for (L = 2; L < n; L++)\r\n    {\r\n        for (i = 1; i < n - L + 1; i++)\r\n        {\r\n            j = i + L - 1;\r\n            m[i][j] = INT_MAX;\r\n            for (k = i; k <= j - 1; k++)\r\n            {\r\n                q = m[i][k] + m[k + 1][j] +\r\n                    p[i - 1] * p[k] * p[j];\r\n                if (q < m[i][j])\r\n                    m[i][j] = q;\r\n            }\r\n        }\r\n    }\r\n    return m[1][n - 1];\r\n}\r\n\r\nint main()\r\n{\r\n    int n; cin>>n;\r\n    int* arr = new int[n];\r\n    for(int i = 0; i < n; i++)\r\n        cin>>arr[i];\r\n    int size = n;\r\n       cout<< MatrixChainOrder(arr, size);\r\n    getchar();\r\n    return 0;\r\n}', 1000, '', '', '﻿1. Associate with each vertex v of the graph a number C[v] (the cheapest cost of a connection to v) and an edge E[v] (the edge providing that cheapest connection). To initialize these values, set all values of C[v] to +∞ (or to any number larger than the maximum edge weight) and set each E[v] to a special flag value indicating that there is no edge connecting v to earlier vertices.\r\n2. Initialize an empty forest F and a set Q of vertices that have not yet been included in F (initially, all vertices).\r\n3. Repeat the following steps until Q is empty:\r\n   1. Find and remove a vertex v from Q having the minimum possible value of C[v]\r\n   2. Add v to F and, if E[v] is not the special flag value, also add E[v] to F\r\n   3. Loop over the edges vw connecting v to other vertices w. For each such edge, if w still belongs to Q and vw has smaller weight than C[w], perform the following steps:\r\n      1. Set C[w] to the cost of edge vw\r\n      2. Set E[w] to point to edge vw.\r\n4. Return F', '2020-05-25'),
(611, 8, 7201012018, '#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint nextpowerof2(int k)\n{\n    return pow(2, int(ceil(log2(k))));\n}\nvoid display(vector< vector<int>> &matrix, int m, int n)\n{\n    for (int i = 0; i < m; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (j != 0)\n            {\n                cout <<\" \";\n            }\n            cout << matrix[i][j];\n        }\n        cout << endl;\n    }\n}\n\nvoid add(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n    int i, j;\n\n    for (i = 0; i < size; i++)\n    {\n        for (j = 0; j < size; j++)\n        {\n            C[i][j] = A[i][j] + B[i][j];\n        }\n    }\n}\n\nvoid sub(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n    int i, j;\n\n    for (i = 0; i < size; i++)\n    {\n        for (j = 0; j < size; j++)\n        {\n            C[i][j] = A[i][j] - B[i][j];\n        }\n    }\n}\n\nvoid STRASSEN_algorithmA(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n    if (size == 1)\n    {\n        C[0][0] = A[0][0] * B[0][0];\n        return;\n    }\n    else\n    {\n        int new_size = size / 2;\n        vector<int> z(new_size);\n        vector<vector<int>>\n            a11(new_size, z), a12(new_size, z), a21(new_size, z), a22(new_size, z),\n            b11(new_size, z), b12(new_size, z), b21(new_size, z), b22(new_size, z),\n            c11(new_size, z), c12(new_size, z), c21(new_size, z), c22(new_size, z),\n            p1(new_size, z), p2(new_size, z), p3(new_size, z), p4(new_size, z),\n            p5(new_size, z), p6(new_size, z), p7(new_size, z),\n            aResult(new_size, z), bResult(new_size, z);\n\nint i, j;\nfor (i = 0; i < new_size; i++)\n        {\n            for (j = 0; j < new_size; j++)\n            {\n                a11[i][j] = A[i][j];\n                a12[i][j] = A[i][j + new_size];\n                a21[i][j] = A[i + new_size][j];\n                a22[i][j] = A[i + new_size][j + new_size];\n\n                b11[i][j] = B[i][j];\n                b12[i][j] = B[i][j + new_size];\n                b21[i][j] = B[i + new_size][j];\n                b22[i][j] = B[i + new_size][j + new_size];\n            }\n}\n\n        add(a11, a22, aResult, new_size);\n        add(b11, b22, bResult, new_size);\n        STRASSEN_algorithmA(aResult, bResult, p1, new_size);\n\n        add(a21, a22, aResult, new_size);\n        STRASSEN_algorithmA(aResult, b11, p2, new_size);\n\n        sub(b12, b22, bResult, new_size);\n        STRASSEN_algorithmA(a11, bResult, p3, new_size);\n\n\n        sub(b21, b11, bResult, new_size);\n        STRASSEN_algorithmA(a22, bResult, p4, new_size);\n        add(a11, a12, aResult, new_size);\n        STRASSEN_algorithmA(aResult, b22, p5, new_size);\n\n        sub(a21, a11, aResult, new_size);\n        add(b11, b12, bResult, new_size);\n        STRASSEN_algorithmA(aResult, bResult, p6, new_size);\n\n        sub(a12, a22, aResult, new_size);\n        add(b21, b22, bResult, new_size);\n        STRASSEN_algorithmA(aResult, bResult, p7, new_size);\n\n        add(p3, p5, c12, new_size);\n        add(p2, p4, c21, new_size);\n\n        add(p1, p4, aResult, new_size);\n        add(aResult, p7, bResult, new_size);\n        sub(bResult, p5, c11, new_size);\n\n        add(p1, p3, aResult, new_size);\n        add(aResult, p6, bResult, new_size);\n        sub(bResult, p2, c22, new_size);\n        for (i = 0; i < new_size; i++)\n        {\n            for (j = 0; j < new_size; j++)\n            {\n                C[i][j] = c11[i][j];\n                C[i][j + new_size] = c12[i][j];\n                C[i + new_size][j] = c21[i][j];\n                C[i + new_size][j + new_size] = c22[i][j];\n            }\n        }\n    }\n}\nvoid STRASSEN_algorithm(vector<vector<int>> &A, vector<vector<int>> &B, int m, int n, int a, int b)\n{\n    int k = max({m, n, a, b});\n\n    int s = nextpowerof2(k);\n\n    vector<int> z(s);\n    vector<vector<int>> Aa(s, z), Bb(s, z), Cc(s, z);\n\n    for (unsigned int i = 0; i < m; i++)\n    {\n        for (unsigned int j = 0; j < n; j++)\n        {\n            Aa[i][j] = A[i][j];\n        }\n    }\n    for (unsigned int i = 0; i < a; i++)\n    {\n        for (unsigned int j = 0; j < b; j++)\n        {\n            Bb[i][j] = B[i][j];\n        }\n    }\n    STRASSEN_algorithmA(Aa, Bb, Cc, s);\n    vector<int> temp1(b);\n    vector<vector<int>> C(m, temp1);\n    for (unsigned int i = 0; i < m; i++)\n    {\n        for (unsigned int j = 0; j < b; j++)\n        {\n            C[i][j] = Cc[i][j];\n        }\n    }\n    display(C, m, b);\n}\n\nbool check(int n, int a)\n{\n    if (n == a)\n        return true;\n    else\n        return false;\n}\n\nint main()\n{\n    int n, a, b;\n    cin >> n;\n\n    vector<vector<int>> A;\n    for (int i = 0; i < n; i++)\n    {\n        vector<int> temp;\n        for (int j = 0; j < n; j++)\n        {\n            int i;\n            cin >> i;\n            temp.push_back(i);\n        }\n        A.push_back(temp);\n    }\n\n    vector<vector<int>> B;\n    for (int i = 0; i < n; i++)\n    {\n        vector<int> temp;\n        for (int j = 0; j < n; j++)\n        {\n            int i;\n            cin >> i;\n            temp.push_back(i);\n        }\n        B.push_back(temp);\n    }\n\n\n        STRASSEN_algorithm(A, B, n, n, n, n);\n\n    return 0;\n}\n\n', 0, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '', '﻿In general, we can find the minimum cost using the following recursive algorithm:\r\n* Take the sequence of matrices and separate it into two subsequences.\r\n* Find the minimum cost of multiplying out each subsequence.\r\n* Add these costs together, and add in the cost of multiplying the two result matrices.\r\n* Do this for each possible position at which the sequence of matrices can be split, and take the minimum over all of them.\r\n\r\n\r\nMatrixChainOrder(int dims[])\r\n{\r\n    // length[dims] = n + 1\r\n    n = dims.length - 1;\r\n    // m[i,j] = Minimum number of scalar multiplications (i.e., cost)\r\n    // needed to compute the matrix A[i]A[i+1]...A[j] = A[i..j]\r\n    // The cost is zero when multiplying one matrix\r\n    for (i = 1; i <= n; i++)\r\n        m[i, i] = 0;\r\n\r\n\r\n    for (len = 2; len <= n; len++) { // Subsequence lengths\r\n        for (i = 1; i <= n - len + 1; i++) {\r\n            j = i + len - 1;\r\n            m[i, j] = MAXINT;\r\n            for (k = i; k <= j - 1; k++) {\r\n                cost = m[i, k] + m[k+1, j] + dims[i-1]*dims[k]*dims[j];\r\n                if (cost < m[i, j]) {\r\n                    m[i, j] = cost;\r\n                    s[i, j] = k; // Index of the subsequence split that achieved minimal cost\r\n                }\r\n            }\r\n        }\r\n    }\r\n}', '2020-05-25'),
(612, 5, 7201012018, '#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint nextpowerof2(int k)\n{\n    return pow(2, int(ceil(log2(k))));\n}\nvoid display(vector< vector<int>> &matrix, int m, int n)\n{\n    for (int i = 0; i < m; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (j != 0)\n            {\n                cout << \" \";\n            }\n            cout << matrix[i][j];\n        }\n        cout << endl;\n    }\n}\n\nvoid add(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n    int i, j;\n\n    for (i = 0; i < size; i++)\n    {\n        for (j = 0; j < size; j++)\n        {\n            C[i][j] = A[i][j] + B[i][j];\n        }\n    }\n}\n\nvoid sub(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n    int i, j;\n\n    for (i = 0; i < size; i++)\n    {\n        for (j = 0; j < size; j++)\n        {\n            C[i][j] = A[i][j] - B[i][j];\n        }\n    }\n}\n\nvoid STRASSEN_algorithmA(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n   \n    if (size == 1)\n    {\n        C[0][0] = A[0][0] * B[0][0];\n        return;\n    }\n    else\n    {\n        int new_size = size / 2;\n        vector<int> z(new_size);\n        vector<vector<int>>\n            a11(new_size, z), a12(new_size, z), a21(new_size, z), a22(new_size, z),\n            b11(new_size, z), b12(new_size, z), b21(new_size, z), b22(new_size, z),\n            c11(new_size, z), c12(new_size, z), c21(new_size, z), c22(new_size, z),\n            p1(new_size, z), p2(new_size, z), p3(new_size, z), p4(new_size, z),\n            p5(new_size, z), p6(new_size, z), p7(new_size, z),\n            aResult(new_size, z), bResult(new_size, z);\n\nint i, j;\n\nfor (i = 0; i < new_size; i++)\n        {\n            for (j = 0; j < new_size; j++)\n            {\n                a11[i][j] = A[i][j];\n                a12[i][j] = A[i][j + new_size];\n                a21[i][j] = A[i + new_size][j];\n                a22[i][j] = A[i + new_size][j + new_size];\n\n                b11[i][j] = B[i][j];\n                b12[i][j] = B[i][j + new_size];\n                b21[i][j] = B[i + new_size][j];\n                b22[i][j] = B[i + new_size][j + new_size];\n            }\n}\n\n\n        add(a11, a22, aResult, new_size);    \n        add(b11, b22, bResult, new_size);    \n        STRASSEN_algorithmA(aResult, bResult, p1, new_size); \n\n        add(a21, a22, aResult, new_size); \n        STRASSEN_algorithmA(aResult, b11, p2, new_size);\n\n        sub(b12, b22, bResult, new_size);      \n        STRASSEN_algorithmA(a11, bResult, p3, new_size);\n\n        sub(b21, b11, bResult, new_size);     \n        STRASSEN_algorithmA(a22, bResult, p4, new_size); \n\n        add(a11, a12, aResult, new_size);     \n        STRASSEN_algorithmA(aResult, b22, p5, new_size);\n\n        sub(a21, a11, aResult, new_size);      \n        add(b11, b12, bResult, new_size);               \n      \n        STRASSEN_algorithmA(aResult, bResult, p6, new_size);\n\n        sub(a12, a22, aResult, new_size);      \n        add(b21, b22, bResult, new_size);                \n        \n        STRASSEN_algorithmA(aResult, bResult, p7, new_size);\n        \n\n        add(p3, p5, c12, new_size); \n        add(p2, p4, c21, new_size); \n\n        add(p1, p4, aResult, new_size);      \n        add(aResult, p7, bResult, new_size); \n        sub(bResult, p5, c11, new_size); \n\n        add(p1, p3, aResult, new_size);     \n        add(aResult, p6, bResult, new_size);  \n        sub(bResult, p2, c22, new_size); \n\n        for (i = 0; i < new_size; i++)\n        {\n            for (j = 0; j < new_size; j++)\n            {\n                C[i][j] = c11[i][j];\n                C[i][j + new_size] = c12[i][j];\n                C[i + new_size][j] = c21[i][j];\n                C[i + new_size][j + new_size] = c22[i][j];\n            }\n        }\n    }\n}\nvoid STRASSEN_algorithm(vector<vector<int>> &A, vector<vector<int>> &B, int m, int n, int a, int b)\n{  \n    int k = max({m, n, a, b});\n\n    int s = nextpowerof2(k);\n\n    vector<int> z(s);\n    vector<vector<int>> Aa(s, z), Bb(s, z), Cc(s, z);\n\n    for (unsigned int i = 0; i < m; i++)\n    {\n        for (unsigned int j = 0; j < n; j++)\n        {\n            Aa[i][j] = A[i][j];\n        }\n    }\n    for (unsigned int i = 0; i < a; i++)\n    {\n        for (unsigned int j = 0; j < b; j++)\n        {\n            Bb[i][j] = B[i][j];\n        }\n    }\n    STRASSEN_algorithmA(Aa, Bb, Cc, s);\n    vector<int> temp1(b);\n    vector<vector<int>> C(m, temp1);\n    for (unsigned int i = 0; i < m; i++)\n    {\n        for (unsigned int j = 0; j < b; j++)\n        {\n            C[i][j] = Cc[i][j];\n        }\n    }\n    display(C, m, b);\n}\n\nbool check(int n, int a)\n{\n    if (n == a)\n        return true;\n    else\n        return false;\n}\n\nint main()\n{\n    int m = 3, n=4, a=4, b=3;\n    vector<vector<int>> A;\n    A = {{1,2,3,4},{4,5,6,1},{7,8,9,2}};\n\n    vector<vector<int>> B;\n    B = {{1,2,3},{5,7,2},{6,3,2},{1,9,2}};\n\n    bool k = check(n, a);\n    if (k)\n    {\n        STRASSEN_algorithm(A, B, m, n, a, b);\n    }\n    else\n    {\n        cout << \"-1\";\n    }\n    return 0;\n}\n\n\n', 1000, '', '', '\r\nALGO: SIMULATANEOUS MAX_MIN (DIVIDE AND CONQUER)\r\n\r\nDivide the array into two parts and compare the maximums and minimums of the two parts to get the maximum and the minimum of the whole array.\r\n\r\nfindMinAndMax(array, array_size)\r\n   if array_size = 1\r\n      return element as both max and min\r\n   else if arry_size = 2\r\n      one comparison to determine max and min\r\n      return that pair\r\n   else    /* array_size  > 2 */\r\n      recur for max and min of left half\r\n      recur for max and min of right half\r\n      one comparison determines true max of the two candidates\r\n      one comparison determines true min of the two candidates\r\n      return the pair of max and min\r\n', '2020-05-25'),
(613, 16, 7201012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n\r\n#define d 256 \r\n\r\nvoid search(char pat[], char txt[],int q) \r\n{ \r\n	int M = strlen(pat); \r\n	int N = strlen(txt); \r\n	int i, j; \r\n	int p = 0; \r\n	int t = 0;  \r\n	int h = 1; \r\n\r\n	for (i = 0; i < M - 1; i++) \r\n		h = (h * d) % q; \r\n\r\n	for (i = 0; i < M; i++) \r\n	{ \r\n		p = (d * p + pat[i]) % q; \r\n		t = (d * t + txt[i]) % q; \r\n	} \r\n\r\n	for (i = 0; i <= N - M; i++) \r\n	{ \r\n		if ( p == t ) \r\n		{ \r\n			for (j = 0; j < M; j++) \r\n			{ \r\n				if (txt[i+j] != pat[j]) \r\n					break; \r\n			} \r\n\r\n			if (j == M) \r\n				cout<<\"Pattern found at index \"<< i<<endl; \r\n		} \r\n\r\n		if ( i < N-M ) \r\n		{ \r\n			t = (d*(t - txt[i]*h) + txt[i+M])%q; \r\n\r\n			if (t < 0) \r\n			t = (t + q); \r\n		} \r\n	} \r\n} \r\n\r\nint main() \r\n{ \r\n	char txt[];\r\n        cin>>txt;\r\n	char pat[];\r\n        cin>>pat;\r\n	int q = 101;  \r\n	search(pat, txt, q); \r\n	return 0; \r\n} \r\n\r\n', 1000, '', '', '1)Divide matrices A and B in 4 sub-matrices of size N/2 x N/2. \r\n2)Calculate the 7 matrix multiplications recursively.\r\n3)Compute the submatricies of C.\r\n4)Combine these submatricies into our new matrix C', '2020-05-25'),
(614, 9, 7301012018, '/#include <iostream> \nusing namespace std; \nclass DisjSet { \n	int *rank, *parent, n; \n\npublic: \n	DisjSet(int n) \n	{ \n		rank = new int[n]; \n		parent = new int[n]; \n		this->n = n; \n		makeSet(); \n	} \n\n	void makeSet() \n	{ \n		for (int i = 0; i < n; i++) { \n			parent[i] = i; \n		} \n	} \n\n	int find(int x) \n	{ \n		if (parent[x] != x) { \n			parent[x] = find(parent[x]); \n		} \n\n		return parent[x]; \n	} \n\n\n	void Union(int x, int y) \n	{ \n		int xset = find(x); \n		int yset = find(y); \n\n		if (xset == yset) \n			return; \n\n		if (rank[xset] < rank[yset]) { \n			parent[xset] = yset; \n		} \n		else if (rank[xset] > rank[yset]) { \n			parent[yset] = xset; \n		} \n\n		else { \n			parent[yset] = xset; \n			rank[xset] = rank[xset] + 1; \n		} \n	} \n}; \n\nint main() \n{ \n    \n	DisjSet obj(6);\n	\n	obj.Union(4,5);\n	obj.Union(0, 2); \n	obj.Union(5, 3); \n	obj.Union(3, 1); \n	if (obj.find(4) == obj.find(5)) \n		cout << \"Yes\n\"; \n	else\n		cout << \"No\n\"; \n	if (obj.find(1) == obj.find(3)) \n		cout << \"Yes\n\"; \n	else\n		cout << \"No\n\"; \n\n	return 0; \n} \n\n', 1000, '', '', 'function MakeSet(x)\r\n   x.parent = x\r\n\r\nfunction Find(x)\r\n   if x.parent == x\r\n      return x\r\n   else\r\n      return Find(x.parent)\r\n\r\nfunction Union(x,y)\r\n   xRoot = Find(x)\r\n   yRoot = Find(y)\r\n   xRoot.parent = yRoot', '2020-05-25'),
(615, 13, 7301012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n\r\n \r\nint minKey(int V,int key[], bool mstSet[]) \r\n{ \r\n	int min = INT_MAX, min_index; \r\n	for (int v = 0; v < V; v++) \r\n		if (mstSet[v] == false && key[v] < min) \r\n			min = key[v], min_index = v; \r\n\r\n	return min_index; \r\n} \r\n\r\n\r\nvoid printMST(int V,int parent[], int graph[100][100]) \r\n{ \r\n	 \r\n	int sum=0;\r\n	for (int i = 1; i < V; i++) \r\n	{sum+=graph[i][parent[i]];\r\n		 }\r\n		cout<<\"\n\"<<sum;\r\n} \r\n\r\n\r\nvoid primMST(int V,int graph[100][100]) \r\n{ \r\n	 \r\n	int parent[V]; \r\n	int key[V]; \r\n	bool mstSet[V]; \r\n\r\n	for (int i = 0; i < V; i++) \r\n		key[i] = INT_MAX, mstSet[i] = false; \r\n\r\n	key[0] = 0; \r\n	parent[0] = -1;  \r\n	for (int count = 0; count < V - 1; count++) \r\n	{ \r\n		int u = minKey(V,key, mstSet);\r\n		mstSet[u] = true; \r\n		for (int v = 0; v < V; v++) \r\n			if (graph[u][v] && mstSet[v] == false && graph[u][v] < key[v]) \r\n				parent[v] = u, key[v] = graph[u][v]; \r\n	} \r\n	printMST( V,parent, graph); \r\n} \r\n\r\n\r\nint main() \r\n{ \r\n	\r\nint V,E;\r\ncin>>V;\r\ncin>>E;\r\n\r\nint graph[100][100];\r\n	\r\n      for(int i=0;i<V;i++)\r\n       for(int j=0;j<V;j++)\r\n        {\r\n        graph[i][j]=0;\r\n       }\r\n     int a,b,w;\r\n      for(int i=0;i<E;i++)\r\n       {\r\n       cin>>a>>b>>w;\r\n       graph[a][b]=w;\r\n       graph[b][a]=w;\r\n       }\r\n	primMST(V,graph); \r\n\r\n	return 0; \r\n} ', 1000, '', '', '﻿1. Associate with each vertex v of the graph a number C[v] (the cheapest cost of a connection to v) and an edge E[v] (the edge providing that cheapest connection). To initialize these values, set all values of C[v] to +∞ (or to any number larger than the maximum edge weight) and set each E[v] to a special flag value indicating that there is no edge connecting v to earlier vertices.\r\n2. Initialize an empty forest F and a set Q of vertices that have not yet been included in F (initially, all vertices).\r\n3. Repeat the following steps until Q is empty:\r\n   1. Find and remove a vertex v from Q having the minimum possible value of C[v]\r\n   2. Add v to F and, if E[v] is not the special flag value, also add E[v] to F\r\n   3. Loop over the edges vw connecting v to other vertices w. For each such edge, if w still belongs to Q and vw has smaller weight than C[w], perform the following steps:\r\n      1. Set C[w] to the cost of edge vw\r\n      2. Set E[w] to point to edge vw.\r\n4. Return F', '2020-05-25'),
(616, 14, 7301012018, '﻿#include <bits/stdc++.h>\r\nstruct Edge {\r\n    int src, dest, weight;\r\n};\r\nstruct Graph {\r\n       int V, E;\r\n      struct Edge* edge;\r\n};\r\nstruct Graph* createGraph(int V, int E)\r\n{\r\n    struct Graph* graph = new Graph;\r\n    graph->V = V;\r\n    graph->E = E;\r\n    graph->edge = new Edge[E];\r\n    return graph;\r\n}\r\nvoid printArr(int dist[], int n)\r\n{\r\n    printf(\"Vertex   Distance from Source\n\");\r\n    for (int i = 0; i < n; ++i)\r\n        printf(\"%d 		 %d\n\", i, dist[i]);\r\n}\r\nvoid BellmanFord(struct Graph* graph, int src)\r\n{\r\n    int V = graph->V;\r\n    int E = graph->E;\r\n    int dist[V];\r\n      for (int i = 0; i < V; i++)\r\n        dist[i] = INT_MAX;\r\n    dist[src] = 0;\r\n      for (int i = 1; i <= V - 1; i++) {\r\n        for (int j = 0; j < E; j++) {\r\n            int u = graph->edge[j].src;\r\n            int v = graph->edge[j].dest;\r\n            int weight = graph->edge[j].weight;\r\n            if (dist[u] != INT_MAX && dist[u] + weight < dist[v])\r\n                dist[v] = dist[u] + weight;\r\n        }\r\n    }\r\n      for (int i = 0; i < E; i++) {\r\n        int u = graph->edge[i].src;\r\n        int v = graph->edge[i].dest;\r\n        int weight = graph->edge[i].weight;\r\n        if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {\r\n            printf(\"Graph contains negative weight cycle\");\r\n            return; // If negative cycle is detected, simply return\r\n        }\r\n    }\r\n    printArr(dist, V);\r\n    return;\r\n}\r\n  \r\nint main()\r\n{\r\n    int V = 5; // Number of vertices in graph\r\n    int E = 8; // Number of edges in graph\r\n    struct Graph* graph = createGraph(V, E);\r\n \r\n    graph->edge[0].src = 0;\r\n    graph->edge[0].dest = 1;\r\n    graph->edge[0].weight = -1;\r\n    graph->edge[1].src = 0;\r\n    graph->edge[1].dest = 2;\r\n    graph->edge[1].weight = 4;\r\n    graph->edge[2].src = 1;\r\n    graph->edge[2].dest = 2;\r\n    graph->edge[2].weight = 3;\r\n    graph->edge[3].src = 1;\r\n    graph->edge[3].dest = 3;\r\n    graph->edge[3].weight = 2;\r\n    graph->edge[4].src = 1;\r\n    graph->edge[4].dest = 4;\r\n    graph->edge[4].weight = 2;\r\n    graph->edge[5].src = 3;\r\n    graph->edge[5].dest = 2;\r\n    graph->edge[5].weight = 5;\r\n  \r\n \r\n    graph->edge[6].src = 3;\r\n    graph->edge[6].dest = 1;\r\n    graph->edge[6].weight = 1;\r\n    graph->edge[7].src = 4;\r\n    graph->edge[7].dest = 3;\r\n    graph->edge[7].weight = -3;\r\n  \r\n    BellmanFord(graph, 0);\r\n  \r\n    return 0;\r\n}\r\n', 1000, '', '', '﻿function BellmanFord(list vertices, list edges, vertex source) is\r\n    ::distance[], predecessor[]\r\n\r\n\r\n    // This implementation takes in a graph, represented as\r\n    // lists of vertices and edges, and fills two arrays\r\n    // (distance and predecessor) about the shortest path\r\n    // from the source to each vertex\r\n\r\n\r\n    // Step 1: initialize graph\r\n    for each vertex v in vertices do\r\n        distance[v] := inf             // Initialize the distance to all vertices to infinity\r\n        predecessor[v] := null         // And having a null predecessor\r\n    \r\n    distance[source] := 0              // The distance from the source to itself is, of course, zero\r\n    // Step 2: relax edges repeatedly\r\n    for i from 1 to size(vertices)−1 do //just |V|−1 repetitions; i is never referenced\r\n        for each edge (u, v) with weight w in edges do\r\n            if distance[u] + w < distance[v] then\r\n                distance[v] := distance[u] + w\r\n                predecessor[v] := u\r\n\r\n\r\n    // Step 3: check for negative-weight cycles\r\n    for each edge (u, v) with weight w in edges do\r\n        if distance[u] + w < distance[v] then\r\n            error \"Graph contains a negative-weight cycle\"\r\n\r\n\r\n    return distance[], predecessor[]', '2020-05-25');
INSERT INTO `qtos_map` (`ID`, `Q_ID`, `ROLL`, `SUBMISSION`, `SCORE`, `INPUT`, `OP`, `ALGO`, `DATE`) VALUES
(617, 8, 7301012018, '#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint nextpowerof2(int k)\n{\n    return pow(2, int(ceil(log2(k))));\n}\nvoid display(vector< vector<int>> &matrix, int m, int n)\n{\n    for (int i = 0; i < m; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (j != 0)\n            {\n                cout <<\" \";\n            }\n            cout << matrix[i][j];\n        }\n        cout << endl;\n    }\n}\n\nvoid add(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n    int i, j;\n\n    for (i = 0; i < size; i++)\n    {\n        for (j = 0; j < size; j++)\n        {\n            C[i][j] = A[i][j] + B[i][j];\n        }\n    }\n}\n\nvoid sub(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n    int i, j;\n\n    for (i = 0; i < size; i++)\n    {\n        for (j = 0; j < size; j++)\n        {\n            C[i][j] = A[i][j] - B[i][j];\n        }\n    }\n}\n\nvoid STRASSEN_algorithmA(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n    if (size == 1)\n    {\n        C[0][0] = A[0][0] * B[0][0];\n        return;\n    }\n    else\n    {\n        int new_size = size / 2;\n        vector<int> z(new_size);\n        vector<vector<int>>\n            a11(new_size, z), a12(new_size, z), a21(new_size, z), a22(new_size, z),\n            b11(new_size, z), b12(new_size, z), b21(new_size, z), b22(new_size, z),\n            c11(new_size, z), c12(new_size, z), c21(new_size, z), c22(new_size, z),\n            p1(new_size, z), p2(new_size, z), p3(new_size, z), p4(new_size, z),\n            p5(new_size, z), p6(new_size, z), p7(new_size, z),\n            aResult(new_size, z), bResult(new_size, z);\n\nint i, j;\nfor (i = 0; i < new_size; i++)\n        {\n            for (j = 0; j < new_size; j++)\n            {\n                a11[i][j] = A[i][j];\n                a12[i][j] = A[i][j + new_size];\n                a21[i][j] = A[i + new_size][j];\n                a22[i][j] = A[i + new_size][j + new_size];\n\n                b11[i][j] = B[i][j];\n                b12[i][j] = B[i][j + new_size];\n                b21[i][j] = B[i + new_size][j];\n                b22[i][j] = B[i + new_size][j + new_size];\n            }\n}\n\n        add(a11, a22, aResult, new_size);\n        add(b11, b22, bResult, new_size);\n        STRASSEN_algorithmA(aResult, bResult, p1, new_size);\n\n        add(a21, a22, aResult, new_size);\n        STRASSEN_algorithmA(aResult, b11, p2, new_size);\n\n        sub(b12, b22, bResult, new_size);\n        STRASSEN_algorithmA(a11, bResult, p3, new_size);\n\n\n        sub(b21, b11, bResult, new_size);\n        STRASSEN_algorithmA(a22, bResult, p4, new_size);\n        add(a11, a12, aResult, new_size);\n        STRASSEN_algorithmA(aResult, b22, p5, new_size);\n\n        sub(a21, a11, aResult, new_size);\n        add(b11, b12, bResult, new_size);\n        STRASSEN_algorithmA(aResult, bResult, p6, new_size);\n\n        sub(a12, a22, aResult, new_size);\n        add(b21, b22, bResult, new_size);\n        STRASSEN_algorithmA(aResult, bResult, p7, new_size);\n\n        add(p3, p5, c12, new_size);\n        add(p2, p4, c21, new_size);\n\n        add(p1, p4, aResult, new_size);\n        add(aResult, p7, bResult, new_size);\n        sub(bResult, p5, c11, new_size);\n\n        add(p1, p3, aResult, new_size);\n        add(aResult, p6, bResult, new_size);\n        sub(bResult, p2, c22, new_size);\n        for (i = 0; i < new_size; i++)\n        {\n            for (j = 0; j < new_size; j++)\n            {\n                C[i][j] = c11[i][j];\n                C[i][j + new_size] = c12[i][j];\n                C[i + new_size][j] = c21[i][j];\n                C[i + new_size][j + new_size] = c22[i][j];\n            }\n        }\n    }\n}\nvoid STRASSEN_algorithm(vector<vector<int>> &A, vector<vector<int>> &B, int m, int n, int a, int b)\n{\n    int k = max({m, n, a, b});\n\n    int s = nextpowerof2(k);\n\n    vector<int> z(s);\n    vector<vector<int>> Aa(s, z), Bb(s, z), Cc(s, z);\n\n    for (unsigned int i = 0; i < m; i++)\n    {\n        for (unsigned int j = 0; j < n; j++)\n        {\n            Aa[i][j] = A[i][j];\n        }\n    }\n    for (unsigned int i = 0; i < a; i++)\n    {\n        for (unsigned int j = 0; j < b; j++)\n        {\n            Bb[i][j] = B[i][j];\n        }\n    }\n    STRASSEN_algorithmA(Aa, Bb, Cc, s);\n    vector<int> temp1(b);\n    vector<vector<int>> C(m, temp1);\n    for (unsigned int i = 0; i < m; i++)\n    {\n        for (unsigned int j = 0; j < b; j++)\n        {\n            C[i][j] = Cc[i][j];\n        }\n    }\n    display(C, m, b);\n}\n\nbool check(int n, int a)\n{\n    if (n == a)\n        return true;\n    else\n        return false;\n}\n\nint main()\n{\n    int n, a, b;\n    cin >> n;\n\n    vector<vector<int>> A;\n    for (int i = 0; i < n; i++)\n    {\n        vector<int> temp;\n        for (int j = 0; j < n; j++)\n        {\n            int i;\n            cin >> i;\n            temp.push_back(i);\n        }\n        A.push_back(temp);\n    }\n\n    vector<vector<int>> B;\n    for (int i = 0; i < n; i++)\n    {\n        vector<int> temp;\n        for (int j = 0; j < n; j++)\n        {\n            int i;\n            cin >> i;\n            temp.push_back(i);\n        }\n        B.push_back(temp);\n    }\n\n\n        STRASSEN_algorithm(A, B, n, n, n, n);\n\n    return 0;\n}\n\n', 0, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '', '1)Divide matrices A and B in 4 sub-matrices of size N/2 x N/2. \r\n2)Calculate the 7 matrix multiplications recursively.\r\n3)Compute the submatricies of C.\r\n4)Combine these submatricies into our new matrix C', '2020-05-25'),
(618, 5, 7301012018, '#include < iostream>\n#include < vector>\n#include < cmath>\n#include < algorithm>\nusing namespace std;\n\nint nextpowerof2(int k)\n{\n    return pow(2, int(ceil(log2(k))));\n}\nvoid display(vector< vector<int>> &matrix, int m, int n)\n{\n    for (int i = 0; i < m; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (j != 0)\n            {\n                cout << \"	\";\n            }\n            cout << matrix[i][j];\n        }\n        cout << endl;\n    }\n}\n\nvoid add(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n    int i, j;\n\n    for (i = 0; i < size; i++)\n    {\n        for (j = 0; j < size; j++)\n        {\n            C[i][j] = A[i][j] + B[i][j];\n        }\n    }\n}\n\nvoid sub(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n    int i, j;\n\n    for (i = 0; i < size; i++)\n    {\n        for (j = 0; j < size; j++)\n        {\n            C[i][j] = A[i][j] - B[i][j];\n        }\n    }\n}\n\nvoid STRASSEN_algorithmA(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n   \n    if (size == 1)\n    {\n        C[0][0] = A[0][0] * B[0][0];\n        return;\n    }\n    else\n    {\n        int new_size = size / 2;\n        vector<int> z(new_size);\n        vector<vector<int>>\n            a11(new_size, z), a12(new_size, z), a21(new_size, z), a22(new_size, z),\n            b11(new_size, z), b12(new_size, z), b21(new_size, z), b22(new_size, z),\n            c11(new_size, z), c12(new_size, z), c21(new_size, z), c22(new_size, z),\n            p1(new_size, z), p2(new_size, z), p3(new_size, z), p4(new_size, z),\n            p5(new_size, z), p6(new_size, z), p7(new_size, z),\n            aResult(new_size, z), bResult(new_size, z);\n\nint i, j;\n\nfor (i = 0; i < new_size; i++)\n        {\n            for (j = 0; j < new_size; j++)\n            {\n                a11[i][j] = A[i][j];\n                a12[i][j] = A[i][j + new_size];\n                a21[i][j] = A[i + new_size][j];\n                a22[i][j] = A[i + new_size][j + new_size];\n\n                b11[i][j] = B[i][j];\n                b12[i][j] = B[i][j + new_size];\n                b21[i][j] = B[i + new_size][j];\n                b22[i][j] = B[i + new_size][j + new_size];\n            }\n}\n\n\n        add(a11, a22, aResult, new_size);    \n        add(b11, b22, bResult, new_size);    \n        STRASSEN_algorithmA(aResult, bResult, p1, new_size); \n\n        add(a21, a22, aResult, new_size); \n        STRASSEN_algorithmA(aResult, b11, p2, new_size);\n\n        sub(b12, b22, bResult, new_size);      \n        STRASSEN_algorithmA(a11, bResult, p3, new_size);\n\n        sub(b21, b11, bResult, new_size);     \n        STRASSEN_algorithmA(a22, bResult, p4, new_size); \n\n        add(a11, a12, aResult, new_size);     \n        STRASSEN_algorithmA(aResult, b22, p5, new_size);\n\n        sub(a21, a11, aResult, new_size);      \n        add(b11, b12, bResult, new_size);               \n      \n        STRASSEN_algorithmA(aResult, bResult, p6, new_size);\n\n        sub(a12, a22, aResult, new_size);      \n        add(b21, b22, bResult, new_size);                \n        \n        STRASSEN_algorithmA(aResult, bResult, p7, new_size);\n        \n\n        add(p3, p5, c12, new_size); \n        add(p2, p4, c21, new_size); \n\n        add(p1, p4, aResult, new_size);      \n        add(aResult, p7, bResult, new_size); \n        sub(bResult, p5, c11, new_size); \n\n        add(p1, p3, aResult, new_size);     \n        add(aResult, p6, bResult, new_size);  \n        sub(bResult, p2, c22, new_size); \n\n        for (i = 0; i < new_size; i++)\n        {\n            for (j = 0; j < new_size; j++)\n            {\n                C[i][j] = c11[i][j];\n                C[i][j + new_size] = c12[i][j];\n                C[i + new_size][j] = c21[i][j];\n                C[i + new_size][j + new_size] = c22[i][j];\n            }\n        }\n    }\n}\nvoid STRASSEN_algorithm(vector<vector<int>> &A, vector<vector<int>> &B, int m, int n, int a, int b)\n{  \n    int k = max({m, n, a, b});\n\n    int s = nextpowerof2(k);\n\n    vector<int> z(s);\n    vector<vector<int>> Aa(s, z), Bb(s, z), Cc(s, z);\n\n    for (unsigned int i = 0; i < m; i++)\n    {\n        for (unsigned int j = 0; j < n; j++)\n        {\n            Aa[i][j] = A[i][j];\n        }\n    }\n    for (unsigned int i = 0; i < a; i++)\n    {\n        for (unsigned int j = 0; j < b; j++)\n        {\n            Bb[i][j] = B[i][j];\n        }\n    }\n    STRASSEN_algorithmA(Aa, Bb, Cc, s);\n    vector<int> temp1(b);\n    vector<vector<int>> C(m, temp1);\n    for (unsigned int i = 0; i < m; i++)\n    {\n        for (unsigned int j = 0; j < b; j++)\n        {\n            C[i][j] = Cc[i][j];\n        }\n    }\n    display(C, m, b);\n}\n\nbool check(int n, int a)\n{\n    if (n == a)\n        return true;\n    else\n        return false;\n}\n\nint main()\n{\n    int m, n, a, b;\n    cin >> m >> n;\n    vector<vector<int>> A;\n   \n    for (int i = 0; i < m; i++)\n    {\n        vector<int> temp;\n        for (int j = 0; j < n; j++)\n        {\n            int i;\n            cin >> i;\n            temp.push_back(i);\n        }\n        A.push_back(temp);\n    }\n    \n    cin >> a >> b;\n    \n    vector<vector<int>> B;\n    for (int i = 0; i < a; i++)\n    {\n        vector<int> temp;\n        for (int j = 0; j < b; j++)\n        {\n            int i;\n            cin >> i;\n            temp.push_back(i);\n        }\n        B.push_back(temp);\n    }\n\n    bool k = check(n, a);\n    if (k)\n    {\n        STRASSEN_algorithm(A, B, m, n, a, b);\n    }\n    else\n    {\n        cout << \"-1\";\n    }\n    return 0;\n}\n\n\n', 1000, '', '', 'function Strassen(M,N)\r\nif M is 1 ? 1 then\r\nreturn M11N11\r\nend if\r\nLet M =  A B\r\n         C D \r\nand N =  E F\r\n         G H \r\nSet S1 = Strassen(B - D, G + H)\r\nSet S2 = Strassen(A + D, E + H)\r\nSet S3 = Strassen(A - C, E + F)\r\nSet S4 = Strassen(A + B, H)\r\nSet S5 = Strassen(A, F - H)\r\nSet S6 = Strassen(D, G - E)\r\nSet S7 = Strassen(C + D, E)\r\nreturn (\r\nS1 + S2 - S4 + S6    S4 + S5\r\nS6 + S7              S2 - S3 + S5 - S7\r\n)\r\nend function\r\n', '2020-05-25'),
(619, 16, 7301012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n\r\n#define d 256 \r\n\r\nvoid search(char pat[], char txt[],int q) \r\n{ \r\n	int M = strlen(pat); \r\n	int N = strlen(txt); \r\n	int i, j; \r\n	int p = 0; \r\n	int t = 0;  \r\n	int h = 1; \r\n\r\n	for (i = 0; i < M - 1; i++) \r\n		h = (h * d) % q; \r\n\r\n	for (i = 0; i < M; i++) \r\n	{ \r\n		p = (d * p + pat[i]) % q; \r\n		t = (d * t + txt[i]) % q; \r\n	} \r\n\r\n	for (i = 0; i <= N - M; i++) \r\n	{ \r\n		if ( p == t ) \r\n		{ \r\n			for (j = 0; j < M; j++) \r\n			{ \r\n				if (txt[i+j] != pat[j]) \r\n					break; \r\n			} \r\n\r\n			if (j == M) \r\n				cout<<\"Pattern found at index \"<< i<<\" \"+endl; \r\n		} \r\n\r\n		if ( i < N-M ) \r\n		{ \r\n			t = (d*(t - txt[i]*h) + txt[i+M])%q; \r\n\r\n			if (t < 0) \r\n			t = (t + q); \r\n		} \r\n	} \r\n} \r\n\r\nint main() \r\n{ \r\n	char txt[];\r\n        cin>>txt;\r\n	char pat[];\r\n        cin>>pat;\r\n	int q = 101;  \r\n	search(pat, txt, q); \r\n	return 0; \r\n} \r\n\r\n', 1000, '', '', '\r\n// Rabin Karp Algorithm\r\n\r\nfunction RabinKarp(string s[1..n], string pattern[1..m])\r\n    hpattern := hash(pattern[1..m]);\r\n    for i from 1 to n-m+1\r\n        hs := hash(s[i..i+m-1])\r\n        if hs = hpattern\r\n            if s[i..i+m-1] = pattern[1..m]\r\n                return i\r\n    return not found', '2020-05-25'),
(620, 3, 7401012018, '#include <iostream>\r\nusing namespace std;\r\n\r\n\r\nvoid swap(int *a, int *b) {\r\n  int t = *a;\r\n  *a = *b;\r\n  *b = t;\r\n}\r\n\r\n\r\nvoid printArray(int array[], int size) {\r\n  int i;\r\n  for (i = 0; i < size; i++)\r\n    cout << array[i] << \" \";\r\n  cout << endl;\r\n}\r\n\r\n\r\nint partition(int array[], int low, int high) {\r\n  // Select the pivot element\r\n  int pivot = array[high];\r\n  int i = (low - 1);\r\n\r\n  // Put the elements smaller than pivot on the left and greater than pivot on the right of pivot\r\n  for (int j = low; j < high; j++) {\r\n    if (array[j] <= pivot) {\r\n      i++;\r\n      swap(&array[i], &array[j]);\r\n    }\r\n  }\r\n  printArray(array, 7);\r\n  cout << \"........\n\";\r\n  swap(&array[i + 1], &array[high]);\r\n  return (i + 1);\r\n}\r\n\r\nvoid quickSort(int array[], int low, int high) {\r\n  if (low < high) {\r\n    // Select pivot position and put all the elements smaller than pivot on left and greater than pivot on right\r\n    int pi = partition(array, low, high);\r\n\r\n    // Sort the elements on the left of pivot\r\n    quickSort(array, low, pi - 1);\r\n\r\n    // Sort the elements on the right of pivot\r\n    quickSort(array, pi + 1, high);\r\n  }\r\n}\r\n\r\n// Driver code\r\nint main() {\r\n  int data[] = {8, 7, 6, 1, 0, 9, 2};\r\n  int n = sizeof(data) / sizeof(data[0]);\r\n  quickSort(data, 0, n - 1);\r\n  cout << \"Sorted array in ascending order: \n\";\r\n  printArray(data, n);\r\n}', 0, '1 2000', '1 0 6 8 7 9 2 \n........\n1 0 2 8 7 9 6 \n........\n0 1 2 8 7 9 6 \n........\n0 1 2 6 7 9 8 \n........\nSorted array in ascending order: \n0 1 2 6 7 8 9 \n', 'quickSort(array, leftmostIndex, rightmostIndex)\r\n  if (leftmostIndex < rightmostIndex)\r\n    pivotIndex <- partition(array,leftmostIndex, rightmostIndex)\r\n    quickSort(array, leftmostIndex, pivotIndex)\r\n    quickSort(array, pivotIndex + 1, rightmostIndex)\r\n\r\npartition(array, leftmostIndex, rightmostIndex)\r\n  set rightmostIndex as pivotIndex\r\n  storeIndex <- leftmostIndex - 1\r\n  for i <- leftmostIndex + 1 to rightmostIndex\r\n  if element[i] < pivotElement\r\n    swap element[i] and element[storeIndex]\r\n    storeIndex++\r\n  swap pivotElement and element[storeIndex+1]\r\nreturn storeIndex + 1', '2020-05-25'),
(621, 7, 7401012018, '#include <cstdlib> \r\n#include <stdio.h>\r\n#include <iostream> \r\nusing namespace std; \r\n  \r\nint partition(int arr[], int start, int end) \r\n{ \r\n    int pivot = arr[end]; \r\n    int i = (start - 1); \r\n  \r\n    for (int j = start; j <= end - 1; j++) { \r\n  \r\n        if (arr[j] <= pivot) { \r\n  \r\n            i++; \r\n            swap(arr[i], arr[j]); \r\n        } \r\n    } \r\n    swap(arr[i + 1], arr[end]); \r\n    return (i + 1); \r\n} \r\n  \r\nint random_partition(int arr[], int start, int end) \r\n{ \r\n   \r\n    int random = start + rand() % (end - start); \r\n  \r\n    swap(arr[random], arr[end]); \r\n  \r\n    return partition(arr, start, end); \r\n} \r\n  \r\nvoid quickSort(int arr[], int start, int end) \r\n{ \r\n    if (start < end) { \r\n  \r\n        int pi = random_partition(arr, start, end); \r\n  \r\n        quickSort(arr, start, pi - 1); \r\n        quickSort(arr, pi + 1, end); \r\n    } \r\n} \r\n  \r\nvoid printArray(int arr[], int size) \r\n{ \r\n    for (int i = 0; i < size; i++){ \r\n 	 cout<<arr[i]<<endl; \r\n    }\r\n   \r\n} \r\n  \r\nint main() \r\n{ \r\n    \r\n    int n;\r\n    cin >> n; \r\n    int arr[n];\r\n    for (int i = 0; i < n; ++i){\r\n	 cin >> arr[i];\r\n    }\r\n    quickSort(arr, 0, n - 1); \r\n    printArray(arr, n);   \r\n} ', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0\n1\n4\n5\n6\n6\n8\n8\n8\n9\n9\n1000\n14000\n', 'partition(arr[], lo, hi) \r\n    pivot = arr[hi]\r\n    i = lo     // place for swapping\r\n    for j := lo to hi – 1 do\r\n        if arr[j] <= pivot then\r\n            swap arr[i] with arr[j]\r\n            i = i + 1\r\n    swap arr[i] with arr[hi]\r\n    return i\r\n\r\npartition_r(arr[], lo, hi)\r\n    r = Random Number from lo to hi\r\n    Swap arr[r] and arr[hi]\r\n    return partition(arr, lo, hi)\r\n\r\nquicksort(arr[], lo, hi)\r\n    if lo < hi\r\n        p = partition_r(arr, lo, hi)\r\n        quicksort(arr, p-1, hi)\r\n        quicksort(arr, p+1, hi)\r\n ', '2020-05-25'),
(622, 9, 7401012018, '#include <iostream>\r\nusing namespace std;\r\nclass DisjSet {\r\n	int *rank, *parent, n;\r\n\r\npublic:\r\n	DisjSet(int n)\r\n	{\r\n		rank = new int[n];\r\n		parent = new int[n];\r\n		this->n = n;\r\n		makeSet();\r\n	}\r\n\r\n	void makeSet()\r\n	{\r\n		for (int i = 0; i < n; i++) {\r\n			parent[i] = i;\r\n		}\r\n	}\r\n\r\n	int find(int x)\r\n	{\r\n		if (parent[x] != x) {\r\n\r\n			parent[x] = find(parent[x]);\r\n		}\r\n\r\n		return parent[x];\r\n	}\r\n\r\n	void Union(int x, int y)\r\n	{\r\n		int xset = find(x);\r\n		int yset = find(y);\r\n\r\n		if (xset == yset)\r\n			return;\r\n\r\n		if (rank[xset] < rank[yset]) {\r\n			parent[xset] = yset;\r\n		}\r\n		else if (rank[xset] > rank[yset]) {\r\n			parent[yset] = xset;\r\n		}\r\n		else {\r\n			parent[yset] = xset;\r\n			rank[xset] = rank[xset] + 1;\r\n		}\r\n	}\r\n};\r\n\r\nint main()\r\n{\r\n	DisjSet obj(5);\r\n    obj.Union(0, 2);\r\n    obj.Union(4, 2);\r\n    obj.Union(3, 1);\r\n    if (obj.find(4) == obj.find(0))\r\n        cout << \"Yes\n\";\r\n    else\r\n        cout << \"No\n\";\r\n    if (obj.find(1) == obj.find(0))\r\n        cout << \"Yes\n\";\r\n    else\r\n        cout << \"No\n\";\r\n\r\n    return 0;\r\n}\r\n', 1000, '', '', 'Begin\r\n   Assume k is the element\r\n   makeset(k):\r\n      k.parent = k.\r\n   Find(x):\r\n   If k.parent == k\r\n      return k.\r\n   else\r\n   return Find(k.parent)\r\n   Union (a,b):\r\n      Take two set a and b as input.\r\n      aroot = Find(a)\r\n      broot = Find(b)\r\n      aroot.parent = broot\r\nEnd', '2020-05-25'),
(623, 10, 7401012018, 'import java.io.*;\r\nimport java.util.*;\r\n\r\npublic class Main {\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        Scanner scn = new Scanner(System.in);\r\n        int n = scn.nextInt();\r\n	int cap = scn.nextInt();\r\n        int[] weight = new int[n];\r\n        int[] price = new int[n];\r\n        for (int i = 0; i < n; i++) {\r\n            price[i] = scn.nextInt();\r\n        }\r\n        for (int i = 0; i < n; i++) {\r\n            weight[i] = scn.nextInt();\r\n        }      \r\n        System.out.println(knapsack(weight, price, cap));\r\n    }\r\n\r\n    public static int knapsack(int[] weight, int[] price, int cap) {\r\n        int[][] dp = new int[price.length][cap + 1];\r\n        \r\n        for (int i = 0; i < dp[0].length; i++) {\r\n            if (weight[0] <= cap && i >= weight[0]) {\r\n                dp[0][i] = price[0];\r\n            }\r\n        }\r\n        for (int i = 1; i < dp.length; i++) {\r\n            for (int j = 1; j < dp[0].length; j++) {\r\n                int val = weight[i];\r\n                if (j - val >= 0) {\r\n                    dp[i][j] = Math.max(dp[i - 1][j], price[i] + dp[i - 1][j - val]);\r\n                } else {\r\n                    dp[i][j] = dp[i - 1][j];\r\n                }\r\n            }\r\n        }\r\n        return dp[dp.length-1][dp[0].length-1];\r\n    }\r\n}', 0, '5 15 4 2 1 2 10 12 2 1 1 4', '15\n', '??G\0r\0e\0e\0d\0y\0-\0F\0r\0a\0c\0t\0i\0o\0n\0a\0l\0-\0K\0n\0a\0p\0s\0a\0c\0k\0 \0(\0w\0[\01\0.\0.\0n\0]\0,\0 \0p\0[\01\0.\0.\0n\0]\0,\0 \0W\0)\0 \0\r\0\n\0f\0o\0r\0 \0i\0 \0=\0 \01\0 \0t\0o\0 \0n\0 \0\r\0\n\0 \0 \0 \0d\0o\0 \0x\0[\0i\0]\0 \0=\0 \00\0 \0\r\0\n\0w\0e\0i\0g\0h\0t\0 \0=\0 \00\0 \0\r\0\n\0f\0o\0r\0 \0i\0 \0=\0 \01\0 \0t\0o\0 \0n\0 \0\r\0\n\0 \0 \0 \0i\0f\0 \0w\0e\0i\0g\0h\0t\0 \0+\0 \0w\0[\0i\0]\0 \0d\" \0W\0 \0t\0h\0e\0n\0 \0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0x\0[\0i\0]\0 \0=\0 \01\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0w\0e\0i\0g\0h\0t\0 \0=\0 \0w\0e\0i\0g\0h\0t\0 \0+\0 \0w\0[\0i\0]\0 \0\r\0\n\0 \0 \0 \0e\0l\0s\0e\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0x\0[\0i\0]\0 \0=\0 \0(\0W\0 \0-\0 \0w\0e\0i\0g\0h\0t\0)\0 \0/\0 \0w\0[\0i\0]\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0w\0e\0i\0g\0h\0t\0 \0=\0 \0W\0 \0\r\0\n\0 \0 \0 \0 \0 \0 \0b\0r\0e\0a\0k\0 \0\r\0\n\0r\0e\0t\0u\0r\0n\0 \0x\0', '2020-05-25'),
(624, 12, 7401012018, '#include<iostream>\r\n#include<algorithm>\r\nusing namespace std;\r\n\r\nclass Edge\r\n{\r\n	public:\r\n	int source;\r\n	int dest;\r\n	int weight;\r\n};\r\n\r\nbool compare(Edge e1,Edge e2){\r\n    return e1.weight< e2.weight;\r\n}\r\nint findParent(int v,int *parent){\r\n    if(parent[v]==v){\r\n        return v;\r\n    }\r\n    return findParent(parent[v],parent);\r\n}\r\nvoid Kruskals(Edge *input,int n,int E){\r\n    sort(input,input+E,compare);\r\n    Edge *output=new Edge[n-1];\r\n    int *parent= new int[n];\r\n    for(int i=0;i<n;i++){\r\n        parent[i]=i;\r\n    }\r\n    int count=0;\r\n    int i=0;\r\n    while(count!=n-1){\r\n        Edge currentEdge = input[i];\r\n        int sourceParent = findParent(currentEdge.source,parent);\r\n        int destParent = findParent(currentEdge.dest,parent);\r\n\r\n        if(sourceParent!=destParent){\r\n            output[count]=currentEdge;\r\n            count++;\r\n            parent[sourceParent]=destParent;\r\n        }\r\n        i++;\r\n    }\r\n    for(int i=0;i<n-1;i++){\r\n        if(output[i].source<output[i].dest){\r\n            cout<<output[i].source<<\"---\"<<output[i].dest<<\"==>\"<<output[i].weight<<\" \";\r\n        }else{\r\n            cout<<output[i].dest<<\"---\"<<output[i].source<<\"==>\"<<output[i].weight<<\" \";\r\n        }\r\n    }\r\n}\r\n\r\nint main(){\r\n    int n=4;\r\n    int E=4;\r\n    Edge *input=new Edge[E];\r\n        input[0].source=0;\r\n        input[0].dest=1;\r\n        input[0].weight=3;\r\n        input[1].source=0;\r\n        input[1].dest=3;\r\n        input[1].weight=5;\r\n        input[2].source=1;\r\n        input[2].dest=2;\r\n        input[2].weight=1;\r\n        input[3].source=2;\r\n        input[3].dest=3;\r\n        input[3].weight=8;\r\n    Kruskals(input,n,E);\r\n}\r\n', 1000, '', '', '1. Sort all the edges in non-decreasing order of their weight.\r\n2. Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If cycle is not formed, include this edge. Else, discard it.\r\n3. Repeat step#2 until there are (V-1) edges in the spanning tree.', '2020-05-25'),
(625, 13, 7401012018, ' \r\n#include <limits.h> \r\n#include <stdbool.h> \r\n#include <stdio.h>  \r\n#define V 5 \r\n\r\nint minKey(int key[], bool mstSet[]) \r\n{ \r\n    \r\n    int min = INT_MAX, min_index; \r\n  \r\n    for (int v = 0; v < V; v++) \r\n        if (mstSet[v] == false && key[v] < min) \r\n            min = key[v], min_index = v; \r\n  \r\n    return min_index; \r\n} \r\n  \r\n\r\nint printMST(int parent[], int graph[V][V]) \r\n{ \r\n    printf(\"Edge 	Weight\n\"); \r\n    for (int i = 1; i < V; i++) \r\n        printf(\"%d - %d 	%d \n\", parent[i], i, graph[i][parent[i]]); \r\n} \r\n  \r\n\r\nvoid primMST(int graph[V][V]) \r\n{ \r\n    \r\n    int parent[V]; \r\n    int key[V]; \r\n    bool mstSet[V];  \r\n    for (int i = 0; i < V; i++) \r\n        key[i] = INT_MAX, mstSet[i] = false; \r\n\r\n    key[0] = 0; \r\n    parent[0] = -1; \r\n    for (int count = 0; count < V - 1; count++) { \r\n        int u = minKey(key, mstSet); \r\n        mstSet[u] = true;  \r\n        for (int v = 0; v < V; v++) \r\n \r\n            if (graph[u][v] && mstSet[v] == false && graph[u][v] < key[v]) \r\n                parent[v] = u, key[v] = graph[u][v]; \r\n    } \r\n  \r\n    \r\n    printMST(parent, graph); \r\n} \r\n \r\nint main() \r\n{ \r\n    int graph[V][V] = { { 0, 2, 0, 6, 0 }, \r\n                        { 2, 0, 3, 8, 5 }, \r\n                        { 0, 3, 0, 0, 7 }, \r\n                        { 6, 8, 0, 0, 9 }, \r\n                        { 0, 5, 7, 9, 0 } };  \r\n    primMST(graph); \r\n  \r\n    return 0; \r\n} ', 1000, '', '', 'Algorithm\r\n1) Create a set mstSet that keeps track of vertices already included in MST.\r\n2) Assign a key value to all vertices in the input graph. Initialize all key values as INFINITE. Assign key value as 0 for the first vertex so that it is picked first.\r\n3) While mstSet doesn’t include all vertices\r\n….a) Pick a vertex u which is not there in mstSet and has minimum key value.\r\n….b) Include u to mstSet.\r\n….c) Update key value of all adjacent vertices of u. To update the key values, iterate through all adjacent vertices. For every adjacent vertex v, if weight of edge u-v is less than the previous key value of v, update the key value as weight of u-v', '2020-05-25'),
(626, 14, 7401012018, '#include<iostream>\r\n#include<conio.h>\r\n#include<stdio.h>\r\nstruct Edge {\r\n    int src, dest, weight;\r\n};\r\n\r\nstruct Graph\r\n{\r\n    int V, E;\r\n    struct Edge* edge;\r\n};\r\nstruct Graph* createGraph(int V, int E)\r\n{\r\n    struct Graph* graph = new Graph;\r\n    graph->V = V;\r\n    graph->E = E;\r\n    graph->edge = new Edge[E];\r\n    return graph;\r\n}\r\nvoid printArr(int dist[], int n)\r\n{\r\n    for (int i = 0; i < n; ++i)\r\n        printf(\"%d %d \", i, dist[i]);\r\n}\r\n\r\nvoid BellmanFord(struct Graph* graph, int src)\r\n{\r\n    int V = graph->V;\r\n    int E = graph->E;\r\n    int dist[V];\r\n\r\n    for (int i = 0; i < V; i++)\r\n        dist[i] = INT_MAX;\r\n    dist[src] = 0;\r\n\r\n    for (int i = 1; i <= V - 1; i++) {\r\n        for (int j = 0; j < E; j++) {\r\n            int u = graph->edge[j].src;\r\n            int v = graph->edge[j].dest;\r\n            int weight = graph->edge[j].weight;\r\n            if (dist[u] != INT_MAX && dist[u] + weight < dist[v])\r\n                dist[v] = dist[u] + weight;\r\n        }\r\n    }\r\n     for (int i = 0; i < E; i++) {\r\n        int u = graph->edge[i].src;\r\n        int v = graph->edge[i].dest;\r\n        int weight = graph->edge[i].weight;\r\n        if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {\r\n            printf(\"Graph contains negative weight cycle\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printArr(dist, V);\r\n\r\n    return;\r\n}\r\n\r\nint main()\r\n{\r\n    int V = 5;\r\n    int E = 8;\r\n    struct Graph* graph = createGraph(V, E);\r\n\r\n\r\n    graph->edge[0].src = 0;\r\n    graph->edge[0].dest = 1;\r\n    graph->edge[0].weight = -1;\r\n\r\n\r\n    graph->edge[1].src = 0;\r\n    graph->edge[1].dest = 2;\r\n    graph->edge[1].weight = 4;\r\n\r\n\r\n    graph->edge[2].src = 1;\r\n    graph->edge[2].dest = 2;\r\n    graph->edge[2].weight = 3;\r\n\r\n\r\n    graph->edge[3].src = 1;\r\n    graph->edge[3].dest = 3;\r\n    graph->edge[3].weight = 2;\r\n\r\n\r\n    graph->edge[4].src = 1;\r\n    graph->edge[4].dest = 4;\r\n    graph->edge[4].weight = 2;\r\n\r\n\r\n    graph->edge[5].src = 3;\r\n    graph->edge[5].dest = 2;\r\n    graph->edge[5].weight = 5;\r\n\r\n\r\n    graph->edge[6].src = 3;\r\n    graph->edge[6].dest = 1;\r\n    graph->edge[6].weight = 1;\r\n\r\n\r\n    graph->edge[7].src = 4;\r\n    graph->edge[7].dest = 3;\r\n    graph->edge[7].weight = -3;\r\n\r\n    BellmanFord(graph, 0);\r\n\r\n    return 0;\r\n}\r\n', 1000, '', '', 'Algorithm\r\nFollowing are the detailed steps.\r\n\r\nInput: Graph and a source vertex src\r\nOutput: Shortest distance to all vertices from src. If there is a negative weight cycle, then shortest distances are not calculated, negative weight cycle is reported.\r\n\r\n\r\n\r\n\r\n1) This step initializes distances from source to all vertices as infinite and distance to source itself as 0. Create an array dist[] of size |V| with all values as infinite except dist[src] where src is source vertex.\r\n\r\n2) This step calculates shortest distances. Do following |V|-1 times where |V| is the number of vertices in given graph.\r\n…..a) Do following for each edge u-v\r\n………………If dist[v] > dist[u] + weight of edge uv, then update dist[v]\r\n………………….dist[v] = dist[u] + weight of edge uv\r\n\r\n3) This step reports if there is a negative weight cycle in graph. Do following for each edge u-v\r\n……If dist[v] > dist[u] + weight of edge uv, then “Graph contains negative weight cycle”\r\nThe idea of step 3 is, step 2 guarantees shortest distances if graph doesn’t contain negative weight cycle. If we iterate through all edges one more time and get a shorter path for any vertex, then there is a negative weight cycle', '2020-05-25'),
(627, 15, 7401012018, '#include<iostream>\r\nusing namespace std;\r\n\r\nint matrix_chain(int array[], int n) {\r\n   int minMul[n][n];\r\n   for (int i=1; i<n; i++)\r\n      minMul[i][i] = 0;\r\n\r\n   for (int length=2; length<n; length++) {\r\n      for (int i=1; i<n-length+1; i++) {\r\n         int j = i+length-1;\r\n         minMul[i][j] = INT_MAX;\r\n         for (int k=i; k<=j-1; k++) {\r\n            int q = minMul[i][k] + minMul[k+1][j] + array[i- 1]*array[k]*array[j];\r\n            if (q < minMul[i][j])\r\n               minMul[i][j] = q;\r\n         }\r\n        }\r\n   }\r\n   return minMul[1][n-1];\r\n}\r\n\r\nint main() {\r\n    int n;\r\n    cin>>n;\r\n    int arr[n];\r\n    for(int i=0;i<n;i++){\r\n        cin>>arr[i];\r\n    }\r\n   cout <<matrix_chain(arr, n);\r\n}\r\n', 1000, '', '', 'Algorithm of Matrix Chain Multiplication\r\nMATRIX-CHAIN-ORDER (p)\r\n\r\n\r\n 1. n   length[p]-1\r\n 2. for i ← 1 to n\r\n 3. do m [i, i] ← 0\r\n 4. for l ← 2 to n    // l is the chain length\r\n 5. do for i ← 1 to n-l + 1\r\n 6. do j ← i+ l -1\r\n 7. m[i,j] ←  ∞\r\n 8. for k  ← i to j-1\r\n 9. do q  ← m [i, k] + m [k + 1, j] + pi-1 pk pj	\r\n 10. If q < m [i,j]\r\n 11. then m [i,j] ← q\r\n 12. s [i,j] ← k\r\n 13. return m and s.  ', '2020-05-25'),
(628, 4, 7401012018, '?? \0\r\0\n\0#\0i\0n\0c\0l\0u\0d\0e\0<\0b\0i\0t\0s\0/\0s\0t\0d\0c\0+\0+\0.\0h\0>\0 \0\r\0\n\0u\0s\0i\0n\0g\0 \0n\0a\0m\0e\0s\0p\0a\0c\0e\0 \0s\0t\0d\0;\0 \0\r\0\n\0\r\0\n\0i\0n\0t\0 \0m\0i\0n\0i\0m\0a\0x\0(\0i\0n\0t\0 \0d\0e\0p\0t\0h\0,\0 \0i\0n\0t\0 \0n\0o\0d\0e\0I\0n\0d\0e\0x\0,\0 \0b\0o\0o\0l\0 \0i\0s\0M\0a\0x\0,\0 \0\r\0\n\0	\0	\0	\0i\0n\0t\0 \0s\0c\0o\0r\0e\0s\0[\0]\0,\0 \0i\0n\0t\0 \0h\0)\0 \0\r\0\n\0{\0 \0\r\0\n\0	\0/\0/\0 \0T\0e\0r\0m\0i\0n\0a\0t\0i\0n\0g\0 \0c\0o\0n\0d\0i\0t\0i\0o\0n\0.\0 \0i\0.\0e\0 \0\r\0\n\0	\0/\0/\0 \0l\0e\0a\0f\0 \0n\0o\0d\0e\0 \0i\0s\0 \0r\0e\0a\0c\0h\0e\0d\0 \0\r\0\n\0	\0i\0f\0 \0(\0d\0e\0p\0t\0h\0 \0=\0=\0 \0h\0)\0 \0\r\0\n\0	\0	\0r\0e\0t\0u\0r\0n\0 \0s\0c\0o\0r\0e\0s\0[\0n\0o\0d\0e\0I\0n\0d\0e\0x\0]\0;\0 \0\r\0\n\0\r\0\n\0	\0/\0/\0 \0I\0f\0 \0c\0u\0r\0r\0e\0n\0t\0 \0m\0o\0v\0e\0 \0i\0s\0 \0m\0a\0x\0i\0m\0i\0z\0e\0r\0,\0 \0\r\0\n\0	\0/\0/\0 \0f\0i\0n\0d\0 \0t\0h\0e\0 \0m\0a\0x\0i\0m\0u\0m\0 \0a\0t\0t\0a\0i\0n\0a\0b\0l\0e\0 \0\r\0\n\0	\0/\0/\0 \0v\0a\0l\0u\0e\0 \0\r\0\n\0	\0i\0f\0 \0(\0i\0s\0M\0a\0x\0)\0 \0\r\0\n\0	\0r\0e\0t\0u\0r\0n\0 \0m\0a\0x\0(\0m\0i\0n\0i\0m\0a\0x\0(\0d\0e\0p\0t\0h\0+\01\0,\0 \0n\0o\0d\0e\0I\0n\0d\0e\0x\0*\02\0,\0 \0f\0a\0l\0s\0e\0,\0 \0s\0c\0o\0r\0e\0s\0,\0 \0h\0)\0,\0 \0\r\0\n\0	\0	\0	\0m\0i\0n\0i\0m\0a\0x\0(\0d\0e\0p\0t\0h\0+\01\0,\0 \0n\0o\0d\0e\0I\0n\0d\0e\0x\0*\02\0 \0+\0 \01\0,\0 \0f\0a\0l\0s\0e\0,\0 \0s\0c\0o\0r\0e\0s\0,\0 \0h\0)\0)\0;\0 \0\r\0\n\0\r\0\n\0	\0/\0/\0 \0E\0l\0s\0e\0 \0(\0I\0f\0 \0c\0u\0r\0r\0e\0n\0t\0 \0m\0o\0v\0e\0 \0i\0s\0 \0M\0i\0n\0i\0m\0i\0z\0e\0r\0)\0,\0 \0f\0i\0n\0d\0 \0t\0h\0e\0 \0m\0i\0n\0i\0m\0u\0m\0 \0\r\0\n\0	\0/\0/\0 \0a\0t\0t\0a\0i\0n\0a\0b\0l\0e\0 \0v\0a\0l\0u\0e\0 \0\r\0\n\0	\0e\0l\0s\0e\0\r\0\n\0	\0	\0r\0e\0t\0u\0r\0n\0 \0m\0i\0n\0(\0m\0i\0n\0i\0m\0a\0x\0(\0d\0e\0p\0t\0h\0+\01\0,\0 \0n\0o\0d\0e\0I\0n\0d\0e\0x\0*\02\0,\0 \0t\0r\0u\0e\0,\0 \0s\0c\0o\0r\0e\0s\0,\0 \0h\0)\0,\0 \0\r\0\n\0	\0	\0	\0m\0i\0n\0i\0m\0a\0x\0(\0d\0e\0p\0t\0h\0+\01\0,\0 \0n\0o\0d\0e\0I\0n\0d\0e\0x\0*\02\0 \0+\0 \01\0,\0 \0t\0r\0u\0e\0,\0 \0s\0c\0o\0r\0e\0s\0,\0 \0h\0)\0)\0;\0 \0\r\0\n\0}\0 \0\r\0\n\0\r\0\n\0/\0/\0 \0A\0 \0u\0t\0i\0l\0i\0t\0y\0 \0f\0u\0n\0c\0t\0i\0o\0n\0 \0t\0o\0 \0f\0i\0n\0d\0 \0L\0o\0g\0 \0n\0 \0i\0n\0 \0b\0a\0s\0e\0 \02\0 \0\r\0\n\0i\0n\0t\0 \0l\0o\0g\02\0(\0i\0n\0t\0 \0n\0)\0 \0\r\0\n\0{\0 \0\r\0\n\0r\0e\0t\0u\0r\0n\0 \0(\0n\0=\0=\01\0)\0?\0 \00\0 \0:\0 \01\0 \0+\0 \0l\0o\0g\02\0(\0n\0/\02\0)\0;\0 \0\r\0\n\0}\0 \0\r\0\n\0\r\0\n\0/\0/\0 \0D\0r\0i\0v\0e\0r\0 \0c\0o\0d\0e\0 \0\r\0\n\0i\0n\0t\0 \0m\0a\0i\0n\0(\0)\0 \0\r\0\n\0{\0 \0\r\0\n\0	\0/\0/\0 \0T\0h\0e\0 \0n\0u\0m\0b\0e\0r\0 \0o\0f\0 \0e\0l\0e\0m\0e\0n\0t\0s\0 \0i\0n\0 \0s\0c\0o\0r\0e\0s\0 \0m\0u\0s\0t\0 \0b\0e\0 \0\r\0\n\0	\0/\0/\0 \0a\0 \0p\0o\0w\0e\0r\0 \0o\0f\0 \02\0.\0 \0\r\0\n\0	\0i\0n\0t\0 \0s\0c\0o\0r\0e\0s\0[\0]\0 \0=\0 \0{\03\0,\0 \05\0,\0 \02\0,\0 \09\0,\0 \01\02\0,\0 \05\0,\0 \02\03\0,\0 \02\03\0}\0;\0 \0\r\0\n\0	\0i\0n\0t\0 \0n\0 \0=\0 \0s\0i\0z\0e\0o\0f\0(\0s\0c\0o\0r\0e\0s\0)\0/\0s\0i\0z\0e\0o\0f\0(\0s\0c\0o\0r\0e\0s\0[\00\0]\0)\0;\0 \0\r\0\n\0	\0i\0n\0t\0 \0h\0 \0=\0 \0l\0o\0g\02\0(\0n\0)\0;\0 \0\r\0\n\0	\0i\0n\0t\0 \0r\0e\0s\0 \0=\0 \0m\0i\0n\0i\0m\0a\0x\0(\00\0,\0 \00\0,\0 \0t\0r\0u\0e\0,\0 \0s\0c\0o\0r\0e\0s\0,\0 \0h\0)\0;\0 \0\r\0\n\0	\0c\0o\0u\0t\0 \0<\0<\0 \0\"\0T\0h\0e\0 \0o\0p\0t\0i\0m\0a\0l\0 \0v\0a\0l\0u\0e\0 \0i\0s\0 \0:\0 \0\"\0 \0<\0<\0 \0r\0e\0s\0 \0<\0<\0 \0e\0n\0d\0l\0;\0 \0\r\0\n\0	\0r\0e\0t\0u\0r\0n\0 \00\0;\0 \0\r\0\n\0}\0 \0\r\0\n\0', 0, '6 1000 11 445 1 330 3000', '', 'Algorithm: Max-Min-Element (numbers[]) \r\nmax := numbers[1] \r\nmin := numbers[1] \r\n\r\nfor i = 2 to n do \r\n   if numbers[i] > max then  \r\n      max := numbers[i] \r\n   if numbers[i] < min then  \r\n      min := numbers[i] \r\nreturn (max, min) ', '2020-05-25'),
(629, 8, 7401012018, '// CPP program to implement Strassen’s Matrix  \r\n// Multiplication Algorithm  \r\n#include<iostream>\r\n#include<conio.h>\r\n#include<stdio.h>\r\nusing namespace std; \r\ntypedef long long lld; \r\ninline lld** MatrixMultiply(lld** a, lld** b, int n, \r\n                                      int l, int m) \r\n{ \r\n    lld** c = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        c[i] = new lld[m]; \r\n  \r\n    for (int i = 0; i < n; i++) { \r\n        for (int j = 0; j < m; j++) { \r\n            c[i][j] = 0; \r\n            for (int k = 0; k < l; k++) { \r\n                c[i][j] += a[i][k] * b[k][j]; \r\n            } \r\n        } \r\n    } \r\n    return c; \r\n} \r\n  \r\ninline lld** Strassen(lld** a, lld** b, int n,  \r\n                                int l, int m) \r\n{ \r\n    if (n == 1 || l == 1 || m == 1)  \r\n        return MatrixMultiply(a, b, n, l, m); \r\n  \r\n    lld** c = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        c[i] = new lld[m]; \r\n  \r\n    int adjN = (n >> 1) + (n & 1); \r\n    int adjL = (l >> 1) + (l & 1); \r\n    int adjM = (m >> 1) + (m & 1); \r\n  \r\n    lld**** As = new lld***[2]; \r\n    for (int x = 0; x < 2; x++) { \r\n        As[x] = new lld**[2]; \r\n        for (int y = 0; y < 2; y++) { \r\n            As[x][y] = new lld*[adjN]; \r\n            for (int i = 0; i < adjN; i++) { \r\n                As[x][y][i] = new lld[adjL]; \r\n                for (int j = 0; j < adjL; j++) { \r\n                    int I = i + (x & 1) * adjN; \r\n                    int J = j + (y & 1) * adjL; \r\n                    As[x][y][i][j] = (I < n && J < l) ? a[I][J] : 0; \r\n                } \r\n            } \r\n        } \r\n    } \r\n  \r\n    lld**** Bs = new lld***[2]; \r\n    for (int x = 0; x < 2; x++) { \r\n        Bs[x] = new lld**[2]; \r\n        for (int y = 0; y < 2; y++) { \r\n            Bs[x][y] = new lld*[adjN]; \r\n            for (int i = 0; i < adjL; i++) { \r\n                Bs[x][y][i] = new lld[adjM]; \r\n                for (int j = 0; j < adjM; j++) { \r\n                    int I = i + (x & 1) * adjL; \r\n                    int J = j + (y & 1) * adjM; \r\n                    Bs[x][y][i][j] = (I < l && J < m) ? b[I][J] : 0; \r\n                } \r\n            } \r\n        } \r\n    } \r\n  \r\n    lld*** s = new lld**[10]; \r\n    for (int i = 0; i < 10; i++) { \r\n        switch (i) { \r\n        case 0: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][1][j][k] - Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 1: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] + As[0][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 2: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[1][0][j][k] + As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 3: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[1][0][j][k] - Bs[0][0][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 4: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] + As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 5: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 6: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][1][j][k] - As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 7: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[1][0][j][k] + Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 8: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] - As[1][0][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 9: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[0][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        } \r\n    } \r\n  \r\n    lld*** p = new lld**[7]; \r\n    p[0] = Strassen(As[0][0], s[0], adjN, adjL, adjM); \r\n    p[1] = Strassen(s[1], Bs[1][1], adjN, adjL, adjM); \r\n    p[2] = Strassen(s[2], Bs[0][0], adjN, adjL, adjM); \r\n    p[3] = Strassen(As[1][1], s[3], adjN, adjL, adjM); \r\n    p[4] = Strassen(s[4], s[5], adjN, adjL, adjM); \r\n    p[5] = Strassen(s[6], s[7], adjN, adjL, adjM); \r\n    p[6] = Strassen(s[8], s[9], adjN, adjL, adjM); \r\n  \r\n    for (int i = 0; i < adjN; i++) { \r\n        for (int j = 0; j < adjM; j++) { \r\n            c[i][j] = p[4][i][j] + p[3][i][j] - p[1][i][j] + p[5][i][j]; \r\n            if (j + adjM < m) \r\n                c[i][j + adjM] = p[0][i][j] + p[1][i][j]; \r\n            if (i + adjN < n) \r\n                c[i + adjN][j] = p[2][i][j] + p[3][i][j]; \r\n            if (i + adjN < n && j + adjM < m) \r\n                c[i + adjN][j + adjM] = p[4][i][j] + p[0][i][j] - p[2][i][j] - p[6][i][j]; \r\n        } \r\n    } \r\n  \r\n    for (int x = 0; x < 2; x++) { \r\n        for (int y = 0; y < 2; y++) { \r\n            for (int i = 0; i < adjN; i++) { \r\n                delete[] As[x][y][i]; \r\n            } \r\n            delete[] As[x][y]; \r\n        } \r\n        delete[] As[x]; \r\n    } \r\n    delete[] As; \r\n  \r\n    for (int x = 0; x < 2; x++) { \r\n        for (int y = 0; y < 2; y++) { \r\n            for (int i = 0; i < adjL; i++) { \r\n                delete[] Bs[x][y][i]; \r\n            } \r\n            delete[] Bs[x][y]; \r\n        } \r\n        delete[] Bs[x]; \r\n    } \r\n    delete[] Bs; \r\n  \r\n    for (int i = 0; i < 10; i++) { \r\n        switch (i) { \r\n        case 0: \r\n        case 3: \r\n        case 5: \r\n        case 7: \r\n        case 9: \r\n            for (int j = 0; j < adjL; j++) { \r\n                delete[] s[i][j]; \r\n            } \r\n            break; \r\n        case 1: \r\n        case 2: \r\n        case 4: \r\n        case 6: \r\n        case 8: \r\n            for (int j = 0; j < adjN; j++) { \r\n                delete[] s[i][j]; \r\n            } \r\n            break; \r\n        } \r\n        delete[] s[i]; \r\n    } \r\n    delete[] s; \r\n  \r\n    for (int i = 0; i < 7; i++) { \r\n        for (int j = 0; j < (n >> 1); j++) { \r\n            delete[] p[i][j]; \r\n        } \r\n        delete[] p[i]; \r\n    } \r\n    delete[] p; \r\n  \r\n    return c; \r\n} \r\n  \r\nint main() \r\n{ \r\n    lld** matA; \r\n    matA = new lld*[2]; \r\n    for (int i = 0; i < 2; i++) \r\n        matA[i] = new lld[3]; \r\n    matA[0][0] = 1; \r\n    matA[0][1] = 2; \r\n    matA[0][2] = 3; \r\n    matA[1][0] = 4; \r\n    matA[1][1] = 5; \r\n    matA[1][2] = 6; \r\n  \r\n    lld** matB; \r\n    matB = new lld*[3]; \r\n    for (int i = 0; i < 3; i++) \r\n        matB[i] = new lld[2]; \r\n    matB[0][0] = 7; \r\n    matB[0][1] = 8; \r\n    matB[1][0] = 9; \r\n    matB[1][1] = 10; \r\n    matB[2][0] = 11; \r\n    matB[2][1] = 12; \r\n  \r\n    lld** matC = Strassen(matA, matB, 2, 3, 2); \r\n    for (int i = 0; i < 2; i++) { \r\n        for (int j = 0; j < 2; j++) { \r\n            printf(\"%lld \", matC[i][j]); \r\n        } \r\n        printf(\"\n\"); \r\n    } \r\n  \r\n    return 0; \r\n} ', 0, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '', 'void multiply(int A[][N], int B[][N], int C[][N]) \r\n{ \r\n    for (int i = 0; i < N; i++) \r\n    { \r\n        for (int j = 0; j < N; j++) \r\n        { \r\n            C[i][j] = 0; \r\n            for (int k = 0; k < N; k++) \r\n            { \r\n                C[i][j] += A[i][k]*B[k][j]; \r\n            } \r\n        } \r\n    } \r\n} ', '2020-05-25');
INSERT INTO `qtos_map` (`ID`, `Q_ID`, `ROLL`, `SUBMISSION`, `SCORE`, `INPUT`, `OP`, `ALGO`, `DATE`) VALUES
(630, 5, 7401012018, '#include<iostream>\r\n#include<conio.h>\r\n#include<stdio.h>\r\nusing namespace std; \r\ntypedef long long lld; \r\ninline lld** MatrixMultiply(lld** a, lld** b, int n, \r\n                                      int l, int m) \r\n{ \r\n    lld** c = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        c[i] = new lld[m]; \r\n  \r\n    for (int i = 0; i < n; i++) { \r\n        for (int j = 0; j < m; j++) { \r\n            c[i][j] = 0; \r\n            for (int k = 0; k < l; k++) { \r\n                c[i][j] += a[i][k] * b[k][j]; \r\n            } \r\n        } \r\n    } \r\n    return c; \r\n} \r\n  \r\ninline lld** Strassen(lld** a, lld** b, int n,  \r\n                                int l, int m) \r\n{ \r\n    if (n == 1 || l == 1 || m == 1)  \r\n        return MatrixMultiply(a, b, n, l, m); \r\n  \r\n    lld** c = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        c[i] = new lld[m]; \r\n  \r\n    int adjN = (n >> 1) + (n & 1); \r\n    int adjL = (l >> 1) + (l & 1); \r\n    int adjM = (m >> 1) + (m & 1); \r\n  \r\n    lld**** As = new lld***[2]; \r\n    for (int x = 0; x < 2; x++) { \r\n        As[x] = new lld**[2]; \r\n        for (int y = 0; y < 2; y++) { \r\n            As[x][y] = new lld*[adjN]; \r\n            for (int i = 0; i < adjN; i++) { \r\n                As[x][y][i] = new lld[adjL]; \r\n                for (int j = 0; j < adjL; j++) { \r\n                    int I = i + (x & 1) * adjN; \r\n                    int J = j + (y & 1) * adjL; \r\n                    As[x][y][i][j] = (I < n && J < l) ? a[I][J] : 0; \r\n                } \r\n            } \r\n        } \r\n    } \r\n  \r\n    lld**** Bs = new lld***[2]; \r\n    for (int x = 0; x < 2; x++) { \r\n        Bs[x] = new lld**[2]; \r\n        for (int y = 0; y < 2; y++) { \r\n            Bs[x][y] = new lld*[adjN]; \r\n            for (int i = 0; i < adjL; i++) { \r\n                Bs[x][y][i] = new lld[adjM]; \r\n                for (int j = 0; j < adjM; j++) { \r\n                    int I = i + (x & 1) * adjL; \r\n                    int J = j + (y & 1) * adjM; \r\n                    Bs[x][y][i][j] = (I < l && J < m) ? b[I][J] : 0; \r\n                } \r\n            } \r\n        } \r\n    } \r\n  \r\n    lld*** s = new lld**[10]; \r\n    for (int i = 0; i < 10; i++) { \r\n        switch (i) { \r\n        case 0: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][1][j][k] - Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 1: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] + As[0][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 2: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[1][0][j][k] + As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 3: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[1][0][j][k] - Bs[0][0][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 4: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] + As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 5: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 6: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][1][j][k] - As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 7: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[1][0][j][k] + Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 8: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] - As[1][0][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 9: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[0][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        } \r\n    } \r\n  \r\n    lld*** p = new lld**[7]; \r\n    p[0] = Strassen(As[0][0], s[0], adjN, adjL, adjM); \r\n    p[1] = Strassen(s[1], Bs[1][1], adjN, adjL, adjM); \r\n    p[2] = Strassen(s[2], Bs[0][0], adjN, adjL, adjM); \r\n    p[3] = Strassen(As[1][1], s[3], adjN, adjL, adjM); \r\n    p[4] = Strassen(s[4], s[5], adjN, adjL, adjM); \r\n    p[5] = Strassen(s[6], s[7], adjN, adjL, adjM); \r\n    p[6] = Strassen(s[8], s[9], adjN, adjL, adjM); \r\n  \r\n    for (int i = 0; i < adjN; i++) { \r\n        for (int j = 0; j < adjM; j++) { \r\n            c[i][j] = p[4][i][j] + p[3][i][j] - p[1][i][j] + p[5][i][j]; \r\n            if (j + adjM < m) \r\n                c[i][j + adjM] = p[0][i][j] + p[1][i][j]; \r\n            if (i + adjN < n) \r\n                c[i + adjN][j] = p[2][i][j] + p[3][i][j]; \r\n            if (i + adjN < n && j + adjM < m) \r\n                c[i + adjN][j + adjM] = p[4][i][j] + p[0][i][j] - p[2][i][j] - p[6][i][j]; \r\n        } \r\n    } \r\n  \r\n    for (int x = 0; x < 2; x++) { \r\n        for (int y = 0; y < 2; y++) { \r\n            for (int i = 0; i < adjN; i++) { \r\n                delete[] As[x][y][i]; \r\n            } \r\n            delete[] As[x][y]; \r\n        } \r\n        delete[] As[x]; \r\n    } \r\n    delete[] As; \r\n  \r\n    for (int x = 0; x < 2; x++) { \r\n        for (int y = 0; y < 2; y++) { \r\n            for (int i = 0; i < adjL; i++) { \r\n                delete[] Bs[x][y][i]; \r\n            } \r\n            delete[] Bs[x][y]; \r\n        } \r\n        delete[] Bs[x]; \r\n    } \r\n    delete[] Bs; \r\n  \r\n    for (int i = 0; i < 10; i++) { \r\n        switch (i) { \r\n        case 0: \r\n        case 3: \r\n        case 5: \r\n        case 7: \r\n        case 9: \r\n            for (int j = 0; j < adjL; j++) { \r\n                delete[] s[i][j]; \r\n            } \r\n            break; \r\n        case 1: \r\n        case 2: \r\n        case 4: \r\n        case 6: \r\n        case 8: \r\n            for (int j = 0; j < adjN; j++) { \r\n                delete[] s[i][j]; \r\n            } \r\n            break; \r\n        } \r\n        delete[] s[i]; \r\n    } \r\n    delete[] s; \r\n  \r\n    for (int i = 0; i < 7; i++) { \r\n        for (int j = 0; j < (n >> 1); j++) { \r\n            delete[] p[i][j]; \r\n        } \r\n        delete[] p[i]; \r\n    } \r\n    delete[] p; \r\n  \r\n    return c; \r\n} \r\n  \r\nint main() \r\n{ \r\n    lld** matA; \r\n    matA = new lld*[2]; \r\n    for (int i = 0; i < 2; i++) \r\n        matA[i] = new lld[3]; \r\n    matA[0][0] = 1; \r\n    matA[0][1] = 2; \r\n    matA[0][2] = 3; \r\n    matA[1][0] = 4; \r\n    matA[1][1] = 5; \r\n    matA[1][2] = 6; \r\n  \r\n    lld** matB; \r\n    matB = new lld*[3]; \r\n    for (int i = 0; i < 3; i++) \r\n        matB[i] = new lld[2]; \r\n    matB[0][0] = 7; \r\n    matB[0][1] = 8; \r\n    matB[1][0] = 9; \r\n    matB[1][1] = 10; \r\n    matB[2][0] = 11; \r\n    matB[2][1] = 12; \r\n  \r\n    lld** matC = Strassen(matA, matB, 2, 3, 2); \r\n    for (int i = 0; i < 2; i++) { \r\n        for (int j = 0; j < 2; j++) { \r\n            printf(\"%lld \", matC[i][j]); \r\n        } \r\n        printf(\"\n\"); \r\n    } \r\n  \r\n    return 0; \r\n', 1000, '', '', 'void multiply(int A[][N], int B[][N], int C[][N]) \r\n{ \r\n    for (int i = 0; i < N; i++) \r\n    { \r\n        for (int j = 0; j < N; j++) \r\n        { \r\n            C[i][j] = 0; \r\n            for (int k = 0; k < N; k++) \r\n            { \r\n                C[i][j] += A[i][k]*B[k][j]; \r\n            } \r\n        } \r\n    } \r\n} ', '2020-05-25'),
(631, 16, 7401012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n\r\n#define d 256 \r\n\r\nvoid search(char pat[], char txt[], int q) \r\n{ \r\n	int M = strlen(pat); \r\n	int N = strlen(txt); \r\n	int i, j; \r\n	int p = 0; \r\n	int t = 0; \r\n	int h = 1; \r\n\r\n	for (i = 0; i < M - 1; i++) \r\n		h = (h * d) % q; \r\n\r\n	for (i = 0; i < M; i++) \r\n	{ \r\n		p = (d * p + pat[i]) % q; \r\n		t = (d * t + txt[i]) % q; \r\n	} \r\n\r\n	for (i = 0; i <= N - M; i++) \r\n	{ \r\n\r\n		if ( p == t ) \r\n		{ \r\n			for (j = 0; j < M; j++) \r\n			{ \r\n				if (txt[i+j] != pat[j]) \r\n					break; \r\n			} \r\n\r\n			if (j == M) \r\n				cout<<\"Pattern found at index\"<<\" \"<<i<<\" \"; \r\n		} \r\n\r\n		if ( i < N-M ) \r\n		{ \r\n			t = (d*(t - txt[i]*h) + txt[i+M])%q; \r\n\r\n			if (t < 0) \r\n			t = (t + q); \r\n		} \r\n	} \r\n} \r\n\r\nint main() \r\n{ \r\n	char txt[101]; \r\n	char pat[101]; \r\n	cin >> txt >> pat;\r\n	int q = 101; \r\n	search(pat, txt, q); \r\n	return 0; \r\n} \r\n\r\n', 1000, '', '', 'function RabinKarp(string s[1..n], string pattern[1..m])\r\n    hpattern := hash(pattern[1..m]);\r\n    for i from 1 to n-m+1\r\n        hs := hash(s[i..i+m-1])\r\n        if hs = hpattern\r\n            if s[i..i+m-1] = pattern[1..m]\r\n                return i\r\n    return not found', '2020-05-25'),
(632, 7, 7501012018, '#include<iostream>\r\n#include<stdio.h>\r\nusing namespace std; \r\ntypedef long long lld; \r\ninline lld** MatrixMultiply(lld** a, lld** b, int n, \r\n                                      int l, int m) \r\n{ \r\n    lld** c = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        c[i] = new lld[m]; \r\n  \r\n    for (int i = 0; i < n; i++) { \r\n        for (int j = 0; j < m; j++) { \r\n            c[i][j] = 0; \r\n            for (int k = 0; k < l; k++) { \r\n                c[i][j] += a[i][k] * b[k][j]; \r\n            } \r\n        } \r\n    } \r\n    return c; \r\n} \r\n  \r\ninline lld** Strassen(lld** a, lld** b, int n,  \r\n                                int l, int m) \r\n{ \r\n    if (n == 1 || l == 1 || m == 1)  \r\n        return MatrixMultiply(a, b, n, l, m); \r\n  \r\n    lld** c = new lld*[n]; \r\n    for (int i = 0; i < n; i++) \r\n        c[i] = new lld[m]; \r\n  \r\n    int adjN = (n >> 1) + (n & 1); \r\n    int adjL = (l >> 1) + (l & 1); \r\n    int adjM = (m >> 1) + (m & 1); \r\n  \r\n    lld**** As = new lld***[2]; \r\n    for (int x = 0; x < 2; x++) { \r\n        As[x] = new lld**[2]; \r\n        for (int y = 0; y < 2; y++) { \r\n            As[x][y] = new lld*[adjN]; \r\n            for (int i = 0; i < adjN; i++) { \r\n                As[x][y][i] = new lld[adjL]; \r\n                for (int j = 0; j < adjL; j++) { \r\n                    int I = i + (x & 1) * adjN; \r\n                    int J = j + (y & 1) * adjL; \r\n                    As[x][y][i][j] = (I < n && J < l) ? a[I][J] : 0; \r\n                } \r\n            } \r\n        } \r\n    } \r\n  \r\n    lld**** Bs = new lld***[2]; \r\n    for (int x = 0; x < 2; x++) { \r\n        Bs[x] = new lld**[2]; \r\n        for (int y = 0; y < 2; y++) { \r\n            Bs[x][y] = new lld*[adjN]; \r\n            for (int i = 0; i < adjL; i++) { \r\n                Bs[x][y][i] = new lld[adjM]; \r\n                for (int j = 0; j < adjM; j++) { \r\n                    int I = i + (x & 1) * adjL; \r\n                    int J = j + (y & 1) * adjM; \r\n                    Bs[x][y][i][j] = (I < l && J < m) ? b[I][J] : 0; \r\n                } \r\n            } \r\n        } \r\n    } \r\n  \r\n    lld*** s = new lld**[10]; \r\n    for (int i = 0; i < 10; i++) { \r\n        switch (i) { \r\n        case 0: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][1][j][k] - Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 1: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] + As[0][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 2: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[1][0][j][k] + As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 3: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[1][0][j][k] - Bs[0][0][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 4: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] + As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 5: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 6: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][1][j][k] - As[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 7: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[1][0][j][k] + Bs[1][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 8: \r\n            s[i] = new lld*[adjN]; \r\n            for (int j = 0; j < adjN; j++) { \r\n                s[i][j] = new lld[adjL]; \r\n                for (int k = 0; k < adjL; k++) { \r\n                    s[i][j][k] = As[0][0][j][k] - As[1][0][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        case 9: \r\n            s[i] = new lld*[adjL]; \r\n            for (int j = 0; j < adjL; j++) { \r\n                s[i][j] = new lld[adjM]; \r\n                for (int k = 0; k < adjM; k++) { \r\n                    s[i][j][k] = Bs[0][0][j][k] + Bs[0][1][j][k]; \r\n                } \r\n            } \r\n            break; \r\n        } \r\n    } \r\n  \r\n    lld*** p = new lld**[7]; \r\n    p[0] = Strassen(As[0][0], s[0], adjN, adjL, adjM); \r\n    p[1] = Strassen(s[1], Bs[1][1], adjN, adjL, adjM); \r\n    p[2] = Strassen(s[2], Bs[0][0], adjN, adjL, adjM); \r\n    p[3] = Strassen(As[1][1], s[3], adjN, adjL, adjM); \r\n    p[4] = Strassen(s[4], s[5], adjN, adjL, adjM); \r\n    p[5] = Strassen(s[6], s[7], adjN, adjL, adjM); \r\n    p[6] = Strassen(s[8], s[9], adjN, adjL, adjM); \r\n  \r\n    for (int i = 0; i < adjN; i++) { \r\n        for (int j = 0; j < adjM; j++) { \r\n            c[i][j] = p[4][i][j] + p[3][i][j] - p[1][i][j] + p[5][i][j]; \r\n            if (j + adjM < m) \r\n                c[i][j + adjM] = p[0][i][j] + p[1][i][j]; \r\n            if (i + adjN < n) \r\n                c[i + adjN][j] = p[2][i][j] + p[3][i][j]; \r\n            if (i + adjN < n && j + adjM < m) \r\n                c[i + adjN][j + adjM] = p[4][i][j] + p[0][i][j] - p[2][i][j] - p[6][i][j]; \r\n        } \r\n    } \r\n  \r\n    for (int x = 0; x < 2; x++) { \r\n        for (int y = 0; y < 2; y++) { \r\n            for (int i = 0; i < adjN; i++) { \r\n                delete[] As[x][y][i]; \r\n            } \r\n            delete[] As[x][y]; \r\n        } \r\n        delete[] As[x]; \r\n    } \r\n    delete[] As; \r\n  \r\n    for (int x = 0; x < 2; x++) { \r\n        for (int y = 0; y < 2; y++) { \r\n            for (int i = 0; i < adjL; i++) { \r\n                delete[] Bs[x][y][i]; \r\n            } \r\n            delete[] Bs[x][y]; \r\n        } \r\n        delete[] Bs[x]; \r\n    } \r\n    delete[] Bs; \r\n  \r\n    for (int i = 0; i < 10; i++) { \r\n        switch (i) { \r\n        case 0: \r\n        case 3: \r\n        case 5: \r\n        case 7: \r\n        case 9: \r\n            for (int j = 0; j < adjL; j++) { \r\n                delete[] s[i][j]; \r\n            } \r\n            break; \r\n        case 1: \r\n        case 2: \r\n        case 4: \r\n        case 6: \r\n        case 8: \r\n            for (int j = 0; j < adjN; j++) { \r\n                delete[] s[i][j]; \r\n            } \r\n            break; \r\n        } \r\n        delete[] s[i]; \r\n    } \r\n    delete[] s; \r\n  \r\n    for (int i = 0; i < 7; i++) { \r\n        for (int j = 0; j < (n >> 1); j++) { \r\n            delete[] p[i][j]; \r\n        } \r\n        delete[] p[i]; \r\n    } \r\n    delete[] p; \r\n  \r\n    return c; \r\n} \r\n  \r\nint main() \r\n{ \r\n    lld** matA; \r\n    matA = new lld*[3]; \r\n    for (int i = 0; i < 3; i++) \r\n        matA[i] = new lld[3]; \r\n    matA[0][0] = 1; \r\n    matA[0][1] = 0; \r\n    matA[0][2] = 0; \r\n    matA[1][0] = 0; \r\n    matA[1][1] = 1; \r\n    matA[1][2] = 0;\r\n    matA[2][0] = 0; \r\n    matA[2][1] = 0; \r\n    matA[2][2] = 1;\r\n    \r\n    \r\n  \r\n    lld** matB; \r\n    matB = new lld*[3]; \r\n    for (int i = 0; i < 3; i++) \r\n        matB[i] = new lld[3]; \r\n    matB[0][0] = 1; \r\n    matB[0][1] = 0; \r\n    matB[0][2] = 0; \r\n    matB[1][0] = 0; \r\n    matB[1][1] = 1; \r\n    matB[1][2] = 0;\r\n    matB[2][0] = 0; \r\n    matB[2][1] = 0; \r\n    matB[2][2] = 1;\r\n  \r\n    lld** matC = Strassen(matA, matB, 3, 3, 3); \r\n    for (int i = 0; i < 3; i++) { \r\n        for (int j = 0; j < 3; j++) { \r\n            printf(\"%lld \", matC[i][j]); \r\n        }\r\n    } \r\n  \r\n    return 0; \r\n} ', 0, '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '', 'function Strassen(M,N)\r\nif M is 1 ? 1 then\r\nreturn M11N11\r\nend if\r\nLet M =  A B\r\n         C D \r\nand N =  E F\r\n         G H \r\nSet S1 = Strassen(B - D, G + H)\r\nSet S2 = Strassen(A + D, E + H)\r\nSet S3 = Strassen(A - C, E + F)\r\nSet S4 = Strassen(A + B, H)\r\nSet S5 = Strassen(A, F - H)\r\nSet S6 = Strassen(D, G - E)\r\nSet S7 = Strassen(C + D, E)\r\nreturn (\r\nS1 + S2 - S4 + S6    S4 + S5\r\nS6 + S7              S2 - S3 + S5 - S7\r\n)\r\nend function\r\n', '2020-05-25'),
(633, 9, 7501012018, '#include <iostream> \nusing namespace std; \nclass DisjSet { \n	int *rank, *parent, n; \n\npublic: \n	DisjSet(int n) \n	{ \n		rank = new int[n]; \n		parent = new int[n]; \n		this->n = n; \n		makeSet(); \n	} \n\n	void makeSet() \n	{ \n		for (int i = 0; i < n; i++) { \n			parent[i] = i; \n		} \n	} \n\n	int find(int x) \n	{ \n		if (parent[x] != x) { \n			parent[x] = find(parent[x]); \n		} \n\n		return parent[x]; \n	} \n\n\n	void Union(int x, int y) \n	{ \n		int xset = find(x); \n		int yset = find(y); \n\n		if (xset == yset) \n			return; \n\n		if (rank[xset] < rank[yset]) { \n			parent[xset] = yset; \n		} \n		else if (rank[xset] > rank[yset]) { \n			parent[yset] = xset; \n		} \n\n		else { \n			parent[yset] = xset; \n			rank[xset] = rank[xset] + 1; \n		} \n	} \n}; \n\nint main() \n{ \n    \n	DisjSet obj(6);\n	\n	obj.Union(4,5);\n	obj.Union(0, 2); \n	obj.Union(5, 3); \n	obj.Union(3, 1); \n	if (obj.find(4) == obj.find(5)) \n		cout << \"Yes\n\"; \n	else\n		cout << \"No\n\"; \n	if (obj.find(1) == obj.find(3)) \n		cout << \"Yes\n\"; \n	else\n		cout << \"No\n\"; \n\n	return 0; \n} \n\n', 1000, '', '', 'function MakeSet(x)\r\n   x.parent = x\r\n\r\nfunction Find(x)\r\n   if x.parent == x\r\n      return x\r\n   else\r\n      return Find(x.parent)\r\n\r\nfunction Union(x,y)\r\n   xRoot = Find(x)\r\n   yRoot = Find(y)\r\n   xRoot.parent = yRoot', '2020-05-25'),
(634, 13, 7501012018, '#include <bits/stdc++.h> \r\nusing namespace std; \r\n\r\nint minKey(int V,int key[], bool mstSet[]) \r\n{ \r\n	int min = INT_MAX, min_index; \r\n	for (int v = 1; v <= V; v++) \r\n		if (mstSet[v] == false && key[v] < min) \r\n			min = key[v], min_index = v; \r\n\r\n	return min_index; \r\n} \r\n\r\n\r\nvoid printMST(int V,int parent[], int graph[100][100]) \r\n{ \r\n	 \r\n	int sum=0;\r\n	for (int i = 1; i <= V; i++) \r\n	{sum+=graph[i][parent[i]];\r\n		 }\r\n		cout<<sum<<endl;\r\n} \r\n\r\n\r\nvoid primMST(int V,int graph[100][100]) \r\n{ \r\n	 \r\n	int parent[V+1]; \r\n	int key[V+1]; \r\n	bool mstSet[V+1]; \r\n\r\n	for (int i = 1; i <= V; i++) \r\n		key[i] = INT_MAX, mstSet[i] = false; \r\n\r\n	key[1] = 0; \r\n	parent[1] = -1;  \r\n	for (int count = 1; count < V; count++) \r\n	{ \r\n		int u = minKey(V,key, mstSet);\r\n		mstSet[u] = true; \r\n		for (int v = 1; v <= V; v++) \r\n			if (graph[u][v] && mstSet[v] == false && graph[u][v] < key[v]) \r\n				parent[v] = u, key[v] = graph[u][v]; \r\n	} \r\n	printMST( V,parent, graph); \r\n} \r\n\r\n\r\nint main() \r\n{ \r\n	\r\nint V,E;\r\ncin>>V;\r\ncin>>E;\r\n\r\nint graph[100][100];\r\n	\r\n      for(int i=0;i<=V;i++)\r\n       for(int j=0;j<=V;j++)\r\n        {\r\n        graph[i][j]=0;\r\n       }\r\n       int a,b,w;\r\n      for(int i=0;i<E;i++)\r\n       {\r\n       cin>>a>>b>>w;\r\n       graph[a][b]=w;\r\n       graph[b][a]=w;\r\n       }\r\n	primMST(V,graph); \r\n\r\n	return 0; \r\n} ', 1000, '', '', '﻿1. Associate with each vertex v of the graph a number C[v] (the cheapest cost of a connection to v) and an edge E[v] (the edge providing that cheapest connection). To initialize these values, set all values of C[v] to +∞ (or to any number larger than the maximum edge weight) and set each E[v] to a special flag value indicating that there is no edge connecting v to earlier vertices.\r\n2. Initialize an empty forest F and a set Q of vertices that have not yet been included in F (initially, all vertices).\r\n3. Repeat the following steps until Q is empty:\r\n   1. Find and remove a vertex v from Q having the minimum possible value of C[v]\r\n   2. Add v to F and, if E[v] is not the special flag value, also add E[v] to F\r\n   3. Loop over the edges vw connecting v to other vertices w. For each such edge, if w still belongs to Q and vw has smaller weight than C[w], perform the following steps:\r\n      1. Set C[w] to the cost of edge vw\r\n      2. Set E[w] to point to edge vw.\r\n4. Return F', '2020-05-25'),
(635, 14, 7501012018, '﻿#include <bits/stdc++.h>\r\nstruct Edge {\r\n    int src, dest, weight;\r\n};\r\nstruct Graph {\r\n       int V, E;\r\n      struct Edge* edge;\r\n};\r\nstruct Graph* createGraph(int V, int E)\r\n{\r\n    struct Graph* graph = new Graph;\r\n    graph->V = V;\r\n    graph->E = E;\r\n    graph->edge = new Edge[E];\r\n    return graph;\r\n}\r\nvoid printArr(int dist[], int n)\r\n{\r\n    printf(\"Vertex   Distance from Source\n\");\r\n    for (int i = 0; i < n; ++i)\r\n        printf(\"%d 		 %d\n\", i, dist[i]);\r\n}\r\nvoid BellmanFord(struct Graph* graph, int src)\r\n{\r\n    int V = graph->V;\r\n    int E = graph->E;\r\n    int dist[V];\r\n      for (int i = 0; i < V; i++)\r\n        dist[i] = INT_MAX;\r\n    dist[src] = 0;\r\n      for (int i = 1; i <= V - 1; i++) {\r\n        for (int j = 0; j < E; j++) {\r\n            int u = graph->edge[j].src;\r\n            int v = graph->edge[j].dest;\r\n            int weight = graph->edge[j].weight;\r\n            if (dist[u] != INT_MAX && dist[u] + weight < dist[v])\r\n                dist[v] = dist[u] + weight;\r\n        }\r\n    }\r\n      for (int i = 0; i < E; i++) {\r\n        int u = graph->edge[i].src;\r\n        int v = graph->edge[i].dest;\r\n        int weight = graph->edge[i].weight;\r\n        if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {\r\n            printf(\"Graph contains negative weight cycle\");\r\n            return; // If negative cycle is detected, simply return\r\n        }\r\n    }\r\n    printArr(dist, V);\r\n    return;\r\n}\r\n  \r\nint main()\r\n{\r\n    int V = 5; // Number of vertices in graph\r\n    int E = 8; // Number of edges in graph\r\n    struct Graph* graph = createGraph(V, E);\r\n \r\n    graph->edge[0].src = 0;\r\n    graph->edge[0].dest = 1;\r\n    graph->edge[0].weight = -1;\r\n    graph->edge[1].src = 0;\r\n    graph->edge[1].dest = 2;\r\n    graph->edge[1].weight = 4;\r\n    graph->edge[2].src = 1;\r\n    graph->edge[2].dest = 2;\r\n    graph->edge[2].weight = 3;\r\n    graph->edge[3].src = 1;\r\n    graph->edge[3].dest = 3;\r\n    graph->edge[3].weight = 2;\r\n    graph->edge[4].src = 1;\r\n    graph->edge[4].dest = 4;\r\n    graph->edge[4].weight = 2;\r\n    graph->edge[5].src = 3;\r\n    graph->edge[5].dest = 2;\r\n    graph->edge[5].weight = 5;\r\n  \r\n \r\n    graph->edge[6].src = 3;\r\n    graph->edge[6].dest = 1;\r\n    graph->edge[6].weight = 1;\r\n    graph->edge[7].src = 4;\r\n    graph->edge[7].dest = 3;\r\n    graph->edge[7].weight = -3;\r\n  \r\n    BellmanFord(graph, 0);\r\n  \r\n    return 0;\r\n}', 1000, '', '', '﻿function BellmanFord(list vertices, list edges, vertex source) is\r\n    ::distance[], predecessor[]\r\n\r\n\r\n    // Step 1: initialize graph\r\n    for each vertex v in vertices do\r\n        distance[v] := inf             // Initialize the distance to all vertices to infinity\r\n        predecessor[v] := null         // And having a null predecessor\r\n    \r\n    distance[source] := 0              // The distance from the source to itself is, of course, zero\r\n    // Step 2: relax edges repeatedly\r\n    for i from 1 to size(vertices)−1 do //just |V|−1 repetitions; i is never referenced\r\n        for each edge (u, v) with weight w in edges do\r\n            if distance[u] + w < distance[v] then\r\n                distance[v] := distance[u] + w\r\n                predecessor[v] := u\r\n\r\n\r\n    // Step 3: check for negative-weight cycles\r\n    for each edge (u, v) with weight w in edges do\r\n        if distance[u] + w < distance[v] then\r\n            error \"Graph contains a negative-weight cycle\"\r\n\r\n\r\n    return distance[], predecessor[]', '2020-05-25'),
(636, 15, 7501012018, '#include<bits/stdc++.h>\r\nusing namespace std;\r\nint MatrixChainOrder(int p[], int n)\r\n{\r\n	int m[n][n];\r\n	int i, j, k, L, q;\r\n	for (i = 1; i < n; i++)\r\n    m[i][i] = 0;\r\n	for (L = 2; L < n; L++)\r\n	{\r\n		for (i = 1; i < n - L + 1; i++)\r\n		{\r\n			j = i + L - 1;\r\n			m[i][j] = INT_MAX;\r\n			for (k = i; k <= j - 1; k++)\r\n			{\r\n				q = m[i][k] + m[k + 1][j] +\r\n					p[i - 1] * p[k] * p[j];\r\n				if (q < m[i][j])\r\n					m[i][j] = q;\r\n			}\r\n		}\r\n	}\r\n	return m[1][n - 1];\r\n}\r\nint main()\r\n{\r\n    int n;\r\n    cin>>n;\r\n	int arr[n];\r\n	for(int i=0;i<n;i++)\r\n        cin>>arr[i];\r\n    cout<< MatrixChainOrder(arr,n);\r\n	return 0;\r\n}\r\n', 1000, '', '', '', '2020-05-25'),
(637, 4, 7501012018, '#include<stdio.h> \r\nstruct pair  \r\n{ \r\n  int min; \r\n  int max; \r\n};   \r\n  \r\nstruct pair getMinMax(int arr[], int low, int high) \r\n{ \r\n  struct pair minmax, mml, mmr;        \r\n  int mid; \r\n    \r\n  if (low == high) \r\n  { \r\n     minmax.max = arr[low]; \r\n     minmax.min = arr[low];      \r\n     return minmax; \r\n  }     \r\n    \r\n  if (high == low + 1) \r\n  {   \r\n     if (arr[low] > arr[high])   \r\n     { \r\n        minmax.max = arr[low]; \r\n        minmax.min = arr[high]; \r\n     }   \r\n     else\r\n     { \r\n        minmax.max = arr[high]; \r\n        minmax.min = arr[low]; \r\n     }   \r\n     return minmax; \r\n  } \r\n    \r\n  mid = (low + high)/2;   \r\n  mml = getMinMax(arr, low, mid); \r\n  mmr = getMinMax(arr, mid+1, high);   \r\n    \r\n  if (mml.min < mmr.min) \r\n    minmax.min = mml.min; \r\n  else\r\n    minmax.min = mmr.min;      \r\n  \r\n  if (mml.max > mmr.max) \r\n    minmax.max = mml.max; \r\n  else\r\n    minmax.max = mmr.max;      \r\n   \r\n  return minmax; \r\n} \r\n  \r\nint main() \r\n{ \r\n  int n=6;\r\n  int arr[n]={1, 5 ,7, 14, 19, 26};\r\n  struct pair minmax = getMinMax(arr, 0, n-1); \r\n  printf(\"\nMinimum element is %d\", minmax.min); \r\n  printf(\"\nMaximum element is %d\", minmax.max); \r\n  getchar(); \r\n}\r\n', 0, '6 1000 11 445 1 330 3000', '', 'Pair MaxMin(array, array_size)\r\n   if array_size = 1\r\n      return element as both max and min\r\n   else if arry_size = 2\r\n      one comparison to determine max and min\r\n      return that pair\r\n   else    /* array_size  > 2 */\r\n      recur for max and min of left half\r\n      recur for max and min of right half\r\n      one comparison determines true max of the two candidates\r\n      one comparison determines true min of the two candidates\r\n      return the pair of max and min', '2020-05-25'),
(638, 8, 7501012018, '#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint nextpowerof2(int k)\n{\n    return pow(2, int(ceil(log2(k))));\n}\nvoid display(vector< vector<int>> &matrix, int m, int n)\n{\n    for (int i = 0; i < m; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (j != 0)\n            {\n                cout << \" \";\n            }\n            cout << matrix[i][j];\n        }\n        cout << endl;\n    }\n}\n\nvoid add(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n    int i, j;\n\n    for (i = 0; i < size; i++)\n    {\n        for (j = 0; j < size; j++)\n        {\n            C[i][j] = A[i][j] + B[i][j];\n        }\n    }\n}\n\nvoid sub(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n    int i, j;\n\n    for (i = 0; i < size; i++)\n    {\n        for (j = 0; j < size; j++)\n        {\n            C[i][j] = A[i][j] - B[i][j];\n        }\n    }\n}\n\nvoid STRASSEN_algorithmA(vector<vector<int>> &A, vector<vector<int>> &B, vector<vector<int>> &C, int size)\n{\n   \n    if (size == 1)\n    {\n        C[0][0] = A[0][0] * B[0][0];\n        return;\n    }\n    else\n    {\n        int new_size = size / 2;\n        vector<int> z(new_size);\n        vector<vector<int>>\n            a11(new_size, z), a12(new_size, z), a21(new_size, z), a22(new_size, z),\n            b11(new_size, z), b12(new_size, z), b21(new_size, z), b22(new_size, z),\n            c11(new_size, z), c12(new_size, z), c21(new_size, z), c22(new_size, z),\n            p1(new_size, z), p2(new_size, z), p3(new_size, z), p4(new_size, z),\n            p5(new_size, z), p6(new_size, z), p7(new_size, z),\n            aResult(new_size, z), bResult(new_size, z);\n\nint i, j;\n\nfor (i = 0; i < new_size; i++)\n        {\n            for (j = 0; j < new_size; j++)\n            {\n                a11[i][j] = A[i][j];\n                a12[i][j] = A[i][j + new_size];\n                a21[i][j] = A[i + new_size][j];\n                a22[i][j] = A[i + new_size][j + new_size];\n\n                b11[i][j] = B[i][j];\n                b12[i][j] = B[i][j + new_size];\n                b21[i][j] = B[i + new_size][j];\n                b22[i][j] = B[i + new_size][j + new_size];\n            }\n}\n\n\n        add(a11, a22, aResult, new_size);    \n        add(b11, b22, bResult, new_size);    \n        STRASSEN_algorithmA(aResult, bResult, p1, new_size); \n\n        add(a21, a22, aResult, new_size); \n        STRASSEN_algorithmA(aResult, b11, p2, new_size);\n\n        sub(b12, b22, bResult, new_size);      \n        STRASSEN_algorithmA(a11, bResult, p3, new_size);\n\n        sub(b21, b11, bResult, new_size);     \n        STRASSEN_algorithmA(a22, bResult, p4, new_size); \n\n        add(a11, a12, aResult, new_size);     \n        STRASSEN_algorithmA(aResult, b22, p5, new_size);\n\n        sub(a21, a11, aResult, new_size);      \n        add(b11, b12, bResult, new_size);               \n      \n        STRASSEN_algorithmA(aResult, bResult, p6, new_size);\n\n        sub(a12, a22, aResult, new_size);      \n        add(b21, b22, bResult, new_size);                \n        \n        STRASSEN_algorithmA(aResult, bResult, p7, new_size);\n        \n\n        add(p3, p5, c12, new_size); \n        add(p2, p4, c21, new_size); \n\n        add(p1, p4, aResult, new_size);      \n        add(aResult, p7, bResult, new_size); \n        sub(bResult, p5, c11, new_size); \n\n        add(p1, p3, aResult, new_size);     \n        add(aResult, p6, bResult, new_size);  \n        sub(bResult, p2, c22, new_size); \n\n        for (i = 0; i < new_size; i++)\n        {\n            for (j = 0; j < new_size; j++)\n            {\n                C[i][j] = c11[i][j];\n                C[i][j + new_size] = c12[i][j];\n                C[i + new_size][j] = c21[i][j];\n                C[i + new_size][j + new_size] = c22[i][j];\n            }\n        }\n    }\n}\nvoid STRASSEN_algorithm(vector<vector<int>> &A, vector<vector<int>> &B, int m, int n, int a, int b)\n{  \n    int k = max({m, n, a, b});\n\n    int s = nextpowerof2(k);\n\n    vector<int> z(s);\n    vector<vector<int>> Aa(s, z), Bb(s, z), Cc(s, z);\n\n    for (unsigned int i = 0; i < m; i++)\n    {\n        for (unsigned int j = 0; j < n; j++)\n        {\n            Aa[i][j] = A[i][j];\n        }\n    }\n    for (unsigned int i = 0; i < a; i++)\n    {\n        for (unsigned int j = 0; j < b; j++)\n        {\n            Bb[i][j] = B[i][j];\n        }\n    }\n    STRASSEN_algorithmA(Aa, Bb, Cc, s);\n    vector<int> temp1(b);\n    vector<vector<int>> C(m, temp1);\n    for (unsigned int i = 0; i < m; i++)\n    {\n        for (unsigned int j = 0; j < b; j++)\n        {\n            C[i][j] = Cc[i][j];\n        }\n    }\n    display(C, m, b);\n}\n\nbool check(int n, int a)\n{\n    if (n == a)\n        return true;\n    else\n        return false;\n}\n\nint main()\n{\n    int m = 3, n=4, a=4, b=3;\n    vector<vector<int>> A;\n    A = {{1,2,3,4},{4,5,6,1},{7,8,9,2}};\n\n    vector<vector<int>> B;\n    B = {{1,2,3},{5,7,2},{6,3,2},{1,9,2}};\n\n    bool k = check(n, a);\n    if (k)\n    {\n        STRASSEN_algorithm(A, B, m, n, a, b);\n    }\n    else\n    {\n        cout << \"-1\";\n    }\n    return 0;\n}\n\n\n', 0, '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '', '1)Divide matrices A and B in 4 sub-matrices of size N/2 x N/2. \r\n2)Calculate the 7 matrix multiplications recursively.\r\n3)Compute the submatricies of C.\r\n4)Combine these submatricies into our new matrix C', '2020-05-25'),
(639, 5, 7501012018, '#include<iostream>\n#include<vector>\nusing namespace std;\nvoid stras(vector<vector<int>> &x,vector<vector<int>> &y)\n{\n    int a,b,c,d,e,f,g,h,m1,m2,m3,m4,m5,m6,m7,m8;\n    vector<vector<int>> q(2, vector<int> (2,0));\n    a=x[0][0];\n    b=x[0][1];\n    c=x[1][0];\n    d=x[1][1];\n    e=y[0][0];\n    f=y[0][1];\n    g=y[1][0];\n    h=y[1][1];\n    m1=(a+c)*(e+f);\n    m2=(b+d)*(g+h);\n    m3=(a-d)*(e+h);\n    m4=a*(f-h);\n    m5=(c+d)*e;\n    m6=(a+b)*h;\n    m7=d*(g-e);\n    q[0][0]=m2+m3-m6-m7;\n    q[0][1]=m4+m6;\n    q[1][0]=m5+m7;\n    q[1][1]=m1-m3-m4-m5;\n    for(int i=0;i<2;i++)\n    {\n        for (int j=0;j<2;j++)\n        {\n            cout<<q[i][j]<<\" \";\n        }\n    }\n}\nint main(int args, char ** argv)\n{\n    int n=2;\n    vector<vector<int>> x(n,vector<int>(n,1)); \n    vector<vector<int>> y(n,vector<int>(n,1));\n    stras(x,y);\n    return 0;\n}', 1000, '', '', 'function Strassen(M,N)\r\nif M is 1 × 1 then\r\nreturn M11N11\r\nend if\r\nLet M =  A B\r\n         C D \r\nand N =  E F\r\n         G H \r\nSet S1 = Strassen(B - D, G + H)\r\nSet S2 = Strassen(A + D, E + H)\r\nSet S3 = Strassen(A - C, E + F)\r\nSet S4 = Strassen(A + B, H)\r\nSet S5 = Strassen(A, F - H)\r\nSet S6 = Strassen(D, G - E)\r\nSet S7 = Strassen(C + D, E)\r\nreturn (\r\nS1 + S2 - S4 + S6    S4 + S5\r\nS6 + S7              S2 - S3 + S5 - S7\r\n)\r\nend function\r\n', '2020-05-25'),
(640, 16, 7501012018, '#include <string.h>\r\n#include <iostream>\r\nusing namespace std;\r\n\r\n#define d 10\r\n\r\nvoid rabinKarp(char pattern[], char text[], int q)\r\n{\r\n	int m = strlen(pattern);\r\n	int n = strlen(text);\r\n	int i, j;\r\n	int p = 0;\r\n	int t = 0;\r\n	int h = 1;\r\n\r\n	for (i = 0; i < m - 1; i++)\r\n		h = (h * d) % q;\r\n\r\n	for (i = 0; i < m; i++)\r\n	{\r\n		p = (d * p + pattern[i]) % q;\r\n		t = (d * t + text[i]) % q;\r\n	}\r\n\r\n	for (i = 0; i <= n - m; i++)\r\n	{\r\n		if (p == t)\r\n		{\r\n			for (j = 0; j < m; j++)\r\n			{\r\n				if (text[i + j] != pattern[j])\r\n					break;\r\n			}\r\n\r\n			if (j == m)\r\n				cout << i<< endl;\r\n		}\r\n\r\n		if (i < n - m)\r\n		{\r\n			t = (d * (t - text[i] * h) + text[i + m]) % q;\r\n\r\n			if (t < 0)\r\n				t = (t + q);\r\n		}\r\n	}\r\n}\r\n\r\nint main()\r\n{\r\n	char text[] = \"AABAACAADAABAABA\";\r\n	char pattern[] = \"AABA\";\r\n	int q = 16;\r\n	rabinKarp(pattern, text, q);\r\n}', 1000, '', '', 'Begin\r\n   patLen := pattern Length\r\n   strLen := string Length\r\n   patHash := 0 and strHash := 0, h := 1\r\n   maxChar := total number of characters in character set\r\n\r\n   for index i of all character in pattern, do\r\n      h := (h*maxChar) mod prime\r\n   done\r\n\r\n   for all character index i of pattern, do\r\n      patHash := (maxChar*patHash + pattern[i]) mod prime\r\n      strHash := (maxChar*strHash + text[i]) mod prime\r\n   done\r\n\r\n   for i := 0 to (strLen - patLen), do\r\n      if patHash = strHash, then\r\n         for charIndex := 0 to patLen -1, do\r\n            if text[i+charIndex] ≠ pattern[charIndex], then\r\n               break the loop\r\n         done\r\n\r\n         if charIndex = patLen, then\r\n            print the location i as pattern found at i position.\r\n      if i < (strLen - patLen), then\r\n         strHash := (maxChar*(strHash – text[i]*h)+text[i+patLen]) mod prime, then\r\n      if strHash < 0, then\r\n         strHash := strHash + prime\r\n   done\r\nEnd', '2020-05-25');

-- --------------------------------------------------------

--
-- Table structure for table `questions_table`
--

CREATE TABLE `questions_table` (
  `Q_ID` int(11) NOT NULL,
  `Q_NAME` varchar(200) NOT NULL,
  `DESCRIPTION` varchar(5000) NOT NULL,
  `LAB_ID` varchar(20) NOT NULL,
  `CHECKER` tinyint(1) NOT NULL,
  `TEST1` text NOT NULL,
  `OP1` text NOT NULL,
  `TEST2` text NOT NULL,
  `OP2` text NOT NULL,
  `TEST3` text NOT NULL,
  `OP3` text NOT NULL,
  `TEST4` text NOT NULL,
  `OP4` text NOT NULL,
  `TEST5` text NOT NULL,
  `OP5` text NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

--
-- Dumping data for table `questions_table`
--

INSERT INTO `questions_table` (`Q_ID`, `Q_NAME`, `DESCRIPTION`, `LAB_ID`, `CHECKER`, `TEST1`, `OP1`, `TEST2`, `OP2`, `TEST3`, `OP3`, `TEST4`, `OP4`, `TEST5`, `OP5`) VALUES
(1, 'Sum of two arrays', 'Add two arrays having different sizes and store the result in a different array.', 'BCS-257', 1, '1000', 'Hello world 1000', '5', 'Hello world 5', '785', 'Hello world 785', '445', 'Hello world 445', '410', 'Hello world 410'),
(2, 'Merge Sort', 'Merge Sort is a Divide and Conquer algorithm. It divides input array in two halves, calls itself for the two halves and then merges the two sorted halves. \r\n\r\nSort an array using Merge Sort algorithm.\r\n\r\nInput Format:\r\n\r\nThere will be 5 test cases provided.\r\nThe first line of each test case contains an integer n, the number of elements represented in the array arr.\r\nThe second line contains n space-separated integers.\r\n\r\nOutput Format:\r\n\r\nPrint the sorted array for each test case.\r\n\r\nExample:\r\n\r\nInput:\r\n6\r\n12 -5 4 1 0 6\r\n\r\nOutput:\r\n-5 0 1 4 6 12', 'BCS-206', 1, '6 12 11 13 5 6 7', '5 6 7 11 12 13 ', '6 1 2 3 4 5 6', '1 2 3 4 5 6 ', '5 8 13 23 4 10', '4 8 10 13 23 ', '7 10 -42 15 12 37 -7 -9', '-42 -9 -7 10 12 15 37 ', '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 '),
(3, 'Quick Sort', 'Quick Sort is a Divide and Conquer algorithm. It picks an element as pivot and partitions the given array around the picked pivot.\r\n\r\nSort an array using Quick Sort algorithm.\r\n\r\nInput Format:\r\n\r\nThere will be 5 test cases provided.\r\nThe first line of each test case contains an integer n, the number of elements represented in the array arr.\r\nThe second line contains n space-separated integers.\r\n\r\nOutput Format:\r\n\r\nPrint the sorted array for each test case.\r\n\r\nExample:\r\n\r\nInput:\r\n6\r\n12 -5 4 1 0 6\r\n\r\nOutput:\r\n-5 0 1 4 6 12\r\n', 'BCS-206', 1, '6 1 2 3 4 5 6', '1 2 3 4 5 6 ', '9 8 9 8 9 8 9 8 9 9', '8 8 8 8 9 9 9 9 9 ', '7 -4 8 -16 0 -1000 5000 8000', '-1000 -16 -4 0 8 5000 8000 ', '5 99 88 77 66 55', '55 66 77 88 99 ', '1 2000', '2000 '),
(4, 'Simultaneous MinMax', 'USe divide and conquer approach.', 'BCS-206', 1, '6 1000 11 445 1 330 3000', '1 3000', '6 1000 11 445 1 330 3000', '1 3000', '6 1000 11 445 1 330 3000', '1 3000', '6 1000 11 445 1 330 3000', '1 3000', '6 1000 11 445 1 330 3000', '1 3000'),
(5, 'Generalized Strassen\'s matrix multiplication.', 'Implementation of generalized Strassen\'s matrix multiplication', 'BCS-206', 0, '', '', '', '', '', '', '', '', '', ''),
(6, 'Display nodes of a tree', 'Write a program to display nodes of a tree', 'BCS-354', 0, '', '', '', '', '', '', '', '', '', ''),
(7, 'Randomized Quick Sort', 'An algorithm that uses random numbers to decide what to do next anywhere in its logic is called Randomized Algorithm.. For example, in Randomized Quick Sort, we use random number to pick the next pivot.\r\n\r\nGiven an array, sort it using Randomized Quick Sort algorithm.\r\n\r\nInput Format:\r\n\r\nThere will be 5 test cases provided.\r\nThe first line of each test case contains an integer n, the number of elements represented in the array arr.\r\nThe second line contains n space-separated integers.\r\n\r\nOutput Format:\r\n\r\nPrint the sorted array for each test case.\r\n\r\nExample:\r\n\r\nInput:\r\n6\r\n12 -5 4 1 0 6\r\n\r\nOutput:\r\n-5 0 1 4 6 12', 'BCS-206', 1, '6 12 11 13 5 6 7', '5 6 7 11 12 13 ', '6 1 2 3 4 5 6', '1 2 3 4 5 6 ', '5 8 13 23 4 10', '4 8 10 13 23 ', '7 10 -42 15 12 37 -7 -9', '-42 -9 -7 10 12 15 37 ', '13 0 8 8 6 5 9 6 1 8 9 4 1000 14000', '0 1 4 5 6 6 8 8 8 9 9 1000 14000 '),
(8, 'Strassen\'s Matrix Multiplication', 'Strassen matrix multiplication is a Divide and Conquer method that helps us to multiply two matrices(of size n X n).\r\n\r\nGiven two square matrices A and B of size n x n each, find their multiplication matrix using Strassen\'s Matrix Multiplication.\r\n\r\nInput Format:\r\n\r\nThe first line of the test case contains an integer n, denoting the size of the first nXn matrix.\r\nThe next n lines contains n space-separated integers each, denoting the first matrix.\r\nThen next n lines contain other n space separated integers each, denoting the second matrix.\r\n\r\nOutput Format:\r\n\r\nPrint the resultant multiplication matrix.\r\n\r\nExample:\r\n\r\nInput:\r\n3\r\n1 0 0\r\n0 1 0\r\n0 0 1\r\n1 0 0\r\n0 1 0\r\n0 0 1\r\n\r\nOutput:\r\n1 0 0\r\n0 1 0\r\n0 0 1', 'BCS-206', 1, '3 5 -2 1 -3 3 2 1 0 4 5 6 7 8 9 10 11 -3 2', '20 9 17\r\n31 3 13\r\n49 -6 15\r\n', '3 -2 -3 -1 0 1 6 2 3 4 2 -3 5 0 7 6 8 -1 1 ', '-12 -14 -29\r\n48 1 12\r\n36 11 32', '3 -3 -4 2 1 -2 3 4 5 6 7 0 2 8 -3 9 4 3 -1', '-45 18 -44\r\n3 15 -19\r\n92 3 47', '3 -3 -4 2 3 5 4 6 -2 7 8 -3 0 3 -1 4 6 1 5', '-24 15 -6\r\n63 -10 40\r\n84 -9 27', '3 -2 -3 4 5 -1 0 1 6 7 3 2 4 5 8 9 1 6 7', '-17 -4 -7\r\n10 2 11\r\n40 92 107'),
(9, 'Implementation of Disjoint Set Data Structure', 'Disjoint Set Data Structure partitions the individual elements into different sets according to the groups in which they fall. It maintains collection of disjoint sets and each set is represented by its representative which is one of its members.\r\n\r\nLet’s define the following operations:\r\n\r\n1. CREATE-SET(x) – creates a new set with one element {x}.\r\n\r\n2. MERGE-SETS(x, y) – merge into one set the set that contains element x and the set that contains element y (x and y are in different sets). The original sets will be destroyed.\r\n\r\n3. FIND-SET(x) – returns the representative or a pointer to the representative of the set that contains element x.\r\n\r\nWrite a program to implement the above functions for a Disjoint Set Data Structure.\r\n\r\nThe code will be evaluated by the lab attendant and marked accordingly. No test cases are provided.', 'BCS-206', 0, '', '', '', '', '', '', '', '', '', ''),
(10, 'Fractional Knapsack Problem', 'Given weights and values of n items, put these items in a knapsack of capacity W to get the maximum total value in the knapsack. You cannot break an item, either pick the complete item or don’t pick it (0-1 property).\r\n\r\nIn other words, given two integer arrays val[0..n-1] and wt[0..n-1] which represent values and weights associated with n items respectively. Also given an integer W which represents knapsack capacity, find out the maximum value subset of val[] such that sum of the weights of this subset is smaller than or equal to W. \r\n\r\nInput Format:\r\n\r\nThe first line of the test case contains two space separated integers n and W. \'n\' denotes the the number of items and \'W\' denotes the maximum weight that can be carried in the knapsack.\r\n\r\nThe second line contains n space-separated integers representing the value of each of the n items respectively.\r\n\r\nThe third line contains n space-separated integers representing the weight of each of the n items respectively. \r\n\r\nOutput Format:\r\n\r\nPrint the maximum value that can be obtained from n items.\r\n\r\nExample:\r\n\r\nInput:\r\n3 50\r\n60 100 120\r\n10 20 30\r\n\r\nOutput:\r\n220', 'BCS-206', 1, '3 50 60 100 120 10 20 30', '220', '4 5 3 4 5 6 2 3 4 5', '7', '5 11 1 6 18 22 28 1 2 5 6 7', '40', '5 11 3 4 4 10 4 3 4 5 9 4 ', '11', '5 15 4 2 1 2 10 12 2 1 1 4', '15'),
(11, 'Implement Huffman Encoding', 'Huffman code is a particular type of optimal prefix code that is commonly used for lossless data compression.\r\n\r\nHuffman Coding implements a rule known as a prefix rule. This is to prevent the ambiguities while decoding. It ensures that the code assigned to any character is not a prefix of the code assigned to any other character.\r\n\r\nThere are two major steps in Huffman Coding-\r\n1. Building a Huffman Tree from the input characters.\r\n2. Assigning code to the characters by traversing the Huffman Tree.\r\n\r\nGiven some characters and their frequency of occurrence in a record, find out the Huffman code for each character.\r\n\r\nInput Format:\r\n\r\nThe first line of the test case contains an integer n denoting the number of characters in the record.\r\n\r\nThe second line contains n space-separated characters representing the characters of the record.\r\n\r\nThe third line contains n space-separated integers representing the frequency of occurrence of each corresponding character respectively. \r\n\r\nOutput Format:\r\n\r\nPrint the Huffman code of each character alongside the character itself, in separate lines.\r\n\r\nExample:\r\n\r\nInput:\r\n6\r\na b c d e f\r\n5 9 12 13 16 45\r\n\r\nOutput:\r\na: 1100\r\nb: 1101\r\nc: 100\r\nd: 101\r\ne: 111\r\nf: 0', 'BCS-206', 1, '6 a b c d e f 5 9 12 13 16 45', 'a: 1100\r\nb: 1101\r\nc: 100\r\nd: 101\r\ne: 111\r\nf: 0', '5 A B R C D 5 2 2 1 1', 'A: 0\r\nB: 111\r\nR: 10\r\nC: 1100\r\nD: 1101\r\n', '7 g o p h e r s 3 3 2 1 1 1 1', 'g: 00\r\no: 01\r\np: 1110\r\nh: 1101\r\ne: 101\r\nr: 1111\r\ns: 1100', '4 m p s i 1 2 4 4', 'm: 100\r\np: 101\r\ns: 11\r\ni: 0', '8 a b c d e f g h 1 1 2 3 5 8 13 21', 'a: 1111110\r\nb: 1111111\r\nc: 111110\r\nd: 11110\r\ne: 1110\r\nf: 110\r\ng: 10\r\nh: 0'),
(12, 'Kruskal MST Algorithm', 'Kruskal\'s algorithm is a minimum-spanning-tree algorithm which finds an edge of the least possible weight that connects any two trees in the forest.[1] It is a greedy algorithm in graph theory as it finds a minimum spanning tree for a connected weighted graph adding increasing cost arcs at each step. \r\n\r\nGiven a graph with n nodes and m edges, find the Minimum Spanning Tree that graph makes using Kruskal\'s algorithm.\r\n\r\nExample:\r\n\r\nGiven a graph with source vertex, destination vertex and weight of the edge as follows:\r\nSrc Dst Wt\r\n 0   1  10\r\n 0   2  6\r\n 0   3  5 \r\n 1   3  15\r\n 2   3  4\r\n\r\nOutput:\r\nEdge    Wt\r\n2---3==>4\r\n0---3==>5\r\n0---1==>10\r\n\r\nThe question will be evaluated by the Lab attendant. No test cases are provided.', 'BCS-206', 0, '4 6\r\n1 2 5\r\n1 3 3\r\n4 1 6\r\n2 4 7\r\n3 2 4\r\n3 4 5', '12', '5 7\r\n1 2 20\r\n1 3 50\r\n1 4 70\r\n1 5 90\r\n2 3 30\r\n3 4 40\r\n4 5 60\r\n\r\n\r\n', '150', '4 6\r\n1 2 5\r\n1 3 3\r\n4 1 6\r\n2 4 7\r\n3 2 4\r\n3 4 5', '12', '5 7\r\n1 2 20\r\n1 3 50\r\n1 4 70\r\n1 5 90\r\n2 3 30\r\n3 4 40\r\n4 5 60\r\n\r\n', '150', '4 6\r\n1 2 5\r\n1 3 3\r\n4 1 6\r\n2 4 7\r\n3 2 4\r\n3 4 5', '12'),
(13, 'Prim\'s MST Algorithm', 'Prim s (also known as Jarník s) algorithm is a greedy algorithm that finds a minimum spanning tree for a weighted undirected graph. This means it finds a subset of the edges that forms a tree that includes every vertex, where the total weight of all the edges in the tree is minimized. \r\n\r\nThe first line has two space-separated integers  and , the number of nodes and edges in the graph.\r\n\r\nThe next  lines each consist of three space-separated integers ,  and , where  and  denote the two nodes between which the undirected edge exists and  denotes the weight of that edge.\r\n\r\nExample:\r\n\r\n5 7\r\n1 2 20\r\n1 3 50\r\n1 4 70\r\n1 5 90\r\n2 3 30\r\n3 4 40\r\n4 5 60\r\n\r\nOutput:\r\n\r\n150\r\n\r\n', 'BCS-206', 0, '4 6\r\n1 2 5\r\n1 3 3\r\n4 1 6\r\n2 4 7\r\n3 2 4\r\n3 4 5', '12', '5 7\r\n1 2 20\r\n1 3 50\r\n1 4 70\r\n1 5 90\r\n2 3 30\r\n3 4 40\r\n4 5 60', '150', '4 6\r\n1 2 5\r\n1 3 3\r\n4 1 6\r\n2 4 7\r\n3 2 4\r\n3 4 5', '12', '5 7\r\n1 2 20\r\n1 3 50\r\n1 4 70\r\n1 5 90\r\n2 3 30\r\n3 4 40\r\n4 5 60', '150', '4 6\r\n1 2 5\r\n1 3 3\r\n4 1 6\r\n2 4 7\r\n3 2 4\r\n3 4 5', '12'),
(14, ' Bellman–Ford Algorithm', 'The Bellman-Ford algorithm is an algorithm that computes shortest paths from a single source vertex to all of the other vertices in a weighted digraph.\r\n\r\nGiven a graph and a source vertex src in the graph, find the shortest paths from src to all vertices in the given graph. The graph may contain negative weight edges.\r\n\r\n\r\nSrc Dest  Wt\r\n0   -1   -1\r\n0    2    4\r\n1    2    3\r\n1    3    2\r\n1    4    2\r\n3    2    5\r\n3    1    1\r\n4    3   -3\r\n\r\nOutput\r\n\r\nVertex  Dist from source\r\n0          0\r\n1         -1\r\n2          2\r\n3         -2\r\n4          1\r\n\r\n\r\n\r\n\r\nThe question will be evaluated by the Lab attendant. No test cases are provided.', 'BCS-206', 0, '', '', '', '', '', '', '', '', '', ''),
(15, 'Matrix Chain Multiplication', 'Given a sequence of matrices, find the most efficient way to multiply these matrices together. The problem is not actually to perform the multiplications, but merely to decide in which order to perform the multiplications. There are many options to multiply a chain of matrices because matrix multiplication is associative i.e. no matter how one parenthesize the product, the result will be the same.\r\n\r\nExample:\r\n if you had four matrices A, B, C, and D, you would have:\r\n\r\n    (ABC)D = (AB)(CD) = A(BCD) = ....\r\nHowever, the order in which one parenthesize the product affects the number of simple arithmetic operations needed to compute the product, or the efficiency.\r\n\r\nFor example:\r\n\r\nA: 10 × 30 matrix\r\nB : 30 × 5 matrix\r\nC : 5 × 60 matrix\r\nThen,\r\n     (AB)C = (10×30×5) + (10×5×60) \r\n           = 1500 + 3000 \r\n           = 4500 operations\r\n     A(BC) = (30×5×60) + (10×30×60) \r\n           = 9000 + 18000 \r\n           = 27000 operations.\r\nGiven an array arr[] which represents the chain of matrices such that the ith matrix Ai is of dimension arr[i-1] x arr[i]. Your task is to write a function that should print the minimum number of multiplications needed to multiply the chain.\r\n\r\n  Input: p[] = {40, 20, 30, 10, 30}   \r\n  Output: 26000  \r\n  There are 4 matrices of dimensions 40x20, \r\n  20x30, 30x10 and 10x30. Let the input 4 \r\n  matrices be A, B, C and D.  The minimum \r\n  number of multiplications are obtained \r\n  by putting parenthesis in following way\r\n  (A(BC))D --> 20*30*10 + 40*20*10 + 40*10*30\r\n\r\n  Input: p[] = {10, 20, 30, 40, 30} \r\n  Output: 30000 \r\n  There are 4 matrices of dimensions 10x20, \r\n  20x30, 30x40 and 40x30. Let the input 4 \r\n  matrices be A, B, C and D.  The minimum \r\n  number of multiplications are obtained by \r\n  putting parenthesis in following way\r\n  ((AB)C)D --> 10*20*30 + 10*30*40 + 10*40*30\r\nInput:\r\nThe first line of the input contains an integer T, denoting the number of test cases. Then T test case follows. The first line of each test case contains an integer N, denoting the number of elements in the array.\r\nThen next line contains N space separated integers denoting the values of the element in the array.\r\n\r\nOutput:\r\nFor each test case the print the minimum number of operations needed to multiply the chain.\r\n\r\nConstraints:\r\n1<=T<=100\r\n2<=N<=100\r\n1<=A[]<=500\r\n\r\nExample:\r\nInput:\r\n2\r\n5\r\n1 2 3 4 5\r\n3\r\n3 3 3\r\nOutput:\r\n38\r\n27', 'BCS-206', 0, '', '', '', '', '', '', '', '', '', ''),
(16, 'Rabin Karp string matching', 'Given a text txt[0..n-1] and a pattern pat[0..m-1], write a program to print all occurrences of pat[] in txt[]. You may assume that n > m.', 'BCS-206', 0, '', '', '', '', '', '', '', '', '', '');

-- --------------------------------------------------------

--
-- Table structure for table `stol_map`
--

CREATE TABLE `stol_map` (
  `ID` int(11) NOT NULL,
  `YEAR` int(4) NOT NULL,
  `BRANCH` varchar(100) NOT NULL,
  `LAB_ID` varchar(80) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

--
-- Dumping data for table `stol_map`
--

INSERT INTO `stol_map` (`ID`, `YEAR`, `BRANCH`, `LAB_ID`) VALUES
(1, 1, 'CSE', 'BCS-110'),
(2, 2, 'IT', 'BIT-259'),
(3, 2, 'CSE', 'BCS-257'),
(4, 3, 'IT', 'BIT-357'),
(5, 3, 'CSE', 'BCS-354'),
(6, 3, 'CSE', 'BCS-356'),
(7, 2, 'CSE', 'BCS-206'),
(8, 3, 'IT', 'BIT-353');

-- --------------------------------------------------------

--
-- Table structure for table `student_registration`
--

CREATE TABLE `student_registration` (
  `ID` int(11) NOT NULL,
  `ROLL` bigint(20) NOT NULL,
  `NAME` varchar(100) NOT NULL,
  `PASSWORD` varchar(100) NOT NULL,
  `YOA` int(4) NOT NULL,
  `BRANCH` varchar(100) NOT NULL,
  `BATCH` varchar(100) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

--
-- Dumping data for table `student_registration`
--

INSERT INTO `student_registration` (`ID`, `ROLL`, `NAME`, `PASSWORD`, `YOA`, `BRANCH`, `BATCH`) VALUES
(1, 7601012018, 'syfahg', 'asd', 2018, 'CSE', 'B1'),
(2, 68, 'Nikita', 'nikita123', 2016, 'CSE', 'A2'),
(3, 78, 'Kajal', 'jaikaal', 2017, 'IT', 'A2'),
(4, 90, 'Harshita', 'hs123', 2019, 'CSE', 'A1'),
(5, 12001012016, 'Neeru', 'neeru', 2016, 'CSE', 'A1'),
(6, 12001012017, 'nikita', 'abcd', 2015, 'cse', 'A1'),
(7, 11901012016, 'Sakriti Dixit', 'hello', 2018, 'CSE', 'A2'),
(9, 5101012018, 'Mehak Jain', 'mnmn@1234', 2018, 'CSE', 'B1'),
(10, 4501012018, 'Isha', 'isha@2467', 2018, 'CSE', 'B1'),
(11, 3901012018, 'Ojasvi Tyagi', 'Ojasvi@152', 2018, 'CSE', 'B1'),
(12, 5301012018, 'Zeba Ali', 'Zebaali1234#', 2018, 'CSE', 'B1'),
(13, 4701012018, 'ISHIKA GOEL', 'c0rrect', 2018, 'CSE', 'B1'),
(14, 4601012018, 'Soumya Sharma', '9132907', 2018, 'CSE', 'B1'),
(15, 6001012018, 'Rhea Hooda', 'Rhea@123', 2018, 'CSE', 'B1'),
(16, 7201012018, 'Apoorva Mittal', 'Apoorva@1501', 2018, 'CSE', 'B1'),
(17, 6501012018, 'Muskan Verma', 'iamthescientist', 2018, 'CSE', 'B1'),
(18, 5401012018, 'Ritika joshi', 'ritikajoshi1020', 2018, 'CSE', 'B1'),
(19, 6101012018, 'Priyanka Maan', 'priyanka@123', 2018, 'CSE', 'B1'),
(20, 4801012018, 'Rushali Khilrani', 'jai mata di', 2018, 'CSE', 'B1'),
(21, 7101012018, 'Pragya', 'pragyaarora', 2018, 'CSE', 'B1'),
(22, 5901012018, 'NANDINI MEHTA', '1234', 2018, 'CSE', 'B1'),
(23, 4901012018, 'Bhoomi', 'bk@22012001', 2018, 'CSE', 'B1'),
(24, 6601012018, 'Vanshika Kishor', 'Vk@16122017', 2018, 'CSE', 'B1'),
(25, 6901012018, 'Shivani', 'Coco@glow5', 2018, 'CSE', 'B1'),
(26, 6801012018, 'KM ANJU', '8742946967', 2018, 'CSE', 'B1'),
(27, 7501012018, 'Shivani', 'Shivani@2001', 2018, 'CSE', 'B1'),
(28, 4001012018, 'Shreya Biswas', 'Shreya@123', 2018, 'CSE', 'B1'),
(29, 5701012018, 'Megha Gupta', 'Megha12345', 2018, 'CSE', 'B1'),
(30, 5001012018, 'Pranjli Singh', 'Sunshine*37', 2018, 'CSE', 'B1'),
(31, 4301012018, 'Karishma Singh Chauhan', 'basketballislove4357', 2018, 'CSE', 'B1'),
(33, 5801012018, 'Tehreem', '1234567', 2018, 'CSE', 'B1'),
(34, 4401012018, 'Navpreet', 'navpreet123', 2018, 'CSE', 'B1'),
(35, 5601012018, 'Saniya', '1234567', 2018, 'CSE', 'B1'),
(36, 6201012018, 'Sara Anwer', 'jiya@123', 2018, 'CSE', 'B1'),
(37, 6701012018, 'Tushti', 'tushti0110', 2018, 'CSE', 'B1'),
(38, 7401012018, 'Nancy Solanki', '1234567', 2018, 'CSE', 'B1'),
(39, 6301012018, 'Pakhi Bansal', 'bansal123', 2018, 'CSE', 'B1'),
(41, 7301012018, 'Swastika Tiwari', 'swastika14', 2018, 'CSE', 'B1'),
(42, 101012018, 'Aamiya Garg', 'aamiya@2412', 2018, 'CSE', 'A1'),
(43, 1901012018, 'Shruti Aggarwal', 'shubh2008', 2018, 'CSE', 'A1'),
(44, 3501012018, 'Muskan Tomar', 'Muskan@8874', 2018, 'CSE', 'A1'),
(45, 2501012018, 'anju', 'king@612427', 2018, 'CSE', 'A1'),
(46, 3001012018, 'Somya', 'ada@12', 2018, 'CSE', 'A1'),
(47, 1501012018, 'aakriti gupta', 'aakriti298', 2018, 'CSE', 'A1'),
(48, 1601012018, 'Lisa', 'hello', 2018, 'CSE', 'A1'),
(49, 201012018, 'Saloni', 'Satya@1967', 2018, 'CSE', 'A1'),
(50, 401012018, 'Kritika Goswami', 'Ginni@8801', 2018, 'CSE', 'A1'),
(51, 3401012018, 'Bhavya', 'singhal', 2018, 'CSE', 'A1'),
(52, 901012018, 'Ankita Haldar', 'ankita11102000', 2018, 'CSE', 'A1'),
(53, 3301012018, 'Kajal Sinha', 'dream_newday', 2018, 'CSE', 'A1'),
(54, 701012018, 'Shailza Singh', 'Alohomora@', 2018, 'CSE', 'A1'),
(55, 1201012018, 'Anahita Singla', 'Anju6@AP', 2018, 'CSE', 'A1'),
(56, 3101012018, 'Astika Nehra', 'igituw@123', 2018, 'CSE', 'A1'),
(57, 1701012018, 'Sakshi Jain', 'jainsakshi@1234', 2018, 'CSE', 'A1'),
(58, 3601012018, 'PARVATI SOHNI', 'parvati41', 2018, 'CSE', 'A1'),
(60, 2801012018, 'Apoorva Gupta', 'anushka@2210', 2018, 'CSE', 'A1'),
(61, 1101012018, 'Mehak Sangwan', '1234', 2018, 'CSE', 'A1'),
(62, 2201012018, 'Kajal', 'kajal8505', 2018, 'CSE', 'A1'),
(63, 2901012018, 'Vanshika Uniyal', 'vanshika123', 2018, 'CSE', 'A1'),
(64, 3201012018, 'amitasha tembulkar', 'Honey@55', 2018, 'CSE', 'A1'),
(65, 1301012018, 'Archita Varshney', 'archita', 2018, 'CSE', 'A1'),
(66, 2001012018, 'Akanksha', 'qwerty', 2018, 'CSE', 'A1'),
(67, 601012018, 'muskan', 'muskan1234', 2018, 'CSE', 'A1'),
(68, 3701012018, 'Akanksha', 'keepmelogintill2022', 2018, 'CSE', 'A1'),
(69, 1001012018, 'Tanya Bhardwaj', 'tanya@99', 2018, 'CSE', 'A1'),
(70, 2301012018, 'Anushka Narula', 'kinnu9$', 2018, 'CSE', 'A1'),
(71, 301012018, 'Tanya Rana', 'tanya123', 2018, 'CSE', 'A1'),
(72, 2601012018, 'Diksha Rajput', '1234567890', 2018, 'CSE', 'A1'),
(73, 4101012018, 'Harshita', '1234567', 2018, 'CSE', 'B1'),
(74, 2701012018, 'Akshita Goyal', ',.123qwerty', 2018, 'CSE', 'A1'),
(75, 1401012018, 'anjali', 'avni2308', 2018, 'CSE', 'A1'),
(76, 1801012018, 'Tanya  Michelle Minj', 'tanya25', 2018, 'CSE', 'A1'),
(77, 3801012018, 'Shiva Singhal', 'shiva@77', 2018, 'CSE', 'A1'),
(78, 501012018, 'Shreya Rastogi', 'Shalu@1234', 2018, 'CSE', 'A1'),
(79, 2101012018, 'Stuti Chauhan', 'dulcet', 2018, 'CSE', 'A1'),
(80, 2401012018, 'anju', 'anju@123', 2018, 'CSE', 'A1'),
(81, 754, 'ria', 'buddy', 2018, 'CSE', 'A1'),
(82, 801012018, 'Suniti ', '00801012018', 2018, 'CSE', 'A1'),
(83, 46545, 'madad', 'sdsdd', 2019, 'CSE', 'A1'),
(85, 6401012018, 'Anusha Mittal', 'anusha123', 2018, 'CSE', 'B1'),
(86, 5501012018, 'Paridhi Gupta', 'asd', 2018, 'CSE', 'B1'),
(87, 4201012018, 'Mehak', 'asd', 2018, 'CSE', 'B1');

-- --------------------------------------------------------

--
-- Table structure for table `teacher_registration`
--

CREATE TABLE `teacher_registration` (
  `ID` int(11) NOT NULL,
  `NAME` varchar(300) NOT NULL,
  `EMAIL` varchar(255) NOT NULL,
  `PASSWORD` varchar(300) NOT NULL,
  `Sign` longblob DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

--
-- Dumping data for table `teacher_registration`
--

INSERT INTO `teacher_registration` (`ID`, `NAME`, `EMAIL`, `PASSWORD`, `Sign`) VALUES
(1, 'Admin', 'admin@admin.com', 'abcd', NULL),
(2, 'admin2', 'admin2@admin.com', 'abcd', ''),
(3, 'admin3', 'admin3@admin.com', 'abcd', ''),
(4, 'ad4', 'ad4@gmail.com', 'qwerty', 0x433a78616d7070096d70706870414342372e746d70),
(5, 'Kajal Aggarwal', 'kajahl@gmail.com', 'kajal67', ''),
(6, 'hrshey', 'has@gmail.com', 'buddy', ''),
(7, 'Sakriti Dixit', 'a@gmail.com', 'qwerty', ''),
(8, 'Sakriti Dixit', 'sd9@gmail.com', 'hw', ''),
(9, 'SD2', 'sd10@gmail.com', 'helloworld', ''),
(10, 'Dr. Vivekanand Jha', 'vivekanandjha@igdtuw.ac.in', 'qwerty', '');

-- --------------------------------------------------------

--
-- Table structure for table `ttol_map`
--

CREATE TABLE `ttol_map` (
  `ID` int(11) NOT NULL,
  `EMAIL` varchar(255) NOT NULL,
  `LAB_ID` varchar(100) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

--
-- Dumping data for table `ttol_map`
--

INSERT INTO `ttol_map` (`ID`, `EMAIL`, `LAB_ID`) VALUES
(1, 'admin3@admin.com', 'BCS-257'),
(2, 'admin3@admin.com', 'BIT-357'),
(3, 'admin3@admin.com', 'BCS-354'),
(4, 'ad4@gmail.com', 'BCS-110'),
(5, 'ad4@gmail.com', 'BCS-206'),
(6, 'ad4@gmail.com', 'BCS-257'),
(7, 'kajahl@gmail.com', 'BCS-257'),
(8, 'has@gmail.com', 'BIT-259'),
(9, 'has@gmail.com', 'BCS-257'),
(10, 'a@gmail.com', 'BCS-354'),
(11, 'a@gmail.com', 'BCS-356'),
(12, 'a@gmail.com', 'BCS-206'),
(13, 'sd9@gmail.com', 'BCS-257'),
(14, 'sd9@gmail.com', 'BIT-357'),
(15, 'sd9@gmail.com', 'BCS-354'),
(16, 'sd10@gmail.com', 'BCS-110'),
(17, 'sd10@gmail.com', 'BIT-259'),
(18, 'sd10@gmail.com', 'BCS-257'),
(19, 'vivekanandjha@igdtuw.ac.in', 'BCS-206');

--
-- Indexes for dumped tables
--

--
-- Indexes for table `batch`
--
ALTER TABLE `batch`
  ADD PRIMARY KEY (`ID`);

--
-- Indexes for table `doubts`
--
ALTER TABLE `doubts`
  ADD PRIMARY KEY (`ID`);

--
-- Indexes for table `lab`
--
ALTER TABLE `lab`
  ADD PRIMARY KEY (`ID`);

--
-- Indexes for table `qtos_map`
--
ALTER TABLE `qtos_map`
  ADD PRIMARY KEY (`ID`);

--
-- Indexes for table `questions_table`
--
ALTER TABLE `questions_table`
  ADD PRIMARY KEY (`Q_ID`);

--
-- Indexes for table `stol_map`
--
ALTER TABLE `stol_map`
  ADD PRIMARY KEY (`ID`);

--
-- Indexes for table `student_registration`
--
ALTER TABLE `student_registration`
  ADD PRIMARY KEY (`ID`);

--
-- Indexes for table `teacher_registration`
--
ALTER TABLE `teacher_registration`
  ADD PRIMARY KEY (`ID`);

--
-- Indexes for table `ttol_map`
--
ALTER TABLE `ttol_map`
  ADD PRIMARY KEY (`ID`);

--
-- AUTO_INCREMENT for dumped tables
--

--
-- AUTO_INCREMENT for table `batch`
--
ALTER TABLE `batch`
  MODIFY `ID` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=13;

--
-- AUTO_INCREMENT for table `doubts`
--
ALTER TABLE `doubts`
  MODIFY `ID` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=12;

--
-- AUTO_INCREMENT for table `lab`
--
ALTER TABLE `lab`
  MODIFY `ID` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=1002;

--
-- AUTO_INCREMENT for table `qtos_map`
--
ALTER TABLE `qtos_map`
  MODIFY `ID` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=641;

--
-- AUTO_INCREMENT for table `questions_table`
--
ALTER TABLE `questions_table`
  MODIFY `Q_ID` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=17;

--
-- AUTO_INCREMENT for table `stol_map`
--
ALTER TABLE `stol_map`
  MODIFY `ID` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=9;

--
-- AUTO_INCREMENT for table `student_registration`
--
ALTER TABLE `student_registration`
  MODIFY `ID` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=88;

--
-- AUTO_INCREMENT for table `teacher_registration`
--
ALTER TABLE `teacher_registration`
  MODIFY `ID` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=11;

--
-- AUTO_INCREMENT for table `ttol_map`
--
ALTER TABLE `ttol_map`
  MODIFY `ID` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=20;
COMMIT;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
